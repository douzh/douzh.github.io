<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>OneKBase</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="OneKBase">
<meta property="og:url" content="http://www.onekbase.com/page/23/index.html">
<meta property="og:site_name" content="OneKBase">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="证心">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="OneKBase" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">OneKBase</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.onekbase.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-blog/plang/java/threadsafe/linkedblockingqueue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/threadsafe/linkedblockingqueue/" class="article-date">
  <time datetime="2015-12-25T03:21:25.000Z" itemprop="datePublished">2015-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/threadsafe/linkedblockingqueue/">JAVA同步之LinkedBlockingQueue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>队列这个数据结构已经很熟悉了，利用其先进先出的特性，多数生产消费模型的首选数据结构就是队列。对于有多个生产者和多个消费者线程的模型来说，最重要是他们共同访问的Queue是线程安全的。JDK中提供的线程安全的Queue的实现还是很丰富的：</p>
<p>ArrayBlockingQueue,LinkedBlockingQueue,PriorityBlockingQueue,DelayQueue,ConcurrentLinkedQueue等等，多数情况下使用这些数据结构编写并发程序足够了。</p>
<p>这里分析一下LinkedBlockingQueue的实现。</p>
<p>首先从简单的开始，先看看LinkedBlockingQueue线程安全的实现。之所以介绍它是因为其实现比较典型，对比ArrayBlokcingQueue使用一个ReentrantLock和两个Condition维护内部的数组来说，它使用了两个ReentrantLock，并且分别对应一个Condition来实现对内部数据结构Node型变量的维护。</p>
<pre><code>public class LinkedBlockingQueue&lt; e&gt; extends AbstractQueue&lt; e&gt;
        implements BlockingQueue&lt; e&gt;, java.io.Serializable &#123;
    private static final long serialVersionUID = -6903933977591709194L;

    /**
     * 节点数据结构
     */
    static class Node&lt; e&gt; &#123;
        /** The item, volatile to ensure barrier separating write and read */
        volatile E item;
        Node&lt; e&gt; next;
        Node(E x) &#123; item = x; &#125;
    &#125;

    /** 队列的容量 */
    private final int capacity;

    /** 持有节点计数器 */
    private final AtomicInteger count = new AtomicInteger(0);

    /** 头指针 */
    private transient Node&lt; e&gt; head;

    /** 尾指针 */
    private transient Node&lt; e&gt; last;

    /** 用于读取的独占锁*/
    private final ReentrantLock takeLock = new ReentrantLock();

    /** 队列是否为空的条件 */
    private final Condition notEmpty = takeLock.newCondition();

    /** 用于写入的独占锁 */
    private final ReentrantLock putLock = new ReentrantLock();

    /** 队列是否已满的条件 */
    private final Condition notFull = putLock.newCondition();

    private void signalNotEmpty() &#123;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lock();
        try &#123;
            notEmpty.signal();
        &#125; finally &#123;
            takeLock.unlock();
        &#125;
    &#125;

    private void signalNotFull() &#123;
        final ReentrantLock putLock = this.putLock;
        putLock.lock();
        try &#123;
            notFull.signal();
        &#125; finally &#123;
            putLock.unlock();
        &#125;
    &#125;

    private void insert(E x) &#123;
        last = last.next = new Node&lt; e&gt;(x);
    &#125;

    private E extract() &#123;
        Node&lt; e&gt; first = head.next;
        head = first;
        E x = first.item;
        first.item = null;
        return x;
    &#125;

    private void fullyLock() &#123;
        putLock.lock();
        takeLock.lock();
    &#125;

    private void fullyUnlock() &#123;
        takeLock.unlock();
        putLock.unlock();
    &#125;

    public LinkedBlockingQueue(int capacity) &#123;
        if (capacity &lt;= 0) throw new IllegalArgumentException();
        this.capacity = capacity;
        last = head = new Node&lt; e&gt;(null);
    &#125;
   ...
&#125;
</code></pre>
<p>这里仅仅展示部分源码，主要的方法在后面的分析中列出。分析之前明确一个最基本的概念。天天念叨着编写线程安全的类，什么是线程安全的类？那就是类内共享的全局变量的访问必须保证是不受多线程形式影响的。如果由于多线程的访问（改变，遍历，查看）而使这些变量结构被破坏或者针对这些变量操作的原子性被破坏，则这个类的编写不是线程安全的。</p>
<p>明确了这个基本的概念就可以很好的理解这个Queue的实现为什么是线程安全的了。在LinkedBlockingQueue的所有共享的全局变量中，final声明的capacity在构造器生成实例时就成了不变量了。而final声明的count由于是AtomicInteger类型的，所以能够保证其操作的原子性。剩下的final的变量都是初始化成了不变量，并且不包含可变属性，所以都是访问安全的。那么剩下的就是Node类型的head和last两个可变量。所以要保证LinkedBlockingQueue是线程安全的就是要保证对head和last的访问是线程安全的。</p>
<p>首先从上面的源码可以看到insert(E x),extract()是真正的操作head,last来入队和出对的方法，但是由于是私有的，所以不能被直接访问，不用担心线程的问题。实际入队的公开的方法是put(E e)，offer(E e)和offer(E e, long timeout, TimeUnit unit)。put(…)方法与offer(…)都是把新元素加入到队尾，所不同的是如果不满足条件put会把当前执行的线程扔到等待集中等待被唤醒继续执行，而offer则是直接退出，所以如果是需要使用它的阻塞特性的话，不能直接使用poll(…)。</p>
<p>put(…)方法中加入元素的操作使用this.putLock来限制多线程的访问，并且使用了可中断的方式：</p>
<pre><code>public void put(E e) throws InterruptedException &#123;
        if (e == null) throw new NullPointerException();
        int c = -1;
        final ReentrantLock putLock = this.putLock;
        final AtomicInteger count = this.count; //----------------a
        putLock.lockInterruptibly();//随时保证响应中断 //--------b
        try &#123;
            //*****************************(1)*********************************
            try &#123;
                while (count.get() == capacity)
                    notFull.await();
            &#125; catch (InterruptedException ie) &#123;
                notFull.signal(); // propagate to a non-interrupted thread
                throw ie;
            &#125;
           //*****************************end*********************************
            insert(e);//真正的入队操作
           //********************(2)**********************
            c = count.getAndIncrement();
            if (c + 1 &lt; capacity)
                notFull.signal();
            //******************end**********************
        &#125; finally &#123;
            putLock.unlock();
        &#125; //-------------------------c
        if (c == 0) //---------------d
            signalNotEmpty();
&#125;
</code></pre>
<p>代码段(1)是阻塞操作，代码段(2)是count递增和唤醒等待的操作。两者之间的insert(e)才是入队操作，其实际是操作的队尾引用last，并且没有牵涉到head。所以设计两个锁的原因就在这里！因为出队操作take()，poll()实际是执行extract()仅仅操作队首引用head。增加了this.takeLock这个锁，就实现了多个不同任务的线程入队的同时可以进行出对的操作，并且由于两个操作所共同使用的count是AtomicInteger类型的，所以完全不用考虑计数器递增递减的问题。假设count换成int，则相应的putLock内的count++和takeLock内的count–有可能相互覆盖，最终造成count的值被腐蚀，故这种设计必须使用原子操作类。</p>
<p>保证类的线程安全只要保证head和last的操作的线程安全，也就是保证insert(E x)和extract()线程安全即可。那么上面的put方法中的代码段(1)放在a,b之间，代码段(2)放在c,d之间不是更好？毕竟锁的粒度越小越好。单纯的考虑count的话这样的改变是正确的，但是await()和singal()这两个方法执行时都会检查当前线程是否是独占锁的那个线程，如果不是则抛出java.lang.IllegalMonitorStateException异常。而这两段代码中包含notFull.await()和notFull.signal()这两句使得(1),(2)必须放在lock保护块内。这里说明主要是count本身并不需要putLock或者takeLock的保护，从</p>
<pre><code>public int size() &#123;
        return count.get();
&#125;
</code></pre>
<p>可以看出count的访问是不需要任何锁的。而在put等方法中，其与锁机制的混用很容易造成迷惑。最后put中的代码d的作用主要是一个低位及时通知的作用，也就是队列刚有值试图获得takeLock去通知等待集中的出队线程。因为c&#x3D;&#x3D;0意味着count.getAndIncrement()原子递增成功，所以count &gt; 0成立。类似作用的代码：</p>
<pre><code>if (c == capacity)
       signalNotFull();
</code></pre>
<p>在take和poll中也有出现，实现了高位及时通知。</p>
<p>分析完了put，对应的offer，take，poll方法都是类似的实现。下面看看遍历队列的操作：</p>
<pre><code>public Object[] toArray() &#123;
        fullyLock();
        try &#123;
            int size = count.get();
            Object[] a = new Object[size];
            int k = 0;
            for (Node p = head.next; p != null; p = p.next)
                a[k++] = p.item;
            return a;
        &#125; finally &#123;
            fullyUnlock();
        &#125;
&#125;
</code></pre>
<p>这个方法很简单主要是要清楚一点：这个操作执行时不允许其他线程再修改队首和队尾，所以使用了fullyLock去获取putLock和takeLock，只要成功则可以保证不会再有修改队列的操作。然后就是安心的遍历到最后一个元素为止了。</p>
<p>另外在offer(E e, long timeout, TimeUnit unit)这个方法中提供了带有超时的入队操作，如果一直不成功的话，它会尝试在timeout的时间内入队：</p>
<pre><code>for (;;) &#123;
     ...//入队操作
     if (nanos &lt;= 0)
         return false;
     try &#123;
          nanos = notFull.awaitNanos(nanos);
     &#125; catch (InterruptedException ie) &#123;
           notFull.signal(); // propagate to a non-interrupted thread
           throw ie;
     &#125;
&#125;
</code></pre>
<p>其内部循环使用notFull.awaitNanos(nanos)方法反复的计算剩余时间的大概值用于实现延时功能。nanos&lt;&#x3D;0则放弃尝试，直接退出。</p>
<p>整体而言，LinkedBlockingQueue的实现还是很清晰的。相对于后面要介绍的ConcurrentLinkedQueue来说，它属于简单的实现。这些看似复杂的数据结构的实现实质都是多线程的基础的综合应用。就好像数学中千变万化的难题其实都是基础公式的组合一样，如果有清晰的基础认知，还是能找到自己分析的思路的。本来是想从mina中找找类似的实现，不过很遗憾的是它好像仅仅实现了一个非线程安全的循环队列，然后在其基础上使用synchronized进行封装成线程安全的Queue。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/threadsafe/linkedblockingqueue/" data-id="clhlnylih00uvojup39e1a085" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/threadsafe/readwritelock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/threadsafe/readwritelock/" class="article-date">
  <time datetime="2015-12-24T06:54:16.000Z" itemprop="datePublished">2015-12-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/threadsafe/readwritelock/">JAVA同步之ReentrantReadWriteLock</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！</p>
<p>ReentrantReadWriteLock会使用两把锁来解决问题，一个读锁，一个写锁</p>
<p>线程进入读锁的前提条件：</p>
<p>没有其他线程的写锁，</p>
<p>没有写请求或者有写请求，但调用线程和持有锁的线程是同一个</p>
<p>线程进入写锁的前提条件：</p>
<p>没有其他线程的读锁</p>
<p>没有其他线程的写锁</p>
<p>ReentrantReadWriteLock锁机制的特性:</p>
<p>(a).重入方面其内部的WriteLock可以获取ReadLock，但是反过来ReadLock想要获得WriteLock则永远都不要想。</p>
<p>(b).WriteLock可以降级为ReadLock，顺序是：先获得WriteLock再获得ReadLock，然后释放WriteLock，这时候线程将保持Readlock的持有。反过来ReadLock想要升级为WriteLock则不可能，为什么？参看(a)</p>
<p>(c).ReadLock可以被多个线程持有并且在作用时排斥任何的WriteLock，而WriteLock则是完全的互斥。这一特性最为重要，因为对于高读取频率而相对较低写入的数据结构，使用此类锁同步机制则可以提高并发量。</p>
<p>(d).不管是ReadLock还是WriteLock都支持Interrupt，语义与ReentrantLock一致。</p>
<p>(e).WriteLock支持Condition并且与ReentrantLock语义一致，而ReadLock则不能使用Condition，否则抛出UnsupportedOperationException异常。</p>
<p>例子1：</p>
<pre><code>package com.thread;

import java.util.Random;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockTest &#123;
    public static void main(String[] args) &#123;
        final Queue3 q3 = new Queue3();
        for(int i=0;i&lt;3;i++)
        &#123;
            new Thread()&#123;
                public void run()&#123;
                    while(true)&#123;
                        q3.get();
                    &#125;
                &#125;

            &#125;.start();
        &#125;
        for(int i=0;i&lt;3;i++)
        &#123;
            new Thread()&#123;
                public void run()&#123;
                    while(true)&#123;
                        q3.put(new Random().nextInt(10000));
                    &#125;
                &#125;

            &#125;.start();
        &#125;
    &#125;
&#125;

class Queue3&#123;
    private Object data = null;//共享数据，只能有一个线程能写该数据，但可以有多个线程同时读该数据。
    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    public void get()&#123;
        rwl.readLock().lock();//上读锁，其他线程只能读不能写
        System.out.println(Thread.currentThread().getName() + &quot; be ready to read data!&quot;);
        try &#123;
            Thread.sleep((long)(Math.random()*1000));
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(Thread.currentThread().getName() + &quot;have read data :&quot; + data);
        rwl.readLock().unlock(); //释放读锁，最好放在finnaly里面
    &#125;

    public void put(Object data)&#123;

        rwl.writeLock().lock();//上写锁，不允许其他线程读也不允许写
        System.out.println(Thread.currentThread().getName() + &quot; be ready to write data!&quot;);
        try &#123;
            Thread.sleep((long)(Math.random()*1000));
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        this.data = data;
        System.out.println(Thread.currentThread().getName() + &quot; have write data: &quot; + data);

        rwl.writeLock().unlock();//释放写锁    
    &#125;
&#125;
</code></pre>
<p>下面使用读写锁模拟一个缓存器：</p>
<pre><code>package com.thread;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class CacheDemo &#123;
    private Map&lt; String,Object&gt; map = new HashMap&lt; String,Object&gt;();//缓存器
    private ReadWriteLock rwl = new ReentrantReadWriteLock();

    public Object get(String id)&#123;
        Object value = null;
        rwl.readLock().lock();//首先开启读锁，从缓存中去取
        try&#123;
            value = map.get(id); 
            if(value == null)&#123;  //如果缓存中没有释放读锁，上写锁
                rwl.readLock().unlock();
                rwl.writeLock().lock();
                try&#123;
                    if(value == null)&#123;
                        value = &quot;aaa&quot;;  //此时可以去数据库中查找，这里简单的模拟一下
                    &#125;
                &#125;finally&#123;
                    rwl.writeLock().unlock(); //释放写锁
                &#125;
                rwl.readLock().lock(); //然后再上读锁
            &#125;
        &#125;finally&#123;
            rwl.readLock().unlock(); //最后释放读锁
        &#125;
        return value;
    &#125;

&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/threadsafe/readwritelock/" data-id="clhlnylij00v5ojupg1lohmfg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/threadsafe/atomic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/threadsafe/atomic/" class="article-date">
  <time datetime="2015-12-24T06:26:30.000Z" itemprop="datePublished">2015-12-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/threadsafe/atomic/">JAVA同步之Atomic类的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>要想理解java.util.concurrent.atomic包的原子类的原理和使用，先要理解CAS(Compare-And-Swap比较并交换)的概念。</p>
<p>现在大多数的处理器都提供对并发访问的支持，这个支持的反映方式就是提供硬件的指令支持多处理的特殊需求。比如检测或者阻止其它处理器的并发访问来更新共享变量的指令。</p>
<p>对于Intel x86架构的处理器来说就是通过提供实现CAS或者比较并设置的硬件原语指令集。CAS操作的三个操作数：内存位置（V），预期原值（A）和新值（B）。执行的过程通常是：预测内存地址V应该包含值A，如果包含则将值B替换到位置V；否则，不更改任何值，告知地址V的当前值。CAS对待“读－修改－写”的操作一般是检测这个过程是否有其它的线程在修改变量，如果有那么这次的CAS操作失败，可以尝试重新进行CAS。</p>
<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>JDK5以后在java.util.concurrent.atomic包下提供了十几个原子类。常见的是AtomicInteger,AtomicLong,AtomicReference以及它们的数组形式，还有AtomicBoolean和为了处理ABA问题引入的AtomicStampedReference类，最后就是基于反射的对volatile变量进行更新的实用工具类：AtomicIntegerFieldUpdater,AtomicLongFieldUpdater,AtomicReferenceFieldUpdater。这些原子类理论上能够大幅的提升性能。并且java.util.concurrent内的并发集合，线程池，执行器，同步器的内部实现大量的依赖这些无锁原子类，从而争取性能的最大化。</p>
<p>原子类的核心方法是一个叫compareAndSet的方法，比如AtomicInteger的：</p>
<pre><code> public final boolean compareAndSet(int expect, int update) &#123;
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    &#125;
</code></pre>
<p>如果当前真实值为expect，那就更新其为update，成功返回true，失败返回false。</p>
<p>让我们看年compareAndSet怎么使用，也以AtomicInteger里的方法为例：</p>
<pre><code>    public final int addAndGet(int delta) &#123;
        for (;;) &#123;
            int current = get();
            int next = current + delta;
            if (compareAndSet(current, next))
                return next;
        &#125;
    &#125;
</code></pre>
<p>addAndGet方法会给当前值加上delta，然后返回相加的值。他是如何保证“读-修改-写”的原子性的呢？</p>
<p>看代码可知，读和修改后，写会用compareAndSet，如果读和修改后在写之前，有其它线程改变了真实值，那current就和内存的值不一样了，这样会返回false，那return就不会执行，for循环会再来一次“读-修改-写”操作。直到成功完成操作，返回修改后的值。</p>
<p>原子类都是用这种方式修改值的，这样就保证了“读-修改-写”的原子性，这就是CAS的用途。</p>
<h2 id="一个例子："><a href="#一个例子：" class="headerlink" title="一个例子："></a>一个例子：</h2><pre><code>import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicInteger;
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicCounterSample</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicCounter atomicCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtomicCounterSample</span><span class="params">(AtomicCounter atomicCounter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.atomicCounter = atomicCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sleepTime</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(sleepTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        atomicCounter.counterIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AtomicCounter</span> <span class="variable">atomicCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicCounter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AtomicCounterSample</span>(atomicCounter).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;counter=&quot;</span> + atomicCounter.getCounter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">counterIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> counter.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (counter.compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt; atomiccounter2&gt; counterUpdater</span><br><span class="line">             = AtomicIntegerFieldUpdater.newUpdater(AtomicCounter2.class, <span class="string">&quot;counter&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">counterIncrement</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        return counter++;</span></span><br><span class="line">        <span class="keyword">return</span> counterUpdater.getAndIncrement(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子实现了原子计数器的两个版本：AtomicCounter，AtomicCounter2。AtomicCounterSample作为Thread的子类对共享变量AtomicCounter或者AtomicCounter2内的counter变量进行增幅为1的递增。主函数的过程是开启5000线程，并且每个线程随机睡眠极短时间后执行递增。所以线程安全的执行结果应该是5000。</p>
<p>首先看版本1：AtomicCounter内的共享变量使用了Integer的原子类代替，在get()方法中不使用锁，也不用担心获取的过程中别的线程去改变counter的值，因为这些原子类可以看成volatile的范化扩展，可见性能够保证。而在counterIncrement()方法中揭示了使用原子类的重要技巧：循环结合CAS。这个技巧可以帮助我们实现复杂的非阻塞并发集合。方法中的counter.compareAndSet(current,next)就是原子类使用的精髓－－CAS操作。compareAndSet(…)可以说是原子类搭积木的原材料，在循环中使用它可以让我们的并发程序昂首挺胸。</p>
<p>再看版本2：AtomicCounter2内有个volatile的共享变量counter，并且有个类变量counterUpdater作为counter的更新器。在counterIncrement()里注释掉的代码是非线程安全的。而counterUpdater.getAndIncrement(this)的内部实现其实和版本1的几乎一样。唯一不同的是通过反射找到要原子操作更新的变量counter，但是“循环+CAS”的精髓是一样的。</p>
<p>最后看看结果吧：版本1和版本2的无锁同步的执行分别20次均是5000，正确。版本2把无锁同步的代码注释，把已注释的非线程安全的代码还原执行，平均每10次大概有1～2次出现&lt;5000的数字。这个例子侧面证明了++的原子性操作非线程安全是保证不了的。因为“读－修改－写”的操作碰到如下场景：线程A“读－修改”后“写”之前，线程B完成“读－修改－写”。这时候A,B的写值是重复的，这就造成了结果&lt;5000，又杯具了…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/threadsafe/atomic/" data-id="clhlnylid00u9ojupglvi3ht7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/threadsafe/deamonjoin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/threadsafe/deamonjoin/" class="article-date">
  <time datetime="2015-12-23T08:59:30.000Z" itemprop="datePublished">2015-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/threadsafe/deamonjoin/">JAVA同步之守护线程和JOIN方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程是辅助线程，比如A线程中启动了线程B，并把B设置成守护，则A为主线程，如果主线程结束，守护它的线程不论做什么都会结束。</p>
<pre><code>public class DaemonSample &#123;
    public static void main(String[] args) throws Exception&#123;
        DaemonThread t = new DaemonThread();
        t.setDaemon(true);//this is set t thread as a daemon thread.
        t.start();
        Thread.sleep(2000);
        System.out.println(&quot;main thread exit.&quot;);
    &#125;
&#125;

class DaemonThread extends Thread &#123;
    @Override
    public void run() &#123;
        for(int i = 0; i &lt; 10; i++) &#123;
            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;i=&quot; + i);
        &#125;
    &#125;
&#125;
</code></pre>
<p>这个例子的结果是main主线程睡两秒之后说再见，而子线程则是在这两秒内计计数然后跟着一起说再见。当然它很不情愿，因为它想计10秒，但是没机会。把t.setDaemonThread(true)注释掉你会看到主线程说再见了，但是子线程快快乐乐的计完数说再见。这就是守护线程的作用，一切以非守护线程为主！</p>
<h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p>在简单的多线程编程中，常常使用join方法来控制线程的执行顺序，也仅仅是一小部分的作用。它的内部实现是wait(0)直至被调用线程执行完毕，调用线程才被唤醒。</p>
<pre><code>public class JoinSample &#123;
    public static void main(String[] args) throws Exception&#123;
        Thread t = new Thread(new SubThread());
        t.start();
        t.join();
        System.out.println(&quot;The end of main thread...&quot;);
    &#125;
&#125;

class SubThread implements Runnable &#123;

    public void run() &#123;
        try &#123;
            Thread.sleep(2000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;The end of sub thread...&quot;);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，被调用join()的线程是t，而调用线程则是main所以会先打印下面的那句再打印上面的，即使t要先睡两秒，main也得等着。把t.join()注释掉，main就可以扬眉吐气了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/threadsafe/deamonjoin/" data-id="clhlnylig00uoojup3u6hc7up" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/threadsafe/conditions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/threadsafe/conditions/" class="article-date">
  <time datetime="2015-12-23T05:24:52.000Z" itemprop="datePublished">2015-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/threadsafe/conditions/">JAVA同步之ReentrantLock多条件的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ReentrantLock的代码段中如何实现线程等待（wait）和唤醒（nofity)呢？ReentrantLock的wait()和notify（）方法是不能用的，那是针对synchronized的。</p>
<p>JAVA的实现方案是用Condition解决，lock.newCondition()可以创建一个条件，一个lock可以创建多个条件，这也是ReentrantLock比synchronized强的地方之一。</p>
<p>Condition 的方法与 wait 、 notify 和 notifyAll 方法类似，分别命名为await 、 signal 和signalAll。当不满足条件时调用Condition的await()方法就可以使当前线程等待。</p>
<p>下面以JAVA自己的线程安全容器为例，介绍一下Condition的使用。</p>
<h2 id="java-util-concurrent-ArrayBlockingQueue"><a href="#java-util-concurrent-ArrayBlockingQueue" class="headerlink" title="java.util.concurrent.ArrayBlockingQueue"></a>java.util.concurrent.ArrayBlockingQueue</h2><pre><code>public class ArrayBlockingQueue&lt; e&gt; extends AbstractQueue&lt; e&gt; implements BlockingQueue&lt; e&gt;, java.io.Serializable &#123;
    ...
    /** Main lock guarding all access */
    private final ReentrantLock lock;

    /** Condition for waiting takes */
    private final Condition notEmpty;

    /** Condition for waiting puts */
    private final Condition notFull;

    ...
    public ArrayBlockingQueue(int capacity, boolean fair) &#123;
        if (capacity &lt;= 0)
            throw new IllegalArgumentException();
        this.items = (E[]) new Object[capacity];
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    &#125;

    public void put(E e) throws InterruptedException &#123;
        if (e == null) throw new NullPointerException();
        final E[] items = this.items;
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try &#123;
            try &#123;
                while (count == items.length)
                    notFull.await();
            &#125; catch (InterruptedException ie) &#123;
                notFull.signal(); // propagate to non-interrupted thread
                throw ie;
            &#125;
            insert(e);
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    private void insert(E x) &#123;
        items[putIndex] = x;
        putIndex = inc(putIndex);
        ++count;
        notEmpty.signal();
    &#125;

    public E take() throws InterruptedException &#123;
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try &#123;
            try &#123;
                while (count == 0)
                    notEmpty.await();
            &#125; catch (InterruptedException ie) &#123;
                notEmpty.signal(); // propagate to non-interrupted thread
                throw ie;
            &#125;
            E x = extract();
            return x;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    private E extract() &#123;
        final E[] items = this.items;
        E x = items[takeIndex];
        items[takeIndex] = null;
        takeIndex = inc(takeIndex);
        --count;
        notFull.signal();
        return x;
    &#125;
    ...
&#125;
</code></pre>
<p>这里notEmpty和notFull作为lock的两个条件，分别负责管理想要加入元素的线程和想要取出元素的线程的wait和notify，通过await()、signal()、signalAll()方法，有效的分离了不同职责的线程。</p>
<p>例如put()方法在元素个数达到最大限制时会使用notFull条件把试图继续插入元素的线程都扔到等待集中，而执行了take()方法时如果顺利进入extract()则会空出空间，这时notFull负责随机的通知被其扔到等待集中的线程执行插入元素的操作。这样的设计使得线程按照功能行为职责管理成为了现实。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/threadsafe/conditions/" data-id="clhlnylif00ulojup7jd56cdz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/threadsafe/lockInterruptibly" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/threadsafe/lockInterruptibly/" class="article-date">
  <time datetime="2015-12-23T03:18:54.000Z" itemprop="datePublished">2015-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/threadsafe/lockInterruptibly/">JAVA同步之ReentrantLock可中断锁的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本本文是对ReentrantLock可中断锁的介绍。可中断锁是通过ReentrantLock提供的lockInterruptibly()方法实现的。</p>
<h2 id="响应中断是什么意思"><a href="#响应中断是什么意思" class="headerlink" title="响应中断是什么意思?"></a>响应中断是什么意思?</h2><p>比如A、B两线程去竞争锁，A得到了锁，B等待，但是A有很多事情要处理，所以一直不返回。B可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。在这种情况下，synchronized的做法是，B线程中断自己（或者别的线程中断它），我不去响应，继续让B线程等待，你再怎么中断，我全当耳边风。而lockInterruptibly()的做法是，B线程中断自己（或者别的线程中断它），ReentrantLock响应这个中断，不再让B等待这个锁的到来。有了这个机制，使用ReentrantLock时死锁了线程可以中断自己来解除死锁。</p>
<h2 id="什么叫做中断自己？"><a href="#什么叫做中断自己？" class="headerlink" title="什么叫做中断自己？"></a>什么叫做中断自己？</h2><p>比如A、B两线程去竞争锁，它们肯定是被父线程创建并启动的，那父线程一定有它们的引用。线程都有interrupt()方法，假设父线程创建的线程B的引用是b，那b.interrupt()就是中断自己。</p>
<h2 id="怎么中断自己"><a href="#怎么中断自己" class="headerlink" title="怎么中断自己"></a>怎么中断自己</h2><p>lock.lockInterruptibly()，这个方法会抛出异常InterruptedException。</p>
<p>什么时候抛出异常呢？当调用interrupt()方法自我中断的时候。</p>
<p>这时线程就进入了中断处理的过程，不会再等待锁了。</p>
<p>至于异常处理是怎样的，有很多种选择呀。比如可以退出线程的run()方法使线程完结，也可以使线程处理另外的事情。</p>
<h2 id="一个中断锁的例子"><a href="#一个中断锁的例子" class="headerlink" title="一个中断锁的例子"></a>一个中断锁的例子</h2><pre><code>import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockSample &#123;

    public static void main(String[] args) &#123;
        testSynchronized();
        testReentrantLock();
    &#125;

    public static void testReentrantLock() &#123;
        final SampleSupport1 support = new SampleSupport1();
        Thread first = new Thread(new Runnable() &#123;
            public void run() &#123;
                try &#123;
                    support.doSomething();
                &#125;
                catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;first&quot;);

        Thread second = new Thread(new Runnable() &#123;
            public void run() &#123;
                try &#123;
                    support.doSomething();
                &#125;
                catch (InterruptedException e) &#123;
                    System.out.println(&quot;Second Thread Interrupted without executing counter++,beacuse it waits a long time.&quot;);
                &#125;
            &#125;
        &#125;,&quot;second&quot;);

        executeTest(first, second);
    &#125;

    public static void testSynchronized() &#123;
        final SampleSupport2 support2 = new SampleSupport2();

        Runnable runnable = new Runnable() &#123;
            public void run() &#123;
                support2.doSomething();
            &#125;
        &#125;;

        Thread third = new Thread(runnable,&quot;third&quot;);
        Thread fourth = new Thread(runnable,&quot;fourth&quot;);

        executeTest(third, fourth);
    &#125;

    /**
     * Make thread a run faster than thread b,
     * then thread b will be interruted after about 1s.
     * @param a
     * @param b
     */
    public static void executeTest(Thread a, Thread b) &#123;
        a.start();
        try &#123;
            Thread.sleep(100);
            b.start(); 
            Thread.sleep(1000);
            b.interrupt(); 
        &#125;
        catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

abstract class SampleSupport &#123;

    protected int counter;

    /**
     * A simple countdown,it will stop after about 5s. 
     */
    public void startTheCountdown() &#123;
        long currentTime = System.currentTimeMillis();
        for (;;) &#123;
            long diff = System.currentTimeMillis() - currentTime;
            if (diff &gt; 5000) &#123;
                break;
            &#125;
        &#125;
    &#125;
&#125;

class SampleSupport1 extends SampleSupport &#123;

    private final ReentrantLock lock = new ReentrantLock();

    public void doSomething() throws InterruptedException &#123;
        lock.lockInterruptibly();
//        try &#123;
//            lock.lockInterruptibly();
//        &#125; catch (InterruptedException e) &#123;
//            //做一些其它的事，不结束线程
//        &#125;
        System.out.println(Thread.currentThread().getName() + &quot; will execute counter++.&quot;);
        startTheCountdown();
        try &#123;
            counter++;
        &#125;
        finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;

class SampleSupport2 extends SampleSupport &#123;

    public synchronized void doSomething() &#123;
        System.out.println(Thread.currentThread().getName() + &quot; will execute counter++.&quot;);
        startTheCountdown();
        counter++;
    &#125;
&#125;
</code></pre>
<h2 id="中断介绍"><a href="#中断介绍" class="headerlink" title="中断介绍"></a>中断介绍</h2><p>中断（Interrupt）一个线程意味着在该线程完成任务之前停止其正在进行的一切，有效地中止其当前的操作。线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序。虽然初次看来它可能显得简单，但是，你必须进行一些预警以实现期望的结果。</p>
<p>从上面的介绍知道，interrupt()并不会使线程停止运行，那如何停止线程呢？</p>
<p>中断线程最好的，最受推荐的方式是，使用共享变量（shared<br>variable）发出信号，告诉线程必须停止正在运行的任务。线程必须周期性的核查这一变量（尤其在冗余操作期间），然后有秩序地中止任务。</p>
<pre><code>class Example2 extends Thread &#123;
    volatile boolean stop = false;

    public static void main(String args[]) throws Exception &#123;
        Example2 thread = new Example2();
        System.out.println(&quot;Starting thread...&quot;);
        thread.start();
        Thread.sleep(3000);
        System.out.println(&quot;Asking thread to stop...&quot;);

        thread.stop = true;
        Thread.sleep(3000);
        System.out.println(&quot;Stopping application...&quot;);
        //System.exit( 0 );
    &#125;

    public void run() &#123;
        while (!stop) &#123;
            System.out.println(&quot;Thread is running...&quot;);
            long time = System.currentTimeMillis();
            while ((System.currentTimeMillis() - time &lt; 1000) &amp;&amp; (!stop)) &#123;
            &#125;
        &#125;
        System.out.println(&quot;Thread exiting under request...&quot;);
    &#125;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/threadsafe/lockInterruptibly/" data-id="clhlnylih00uyojupdfydd8re" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/threadsafe/reentrantlock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/threadsafe/reentrantlock/" class="article-date">
  <time datetime="2015-12-23T02:27:39.000Z" itemprop="datePublished">2015-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/threadsafe/reentrantlock/">JAVA同步之ReentrantLock 类简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ReentrantLock-类"><a href="#ReentrantLock-类" class="headerlink" title="ReentrantLock 类"></a>ReentrantLock 类</h2><p>java.util.concurrent.lock 中的 Lock框架是锁定的一个抽象，它允许把锁定的实现作为 Java类，而不是作为语言的特性来实现。这就为 Lock的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。</p>
<p>ReentrantLock 类实现了 Lock ，它拥有与 synchronized相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM可以花更少的时候来调度线程，把更多时间用在执行线程上。）</p>
<p>reentrant锁意味着什么呢？简单来说，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。这模仿了synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续）<br>synchronized 块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个synchronized 块时，才释放锁。</p>
<p>Lock 和 synchronized 有一点明显的区别 —— lock 必须在 finally块中释放。否则，如果受保护的代码将抛出异常，锁就有可能永远得不到释放！这一点区别看起来可能没什么，但是实际上，它极为重要。忘记在finally<br>块中释放锁，可能会在程序中留下一个定时炸弹，当有一天炸弹爆炸时，您要花费很大力气才有找到源头在哪。而使用同步，JVM将确保锁会获得自动释放。</p>
<pre><code>Lock lock = new ReentrantLock();
lock.lock();
try &#123; 
  // update object state
&#125;
finally &#123;
  lock.unlock(); 
&#125;
</code></pre>
<p>除此之外，与目前的 synchronized 实现相比，争用下的 ReentrantLock实现更具可伸缩性。（在未来的 JVM 版本中，synchronized的争用性能很有可能会获得提高。）这意味着当许多线程都在争用同一个锁时，使用<br>ReentrantLock 的总体开支通常要比 synchronized 少得多。</p>
<p>根类 Object 包含某些特殊的方法，用来在线程的 wait() 、 notify() 和notifyAll() 之间进行通信。</p>
<p>通知与锁定之间有一个交互 —— 为了在对象上 wait 或 notify，您必须持有该对象的锁。就像 Lock 是同步的概括一样， Lock 框架包含了对wait 和 notify 的概括，这个概括叫作 条件（Condition） 。 Lock对象则充当绑定到这个锁的条件变量的工厂对象，与标准的 wait 和 notify方法不同，对于指定的 Lock，可以有不止一个条件变量与它关联。这样就简化了许多并发算法的开发。例如，条件（Condition） 的 Javadoc显示了一个有界缓冲区实现的示例，该示例使用了两个条件变量，“notfull”和“not empty”，它比每个 lock 只用一个 wait设置的实现方式可读性要好一些（而且更有效）。 Condition 的方法与 wait 、notify 和 notifyAll 方法类似，分别命名为 await 、 signal 和 signalAll，因为它们不能覆盖 Object 上的对应方法。</p>
<h2 id="不要抛弃-synchronized"><a href="#不要抛弃-synchronized" class="headerlink" title="不要抛弃 synchronized"></a>不要抛弃 synchronized</h2><p>虽然 ReentrantLock 是个非常动人的实现，相对 synchronized来说，它有一些重要的优势，但是我认为急于把 synchronized视若敝屣，绝对是个严重的错误。 java.util.concurrent.lock中的锁定类是用于高级用户和高级情况的工具 。一般来说，除非您对 Lock的某个高级特性有明确的需要，或者有明确的证据（而不是仅仅是怀疑）表明在特定情况下，同步已经成为可伸缩性的瓶颈，否则还是应当继续使用synchronized。</p>
<p>为什么我在一个显然“更好的”实现的使用上主张保守呢？因为对于java.util.concurrent.lock 中的锁定类来说，synchronized仍然有一些优势。比如，在使用 synchronized 的时候，不能忘记释放锁；在退出synchronized 块时，JVM 会为您做这件事。您很容易忘记用 finally块释放锁，这对程序非常有害。您的程序能够通过测试，但会在实际工作中出现死锁，那时会很难指出原因（这也是为什么根本不让初级开发人员使用<br>Lock 的一个好理由。）</p>
<p>另一个原因是因为，当 JVM 用 synchronized 管理锁定请求和释放时，JVM在生成线程转储时能够包括锁定信息。这些对调试非常有价值，因为它们能标识死锁或者其他异常行为的来源。</p>
<p>Lock 类只是普通的类，JVM 不知道具体哪个线程拥有 Lock对象。而且，几乎每个开发人员都熟悉synchronized，它可以在 JVM的所有版本中工作。在 JDK 5.0成为标准（从现在开始可能需要两年）之前，使用 Lock类将意味着要利用的特性不是每个 JVM都有的，而且不是每个开发人员都熟悉的。</p>
<h2 id="什么时候选择用-ReentrantLock-代替-synchronized"><a href="#什么时候选择用-ReentrantLock-代替-synchronized" class="headerlink" title="什么时候选择用 ReentrantLock 代替 synchronized"></a>什么时候选择用 ReentrantLock 代替 synchronized</h2><p>既然如此，我们什么时候才应该使用 ReentrantLock 呢？答案非常简单 ——在确实需要一些 synchronized<br>所没有的特性的时候，比如时间锁等候、可中断锁等候、无块结构锁、多个条件变量或者锁投票。</p>
<p>ReentrantLock</p>
<p>还具有可伸缩性的好处，应当在高度争用的情况下使用它，但是请记住，大多数synchronized块几乎从来没有出现过争用，所以可以把高度争用放在一边。我建议用synchronized 开发，直到确实证明 synchronized不合适，而不要仅仅是假设如果使用 ReentrantLock“性能会更好”。请记住，这些是供高级用户使用的高级工具。（而且，真正的高级用户喜欢选择能够找到的最简单工具，直到他们认为简单的工具不适用为止。）。一如既往，首先要把事情做好，然后再考虑是不是有必要做得更快。</p>
<p>Lock 框架是同步的兼容替代品，它提供了 synchronized没有提供的许多特性，它的实现在争用下提供了更好的性能。但是，这些明显存在的好处，还不足以成为用ReentrantLock 代替 synchronized 的理由。相反，应当根据您是否 需要ReentrantLock 的能力来作出选择。大多数情况下，您不应当选择它 ——synchronized 工作得很好，可以在所有 JVM上工作，更多的开发人员了解它，而且不太容易出错。只有在真正需要 Lock的时候才用它。在这些情况下，您会很高兴拥有这款工具。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/threadsafe/reentrantlock/" data-id="clhlnylik00v9ojupcmk7dsj3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/threadsafe/threadlocal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/threadsafe/threadlocal/" class="article-date">
  <time datetime="2015-12-22T10:23:16.000Z" itemprop="datePublished">2015-12-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/threadsafe/threadlocal/">JAVA同步之ThreadLocal的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当多个线程可以访问一个对象的实例变量时，这个实例变量是线程不安全的。如果我们想保证变量的原子性可以用Synchonized来解决。如果我们想让每个线程都有自己的实例变量怎么办？</p>
<p>比如一个Servlet中众多方法要使用数据库的查询内容，但每个请求的查询内容是不同的，这就要求方法在获取数据库查询内容时是指定线程查出来的。这时就要用到ThreadLocal。</p>
<p>ThreadLocal的实现原理很简单，每个Thread都有一个MAP，叫做threadLocals。</p>
<pre><code>public
class Thread implements Runnable &#123;
    ...
    ThreadLocal.ThreadLocalMap threadLocals = null;
    ...
&#125;
</code></pre>
<p>ThreadLocal主要用两个方法：</p>
<p>void set(Object obj) 设置当前线程的变量的副本的值。</p>
<p>Object get() 返回当前线程的变量副本</p>
<p>看一下具体实现：</p>
<pre><code>    public T get() &#123;
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) &#123;
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null)
                return (T)e.value;
        &#125;
        return setInitialValue();
    &#125;
    public void set(T value) &#123;
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    &#125;
</code></pre>
<p>它设置的是当前线程中的threadLocals这个MAP，Map的key是ThreadLocal对象本身的实例。</p>
<p>来一个例子：</p>
<pre><code>    public class ThreadLocalDemo implements Runnable &#123;
       private final static  ThreadLocal studentLocal = new ThreadLocal();  //ThreadLocal对象在这

       public static void main(String[] agrs) &#123;
           TreadLocalDemo td = new TreadLocalDemo();
             Thread t1 = new Thread(td,&quot;a&quot;);
             Thread t2 = new Thread(td,&quot;b&quot;);
            t1.start();
            t2.start();
          &#125;

        public void run() &#123;
             accessStudent();
        &#125;

        public  void  accessStudent() &#123;
            String currentThreadName = Thread.currentThread().getName();
            System.out.println(currentThreadName+&quot; is running!&quot;);
            Random random = new Random();
            int age = random.nextInt(100);
            System.out.println(&quot;thread &quot;+currentThreadName +&quot; set age to:&quot;+age);
            Student student = getStudent();  //每个线程都独立维护一个Student变量
            student.setAge(age);
            System.out.println(&quot;thread &quot;+currentThreadName+&quot; first  read age is:&quot;+student.getAge());
            try &#123;
            Thread.sleep(5000);
            &#125;
            catch(InterruptedException ex) &#123;
                ex.printStackTrace();
            &#125;
            System.out.println(&quot;thread &quot;+currentThreadName +&quot; second read age is:&quot;+student.getAge());

        &#125;

        protected Student getStudent() &#123;
            Student student = (Student)studentLocal.get();  //从ThreadLocal对象中取
            if(student == null) &#123;
                student = new Student();
                studentLocal.set(student);  //如果没有就创建一个
            &#125;
            return student;
        &#125;

        protected void setStudent(Student student) &#123;
            studentLocal.set(student);  //放入ThreadLocal对象中
        &#125;
    &#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/threadsafe/threadlocal/" data-id="clhlnylin00vlojup39yrhuv9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/threadsafe/waitnotify" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/threadsafe/waitnotify/" class="article-date">
  <time datetime="2015-12-22T09:41:41.000Z" itemprop="datePublished">2015-12-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/threadsafe/waitnotify/">JAVA同步之wait()和notify()的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>wait()&#x2F;notify()：调用任意对象的 wait()方法导致线程阻塞，并且该对象上的锁被释放。而调用任意对象的notify()方法则导致因调用该对象的wait()方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p>
<p>synchronized与这两个方法之间的关系：</p>
<p>1.有synchronized的地方不一定有wait,notify</p>
<p>2.有wait,notify的地方必有synchronized.这是因为wait和notify不是属于线程类，而是每一个对象都具有的方法（事实上，这两个方法是Object类里的），而且，这两个方法都和对象锁有关，有锁的地方，必有synchronized。</p>
<p>锁是针对对象的，wait()&#x2F;notify()的操作是与对象锁相关的，那么把wait()&#x2F;notify()设计在Object中也就是合情合理的了。</p>
<p>为什么有wait,notify的地方必有synchronized？</p>
<p>synchronized方法中由当前线程占有锁。另一方面，调用wait()notify()方法的对象上的锁必须为当前线程所拥有。因此，wait()notify()方法调用必须放置在synchronized方法中，synchronized方法的上锁对象就是调用wait()notify()方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException异常。</p>
<p>能调用wait()&#x2F;notify()的只有当前线程，前提是必须获得了对象锁，就是说必须要进入到synchronized方法中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/threadsafe/waitnotify/" data-id="clhlnyliq00vyojupa30qhcdf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/threadsafe/synchronized" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/threadsafe/synchronized/" class="article-date">
  <time datetime="2015-12-22T09:13:25.000Z" itemprop="datePublished">2015-12-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/threadsafe/synchronized/">JAVA同步之synchronized关键字的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>synchronized是针对对象的隐式锁使用的，注意是对象！</p>
<p>举个小例子，该例子没有任何业务含义，只是为了说明synchronized的基本用法：</p>
<pre><code>Class MyClass()&#123;
  synchronized void myFunction()&#123;
    //do something
  &#125;
&#125;

public static void main()&#123;
  MyClass myClass = new MyClass();
  myClass.myFunction();
&#125;
</code></pre>
<p>myFunction()方法是个同步方法，隐式锁是谁的？答：是该方法所在类的对象。</p>
<p>看看怎么使用的：myClass.myFunction();很清楚了吧，隐式锁是myClass的。</p>
<p>说的在明白一点，线程想要执行myClass.myFunction();就要先获得myClass的锁。</p>
<p>下面总结一下：</p>
<p>1、synchronized关键字的作用域有二种：</p>
<p>1）是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法；</p>
<p>2）是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static方法。它可以对类的所有对象实例起作用。（注：这个可以认为是对Class对象起作用）</p>
<p>2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是:</p>
<p>synchronized(this){&#x2F;*区块*&#x2F;}，它的作用域是this，即是当前对象。当然这个括号里可以是任何对象，synchronized对方法和块的含义和用法并无本质不同；</p>
<p>3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法；</p>
<p>synchronized可能造成死锁，比如：</p>
<pre><code>    class DeadLockSample&#123;
        public final Object lock1 = new Object();
        public final Object lock2 = new Object();

        public void methodOne()&#123;
           synchronized(lock1)&#123;
              ...
              synchronized(lock2)&#123;...&#125;
           &#125;
        &#125;

        public void methodTwo()&#123;
           synchronized(lock2)&#123;
          ...
              synchronized(lock1)&#123;...&#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<p>假设场景：线程A调用methodOne()，获得lock1的隐式锁后，在获得lock2的隐式锁之前线程B进入运行，调用methodTwo()，抢先获得了lock2的隐式锁，此时线程A等着线程B交出lock2，线程B等着lock1进入方法块，死锁就这样被创造出来了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/threadsafe/synchronized/" data-id="clhlnylim00vgojupezi2213x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/22/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/24/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/">JAVA WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/Spring-Boot/">Spring Boot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%BC%80%E5%8F%91/">WEB开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/">nosql</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/MongoDB/">MongoDB</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E9%9B%86/">字符集</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/">spark</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/Emacs/">Emacs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/GIT/">GIT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/SSO/">SSO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%B8%80%E8%87%B4%E6%80%A7/">一致性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%AF%86%E7%A0%81%E6%9C%AF/">密码术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/JMS/">JMS</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6/">组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%AE%97%E6%B3%95/">树算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/BASE/">BASE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/JAVA8/">JAVA8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/NIO/">NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/">Lisp</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/Common-Lisp/">Common Lisp</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Scala/">Scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ASCII%E7%A0%81/" rel="tag">ASCII码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActiveMQ/" rel="tag">ActiveMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ajax/" rel="tag">Ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BAT%E8%84%9A%E6%9C%AC/" rel="tag">BAT脚本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAP/" rel="tag">CAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS/" rel="tag">CAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Common-Lisp/" rel="tag">Common Lisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Emacs/" rel="tag">Emacs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Emmet/" rel="tag">Emmet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GIT/" rel="tag">GIT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HttpClient/" rel="tag">HttpClient</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPFS/" rel="tag">IPFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-IO/" rel="tag">JAVA IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-NIO/" rel="tag">JAVA NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-WEB/" rel="tag">JAVA WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA8/" rel="tag">JAVA8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/" rel="tag">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lisp/" rel="tag">Lisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/" rel="tag">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shiro/" rel="tag">Shiro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/" rel="tag">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/" rel="tag">UML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB%E5%BC%80%E5%8F%91/" rel="tag">WEB开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/" rel="tag">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/archtype/" rel="tag">archtype</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/azkaban/" rel="tag">azkaban</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/" rel="tag">hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jquery/" rel="tag">jquery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql/" rel="tag">nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql-neo4j/" rel="tag">nosql neo4j</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openssl/" rel="tag">openssl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/" rel="tag">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webservice/" rel="tag">webservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag">一致性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" rel="tag">任务调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/" rel="tag">字符集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%A1%E8%AE%A1/" rel="tag">审计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E6%9C%AF/" rel="tag">密码术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%BE%E9%80%92%E5%BD%92/" rel="tag">尾递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/" rel="tag">摘要算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" rel="tag">数字签名</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/" rel="tag">数字证书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/" rel="tag">数据权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E7%AE%97%E6%B3%95/" rel="tag">树算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正规表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" rel="tag">知识体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A5%9E%E5%99%A8/" rel="tag">神器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">自制操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" rel="tag">负载均衡</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10.5px;">AOP</a> <a href="/tags/ASCII%E7%A0%81/" style="font-size: 10px;">ASCII码</a> <a href="/tags/ActiveMQ/" style="font-size: 11px;">ActiveMQ</a> <a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/BAT%E8%84%9A%E6%9C%AC/" style="font-size: 10px;">BAT脚本</a> <a href="/tags/CAP/" style="font-size: 10px;">CAP</a> <a href="/tags/CAS/" style="font-size: 10.5px;">CAS</a> <a href="/tags/Common-Lisp/" style="font-size: 13.5px;">Common Lisp</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10.5px;">C语言</a> <a href="/tags/Eclipse/" style="font-size: 11px;">Eclipse</a> <a href="/tags/Emacs/" style="font-size: 16.5px;">Emacs</a> <a href="/tags/Emmet/" style="font-size: 10px;">Emmet</a> <a href="/tags/GIT/" style="font-size: 10px;">GIT</a> <a href="/tags/HttpClient/" style="font-size: 12.5px;">HttpClient</a> <a href="/tags/IPFS/" style="font-size: 10px;">IPFS</a> <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/JAVA-IO/" style="font-size: 15.5px;">JAVA IO</a> <a href="/tags/JAVA-NIO/" style="font-size: 17px;">JAVA NIO</a> <a href="/tags/JAVA-WEB/" style="font-size: 10.5px;">JAVA WEB</a> <a href="/tags/JAVA8/" style="font-size: 13.5px;">JAVA8</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Lisp/" style="font-size: 12px;">Lisp</a> <a href="/tags/Markdown/" style="font-size: 10.5px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 18px;">MongoDB</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/Scala/" style="font-size: 11px;">Scala</a> <a href="/tags/Shiro/" style="font-size: 10px;">Shiro</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/VIM/" style="font-size: 16px;">VIM</a> <a href="/tags/WEB%E5%BC%80%E5%8F%91/" style="font-size: 11px;">WEB开发</a> <a href="/tags/XML/" style="font-size: 10.5px;">XML</a> <a href="/tags/archtype/" style="font-size: 10px;">archtype</a> <a href="/tags/azkaban/" style="font-size: 10.5px;">azkaban</a> <a href="/tags/hadoop/" style="font-size: 13px;">hadoop</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/hive/" style="font-size: 10px;">hive</a> <a href="/tags/javascript/" style="font-size: 14px;">javascript</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/linux/" style="font-size: 13px;">linux</a> <a href="/tags/maven/" style="font-size: 12px;">maven</a> <a href="/tags/nosql/" style="font-size: 18.5px;">nosql</a> <a href="/tags/nosql-neo4j/" style="font-size: 11.5px;">nosql neo4j</a> <a href="/tags/openssl/" style="font-size: 11px;">openssl</a> <a href="/tags/servlet/" style="font-size: 11px;">servlet</a> <a href="/tags/spark/" style="font-size: 12px;">spark</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/webservice/" style="font-size: 11px;">webservice</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 11.5px;">一致性</a> <a href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" style="font-size: 10.5px;">任务调度</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 10px;">区块链</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 17.5px;">大数据</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/" style="font-size: 12.5px;">字符集</a> <a href="/tags/%E5%AE%A1%E8%AE%A1/" style="font-size: 10px;">审计</a> <a href="/tags/%E5%AF%86%E7%A0%81%E6%9C%AF/" style="font-size: 14.5px;">密码术</a> <a href="/tags/%E5%B0%BE%E9%80%92%E5%BD%92/" style="font-size: 10px;">尾递归</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 12px;">并发</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 14px;">排序</a> <a href="/tags/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/" style="font-size: 10px;">摘要算法</a> <a href="/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" style="font-size: 10.5px;">数字签名</a> <a href="/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/" style="font-size: 10px;">数字证书</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 18.5px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/" style="font-size: 10px;">数据权限</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 11.5px;">杂谈</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 13.5px;">架构</a> <a href="/tags/%E6%A0%91%E7%AE%97%E6%B3%95/" style="font-size: 14px;">树算法</a> <a href="/tags/%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正规表达式</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" style="font-size: 12px;">知识体系</a> <a href="/tags/%E7%A5%9E%E5%99%A8/" style="font-size: 12px;">神器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.5px;">算法</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" style="font-size: 19px;">线程安全</a> <a href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">自制操作系统</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.5px;">设计模式</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 13px;">负载均衡</a> <a href="/tags/%E9%94%81/" style="font-size: 11px;">锁</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2999/12/">十二月 2999</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/02/">二月 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/09/">九月 2009</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/explain/">【置顶】特别说明</a>
          </li>
        
          <li>
            <a href="/blog/tools/maven/dn-cst-maven-archtype/">开发一个maven脚手架</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustrystock/">neo4j创建行业与股票关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustry/">neo4j创建三级行业关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jtimeline/">neo4j创建时间线</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 证心<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>