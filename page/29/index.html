<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>OneKBase</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="OneKBase">
<meta property="og:url" content="http://www.onekbase.com/page/29/index.html">
<meta property="og:site_name" content="OneKBase">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="证心">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="OneKBase" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">OneKBase</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.onekbase.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-blog/plang/lisp/lispdiary/lispgkxx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/lisp/lispdiary/lispgkxx/" class="article-date">
  <time datetime="2015-10-21T04:15:29.000Z" itemprop="datePublished">2015-10-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/">Lisp</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/lisp/lispdiary/lispgkxx/">(转)Lisp概况与学习方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Lisp名字来源于LISt Processor，也就是列表处理的意思。初学者第一眼见到Lisp往往印象最深的也就是里面成堆的括号。的确没错，括号就是该语言最显著的特点。整个语言的源代码也是以括号作为构造其语法树的依据。</p>
<p>很多初学者有考古的爱好，听闻了传说中的7公理，所谓7个操作符可以构造一切，并且为止着迷。且不说这7公理是不是真的能构造出目前很多应用上所需要的一切，就算真的能，性能也必定很低，因为具备的材料太少，很多基础的东西也要从头开始构造。而精简的构造似乎并没有为实际应用带来多少好处，图灵机的构造比这几个公理更简单，但是你不会看到有多少人用图灵机编程。制造计算机系统就是一个寻找扩展性、成本、体积、功耗等等参考的平衡点的过程，不在那个平衡点则很容易被淘汰。</p>
<p>最初版的Lisp早已没人使用，取而代之的是无数人基于Lisp的特点构造出的一系列类似Lisp的语言，无论他们名字里有没有Lisp，他们已经不是Lisp了，但是他们又是带有Lisp特点的语言，所以又被叫做Lisp的方言。所以看到某本书里介绍的某个Lisp的源代码，里面无数的括号的组织和括号之间关键字，千万不要觉得很神秘，因为那已经完全是个人或者某个组织定义的，不是非得那么设计的，如果你愿意，你也可以实现一个自己的Lisp方言。</p>
<p>Lisp以括号的简洁形态激励了无数人和无数组织制定和实现自己的Lisp方言、一旦有后来者不满意又会对之前存在的Lisp标准和实现进行“总结”而开发新的Lisp，加上开发新的Lisp的确简单（因为其语法简单，非常繁琐的语法分析部分很容易写），则更是激励无数初学者实现自己的Lisp，甚至有教科书的作业就是实现Lisp，所以到目前，已经根本无法统计到底存在多少种Lisp或者说Lisp的方言了。但是总的来说，目前还是有一些名气比较大的Lisp分类，用户比较多、实现比较多、资料也比较多，学习的时候可以优先选择下面三种：</p>
<h2 id="Scheme："><a href="#Scheme：" class="headerlink" title="Scheme："></a>Scheme：</h2><p>非常小型的Lisp方言，内容少至早期标准也仅仅有几十页，非常适合初学者学习。由于早期似乎被用作教学语言，所以并没有针对项目开发设计一些必要的措施，包括模块、名字空间等等。最新的标准正在尝试弥补这个缺陷但是进展似乎比较缓慢。目前来说比较好的实现有：</p>
<p>1. DrRacket，开源实现，自带IDE，有高亮、调试功能，支持Scheme相关的几种方言，自带手册比较完备，适合初学者。</p>
<p>2. Chez Scheme，传说中的异常高效的Scheme实现，支持最新标准，且作者是Scheme实现的权威，品质有保证。但是该软件为专有软件，需要购买使用。作者在其首页提供免费精简版Petite Chez Scheme。</p>
<p>3. Guile，GNU的扩展语言，一些GNU的软件就是用这个实现进行扩展的。</p>
<p>等等……</p>
<p>当然，因为Scheme语言的确比较精简，自己实现一个Scheme也是不错的选择。难度并没有想象中的大，实现后还可以嵌入在自己的项目中于扩展用。</p>
<p>Scheme学习资料非常多，包括</p>
<p>《The Scheme Programming Language》这本书是之前介绍的Chez Scheme的作者R. Kent Dybvig写的，内容详尽、语言的每个特性都给出示例。</p>
<p>《Structure and Interpretation of Computer Programs》这本书又叫做“计算机程序的构造和解释”，虽然通常被认为是一本入门书，但是实际上内容涵盖很广，包括计算机原理、编译器构造、符号计算、电子电路等等，编程语言成了描述这些内容的无关紧要的工具，做完大部分习题很有挑战性。</p>
<p>《Revised5 Report on the Algorithmic Language Scheme》又被叫做“R5RS”，初看这个题目有点莫名其妙，实际上这是一份类似Scheme标准的东西，里面最直接的描述了Scheme的关键特性，甚至有点面向语言实现者的意味。该标准之后还在不断地出第六份第七份等等，增加了一些标准库的内容。读通这本可以几乎完全掌握Scheme了。</p>
<p>因为Scheme的资料太多，暂时就列出上面三份，能看完这些掌握得就差不多了。</p>
<h2 id="Common-Lisp："><a href="#Common-Lisp：" class="headerlink" title="Common Lisp："></a>Common Lisp：</h2><p>又被叫做CL，是一个典型的“总结性”Lisp方言，也就是一次把各个Lisp方言的特性进行总结的尝试，并且获得了一定的成功。该语言极其复杂以至于很少有实现能比较完整实现其标准（虽然不少CL的实现都自称自己完整实现了标准）。比较常见的实现有：</p>
<p>1. SBCL，开源实现，来自与CMUCL，编译到原生码执行性能有保障。</p>
<p>2. CLISP，一些教科书推荐的Common Lisp实现，性能比较差。</p>
<p>等等……</p>
<p>PS：据Common Lisp界著名人物小妮补充的部分CL实现现状：</p>
<p>Allegro Cl, Lispworks, CCL, SBCL, ECL, CMUCL(已死)，CLISP（垂死），ABCL，MKCL（半主流，这个是从ECL改过来的），mocl（小众），Corman Lisp（已死）常见的教材有：</p>
<p>《ANSI Common Lisp》传统风格的编程语言教科书，内容详尽。</p>
<p>《Practical Common Lisp》据说得了Jolt大奖，里面以一系列所谓现实生活中的例子来推进教学，喜欢这种类型教材的可以看看。</p>
<h2 id="Emacs-Lisp："><a href="#Emacs-Lisp：" class="headerlink" title="Emacs Lisp："></a>Emacs Lisp：</h2><p>这算是一种专用Lisp，也就是说它并不是通用编程语言，而仅仅是用于扩展一个叫Emacs的文本编辑器。这个文本编辑器历史悠久，按键绑定灵活，用这种编程语言进行扩展后实现一些比较简单的功能可以简化文本编辑工作（当然本身还有其它问题，是否值得专门学习有很大争议）。学习Emacs Lisp是在对Emacs这个文本编辑器产生兴趣并且初步掌握后，想进一步探索和扩展的很自然的选择。</p>
<p>比较常见的实现有……当然是GNU Emacs，本身就是内嵌在Emacs编辑器中的。而最好的教材，毫无疑问就是自带的手册。推荐学习过程为</p>
<p>第一步：初步掌握Emacs编辑器的操作</p>
<p>第二步：学会一些基本的语法</p>
<p>第三部：尝试写一些扩展，需要的功能就去查找手册，找到该功能的接口后用之前学到的基本语法组合起来。</p>
<p>正如之前介绍的Lisp的特性，仅仅以括号作为明显的特征，激励无数人不断总结和发明自己的方言，这些方言没法介绍完，具体哪些值得学习观察。有一些现代的Lisp方言和实现挺有价值，比如Clojure，可以运行在JVM上，丰富的语法，还能运行在JVM上，重复利用之前用别的运行在JVM上的语言写的程序，这就是一个不错的选择。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/lisp/lispdiary/lispgkxx/" data-id="clhlnyli200ryojupcdyq9kaz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lisp/" rel="tag">Lisp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/lib/logbacksyjj" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/lib/logbacksyjj/" class="article-date">
  <time datetime="2015-10-20T10:07:56.000Z" itemprop="datePublished">2015-10-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/lib/logbacksyjj/">【JAVA】logback使用简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不打log的程序员不是好程序员，log4j已经过时了，开发他的人又开发了logback。这里说一说怎么配制logback。</p>
<p>一般的log接口都在用slf4j，这样以后改为其它log组件就不用改程序了，原理是log组件加个桥接的包,覆盖slf4j里的一些类，实现功能的嫁接。</p>
<h2 id="需要的jar包"><a href="#需要的jar包" class="headerlink" title="需要的jar包"></a>需要的jar包</h2><ul>
<li>slf4j-api-1.6.2.jar</li>
<li>logback-core-0.9.29.jar</li>
<li>logback-classic-0.9.29.jar</li>
</ul>
<p>如果是从commons-logging+log4j切换过来，还需要jcl-over-slf4j-1.6.2.jar，用于桥接commons-logging<br>到 slf4j。</p>
<p>如果用Maven依赖引入，可以用下面的代码。</p>
<pre><code>    org.slf4j 
    slf4j-api 
    1.6.2 
 
 
    org.slf4j 
    jcl-over-slf4j 
    1.6.2 
 
 
    ch.qos.logback 
    logback-core 
    0.9.29 
 
 
    ch.qos.logback 
    logback-classic 
    0.9.29 
 
</code></pre>
<h2 id="logback配制文件加载顺序"><a href="#logback配制文件加载顺序" class="headerlink" title="logback配制文件加载顺序"></a>logback配制文件加载顺序</h2><p>logback会依次读取以下类型配置文件</p>
<ol>
<li>logback.groovy</li>
<li>logback-test.xml</li>
<li>logback.xml</li>
<li>采用默认配置</li>
</ol>
<h2 id="logback-xml样例"><a href="#logback-xml样例" class="headerlink" title="logback.xml样例"></a>logback.xml样例</h2><p>下面是一个项目中的配制文件内容：</p>
<pre><code>        System.out
        
            %date [%level] [%thread] %logger&#123;80&#125; [%file : %line] %n%msg%n
            
        
    

    
        ../logs/logfile.log
        
            %date [%level] [%thread] %logger&#123;80&#125; [%file : %line] %n%msg%n
            
        
        
            ../logs/logfile.log.%d&#123;yyyy-MM-dd&#125;
        
    

    
    
    
    
    

    
    
    
    
    
    
        
        
    
</code></pre>
<p>思想和log4j类似，几个常用配制</p>
<ul>
<li>appender:输出位置，可以有多个</li>
<li>logger:对指定log设置，因为log都是通过类名来的，所以可以通过包路径来批量限制</li>
<li>root：所有log的根</li>
<li>pattern：输出格式，和log4j一样</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/lib/logbacksyjj/" data-id="clhlnylir00w5ojup9uqx8573" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/lisp/lispdiary/lispbz" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/lisp/lispdiary/lispbz/" class="article-date">
  <time datetime="2015-10-20T04:41:36.000Z" itemprop="datePublished">2015-10-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/">Lisp</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/lisp/lispdiary/lispbz/">(转)Lisp 的本质-深度好文</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最初在web的某些角落偶然看到有人赞美Lisp时, 我那时已经是一个颇有经验的程序员。在我的履历上,掌握的语言范围相当广泛, 象C++, Java, C#主流语言等等都不在话下,我觉得我差不多知道所有的有关编程语言的事情。对待编程语言的问题上, 我觉得自己不太会遇到什么大问题。其实我大错特错了。</p>
<p>我试着学了一下Lisp, 结果马上就撞了墙。我被那些范例代码吓坏了。我想很多初次接触Lisp语言的人, 一定也有过类似的感受。Lisp的语法太次了。一个语言的发明人, 居然不肯用心弄出一套漂亮的语法, 那谁还会愿意学它。反正, 我是确确实实被那些难看的无数的括号搞蒙了。</p>
<p>回过神来之后, 我和Lisp社区的那伙人交谈, 诉说我的沮丧心情。结果, 立马就有一大套理论砸过来, 这套理论在Lisp社区处处可见, 几成惯例。比如说: Lisp的括号只是表面现象; Lisp的代码和数据的表达方式没有差别, 而且比XML语法高明许多, 所以有无穷的好处; Lisp有强大无比的元语言能力, 程序员可以写出自我维护的代码; Lisp可以创造出针对特定应用的语言子集; Lisp的运行时和编译时没有明确的分界; 等等, 等等, 等等。这么长的赞美词虽然看起来相当动人, 不过对我毫无意义。没人能给我演示这些东西是如何应用的, 因为这些东西一般来说只有在大型系统才会用到。我争辩说, 这些东西传统语言一样办得到。在和别人争论了数个小时之后, 我最终还是放弃了学Lisp的念头。为什么要花费几个月的时间学习语法这么难看的语言呢? 这种语言的概念这么晦涩, 又没什么好懂的例子。也许这语言不是该我这样的人学的。</p>
<p>几个月来, 我承受着这些Lisp辩护士对我心灵的重压。我一度陷入了困惑。我认识一些绝顶聪明的人, 我对他们相当尊敬, 我看到他们对Lisp的赞美达到了宗教般的高度。这就是说, Lisp中一定有某种神秘的东西存在, 我不能忍受自己对此的无知, 好奇心和求知欲最终不可遏制。我于是咬紧牙关埋头学习Lisp, 经过几个月的时间费劲心力的练习, 终于,我看到了那无穷无尽的泉水的源头。在经过脱胎换骨的磨练之后, 在经过七重地狱的煎熬之后, 终于, 我明白了。</p>
<p>顿悟在突然之间来临。曾经许多次, 我听到别人引用雷蒙德(译者注: 论文&lt;&lt;大教堂和市集&gt;&gt;的作者, 著名的黑客社区理论家)的话: “Lisp语言值得学习。当你学会Lisp之后, 你会拥有深刻的体验。就算你平常并不用Lisp编程, 它也会使你成为更加优秀的程序员”。过去, 我根本不懂这些话的含义, 我也不相信这是真的。可是现在我懂得了。这些话蕴含的真理远远超过我过去的想像。我内心体会到一种神圣的情感, 一瞬间的顿悟, 几乎使我对电脑科学的观念发生了根本的改变。</p>
<p>顿悟的那一刻, 我成了Lisp的崇拜者。我体验到了宗教大师的感受: 一定要把我的知识传布开来, 至少要让10个迷失的灵魂得到拯救。按照通常的办法, 我把这些道理(就是刚开始别人砸过来的那一套, 不过现在我明白了真实的含义)告诉旁人。结果太令人失望了,只有少数几个人在我坚持之下, 发生了一点兴趣, 但是仅仅看了几眼Lisp代码, 他们就退却了。照这样的办法, 也许费数年功夫能造就了几个Lisp迷, 但我觉得这样的结果太差强人意了, 我得想一套有更好的办法。</p>
<p>我深入地思考了这个问题。是不是Lisp有什么很艰深的东西, 令得那么多老练的程序员都不能领会? 不是, 没有任何绝对艰深的东西。因为我能弄懂, 我相信其他人也一定能。那么问题出在那里? 后来我终于找到了答案。我的结论就是, 凡是教人学高级概念, 一定要从他已经懂得的东西开始。如果学习过程很有趣, 学习的内容表达得很恰当, 新概念就会变得相当直观。这就是我的答案。所谓元编程, 所谓数据和代码形式合一, 所谓自修改代码, 所谓特定应用的子语言, 所有这些概念根本就是同族概念, 彼此互为解释, 肯定越讲越不明白。还是从实际的例子出发最有用。</p>
<p>我把我的想法说给Lisp程序员听, 遭到了他们的反对。”这些东西本身当然不可能用熟悉的知识来解释, 这些概念完全与众不同, 你不可能在别人已有的经验里找到类似的东西”,可是我认为这些都是遁词。他们又反问我, “你自己为啥不试一下?” 好吧, 我来试一下。这篇文章就是我尝试的结果。我要用熟悉的直观的方法来解释Lisp, 我希望有勇气的人读完它, 拿杯饮料, 深呼吸一下, 准备被搞得晕头转向。来吧, 愿你获得大能。</p>
<h2 id="重新审视XML"><a href="#重新审视XML" class="headerlink" title="重新审视XML"></a>重新审视XML</h2><p>千里之行始于足下。让我们的第一步从XML开始。可是XML已经说得更多的了, 还能有什么新意思可说呢? 有的。XML自身虽然谈谈不上有趣, 但是XML和Lisp的关系却相当有趣。XML和Lisp的概念有着惊人的相似之处。XML是我们通向理解Lisp的桥梁。好吧, 我们且把XML当作活马医。让我们拿好手杖, 对XML的无人涉及的荒原地带作一番探险。我们要从一个全新的视角来考察这个题目。</p>
<p>表面上看, XML是一种标准化语法, 它以适合人阅读的格式来表达任意的层次化数据(hirearchical data)。象任务表(to-do list), 网页, 病历, 汽车保险单, 配置文件等等, 都是XML用武的地方。比如我们拿任务表做例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;todo name=&quot;housework&quot;&gt;</span><br><span class="line">	&lt;item priority=&quot;high&quot;&gt;Clean the house.&lt;/item&gt;</span><br><span class="line">	&lt;item priority=&quot;medium&quot;&gt;Wash the dishes.&lt;/item&gt;</span><br><span class="line">	&lt;item priority=&quot;medium&quot;&gt;Buy more soap.&lt;/item&gt;</span><br><span class="line">&lt;/todo&gt;</span><br></pre></td></tr></table></figure>

<p>解析这段数据时会发生什么情况? 解析之后的数据在内存中怎样表示? 显然, 用树来表示这种层次化数据是很恰当的。说到底, XML这种比较容易阅读的数据格式, 就是树型结构数据经过序列化之后的结果。任何可以用树来表示的数据, 同样可以用XML来表示, 反之亦然。希望你能懂得这一点, 这对下面的内容极其重要。</p>
<p>再进一步。还有什么类型的数据也常用树来表示? 无疑列表(list)也是一种。上过编译课吧? 还模模糊糊记得一点吧? 源代码在解析之后也是用树结构来存放的, 任何编译程序都会把源代码解析成一棵抽象语法树, 这样的表示法很恰当, 因为源代码就是层次结构的:函数包含参数和代码块, 代码快包含表达式和语句, 语句包含变量和运算符等等。</p>
<p>我们已经知道, 任何树结构都可以轻而易举的写成XML, 而任何代码都会解析成树, 因此,任何代码都可以转换成XML, 对不对? 我举个例子, 请看下面的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int add(int arg1, int arg2)</span><br><span class="line">&#123;</span><br><span class="line">return arg1+arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>能把这个函数变成对等的XML格式吗? 当然可以。我们可以用很多种方式做到, 下面是其中的一种, 十分简单:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;define-function return-type=&quot;int&quot; name=&quot;add&quot;&gt;</span><br><span class="line">	&lt;arguments&gt;</span><br><span class="line">		&lt;argument type=&quot;int&quot;&gt;arg1&lt;/argument&gt;</span><br><span class="line">		&lt;argument type=&quot;int&quot;&gt;arg2&lt;/argument&gt;</span><br><span class="line">	&lt;/arguments&gt;</span><br><span class="line">	&lt;return&gt;</span><br><span class="line">		&lt;add value1=&quot;arg1&quot; value2=&quot;arg2&quot;&gt;&lt;/add&gt;</span><br><span class="line">	&lt;/return&gt;</span><br><span class="line">&lt;/define-function&gt;</span><br></pre></td></tr></table></figure>

<p>这个例子非常简单, 用哪种语言来做都不会有太大问题。我们可以把任何程序码转成XML,也可以把XML转回到原来的程序码。我们可以写一个转换器, 把Java代码转成XML, 另一个转换器把XML转回到Java。一样的道理, 这种手段也可以用来对付C++(这样做跟发疯差不多么。可是的确有人在做, 看看GCC-XML(<a target="_blank" rel="noopener" href="http://www.gccxml.org)就知道了).进一步说,凡是有相同语言特性而语法不同的语言/">http://www.gccxml.org)就知道了)。进一步说,凡是有相同语言特性而语法不同的语言</a>, 都可以把XML当作中介来互相转换代码。实际上几乎所有的主流语言都在一定程度上满足这个条件。我们可以把XML作为一种中间表示法,在两种语言之间互相译码。比方说, 我们可以用Java2XML把Java代码转换成XML, 然后用XML2CPP再把XML转换成C++代码, 运气好的话, 就是说, 如果我们小心避免使用那些C++不具备的Java特性的话, 我们可以得到完好的C++程序。这办法怎么样, 漂亮吧?</p>
<p>这一切充分说明, 我们可以把XML作为源代码的通用存储方式, 其实我们能够产生一整套使用统一语法的程序语言, 也能写出转换器, 把已有代码转换成XML格式。如果真的采纳这种办法, 各种语言的编译器就用不着自己写语法解析了, 它们可以直接用XML的语法解析来直接生成抽象语法树。</p>
<p>说到这里你该问了, 我们研究了这半天XML, 这和Lisp有什么关系呢? 毕竟XML出来之时,Lisp早已经问世三十年了。这里我可以保证, 你马上就会明白。不过在继续解释之前, 我们先做一个小小的思维练习。看一下上面这个XML版本的add函数例子, 你怎样给它分类,是代码还是数据? 不用太多考虑都能明白, 把它分到哪一类都讲得通。它是XML, 它是标准格式的数据。我们也知道, 它可以通过内存中的树结构来生成(GCC-XML做的就是这个事情)。它保存在不可执行的文件中。我们可以把它解析成树节点, 然后做任意的转换。显而易见, 它是数据。不过且慢, 虽然它语法有点陌生, 可它又确确实实是一个add函数,对吧?? 一旦经过解析, 它就可以拿给编译器编译执行。我们可以轻而易举写出这个XML代码解释器, 并且直接运行它。或者我们也可以把它译成Java或C++代码, 然后再编译运行。所以说, 它也是代码。</p>
<p>我们说到那里了? 不错, 我们已经发现了一个有趣的关键之点。过去被认为很难解的概念已经非常直观非常简单的显现出来。代码也是数据, 并且从来都是如此。这听起来疯疯癫癫的, 实际上却是必然之事。我许诺过会以一种全新的方式来解释Lisp, 我要重申我的许诺。但是我们此刻还没有到预定的地方, 所以还是先继续上边的讨论。</p>
<p>刚才我说过, 我们可以非常简单地实现XML版的add函数解释器, 这听起来好像不过是说说而已。谁真的会动手做一下呢? 未必有多少人会认真对待这件事。随便说说, 并不打算真的去做, 这样的事情你在生活中恐怕也遇到吧。你明白我这样说的意思吧, 我说的有没有打动你? 有哇, 那好, 我们继续。</p>
<h2 id="重新审视Ant"><a href="#重新审视Ant" class="headerlink" title="重新审视Ant"></a>重新审视Ant</h2><p>我们现在已经来到了月亮背光的那一面, 先别忙着离开。再探索一下, 看看我们还能发现什么东西。闭上眼睛, 想一想2000年冬天的那个雨夜, 一个名叫James Duncan Davidson的杰出的程序员正在研究Tomcat的servlet容器。那时, 他正小心地保存好刚修改过的文件, 然后执行make。结果冒出了一大堆错误, 显然有什么东西搞错了。经过仔细检查, 他想, 难道是因为tab前面加了个空格而导致命令不能执行吗? 确实如此。老是这样, 他真的受够了。乌云背后的月亮给了他启示, 他创建了一个新的Java项目, 然后写了一个简单但是十分有用的工具, 这个工具巧妙地利用了Java属性文件中的信息来构造工程, 现在James可以写makefile的替代品, 它能起到相同的作用, 而形式更加优美, 也不用担心有makefile那样可恨的空格问题。这个工具能够自动解释属性文件, 然后采取正确的动作来编译工程。真是简单而优美。</p>
<p>(作者注: 我不认识James, James也不认识我, 这个故事是根据网上关于Ant历史的帖子虚构的)</p>
<p>使用Ant构造Tomcat之后几个月, 他越来越感到Java的属性文件不足以表达复杂的构造指令。文件需要检出, 拷贝, 编译, 发到另外一台机器, 进行单元测试。要是出错, 就发邮件给相关人员, 要是成功, 就继续在尽可能高层的卷(volumn)上执行构造。追踪到最后,卷要回复到最初的水平上。确实, Java的属性文件不够用了, James需要更有弹性的解决方案。他不想自己写解析器(因为他更希望有一个具有工业标准的方案)。XML看起来是个不错的选择。他花了几天工夫把Ant移植到XML，于是，一件伟大的工具诞生了。</p>
<p>Ant是怎样工作的？原理非常简单。Ant把包含有构造命令的XML文件(算代码还是算数据,你自己想吧)，交给一个Java程序来解析每一个元素，实际情况比我说的还要简单得多。一个简单的XML指令会导致具有相同名字的Java类装入，并执行其代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;copy todir=&quot;../new/dir&quot;&gt;</span><br><span class="line">	&lt;fileset dir=&quot;src_dir&quot;&gt;&lt;/fileset&gt;</span><br><span class="line">&lt;/copy&gt;</span><br></pre></td></tr></table></figure>

<p>这段文字的含义是把源目录复制到目标目录，Ant会找到一个”copy”任务(实际上就是一个Java类), 通过调用Java的方法来设置适当参数(todir和fileset)，然后执行这个任务。Ant带有一组核心类, 可以由用户任意扩展, 只要遵守若干约定就可以。Ant找到这些类,每当遇到XML元素有同样的名字, 就执行相应的代码。过程非常简单。Ant做到了我们前面所说的东西: 它是一个语言解释器, 以XML作为语法, 把XML元素转译为适当的Java指令。我们可以写一个”add”任务, 然后, 当发现XML中有add描述的时候, 就执行这个add任务。由于Ant是非常流行的项目, 前面展示的策略就显得更为明智。毕竟, 这个工具每天差不多有几千家公司在使用。</p>
<p>到目前为之, 我还没有说Ant在解析XML时所遇到困难。你也不用麻烦去它的网站上去找答案了, 不会找到有价值的东西。至少对我们这个论题来说是如此。我们还是继续下一步讨论吧。我们答案就在那里。</p>
<h2 id="为什么是XML"><a href="#为什么是XML" class="headerlink" title="为什么是XML"></a>为什么是XML</h2><p>有时候正确的决策并非完全出于深思熟虑。我不知道James选择XML是否出于深思熟虑。也许仅仅是个下意识的决定。至少从James在Ant网站上发表的文章看起来, 他所说的理由完全是似是而非。他的主要理由是移植性和扩展性, 在Ant案例上, 我看不出这两条有什么帮助。使用XML而不是Java代码, 到底有什么好处? 为什么不写一组Java类, 提供api来满足基本任务(拷贝目录, 编译等等), 然后在Java里直接调用这些代码? 这样做仍然可以保证移植性, 扩展性也是毫无疑问的。而且语法也更为熟悉, 看着顺眼。那为什么要用 XML呢? 有什么更好的理由吗?</p>
<p>有的。虽然我不确定James是否确实意识到了。在语义的可构造性方面, XML的弹性是Java望尘莫及的。我不想用高深莫测的名词来吓唬你, 其中的道理相当简单, 解释起来并不费很多功夫。好, 做好预备动作, 我们马上就要朝向顿悟的时刻做奋力一跃。</p>
<p>上面的那个copy的例子, 用Java代码怎样实现呢? 我们可以这样做:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CopyTask copy = new CopyTask();</span><br><span class="line">Fileset fileset = new Fileset();</span><br><span class="line"></span><br><span class="line">fileset.setDir(&quot;src_dir&quot;);</span><br><span class="line">copy.setToDir(&quot;../new/dir&quot;);</span><br><span class="line">copy.setFileset(fileset);</span><br><span class="line"></span><br><span class="line">copy.excute();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个代码看起来和XML的那个很相似, 只是稍微长一点。差别在那里? 差别在于XML构造了一个特殊的copy动词, 如果我们硬要用Java来写的话, 应该是这个样子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">copy(&quot;../new/dir&quot;);</span><br><span class="line">&#123;</span><br><span class="line">    fileset(&quot;src_dir&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到差别了吗? 以上代码(如果可以在Java中用的化), 是一个特殊的copy算符, 有点像for循环或者Java5中的foreach循环。如果我们有一个转换器, 可以把XML转换到Java, 大概就会得到上面这段事实上不可以执行的代码。因为Java的技术规范是定死的, 我们没有办法在程序里改变它。我们可以增加包, 增加类, 增加方法, 但是我们没办法增加算符,而对于XML, 我们显然可以任由自己增加这样的东西。对于XML的语法树来说, 只要原意,我们可以任意增加任何元素, 因此等于我们可以任意增加算符。如果你还不太明白的话,看下面这个例子, 加入我们要给Java引入一个unless算符:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unless(someObject.canFly())</span><br><span class="line">&#123;</span><br><span class="line">    someObject.transportByGround():</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的两个例子中, 我们打算给Java语法扩展两个算符, 成组拷贝文件算符和条件算符unless, 我们要想做到这一点, 就必须修改Java编译器能够接受的抽象语法树, 显然我们无法用Java标准的功能来实现它。但是在XML中我们可以轻而易举地做到。我们的解析器根据 XML元素, 生成抽象语法树, 由此生成算符, 所以, 我们可以任意引入任何算符。</p>
<p>对于复杂的算符来说, 这样做的好处显而易见。比如, 用特定的算符来做检出源码, 编译文件, 单元测试, 发送邮件等任务, 想想看有多么美妙。对于特定的题目, 比如说构造软件项目, 这些算符的使用可以大幅减低少代码的数量。增加代码的清晰程度和可重用性。解释性的XML可以很容易的达到这个目标。XML是存储层次化数据的简单数据文件, 而在Java中, 由于层次结构是定死的(你很快就会看到, Lisp的情况与此截然不同), 我们就没法达到上述目标。也许这正是Ant的成功之处呢。</p>
<p>你可以注意一下最近Java和C#的变化(尤其是C#3.0的技术规范), C#把常用的功能抽象出来, 作为算符增加到C#中。C#新增加的query算符就是一个例子。它用的还是传统的作法:C#的设计者修改抽象语法树, 然后增加对应的实现。如果程序员自己也能修改抽象语法树该有多好! 那样我们就可以构造用于特定问题的子语言(比如说就像Ant这种用于构造项目的语言), 你能想到别的例子吗? 再思考一下这个概念。不过也不必思考太甚, 我们待会还会回到这个题目。那时候就会更加清晰。</p>
<h2 id="离Lisp越来越近"><a href="#离Lisp越来越近" class="headerlink" title="离Lisp越来越近"></a>离Lisp越来越近</h2><p>我们先把算符的事情放一放, 考虑一下Ant设计局限之外的东西。我早先说过, Ant可以通过写Java类来扩展。Ant解析器会根据名字来匹配XML元素和Java类, 一旦找到匹配, 就执行相应任务。为什么不用Ant自己来扩展Ant呢? 毕竟核心任务要包含很多传统语言的结构(例如”if”), 如果Ant自身就能提供构造任务的能力(而不是依赖java类), 我们就可以得到更高的移植性。我们将会依赖一组核心任务(如果你原意, 也不妨把它称作标准库), 而不用管有没有Java 环境了。这组核心任务可以用任何方式来实现, 而其他任务建筑在这组核心任务之上, 那样的话, Ant就会成为通用的, 可扩展的, 基于XML的编程语言。考虑下面这种代码的可能性:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;task name=&quot;Test&quot;&gt;</span><br><span class="line">	&lt;echo message=&quot;Hello World&quot;&gt;&lt;/echo&gt;</span><br><span class="line">&lt;/task&gt;</span><br><span class="line">&lt;test&gt;</span><br><span class="line">&lt;/test&gt;</span><br></pre></td></tr></table></figure>

<p>如果XML支持”task”的创建, 上面这段代码就会输出”Hello World!”. 实际上, 我们可以用Java写个”task”任务, 然后用Ant-XML来扩展它。Ant可以在简单原语的基础上写出更复杂的原语, 就像其他编程语言常用的作法一样。这也就是我们一开始提到的基于XML的编程语言。这样做用处不大(你知道为甚么吗?), 但是真的很酷。</p>
<p>再看一回我们刚才说的Task任务。祝贺你呀, 你在看Lisp代码!!! 我说什么? 一点都不像Lisp吗? 没关系, 我们再给它收拾一下。</p>
<h2 id="比XML更好"><a href="#比XML更好" class="headerlink" title="比XML更好"></a>比XML更好</h2><p>前面一节说过, Ant自我扩展没什么大用, 原因在于XML很烦琐。对于数据来说, 这个问题还不太大, 但如果代码很烦琐的话, 光是打字上的麻烦就足以抵消它的好处。你写过Ant的脚本吗? 我写过, 当脚本达到一定复杂度的时候, XML非常让人厌烦。想想看吧, 为了写结束标签, 每个词都得打两遍, 不发疯算好的!</p>
<p>为了解决这个问题, 我们应当简化写法。须知, XML仅仅是一种表达层次化数据的方式。我们并不是一定要使用尖括号才能得到树的序列化结果。我们完全可以采用其他的格式。其中的一种(刚好就是Lisp所采用的)格式, 叫做s表达式。s表达式要做的和XML一样, 但它的好处是写法更简单, 简单的写法更适合代码输入。后面我会详细讲s表达式。这之前我要清理一下XML的东西。考虑一下关于拷贝文件的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;copy todir=&quot;../new/dir&quot;&gt;</span><br><span class="line">	&lt;fileset dir=&quot;src_dir&quot;&gt;&lt;/fileset&gt;</span><br><span class="line">&lt;/copy&gt;</span><br></pre></td></tr></table></figure>

<p>想想看在内存里面, 这段代码的解析树在内存会是什么样子? 会有一个”copy”节点, 其下有一个 “fileset”节点, 但是属性在哪里呢? 它怎样表达呢? 如果你以前用过XML, 并且弄不清楚该用元素还是该用属性, 你不用感到孤单, 别人一样糊涂着呢。没人真的搞得清楚。这个选择与其说是基于技术的理由, 还不如说是闭着眼瞎摸。从概念上来讲, 属性也是一种元素, 任何属性能做的, 元素一样做得到。XML引入属性的理由, 其实就是为了让XML写法不那么冗长。比如我们看个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;copy&gt;</span><br><span class="line">	&lt;todir&gt;../new/dir&lt;/todir&gt;</span><br><span class="line">	&lt;fileset&gt;</span><br><span class="line">		&lt;dir&gt;src_dir&lt;/dir&gt;</span><br><span class="line">	&lt;/fileset&gt;</span><br><span class="line">&lt;/copy&gt;</span><br></pre></td></tr></table></figure>

<p>两下比较, 内容的信息量完全一样, 用属性可以减少打字数量。如果XML没有属性的话,光是打字就够把人搞疯掉。</p>
<p>说完了属性的问题, 我们再来看一看s表达式。之所以绕这么个弯, 是因为s表达式没有属性的概念。因为s表达式非常简练, 根本没有必要引入属性。我们在把XML转换成s表达式的时候, 心里应该记住这一点。看个例子, 上面的代码译成s表达式是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(copy</span><br><span class="line">(todir &quot;../new/dir&quot;)</span><br><span class="line">(fileset (dir &quot;src_dir&quot;)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仔细看看这个例子, 差别在哪里? 尖括号改成了圆括号, 每个元素原来是有一对括号标记包围的, 现在取消了后一个(就是带斜杠的那个)括号标记。表示元素的结束只需要一个”)”就可以了。不错, 差别就是这些。这两种表达方式的转换, 非常自然, 也非常简单。s表达式打起字来, 也省事得多。第一次看s表达式(Lisp)时, 括号很烦人是吧? 现在我们明白了背后的道理, 一下子就变得容易多了。至少, 比XML要好的多。用s表达式写代码, 不单是实用, 而且也很让人愉快。s表达式具有XML的一切好处, 这些好处是我们刚刚探讨过的。现在我们看看更加Lisp风格的task例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(task (name &quot;Test&quot;)</span><br><span class="line">(echo (message &quot;Hellow World!&quot;)))</span><br><span class="line">(Test)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用Lisp的行话来讲, s表达式称为表(list)。对于上面的例子, 如果我们写的时候不加换行, 用逗号来代替空格, 那么这个表达式看起来就非常像一个元素列表, 其中又嵌套着其他标记。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(task, (name, &quot;test&quot;), (echo, (message, &quot;Hello World!&quot;)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>XML自然也可以用这样的风格来写。当然上面这句并不是一般意义上的元素表。它实际上是一个树。这和XML的作用是一样的。称它为列表, 希望你不会感到迷惑, 因为嵌套表和树实际上是一码事。Lisp的字面意思就是表处理(list processing), 其实也可以称为树处理, 这和处理XML节点没有什么不同。</p>
<p>经受这一番折磨以后, 现在我们终于相当接近Lisp了, Lisp的括号的神秘本质(就像许多Lisp狂热分子认为的)逐渐显现出来。现在我们继续研究其他内容。</p>
<h2 id="重新审视C语言的宏"><a href="#重新审视C语言的宏" class="headerlink" title="重新审视C语言的宏"></a>重新审视C语言的宏</h2><p>到了这里, 对XML的讨论你大概都听累了, 我都讲累了。我们先停一停, 把树, s表达式,Ant这些东西先放一放, 我们来说说C的预处理器。一定有人问了, 我们的话题和C有什么关系? 我们已经知道了很多关于元编程的事情, 也探讨过专门写代码的代码。理解这问题有一定难度, 因为相关讨论文章所使用的编程语言, 都是你们不熟悉的。但是如果只论概念的话, 就相对要简单一些。我相信, 如果以C语言做例子来讨论元编程, 理解起来一定会容易得多。好, 我们接着看。</p>
<p>一个问题是, 为什么要用代码来写代码呢? 在实际的编程中, 怎样做到这一点呢? 到底元编程是什么意思? 你大概已经听说过这些问题的答案, 但是并不懂得其中缘由。为了揭示背后的真理, 我们来看一下一个简单的数据库查询问题。这种题目我们都做过。比方说,直接在程序码里到处写SQL语句来修改表(table)里的数据, 写多了就非常烦人。即便用C#3.0的LINQ, 仍然不减其痛苦。写一个完整的SQL查询(尽管语法很优美)来修改某人的地址, 或者查找某人的名字, 绝对是件令程序员倍感乏味的事情, 那么我们该怎样来解决这个问题? 答案就是: 使用数据访问层。</p>
<p>概念挺简单, 其要点是把数据访问的内容(至少是那些比较琐碎的部分)抽象出来, 用类来映射数据库的表, 然后用访问对象属性访问器(accessor)的办法来间接实现查询。这样就极大地简化了开发工作量。我们用访问对象的方法(或者属性赋值, 这要视你选用的语言而定)来代替写SQL查询语句。凡是用过这种方法的人, 都知道这很节省时间。当然, 如果你要亲自写这样一个抽象层, 那可是要花非常多的时间的–你要写一组类来映射表, 把属性访问转换为SQL查询, 这个活相当耗费精力。用手工来做显然是很不明智的。但是一旦你有了方案和模板, 实际上就没有多少东西需要思考的。你只需要按照同样的模板一次又一次重复编写相似代码就可以了。事实上很多人已经发现了更好的方法, 有一些工具可以帮助你连接数据库, 抓取数据库结构定义(schema), 按照预定义的或者用户定制的模板来自动编写代码。</p>
<p>如果你用过这种工具, 你肯定会对它的神奇效果深为折服。往往只需要鼠标点击数次, 就可以连接到数据库, 产生数据访问源码, 然后把文件加入到你的工程里面, 十几分钟的工作, 按照往常手工方式来作的话, 也许需要数百个小时人工(man-hours)才能完成。可是,如果你的数据库结构定义后来改变了怎么办? 那样的话, 你只需把这个过程重复一遍就可以了。甚至有一些工具能自动完成这项变动工作。你只要把它作为工程构造的一部分, 每次编译工程的时候, 数据库部分也会自动地重新构造。这真的太棒了。你要做的事情基本上减到了0。如果数据库结构定义发生了改变, 并在编译时自动更新了数据访问层的代码,那么程序中任何使用过时的旧代码的地方, 都会引发编译错误。</p>
<p>数据访问层是个很好的例子, 这样的例子还有好多。从GUI样板代码, WEB代码, COM和CORBA存根, 以及MFC和ATL等等。在这些地方, 都是有好多相似代码多次重复。既然这些代码有可能自动编写, 而程序员时间又远远比CPU时间昂贵, 当然就产生了好多工具来自动生成样板代码。这些工具的本质是什么呢? 它们实际上就是制造程序的程序。它们有一个神秘的名字, 叫做元编程。所谓元编程的本义, 就是如此。</p>
<p>元编程本来可以用到无数多的地方, 但实际上使用的次数却没有那么多。归根结底, 我们心里还是在盘算, 假设重复代码用拷贝粘贴的话, 大概要重复6,7次, 对于这样的工作量,值得专门建立一套生成工具吗? 当然不值得。数据访问层和COM存根往往需要重用数百次,甚至上千次, 所以用工具生成是最好的办法。而那些仅仅是重复几次十几次的代码, 是没有必要专门做工具的。不必要的时候也去开发代码生成工具, 那就显然过度估计了代码生成的好处。当然, 如果创建这类工具足够简单的话, 还是应当尽量多用, 因为这样做必然会节省时间。现在来看一下有没有合理的办法来达到这个目的。</p>
<p>现在, C预处理器要派上用场了。我们都用过C&#x2F;C++的预处理器, 我们用它执行简单的编译指令, 来产生简单的代码变换(比方说, 设置调试代码开关), 看一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define triple(X) X+X+X</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这一行的作用是什么? 这是一个简单的预编译指令, 它把程序中的triple(X)替换称为X+X+X。例如, 把所有的triple(5)都换成5+5+5, 然后再交给编译器编译。这就是一个简单的代码生成的例子。要是C的预处理器再强大一点, 要是能够允许连接数据库, 要是能多一些其他简单的机制, 我们就可以在我们程序的内部开发自己的数据访问层。下面这个例子, 是一个假想的对C宏的扩展:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#get-db-schema(&quot;127.0.0.1&quot;)</span><br><span class="line">#iterate-through-tables</span><br><span class="line">#for-each-table</span><br><span class="line">class #table-name</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line">#end-for-each</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们连接数据库结构定义, 遍历数据表, 然后对每个表创建一个类, 只消几行代码就完成了这个工作。这样每次编译工程的时候, 这些类都会根据数据库的定义同步更新。显而易见, 我们不费吹灰之力就在程序内部建立了一个完整的数据访问层, 根本用不着任何外部工具。当然这种作法有一个缺点, 那就是我们得学习一套新的”编译时语言”, 另一个缺点就是根本不存在这么一个高级版的C预处理器。需要做复杂代码生成的时候, 这个语言(译者注: 这里指预处理指令, 即作者所说的”编译时语言”)本身也一定会变得相当复杂。它必须支持足够多的库和语言结构。比如说我们想要生成的代码要依赖某些ftp服务器上的文件, 预处理器就得支持ftp访问, 仅仅因为这个任务而不得不创造和学习一门新的语言,真是有点让人恶心(事实上已经存在着有此能力的语言, 这样做就更显荒谬)。我们不妨再灵活一点, 为什么不直接用 C&#x2F;C++自己作为自己的预处理语言呢?? 这样子的话, 我们可以发挥语言的强大能力, 要学的新东西也只不过是几个简单的指示字 , 这些指示字用来区别编译时代码和运行时代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">cout&lt;&lt;&quot;Enter a number: &quot;;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">%&gt;</span><br><span class="line">for(int i=0;i&lt; &lt;% n %&gt;;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;hello&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你明白了吗? 在&lt;%和%&gt;标记之间的代码是在编译时运行的, 标记之外的其他代码都是普通代码。编译程序时, 系统会提示你输入一个数, 这个数在后面的循环中会用到。而for循环的代码会被编译。假定你在编译时输入5, for循环的代码将会是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;5; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;hello&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>又简单又有效率, 也不需要另外的预处理语言。我们可以在编译时就充分发挥宿主语言(此处是C&#x2F;C++)的强大能力, 我们可以很容易地在编译时连接数据库, 建立数据访问层, 就像JSP或者ASP创建网页那样。我们也用不着专门的窗口工具来另外建立工程。我们可以在代码中立即加入必要的工具。我们也用不着顾虑建立这种工具是不是值得, 因为这太容易了, 太简单了。这样子不知可以节省多少时间啊。</p>
<h2 id="你好-Lisp"><a href="#你好-Lisp" class="headerlink" title="你好, Lisp"></a>你好, Lisp</h2><p>到此刻为止, 我们所知的关于Lisp的指示可以总结为一句话: Lisp是一个可执行的语法更优美的XML, 但我们还没有说Lisp是怎样做到这一点的, 现在开始补上这个话题。</p>
<p>Lisp有丰富的内置数据类型, 其中的整数和字符串和其他语言没什么分别。像71或者”hello”这样的值, 含义也和C++或者Java这样的语言大体相同。真正有意思的三种类型是符号(symbol), 表和函数。这一章的剩余部分, 我都会用来介绍这几种类型, 还要介绍Lisp环境是怎样编译和运行源码的。这个过程用Lisp的术语来说通常叫做求值。通读这一节内容, 对于透彻理解元编程的真正潜力, 以及代码和数据的同一性, 和面向领域语言的观念, 都极其重要。万勿等闲视之。我会尽量讲得生动有趣一些, 也希望你能获得一些启发。那好, 我们先讲符号。</p>
<p>大体上, 符号相当于C++或Java语言中的标志符, 它的名字可以用来访问变量值(例如currentTime, arrayCount, n, 等等), 差别在于, Lisp中的符号更加基本。在C++或Java里面, 变量名只能用字母和下划线的组合, 而Lisp的符号则非常有包容性, 比如, 加号(+)就是一个合法的符号, 其他的像-, &#x3D;, hello-world, *等等都可以是符号名。符号名的命名规则可以在网上查到。你可以给这些符号任意赋值, 我们这里先用伪码来说明这一点。假定函数set是给变量赋值(就像等号&#x3D;在C++和Java里的作用), 下面是我们的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set(test, 5)            // 符号test的值为5</span><br><span class="line">set(=, 5)               // 符号=的值为5</span><br><span class="line">set(test, &quot;hello&quot;)      // 符号test的值为字符串&quot;hello&quot;</span><br><span class="line">set(test, =)            // 此时符号=的值为5, 所以test的也为5</span><br><span class="line">set(*, &quot;hello&quot;)         // 符号*的值为&quot;hello&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好像有什么不对的地方? 假定我们对<em>赋给整数或者字符串值, 那做乘法时怎么办? 不管怎么说, <em>总是乘法呀? 答案简单极了。Lisp中函数的角色十分特殊, 函数也是一种数据类型, 就像整数和字符串一样, 因此可以把它赋值给符号。乘法函数Lisp的内置函数, 默认赋给</em>, 你可以把其他函数赋值给</em>, 那样*就不代表乘法了。你也可以把这函数的值存到另外的变量里。我们再用伪码来说明一下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(*,3,4)       // 3乘4, 结果是12</span><br><span class="line">set(temp, *)    // 把*的值, 也就是乘法函数, 赋值给temp</span><br><span class="line">set(*, 3)       // 把3赋予*</span><br><span class="line">*(3,4)          // 错误的表达式, *不再是乘法, 而是数值3</span><br><span class="line">temp(3,4)       // temp是乘法函数, 所以此表达式的值为3乘4等于12</span><br><span class="line">set(*, temp)    // 再次把乘法函数赋予*</span><br><span class="line">*(3,4)          // 3乘4等于12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再古怪一点, 把减号的值赋给加号:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(+, -)       // 减号(-)是内置的减法函数</span><br><span class="line">+(5, 4)         // 加号(+)现在是代表减法函数, 结果是5减4等于1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这只是举例子, 我还没有详细讲函数。Lisp中的函数是一种数据类型, 和整数, 字符串,符号等等一样。一个函数并不必然有一个名字, 这和C++或者Java语言的情形很不相同。在这里函数自己代表自己。事实上它是一个指向代码块的指针, 附带有一些其他信息(例如一组参数变量)。只有在把函数赋予其他符号时, 它才具有了名字, 就像把一个数值或字符串赋予变量一样的道理。你可以用一个内置的专门用于创建函数的函数来创建函数,然后把它赋值给符号fn, 用伪码来表示就是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn [a]</span><br><span class="line">&#123;</span><br><span class="line">    return *(a, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码返回一个具有一个参数的函数, 函数的功能是计算参数乘2的结果。这个函数还没有名字, 你可以把此函数赋值给别的符号:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(times-two, fn [a] &#123;return *(a, 2)&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们现在可以这样调用这个函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time-two(5)   // 返回10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们先跳过符号和函数, 讲一讲表。什么是表? 你也许已经听过好多相关的说法。表, 一言以蔽之, 就是把类似XML那样的数据块, 用s表达式来表示。表用一对括号括住, 表中元素以空格分隔, 表可以嵌套。例如(这回我们用真正的Lisp语法, 注意用分号表示注释):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">()                      ; 空表</span><br><span class="line">(1)                     ; 含一个元素的表</span><br><span class="line">(1 &quot;test&quot;)              ; 两元素表, 一个元素是整数1, 另一个是字符串</span><br><span class="line">(test &quot;hello&quot;)          ; 两元素表, 一个元素是符号, 另一个是字符串</span><br><span class="line">(test (1 2) &quot;hello&quot;)    ; 三元素表, 一个符号test, 一个含有两个元素1和2的</span><br><span class="line">; 表, 最后一个元素是字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当Lisp系统遇到这样的表时, 它所做的, 和Ant处理XML数据所做的, 非常相似, 那就是试图执行它们。其实, Lisp源码就是特定的一种表, 好比Ant源码是一种特定的XML一样。Lisp执行表的顺序是这样的, 表的第一个元素当作函数, 其他元素当作函数的参数。如果其中某个参数也是表, 那就按照同样的原则对这个表求值, 结果再传递给最初的函数作为参数。这就是基本原则。我们看一下真正的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(* 3 4)                 ; 相当于前面列举过的伪码*(3,4), 即计算3乘4</span><br><span class="line">(times-two 5)           ; 返回10, times-two按照前面的定义是求参数的2倍</span><br><span class="line">(3 4)                   ; 错误, 3不是函数</span><br><span class="line">(time-two)              ; 错误, times-two要求一个参数</span><br><span class="line">(times-two 3 4)         ; 错误, times-two只要求一个参数</span><br><span class="line">(set + -)               ; 把减法函数赋予符号+</span><br><span class="line">(+ 5 4)                 ; 依据上一句的结果, 此时+表示减法, 所以返回1</span><br><span class="line">(* 3 (+ 2 2))           ; 2+2的结果是4, 再乘3, 结果是12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述的例子中, 所有的表都是当作代码来处理的。怎样把表当作数据来处理呢? 同样的,设想一下, Ant是把XML数据当作自己的参数。在Lisp中, 我们给表加一个前缀’来表示数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(set test &#x27;(1 2))       ; test的值为两元素表</span><br><span class="line">(set test (1 2))        ; 错误, 1不是函数</span><br><span class="line">(set test &#x27;(* 3 4))     ; test的值是三元素表, 三个元素分别是*, 3, 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以用一个内置的函数head来返回表的第一个元素, tail函数来返回剩余元素组成的表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(head &#x27;(* 3 4))         ; 返回符号*</span><br><span class="line">(tail &#x27;(* 3 4))         ; 返回表(3 4)</span><br><span class="line">(head (tal &#x27;(* 3 4)))   ; 返回3</span><br><span class="line">(head test)             ; 返回*</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可以把Lisp的内置函数想像成Ant的任务。差别在于, 我们不用在另外的语言中扩展Lisp(虽然完全可以做得到), 我们可以用Lisp自己来扩展自己, 就像上面举的times-two函数的例子。Lisp的内置函数集十分精简, 只包含了十分必要的部分。剩下的函数都是作为标准库来实现的。</p>
<h2 id="Lisp宏"><a href="#Lisp宏" class="headerlink" title="Lisp宏"></a>Lisp宏</h2><p>我们已经看到, 元编程在一个类似jsp的模板引擎方面的应用。我们通过简单的字符串处理来生成代码。但是我们可以做的更好。我们先提一个问题, 怎样写一个工具, 通过查找目录结构中的源文件来自动生成Ant脚本。</p>
<p>用字符串处理的方式生成Ant脚本是一种简单的方式。当然, 还有一种更加抽象, 表达能力更强, 扩展性更好的方式, 就是利用XML库在内存中直接生成XML节点, 这样的话内存中的节点就可以自动序列化成为字符串。不仅如此, 我们的工具还可以分析这些节点, 对已有的XML文件做变换。通过直接处理XML节点。我们可以超越字符串处理, 使用更高层次的概念, 因此我们的工作就会做的更快更好。</p>
<p>我们当然可以直接用Ant自身来处理XML变换和制作代码生成工具。或者我们也可以用Lisp来做这项工作。正像我们以前所知的, 表是Lisp内置的数据结构, Lisp含有大量的工具来快速有效的操作表(head和tail是最简单的两个)。而且, Lisp没有语义约束, 你可以构造任何数据结构, 只要你原意。</p>
<p>Lisp通过宏(macro)来做元编程。我们写一组宏来把任务列表(to-do list)转换为专用领域语言。</p>
<p>回想一下上面to-do list的例子, 其XML的数据格式是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;todo name=&quot;housework&quot;&gt;</span><br><span class="line">	&lt;item priority=&quot;high&quot;&gt;Clean the hose&lt;/item&gt;</span><br><span class="line">	&lt;item priority=&quot;medium&quot;&gt;Wash the dishes&lt;/item&gt;</span><br><span class="line">	&lt;item priority=&quot;medium&quot;&gt;Buy more soap&lt;/item&gt;</span><br><span class="line">&lt;/todo&gt;</span><br></pre></td></tr></table></figure>

<p>相应的s表达式是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(todo &quot;housework&quot;</span><br><span class="line">(item (priority high) &quot;Clean the house&quot;)</span><br><span class="line">(item (priority medium) &quot;Wash the dishes&quot;)</span><br><span class="line">(item (priority medium) &quot;Buy more soap&quot;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设我们要写一个任务表的管理程序, 把任务表数据存到一组文件里, 当程序启动时, 从文件读取这些数据并显示给用户。在别的语言里(比如说Java), 这个任务该怎么做? 我们会解析XML文件, 从中得出任务表数据, 然后写代码遍历XML树, 再转换为Java的数据结构(老实讲, 在Java里解析XML真不是件轻松的事情), 最后再把数据展示给用户。现在如果用Lisp, 该怎么做?</p>
<p>假定要用同样思路的化, 我们大概会用Lisp库来解析XML。XML对我们来说就是一个Lisp的表(s表达式), 我们可以遍历这个表, 然后把相关数据提交给用户。可是, 既然我们用Lisp, 就根本没有必要再用XML格式保存数据, 直接用s表达式就好了, 这样就没有必要做转换了。我们也用不着专门的解析库, Lisp可以直接在内存里处理s表达式。注意, Lisp编译器和.net编译器一样, 对Lisp程序来说, 在运行时总是随时可用的。</p>
<p>但是还有更好的办法。我们甚至不用写表达式来存储数据, 我们可以写宏, 把数据当作代码来处理。那该怎么做呢? 真的简单。回想一下, Lisp的函数调用格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function-name arg1 arg2 arg3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中每个参数都是s表达式, 求值以后, 传递给函数。如果我们用(+ 4 5)来代替arg1,那么, 程序会先求出结果, 就是9, 然后把9传递给函数。宏的工作方式和函数类似。主要的差别是, 宏的参数在代入时不求值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(macro-name (+ 4 5))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里, (+ 4 5)作为一个表传递给宏, 然后宏就可以任意处理这个表, 当然也可以对它求值。宏的返回值是一个表, 然后有程序作为代码来执行。宏所占的位置, 就被替换为这个结果代码。我们可以定义一个宏把数据替换为任意代码, 比方说, 替换为显示数据给用户的代码。</p>
<p>这和元编程, 以及我们要做的任务表程序有什么关系呢? 实际上, 编译器会替我们工作,调用相应的宏。我们所要做的, 仅仅是创建一个把数据转换为适当代码的宏。</p>
<p>例如, 上面曾经将过的C的求三次方的宏, 用Lisp来写是这样子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(defmacro triple (x)</span><br><span class="line">`(+ ~x ~x ~x))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(译注: 在Common Lisp中, 此处的单引号应当是反单引号, 意思是对表不求值, 但可以对表中某元素求值, 记号~表示对元素x求值, 这个求值记号在Common Lisp中应当是逗号。反单引号和单引号的区别是, 单引号标识的表, 其中的元素都不求值。这里作者所用的记号是自己发明的一种Lisp方言Blaise, 和common lisp略有不同, 事实上, 发明方言是lisp高手独有的乐趣, 很多狂热分子都热衷这样做。比如Paul Graham就发明了ARC, 许多记号比传统的Lisp简洁得多, 显得比较现代)</p>
<p>单引号的用处是禁止对表求值。每次程序中出现triple的时候,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(triple 4)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>都会被替换成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(+ 4 4 4)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以为任务表程序写一个宏, 把任务数据转换为可执行码, 然后执行。假定我们的输出是在控制台:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defmacro item (priority note)</span><br><span class="line">`(block</span><br><span class="line">(print stdout tab &quot;Prority: &quot; ~(head (tail priority)) endl)</span><br><span class="line">(print stdout tab &quot;Note: &quot; ~note endl endl)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们创造了一个非常小的有限的语言来管理嵌在Lisp中的任务表。这个语言只用来解决特定领域的问题, 通常称之为DSLs(特定领域语言, 或专用领域语言)。</p>
<h2 id="特定领域语言"><a href="#特定领域语言" class="headerlink" title="特定领域语言"></a>特定领域语言</h2><p>本文谈到了两个特定领域语言, 一个是Ant, 处理软件构造。一个是没起名字的, 用于处理任务表。两者的差别在于, Ant是用XML, XML解析器, 以及Java语言合在一起构造出来的。而我们的迷你语言则完全内嵌在Lisp中, 只消几分钟就做出来了。</p>
<p>我们已经说过了DSL的好处, 这也就是Ant用XML而不直接用Java的原因。如果使用Lisp,我们可以任意创建DSL, 只要我们需要。我们可以创建用于网站程序的DSL, 可以写多用户游戏, 做固定收益贸易(fixed income trade), 解决蛋白质折叠问题, 处理事务问题, 等等。我们可以把这些叠放在一起, 造出一个语言, 专门解决基于网络的贸易程序, 既有网络语言的优势, 又有贸易语言的好处。每天我们都会收获这种方法带给我们的益处, 远远超过Ant所能给予我们的。</p>
<p>用DSL解决问题, 做出的程序精简, 易于维护, 富有弹性。在Java里面, 我们可以用类来处理问题。这两种方法的差别在于, Lisp使我们达到了一个更高层次的抽象, 我们不再受语言解析器本身的限制, 比较一下用Java库直接写的构造脚本和用Ant写的构造脚本其间的差别。同样的, 比较一下你以前所做的工作, 你就会明白Lisp带来的好处。</p>
<h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>学习Lisp就像战争中争夺山头。尽管在电脑科学领域, Lisp已经算是一门古老的语言, 直到现在仍然很少有人真的明白该怎样给初学者讲授Lisp。尽管Lisp老手们尽了很大努力,今天新手学习Lisp仍然是困难重重。好在现在事情正在发生变化, Lisp的资源正在迅速增加, 随着时间推移, Lisp将会越来越受关注。</p>
<p>Lisp使人超越平庸, 走到前沿。学会Lisp意味着你能找到更好的工作, 因为聪明的雇主会被你与众不同的洞察力所打动。学会Lisp也可能意味着明天你可能会被解雇, 因为你总是强调, 如果公司所有软件都用Lisp写, 公司将会如何卓越, 而这些话你的同事会听烦的。Lisp值得努力学习吗? 那些已经学会Lisp的人都说值得, 当然, 这取决于你的判断。</p>
<h2 id="你的看法呢"><a href="#你的看法呢" class="headerlink" title="你的看法呢?"></a>你的看法呢?</h2><p>这篇文章写写停停, 用了几个月才最终完成。如果你觉得有趣, 或者有什么问题, 意见或建议, 请给我发邮件<a href="mailto:&#x63;&#111;&#x66;&#x66;&#101;&#101;&#x6d;&#x75;&#x67;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#x63;&#111;&#x66;&#x66;&#101;&#101;&#x6d;&#x75;&#x67;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;</a>, 我会很高兴收到你的反馈。</p>
<p>转自：<a target="_blank" rel="noopener" href="http://blog.jobbole.com/30614/">http://blog.jobbole.com/30614/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/lisp/lispdiary/lispbz/" data-id="clhlnyli100rvojupfqh1c8sn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lisp/" rel="tag">Lisp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/bigdata/hadoop/hadoopwebmanager" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/bigdata/hadoop/hadoopwebmanager/" class="article-date">
  <time datetime="2015-10-18T09:36:00.000Z" itemprop="datePublished">2015-10-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/bigdata/hadoop/hadoopwebmanager/">Hadoop WEB控制台的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>hadoop提供了WEB服务可供使用者查看系统状态，主要有两个控制台：</p>
<p>任务控制台：<a target="_blank" rel="noopener" href="http://hadoop-1:50030/jobtracker.jsp">http://hadoop-1:50030/jobtracker.jsp</a></p>
<p>文件控制台：<a target="_blank" rel="noopener" href="http://hadoop-1:50070/dfshealth.jsp">http://hadoop-1:50070/dfshealth.jsp</a></p>
<h2 id="任务控制台"><a href="#任务控制台" class="headerlink" title="任务控制台"></a>任务控制台</h2><p>可以查看集群信息、计划中任务、运行中任务、已完成任务。</p>
<p>任务控制台首页：</p>
<p><img src="/images/hadoop/jobtrackerjsp.png"></p>
<p>tasktracker节点：</p>
<p><img src="/images/hadoop/machinesjsp.png"></p>
<p>已完成任务详情：</p>
<p><img src="/images/hadoop/jobdetailsjsp.png"></p>
<h2 id="文件控制台"><a href="#文件控制台" class="headerlink" title="文件控制台"></a>文件控制台</h2><p>可以查看活动节点和死亡节点，还有一个WEB版文件浏览器可以看HDFS的目录和文件。</p>
<p>HDFS控制台首页：</p>
<p><img src="/images/hadoop/dfshealthjsp.png"></p>
<p>活动datanode列表：</p>
<p><img src="/images/hadoop/dfsnodelistjsp.png"></p>
<p>浏览HDFS文件系统：</p>
<p><img src="/images/hadoop/browsedirjsp.png"></p>
<p>查看HDFS文件：</p>
<p><img src="/images/hadoop/browseblockjsp.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/bigdata/hadoop/hadoopwebmanager/" data-id="clhlnyldq002hojupa8uj6hyc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/bigdata/hadoop/helloworld" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/bigdata/hadoop/helloworld/" class="article-date">
  <time datetime="2015-10-18T08:33:32.000Z" itemprop="datePublished">2015-10-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/bigdata/hadoop/helloworld/">Hadoop的hello world程序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这里利用hadoop自带的hadoop-0.20.2-examples.jar做一个单词统计的测试，相当于编程时的Hello<br>World程序。</p>
<p>注意切换目录，”hadoop@hadoop-1:~&#x2F;hadoop-0.20.2$“的格式为”用户@主机:目录$“，注意命令运行时的目录所在，可以通过CD命令切换目录。</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ ls
bin          docs                        ivy          NOTICE.txt
build.xml    hadoop-0.20.2-ant.jar       ivy.xml      README.txt
c++          hadoop-0.20.2-core.jar      lib          src
CHANGES.txt  hadoop-0.20.2-examples.jar  librecordio  webapps
conf         hadoop-0.20.2-test.jar      LICENSE.txt
contrib      hadoop-0.20.2-tools.jar     logs
hadoop@hadoop-1:~/hadoop-0.20.2$ 
</code></pre>
<p>创建input文件夹，在里面创建两个文件，里面输入英文单词。</p>
<pre><code>hadoop@hadoop-1:~$ mkdir input
hadoop@hadoop-1:~$ ls
1  hadoop-0.20.2         input   模板  图片  下载  桌面
3  hadoop-0.20.2.tar.gz  公共的  视频  文档  音乐
hadoop@hadoop-1:~$ cd input
hadoop@hadoop-1:~/input$ echo &quot;hello world&quot;&gt;test1.txt
hadoop@hadoop-1:~/input$ echo &quot;hello hadoop&quot;&gt;test2.txt
hadoop@hadoop-1:~/input$ cat test1.txt 
hello world
hadoop@hadoop-1:~/input$ cat test2.txt 
hello hadoop
hadoop@hadoop-1:~/input$ 
</code></pre>
<p>将input目录复制到HDFS文件系统的in目录。</p>
<pre><code>hadoop@hadoop-1:~/input$ cd ../hadoop-0.20.2/
hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop dfs -put ../input in
hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop dfs -ls ./in/*
-rw-r--r--   2 hadoop supergroup         12 2015-10-18 00:59 /user/hadoop/in/test1.txt
-rw-r--r--   2 hadoop supergroup         13 2015-10-18 00:59 /user/hadoop/in/test2.txt
hadoop@hadoop-1:~/hadoop-0.20.2$ 
</code></pre>
<p>执行统计单词的任务，统计in目录里的文件，结果放到out目录里。</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop jar hadoop-0.20.2-examples.jar wordcount in out 
15/10/18 01:03:40 INFO input.FileInputFormat: Total input paths to process : 2
15/10/18 01:03:41 INFO mapred.JobClient: Running job: job_201510171812_0001
15/10/18 01:03:42 INFO mapred.JobClient:  map 0% reduce 0%
15/10/18 01:03:52 INFO mapred.JobClient:  map 50% reduce 0%
15/10/18 01:03:56 INFO mapred.JobClient:  map 100% reduce 0%
15/10/18 01:04:07 INFO mapred.JobClient:  map 100% reduce 100%
15/10/18 01:04:09 INFO mapred.JobClient: Job complete: job_201510171812_0001
15/10/18 01:04:09 INFO mapred.JobClient: Counters: 17
15/10/18 01:04:09 INFO mapred.JobClient:   Map-Reduce Framework
15/10/18 01:04:09 INFO mapred.JobClient:     Combine output records=4
15/10/18 01:04:09 INFO mapred.JobClient:     Spilled Records=8
15/10/18 01:04:09 INFO mapred.JobClient:     Reduce input records=4
15/10/18 01:04:09 INFO mapred.JobClient:     Reduce output records=3
15/10/18 01:04:09 INFO mapred.JobClient:     Map input records=2
15/10/18 01:04:09 INFO mapred.JobClient:     Map output records=4
15/10/18 01:04:09 INFO mapred.JobClient:     Map output bytes=41
15/10/18 01:04:09 INFO mapred.JobClient:     Reduce shuffle bytes=61
15/10/18 01:04:09 INFO mapred.JobClient:     Combine input records=4
15/10/18 01:04:09 INFO mapred.JobClient:     Reduce input groups=3
15/10/18 01:04:09 INFO mapred.JobClient:   FileSystemCounters
15/10/18 01:04:09 INFO mapred.JobClient:     HDFS_BYTES_READ=25
15/10/18 01:04:09 INFO mapred.JobClient:     FILE_BYTES_WRITTEN=180
15/10/18 01:04:09 INFO mapred.JobClient:     FILE_BYTES_READ=55
15/10/18 01:04:09 INFO mapred.JobClient:     HDFS_BYTES_WRITTEN=25
15/10/18 01:04:09 INFO mapred.JobClient:   Job Counters 
15/10/18 01:04:09 INFO mapred.JobClient:     Launched map tasks=2
15/10/18 01:04:09 INFO mapred.JobClient:     Launched reduce tasks=1
15/10/18 01:04:09 INFO mapred.JobClient:     Data-local map tasks=2
hadoop@hadoop-1:~/hadoop-0.20.2$ 
</code></pre>
<p>查看HDFS文件系统，可以看到多出了个out目录。</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop dfs -ls
Found 2 items
drwxr-xr-x   - hadoop supergroup          0 2015-10-18 00:59 /user/hadoop/in
drwxr-xr-x   - hadoop supergroup          0 2015-10-18 01:04 /user/hadoop/out
hadoop@hadoop-1:~/hadoop-0.20.2$ 
</code></pre>
<p>查看out目录，时面有个_logs目录，还有一个part-r-00000文件。</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop dfs -ls ./out
Found 2 items
drwxr-xr-x   - hadoop supergroup          0 2015-10-18 01:03 /user/hadoop/out/_logs
-rw-r--r--   2 hadoop supergroup         25 2015-10-18 01:04 /user/hadoop/out/part-r-00000
</code></pre>
<p>查看结果，可以看到统计结果。</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop dfs -cat ./out/part-r-00000
hadoop  1
hello   2
world   1
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/bigdata/hadoop/helloworld/" data-id="clhlnyldq002kojup0rpx0b18" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/algorithm/other/monte-carlo-method" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/algorithm/other/monte-carlo-method/" class="article-date">
  <time datetime="2015-10-14T09:58:58.000Z" itemprop="datePublished">2015-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/algorithm/other/monte-carlo-method/">蒙特卡罗方法入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文通过五个例子，介绍蒙特卡罗方法（Monte Carlo Method）。</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>蒙特卡罗方法是一种计算方法。原理是通过大量随机样本，去了解一个系统，进而得到所要计算的值。</p>
<p>它非常强大和灵活，又相当简单易懂，很容易实现。对于许多问题来说，它往往是最简单的计算方法，有时甚至是唯一可行的方法。</p>
<p><img src="/images/algorithm/mtklrm1.jpg"></p>
<p>它诞生于上个世纪40年代美国的&quot;曼哈顿计划&quot;，名字来源于赌城蒙特卡罗，象征概率。</p>
<h2 id="二、π的计算"><a href="#二、π的计算" class="headerlink" title="二、π的计算"></a>二、π的计算</h2><p>第一个例子是，如何用蒙特卡罗方法计算圆周率π。</p>
<p>正方形内部有一个相切的圆，它们的面积之比是π&#x2F;4。</p>
<p><img src="/images/algorithm/mtklrm2.jpg"></p>
<p><img src="/images/algorithm/mtklrm3.jpg"></p>
<p>现在，在这个正方形内部，随机产生10000个点（即10000个坐标对 (x,<br>y)），计算它们与中心点的距离，从而判断是否落在圆的内部。</p>
<p><img src="/images/algorithm/mtklrm4.jpg"></p>
<p>如果这些点均匀分布，那么圆内的点应该占到所有点的<br>π&#x2F;4，因此将这个比值乘以4，就是π的值。通过R语言脚本随机模拟30000个点，π的估算值与真实值相差0.07%。</p>
<h2 id="三、积分的计算"><a href="#三、积分的计算" class="headerlink" title="三、积分的计算"></a>三、积分的计算</h2><p>上面的方法加以推广，就可以计算任意一个积分的值。</p>
<p><img src="/images/algorithm/mtklrm5.gif"></p>
<p>比如，计算函数 y &#x3D; x^2^ 在 [0, 1]<br>区间的积分，就是求出下图红色部分的面积。</p>
<p><img src="/images/algorithm/mtklrm6.jpg"></p>
<p>这个函数在 (1,1)<br>点的取值为1，所以整个红色区域在一个面积为1的正方形里面。在该正方形内部，产生大量随机点，可以计算出有多少点落在红色区域（判断条件<br>y &lt; x^2^）。这个比重就是所要求的积分值。</p>
<p>用Matlab模拟100万个随机点，结果为0.3328。</p>
<h2 id="四、交通堵塞"><a href="#四、交通堵塞" class="headerlink" title="四、交通堵塞"></a>四、交通堵塞</h2><p>蒙特卡罗方法不仅可以用于计算，还可以用于模拟系统内部的随机运动。下面的例子模拟单车道的交通堵塞。</p>
<p>根据 Nagel-Schreckenberg 模型，车辆的运动满足以下规则。</p>
<blockquote>
<ul>
<li>当前速度是 v 。</li>
<li>如果前面没车，它在下一秒的速度会提高到 v + 1<br>，直到达到规定的最高限速。</li>
<li>如果前面有车，距离为d，且 d &lt; v，那么它在下一秒的速度会降低到 d -<br>1 。</li>
<li>此外，司机还会以概率 p 随机减速， 将下一秒的速度降低到 v - 1 。</li>
</ul>
</blockquote>
<p>在一条直线上，随机产生100个点，代表道路上的100辆车，另取概率 p 为 0.3 。</p>
<p><img src="/images/algorithm/mtklrm7.png"></p>
<p>上图中，横轴代表距离（从左到右），纵轴代表时间（从上到下），因此每一行就表示下一秒的道路情况。</p>
<p>可以看到，该模型会随机产生交通拥堵（图形上黑色聚集的部分）。这就证明了，单车道即使没有任何原因，也会产生交通堵塞。</p>
<h2 id="五、产品厚度"><a href="#五、产品厚度" class="headerlink" title="五、产品厚度"></a>五、产品厚度</h2><p>某产品由八个零件堆叠组成。也就是说，这八个零件的厚度总和，等于该产品的厚度。</p>
<p><img src="/images/algorithm/mtklrm8.jpg"></p>
<p>已知该产品的厚度，必须控制在27mm以内，但是每个零件有一定的概率，厚度会超出误差。请问有多大的概率，产品的厚度会超出27mm？</p>
<p><img src="/images/algorithm/mtklrm9.png"></p>
<p>取100000个随机样本，每个样本有8个值，对应8个零件各自的厚度。计算发现，产品的合格率为99.9979%，即百万分之21的概率，厚度会超出27mm。</p>
<h2 id="六、证券市场"><a href="#六、证券市场" class="headerlink" title="六、证券市场"></a>六、证券市场</h2><p>证券市场有时交易活跃，有时交易冷清。下面是你对市场的预测。</p>
<ul>
<li>如果交易冷清，你会以平均价11元，卖出5万股。</li>
<li>如果交易活跃，你会以平均价8元，卖出10万股。</li>
<li>如果交易温和，你会以平均价10元，卖出7.5万股。</li>
</ul>
<p>已知你的成本在每股5.5元到7.5元之间，平均是6.5元。请问接下来的交易，你的净利润会是多少？</p>
<p>取1000个随机样本，每个样本有两个数值：一个是证券的成本（5.5元到7.5元之间的均匀分布），另一个是当前市场状态（冷清、活跃、温和，各有三分之一可能）。</p>
<p><img src="/images/algorithm/mtklrm10.png"></p>
<p>模拟计算得到，平均净利润为92, 427美元。</p>
<p>转自：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/07/monte-carlo-method.html">http://www.ruanyifeng.com/blog/2015/07/monte-carlo-method.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/algorithm/other/monte-carlo-method/" data-id="clhlnyldi001eojupasic6b2h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/tools/emacs/emacsdiary/emacsksrm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/tools/emacs/emacsdiary/emacsksrm/" class="article-date">
  <time datetime="2015-10-14T07:57:22.000Z" itemprop="datePublished">2015-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/Emacs/">Emacs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/tools/emacs/emacsdiary/emacsksrm/">Emacs快速入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Emacs的基本编辑功能并不复杂，这里主要介绍Emacs的常用编辑功能。</p>
<h2 id="控制键"><a href="#控制键" class="headerlink" title="控制键"></a>控制键</h2><p>Emacs 键盘命令通常包含 CONTROL 键（有时候以 CTRL 或 CTL 来标示）和META键（有时候用 EDIT 或 ALT<br>来标示）。为了避免每次都要写出全名，我们约定使用下述缩写：</p>
<p>C-:表示当输入字符 时按住 CONTROL 键。因此 C-f 就表示：按住 CONTROL键再输入 f。</p>
<p>M-: 表示当输入字符 时按住 META（或 EDIT 或 ALT）键。如果你的键盘上没有META 、EDIT 或 ALT 键，用下述方法也等效：先按一下 ESC 键然后放开，再输入。我们用 来表示ESC 键。</p>
<p>通常的惯例是：META系列组合键用来操作“由语言定义的单位（比如词、句子、段落）”，而CONTROL系列组合键用来操作“与语言无关的基本单位（比如字符、行等等）”。</p>
<p>CTRL有很多按法，推荐用两手小拇指按，一手按CTRL一手按字母。</p>
<p>ALT推荐用两手大拇指，一手按ALT一手按字母。</p>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul>
<li>C-x C-f：寻找文件。</li>
<li>C-x C-s：保存文件</li>
<li>C-x C-b：列出缓冲区</li>
<li>C-x C-c：离开 Emacs</li>
<li>C-x 1：关掉其它所有窗格，只保留一个</li>
<li>C-x u：撤销</li>
</ul>
<h2 id="滚屏"><a href="#滚屏" class="headerlink" title="滚屏"></a>滚屏</h2><ul>
<li>C-v:向前移动一屏</li>
<li>M-v:向后移动一屏</li>
<li>C-l:重绘屏幕，并将光标所在行置于屏幕的中央</li>
</ul>
<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><pre><code>                  上一行 C-p
                       :
                       :
 向左移 C-b .... 目前光标位置 .... 向右移 C-f
                       :
                       :
                  下一行 C-n
</code></pre>
<ul>
<li>C-b:B 代表 backward（回退）</li>
<li>C-f:F 则代表 forward（前进）</li>
<li>C-p:P 代表 previous（上一行）</li>
<li>C-n:N 代表 next（下一行）</li>
</ul>
<p>按单词移动,这里的“词”指英文单词，对中文来说，则是指移动到下一个标点符号：</p>
<ul>
<li>M-f:(META-f) 向前移动一个词</li>
<li>M-b:向后移动一个词</li>
</ul>
<p>移动动到首尾：</p>
<ul>
<li>C-a：移动到行首</li>
<li>C-e：移动到行尾</li>
<li>M-a：移动到句首</li>
<li>M-e：移动到句尾</li>
<li>M-&lt;：移到文件最开始</li>
<li>M-&gt;：移到文件最末尾</li>
</ul>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><p>命令参数最常用的是重复执行命令。</p>
<p>输入方法：先输入 C-u，然后输入数字作为参数，最后再输入命令。</p>
<p>例：向前移动 8 个字符</p>
<pre><code> C-u 8 C-f
</code></pre>
<p>例：输入相同字符，插入 ********</p>
<pre><code> C-u 8 *
</code></pre>
<h2 id="终止命令"><a href="#终止命令" class="headerlink" title="终止命令"></a>终止命令</h2><p>如果 Emacs 对你的命令失去响应，你可以用 C-g来安全地终止这条命令。C-g也可以终止一条执行过久的命令。</p>
<p>C-g 还可以取消数字参数和只输入到一半的命令。</p>
<h2 id="删除剪切内容"><a href="#删除剪切内容" class="headerlink" title="删除剪切内容"></a>删除剪切内容</h2><p>Emacs的编辑和普通的编辑器的输入删除一样，这里介绍几个删除的快捷键：</p>
<ul>
<li>C-d:删除光标后的一个字符</li>
<li>M-d:移除（剪切）光标后的一个词</li>
<li>C-k:移除（剪切）从光标到“行尾”间的字符</li>
<li>M-k:移除（剪切）从光标到“句尾”间的字符</li>
<li>C-w:移除（剪切）区块</li>
<li>M-w:复制区块</li>
</ul>
<p>注意,“移除（kill）”和“删除（delete）”的不同在于被移除的东西可以被重新插入（在任何位置），而被删除的就不能使用相同的方法重新插入了。</p>
<p>一般而言，那些可能消除很多文字的命令会把消除掉的文字记录下来（它们被设定成了“可召回”），而那些只消除一个字符或者只消除空白的命令就不会记录被消除的内容（自然你也就无法召回了）。</p>
<h2 id="粘贴-x2F-召回内容"><a href="#粘贴-x2F-召回内容" class="headerlink" title="粘贴&#x2F;召回内容"></a>粘贴&#x2F;召回内容</h2><ul>
<li>C-y:光标所在处插入你最后移除的文字。</li>
<li>M-y:召回再前一次被移除的内容，可以一直向前召回。</li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul>
<li>C-s:向前搜索</li>
<li>C-r:向后搜索</li>
</ul>
<p>按回车可以结束搜索,如果想搜索下一个结果就按C-s&#x2F;C-r</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/emacs/emacsdiary/emacsksrm/" data-id="clhlnylix00x3ojup5aq91zlu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Emacs/" rel="tag">Emacs</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/basetech/math/xxds/jzcfbz" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/basetech/math/xxds/jzcfbz/" class="article-date">
  <time datetime="2015-10-12T10:22:39.000Z" itemprop="datePublished">2015-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/basetech/math/xxds/jzcfbz/">矩阵乘法和矩阵的本质理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>大多数人在高中，或者大学低年级，都上过一门课《线性代数》。这门课其实是教矩阵。</p>
<p>刚学的时候，还蛮简单的，矩阵加法就是相同位置的数字加一下。</p>
<p><img src="/images/matrix/ljjzcf1.png"></p>
<p>矩阵减法也类似。</p>
<p>矩阵乘以一个常数，就是所有位置都乘以这个数。</p>
<p><img src="/images/matrix/ljjzcf2.png"></p>
<p>但是，等到矩阵乘以矩阵的时候，一切就不一样了。</p>
<p><img src="/images/matrix/ljjzcf3.png"></p>
<p>这个结果是怎么算出来的？</p>
<p>教科书告诉你，计算规则是，第一个矩阵第一行的每个数字（2和1），各自乘以第二个矩阵第一列对应位置的数字（1和1），然后将乘积相加（<br>2 x 1 + 1 x 1），得到结果矩阵左上角的那个值3。</p>
<p><img src="/images/matrix/ljjzcf4.gif"></p>
<p>也就是说，结果矩阵第m行与第n列交叉位置的那个值，等于第一个矩阵第m行与第二个矩阵第n列，对应位置的每个值的乘积之和。</p>
<p>怎么会有这么奇怪的规则？</p>
<p>我一直没理解这个规则的含义，导致《线性代数》这门课就没学懂。研究生时发现，线性代数是向量计算的基础，很多重要的数学模型都要用到向量计算，所以我做不了复杂模型。这一直让我有点伤心。</p>
<p>前些日子，受到一篇文章的启发，我终于想通了，矩阵乘法到底是什么东西。关键就是一句话，<strong>矩阵的本质就是线性方程式，两者是一一对应关系。</strong>如果从线性方程式的角度，理解矩阵乘法就毫无难度。</p>
<p>下面是一组线性方程式。</p>
<p><img src="/images/matrix/ljjzcf5.png"></p>
<p>矩阵的最初目的，只是为线性方程组提供一个简写形式。</p>
<p><img src="/images/matrix/ljjzcf6.png"></p>
<p>老实说，从上面这种写法，已经能看出矩阵乘法的规则了：系数矩阵第一行的2和1，各自与<br>x 和 y<br>的乘积之和，等于3。不过，这不算严格的证明，只是线性方程式转为矩阵的书写规则。</p>
<p>下面才是严格的证明。有三组未知数 x、y 和 t，其中 x 和 y 的关系如下。</p>
<p><img src="/images/matrix/ljjzcf7.png"></p>
<p>x 和 t 的关系如下。</p>
<p><img src="/images/matrix/ljjzcf8.png"></p>
<p>有了这两组方程式，就可以求 y 和 t<br>的关系。从矩阵来看，很显然，只要把第二个矩阵代入第一个矩阵即可。</p>
<p><img src="/images/matrix/ljjzcf9.png"></p>
<p>从方程式来看，也可以把第二个方程组代入第一个方程组。</p>
<p><img src="/images/matrix/ljjzcf10.png"></p>
<p>上面的方程组可以整理成下面的形式。</p>
<p><img src="/images/matrix/ljjzcf11.png"></p>
<p>最后那个矩阵等式，与前面的矩阵等式一对照，就会得到下面的关系。</p>
<p><img src="/images/matrix/ljjzcf12.png"></p>
<p>矩阵乘法的计算规则，从而得到证明。</p>
<p>转自：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/09/matrix/ljjzcf-multiplication.html">http://www.ruanyifeng.com/blog/2015/09/matrix/ljjzcf-multiplication.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/basetech/math/xxds/jzcfbz/" data-id="clhlnylgx00loojup3mv1433x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blog/tools/vim/vimksrm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/tools/vim/vimksrm/" class="article-date">
  <time datetime="2015-10-10T05:57:57.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/tools/vim/vimksrm/">Vim快速入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Vim的基本功能学习还是很容易的，主要掌握Vim的模式和几个快捷键就行了。分分钟的事，没有多难。</p>
<h2 id="Vim模式"><a href="#Vim模式" class="headerlink" title="Vim模式"></a>Vim模式</h2><ul>
<li>正常模式:浏览和修改文本内容</li>
<li>命令模式:多用于操作文本文件,而不是操作文本文件的内容</li>
<li>插入模式:向文本中添加内容</li>
<li>可视模式:选取文本</li>
</ul>
<h2 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h2><p>在任何时候按Esc键都会退到正常模式。</p>
<p>记住移动光标的四个快捷键：</p>
<pre><code>k                上移；
j                下移；
h                左移；
l                右移。
</code></pre>
<p>记住删除快捷键：</p>
<p>d：删除行</p>
<p>x:删除字符</p>
<p>不多吧，一共6个。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>在编辑模式下键入 :<br>，光标就跳到屏幕最后一行，并在那里显示冒号，此时已进入命令模式。命令模式又称<br>末行模式 ，用户输入的内容均显示在屏幕的最后一行，按回车键，Vim<br>执行命令。</p>
<p>打开文件需要用 <strong><code>:e</code></strong> 命令：</p>
<pre><code>:e path_to_file/filename
</code></pre>
<p>保存文件需要用 <strong><code>:w</code></strong> 命令（单词 <code>write</code> 的缩写）：</p>
<pre><code>:w
</code></pre>
<p>将当前文件另存为 <code>file_temp</code> 则：</p>
<pre><code>:w file_temp
</code></pre>
<p>退出编辑程序，而不打算保存编辑的内容，可用下面的命令：</p>
<pre><code>: q                在未作修改的情况下退出；
: q!               放弃所有修改，退出编辑程序。
</code></pre>
<p>保存并退出则可以讲两条命令结合起来使用（注意命令顺序，先保存，后退出）：</p>
<pre><code>:wq
</code></pre>
<p>不多，就ewq三个而已。</p>
<h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><p>在编辑模式下正确定位光标之后，可用以下命令切换到插入模式：</p>
<pre><code>i            在光标左侧插入正文
I            在光标所在行的开头插入
a            在光标右侧插入正文
A            在光标所在行的末尾插入
o            在光标所在行的下一行增添新行
O            在光标所在行的上一行增添新行
</code></pre>
<p>只有大小写的iao而已。</p>
<h2 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h2><p>为了便于选取文本，VIM 引入了可视(Visual)模式。</p>
<p>在正常模式下按v键进入可视模式。</p>
<p>按正常模式的方式移动光标，光标移动过的区域会被选中。</p>
<p>删除或复制:</p>
<pre><code>x或d     剪切(即删除，同时所选的文本进入剪贴板) 
y        复制
</code></pre>
<p>当输入了命令以后，VIM 将回到普通模式，这时可以按 p 或 P 进行粘贴。</p>
<pre><code>p   粘在光标所在字符后面
P    粘在前面
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/vim/vimksrm/" data-id="clhlnylgp00k6ojupfn0yedoq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/tools/vim/vimregzdpp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/tools/vim/vimregzdpp/" class="article-date">
  <time datetime="2015-10-09T09:14:10.000Z" itemprop="datePublished">2015-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/tools/vim/vimregzdpp/">Vim正规表达式最短匹配</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>&lt;pre class=&quot;hljs matlab&quot;&gt;&lt;code class=&quot;matlab&quot;&gt;k                上移；
&lt;span class=&quot;hljs-built_in&quot;&gt;j&lt;/span&gt;                下移；
h                左移；
l                右移。&lt;/code&gt;&lt;/pre&gt;
</code></pre>
<p>如果用vim删除上面所有class属性，用如下命令会出问题：</p>
<pre><code>:1,$ s/class=&quot;.\+&quot;//g
</code></pre>
<p>原因是+加的匹配默认是最长匹配，也就是能匹配多长就多长，也以匹配结果为：</p>
<pre><code>class=&quot;hljs matlab&quot;&gt;&lt;code class=&quot;matlab&quot;
</code></pre>
<p>但我们想要的是：</p>
<pre><code>class=&quot;hljs matlab&quot;

class=&quot;matlab&quot;
</code></pre>
<p>这就是正规表达式的最短匹配问题，所有用到正则表达式的地方都有处理这个问题的专用方法，很不幸的是大多不一样。</p>
<p>vim的最短匹配方法是把\+改为\{-}。</p>
<p>上面的替换这样用就正常了：</p>
<pre><code>:1,$ s/class=&quot;.\&#123;-&#125;&quot;//g
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/vim/vimregzdpp/" data-id="clhlnylgr00kiojup577z8wqm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/28/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="page-number" href="/page/28/">28</a><span class="page-number current">29</span><a class="page-number" href="/page/30/">30</a><a class="page-number" href="/page/31/">31</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/30/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/">JAVA WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/Spring-Boot/">Spring Boot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%BC%80%E5%8F%91/">WEB开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/">nosql</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/MongoDB/">MongoDB</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E9%9B%86/">字符集</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/">spark</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/Emacs/">Emacs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/GIT/">GIT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/SSO/">SSO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%B8%80%E8%87%B4%E6%80%A7/">一致性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%AF%86%E7%A0%81%E6%9C%AF/">密码术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/JMS/">JMS</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6/">组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%AE%97%E6%B3%95/">树算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/BASE/">BASE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/JAVA8/">JAVA8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/NIO/">NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/">Lisp</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/Common-Lisp/">Common Lisp</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Scala/">Scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ASCII%E7%A0%81/" rel="tag">ASCII码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActiveMQ/" rel="tag">ActiveMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ajax/" rel="tag">Ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BAT%E8%84%9A%E6%9C%AC/" rel="tag">BAT脚本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAP/" rel="tag">CAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS/" rel="tag">CAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Common-Lisp/" rel="tag">Common Lisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Emacs/" rel="tag">Emacs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Emmet/" rel="tag">Emmet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GIT/" rel="tag">GIT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HttpClient/" rel="tag">HttpClient</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPFS/" rel="tag">IPFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-IO/" rel="tag">JAVA IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-NIO/" rel="tag">JAVA NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-WEB/" rel="tag">JAVA WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA8/" rel="tag">JAVA8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/" rel="tag">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lisp/" rel="tag">Lisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/" rel="tag">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shiro/" rel="tag">Shiro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/" rel="tag">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/" rel="tag">UML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB%E5%BC%80%E5%8F%91/" rel="tag">WEB开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/" rel="tag">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/archtype/" rel="tag">archtype</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/azkaban/" rel="tag">azkaban</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/" rel="tag">hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jquery/" rel="tag">jquery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql/" rel="tag">nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql-neo4j/" rel="tag">nosql neo4j</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openssl/" rel="tag">openssl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/" rel="tag">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webservice/" rel="tag">webservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag">一致性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" rel="tag">任务调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/" rel="tag">字符集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%A1%E8%AE%A1/" rel="tag">审计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E6%9C%AF/" rel="tag">密码术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%BE%E9%80%92%E5%BD%92/" rel="tag">尾递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/" rel="tag">摘要算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" rel="tag">数字签名</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/" rel="tag">数字证书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/" rel="tag">数据权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E7%AE%97%E6%B3%95/" rel="tag">树算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正规表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" rel="tag">知识体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A5%9E%E5%99%A8/" rel="tag">神器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">自制操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" rel="tag">负载均衡</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10.5px;">AOP</a> <a href="/tags/ASCII%E7%A0%81/" style="font-size: 10px;">ASCII码</a> <a href="/tags/ActiveMQ/" style="font-size: 11px;">ActiveMQ</a> <a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/BAT%E8%84%9A%E6%9C%AC/" style="font-size: 10px;">BAT脚本</a> <a href="/tags/CAP/" style="font-size: 10px;">CAP</a> <a href="/tags/CAS/" style="font-size: 10.5px;">CAS</a> <a href="/tags/Common-Lisp/" style="font-size: 13.5px;">Common Lisp</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10.5px;">C语言</a> <a href="/tags/Eclipse/" style="font-size: 11px;">Eclipse</a> <a href="/tags/Emacs/" style="font-size: 16.5px;">Emacs</a> <a href="/tags/Emmet/" style="font-size: 10px;">Emmet</a> <a href="/tags/GIT/" style="font-size: 10px;">GIT</a> <a href="/tags/HttpClient/" style="font-size: 12.5px;">HttpClient</a> <a href="/tags/IPFS/" style="font-size: 10px;">IPFS</a> <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/JAVA-IO/" style="font-size: 15.5px;">JAVA IO</a> <a href="/tags/JAVA-NIO/" style="font-size: 17px;">JAVA NIO</a> <a href="/tags/JAVA-WEB/" style="font-size: 10.5px;">JAVA WEB</a> <a href="/tags/JAVA8/" style="font-size: 13.5px;">JAVA8</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Lisp/" style="font-size: 12px;">Lisp</a> <a href="/tags/Markdown/" style="font-size: 10.5px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 18px;">MongoDB</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/Scala/" style="font-size: 11px;">Scala</a> <a href="/tags/Shiro/" style="font-size: 10px;">Shiro</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/VIM/" style="font-size: 16px;">VIM</a> <a href="/tags/WEB%E5%BC%80%E5%8F%91/" style="font-size: 11px;">WEB开发</a> <a href="/tags/XML/" style="font-size: 10.5px;">XML</a> <a href="/tags/archtype/" style="font-size: 10px;">archtype</a> <a href="/tags/azkaban/" style="font-size: 10.5px;">azkaban</a> <a href="/tags/hadoop/" style="font-size: 13px;">hadoop</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/hive/" style="font-size: 10px;">hive</a> <a href="/tags/javascript/" style="font-size: 14px;">javascript</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/linux/" style="font-size: 13px;">linux</a> <a href="/tags/maven/" style="font-size: 12px;">maven</a> <a href="/tags/nosql/" style="font-size: 18.5px;">nosql</a> <a href="/tags/nosql-neo4j/" style="font-size: 11.5px;">nosql neo4j</a> <a href="/tags/openssl/" style="font-size: 11px;">openssl</a> <a href="/tags/servlet/" style="font-size: 11px;">servlet</a> <a href="/tags/spark/" style="font-size: 12px;">spark</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/webservice/" style="font-size: 11px;">webservice</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 11.5px;">一致性</a> <a href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" style="font-size: 10.5px;">任务调度</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 10px;">区块链</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 17.5px;">大数据</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/" style="font-size: 12.5px;">字符集</a> <a href="/tags/%E5%AE%A1%E8%AE%A1/" style="font-size: 10px;">审计</a> <a href="/tags/%E5%AF%86%E7%A0%81%E6%9C%AF/" style="font-size: 14.5px;">密码术</a> <a href="/tags/%E5%B0%BE%E9%80%92%E5%BD%92/" style="font-size: 10px;">尾递归</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 12px;">并发</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 14px;">排序</a> <a href="/tags/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/" style="font-size: 10px;">摘要算法</a> <a href="/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" style="font-size: 10.5px;">数字签名</a> <a href="/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/" style="font-size: 10px;">数字证书</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 18.5px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/" style="font-size: 10px;">数据权限</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 11.5px;">杂谈</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 13.5px;">架构</a> <a href="/tags/%E6%A0%91%E7%AE%97%E6%B3%95/" style="font-size: 14px;">树算法</a> <a href="/tags/%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正规表达式</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" style="font-size: 12px;">知识体系</a> <a href="/tags/%E7%A5%9E%E5%99%A8/" style="font-size: 12px;">神器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.5px;">算法</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" style="font-size: 19px;">线程安全</a> <a href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">自制操作系统</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.5px;">设计模式</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 13px;">负载均衡</a> <a href="/tags/%E9%94%81/" style="font-size: 11px;">锁</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2999/12/">十二月 2999</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/02/">二月 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/09/">九月 2009</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/explain/">【置顶】特别说明</a>
          </li>
        
          <li>
            <a href="/blog/tools/maven/dn-cst-maven-archtype/">开发一个maven脚手架</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustrystock/">neo4j创建行业与股票关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustry/">neo4j创建三级行业关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jtimeline/">neo4j创建时间线</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 证心<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>