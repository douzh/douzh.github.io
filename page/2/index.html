<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>OneKBase</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="OneKBase">
<meta property="og:url" content="http://www.onekbase.com/page/2/index.html">
<meta property="og:site_name" content="OneKBase">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="证心">
<meta name="twitter:card" content="summary">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">OneKBase</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">归一</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" target="_blank" rel="noopener" href="http://site.onekbase.com">ITEEDU</a>
        
          <a class="main-nav-link" href="/about/">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.onekbase.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-blog/arch/component/dataauth" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/arch/component/dataauth/" class="article-date">
  <time class="dt-published" datetime="2019-05-19T03:31:25.000Z" itemprop="datePublished">2019-05-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>►<a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6/">组件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/arch/component/dataauth/">【权限】如何用AOP实现数据权限功能</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>针对不同用户，在数据查询时要在SQL上拼上可以访问的部门机构部分。</p>
<p>这部分数据查询权限一般都是按一定配制或规则制定的。</p>
<p>这里看到一种比较好的方法可以实现数据权限。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>其中tableAlias为SQL中表的别名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@DataAuth(tableAlias = &quot;s&quot;)</span><br><span class="line">public Result list(@RequestParam Map&lt;String, Object&gt; params)&#123;</span><br><span class="line">	//查询列表数据</span><br><span class="line">       Query query = new Query(params);</span><br><span class="line"></span><br><span class="line">	List&lt;UserEntity&gt; userList = userService.queryList(query);</span><br><span class="line">	int total = userService.queryTotal(query);</span><br><span class="line">	</span><br><span class="line">	PageUtils pageUtil = new PageUtils(userList, total, query.getLimit(), query.getPage());</span><br><span class="line">	</span><br><span class="line">	return Result.ok().put(&quot;page&quot;, pageUtil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键的AOP方法"><a href="#关键的AOP方法" class="headerlink" title="关键的AOP方法"></a>关键的AOP方法</h3><p>核心思想就是查询参数是一个MAP，在MAP中加入dataAuthSql参数，dataAuthSql是通过用户配制信息生成的一个SQL片段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class DataAuthAspect &#123;</span><br><span class="line">    @Pointcut(&quot;@annotation(com.hxy.modules.common.annotation.DataAuth)&quot;)</span><br><span class="line">    public void dataAuthPointcut()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;dataAuthPointcut()&quot;)</span><br><span class="line">    public void dataAuth(JoinPoint joinPoint) throws Throwable&#123;</span><br><span class="line">        //获取方面第一个参数</span><br><span class="line">        Object params = joinPoint.getArgs()[0];</span><br><span class="line">        //如果参数为Map类型</span><br><span class="line">        if(params != null &amp;&amp; params instanceof Map)&#123;</span><br><span class="line">            String currentUserId = UserUtils.getCurrentUserId();</span><br><span class="line">            //如果当前用户不为超级管理员，则需要进行数据过滤</span><br><span class="line">            if(!currentUserId.equals(Constant.SUPERR_USER))&#123;</span><br><span class="line">                ((Map) params).put(&quot;dataAuthSql&quot;,dataAuthSql(joinPoint));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            throw new MyException(&quot;需要数据权限过滤，需要查询方法的第一个参数为Map类型，且不能为NULL&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String dataAuthSql(JoinPoint joinPoint)&#123;</span><br><span class="line">        //获取目标方法签名</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        //通过方法签名，获取数据过滤注解</span><br><span class="line">        DataAuth annotation = signature.getMethod().getAnnotation(DataAuth.class);</span><br><span class="line">        //通过注解获取别名</span><br><span class="line">        String tableAlias = annotation.tableAlias();</span><br><span class="line">        if(!StringUtils.isEmpty(tableAlias))&#123;</span><br><span class="line">            tableAlias+=&quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder dataAuthSql = new StringBuilder();</span><br><span class="line">        dataAuthSql.append(&quot; AND (&quot;);</span><br><span class="line"></span><br><span class="line">        //获取用户授权部门</span><br><span class="line">        String baids = UserUtils.getDateAuth(Constant.DataAuth.BA_DATA.getValue());</span><br><span class="line">        //获取用户授权机构</span><br><span class="line">        String bapids = UserUtils.getDateAuth(Constant.DataAuth.BAP_DATA.getValue());</span><br><span class="line">        dataAuthSql.append(tableAlias);</span><br><span class="line">        dataAuthSql.append(&quot;create_id = &quot;);</span><br><span class="line">        dataAuthSql.append(&quot;&#x27;&quot; + UserUtils.getCurrentUserId() + &quot;&#x27;&quot;);</span><br><span class="line">        if(baids != null &amp;&amp; !StringUtils.isEmpty(baids))&#123;</span><br><span class="line">            dataAuthSql.append(&quot;OR &quot;);</span><br><span class="line">            dataAuthSql.append(tableAlias);</span><br><span class="line">            dataAuthSql.append(&quot;baid IN(&quot;);</span><br><span class="line">            dataAuthSql.append(baids);</span><br><span class="line">            dataAuthSql.append(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(bapids != null &amp;&amp; !StringUtils.isEmpty(bapids))&#123;</span><br><span class="line">            dataAuthSql.append(&quot;OR &quot;);</span><br><span class="line">            dataAuthSql.append(tableAlias);</span><br><span class="line">            dataAuthSql.append(&quot;bapid IN(&quot;);</span><br><span class="line">            dataAuthSql.append(bapids);</span><br><span class="line">            dataAuthSql.append(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        dataAuthSql.append(&quot;)&quot;);</span><br><span class="line">        return dataAuthSql.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/arch/component/dataauth/" data-id="clhlnylez00a0ojup3msf9i1b" data-title="【权限】如何用AOP实现数据权限功能" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/" rel="tag">数据权限</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/arch/component/aopaudit" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/arch/component/aopaudit/" class="article-date">
  <time class="dt-published" datetime="2019-05-19T03:08:18.000Z" itemprop="datePublished">2019-05-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>►<a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6/">组件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/arch/component/aopaudit/">【组件】如何用AOP实现功能审计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>审计一般要记录用户访问了哪个功能，参数是什么，用于找出用户干了什么事。</p>
<p>今天看了一个比较好的方法，用JAVA注解和AOP实现审计功能。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>在要审计的方法上加上JAVA注解SysLog</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SysLog(&quot;新增系统用户&quot;)</span><br><span class="line">public Result save(@RequestBody UserEntity user)&#123;</span><br><span class="line">	userService.save(user);</span><br><span class="line">	return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解SysLog"><a href="#注解SysLog" class="headerlink" title="注解SysLog"></a>注解SysLog</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SysLog &#123;</span><br><span class="line"></span><br><span class="line">	String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键的AOP实现"><a href="#关键的AOP实现" class="headerlink" title="关键的AOP实现"></a>关键的AOP实现</h3><p>把切入各项要记录的信息收集到，插入数据库，为了效率也可以异步放入MQ慢慢处理，都可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class SysLogAspect &#123;</span><br><span class="line">	@Autowired</span><br><span class="line">	private SysLogService sysLogService;</span><br><span class="line">	</span><br><span class="line">	@Pointcut(&quot;@annotation(com.xxxxxx.SysLog)&quot;)</span><br><span class="line">	public void logPointCut() &#123; </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Before(&quot;logPointCut()&quot;)</span><br><span class="line">	public void saveSysLog(JoinPoint joinPoint) &#123;</span><br><span class="line">		MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">		Method method = signature.getMethod();</span><br><span class="line">		</span><br><span class="line">		SysLogEntity sysLog = new SysLogEntity();</span><br><span class="line">		SysLog syslog = method.getAnnotation(SysLog.class);</span><br><span class="line">		if(syslog != null)&#123;</span><br><span class="line">			//注解上的描述 </span><br><span class="line">			sysLog.setOperation(syslog.value());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//请求的方法名</span><br><span class="line">		String className = joinPoint.getTarget().getClass().getName();</span><br><span class="line">		String methodName = signature.getName();</span><br><span class="line">		sysLog.setMethod(className + &quot;.&quot; + methodName + &quot;()&quot;);</span><br><span class="line">		</span><br><span class="line">		//请求的参数</span><br><span class="line">		Object[] args = joinPoint.getArgs();</span><br><span class="line">		if(args.length&gt;0)&#123;</span><br><span class="line">			String params = JSON.toJSONString(args[0]);</span><br><span class="line">			sysLog.setParams(params);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//获取request</span><br><span class="line">		HttpServletRequest request = HttpContextUtils.getHttpServletRequest();</span><br><span class="line">		//设置IP地址</span><br><span class="line">		sysLog.setIp(IPUtils.getIpAddr(request));</span><br><span class="line">		</span><br><span class="line">		//用户名</span><br><span class="line">		String username = ShiroUtils.getUserEntity().getUserName();</span><br><span class="line"></span><br><span class="line">		sysLog.setUsername(username);</span><br><span class="line">		</span><br><span class="line">		sysLog.setCreateDate(new Date());</span><br><span class="line">		//保存系统日志</span><br><span class="line">		sysLogService.save(sysLog);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/arch/component/aopaudit/" data-id="clhlnyley009xojupbzykbqac" data-title="【组件】如何用AOP实现功能审计" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%A1%E8%AE%A1/" rel="tag">审计</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/arch/cap/atomicrefer" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/arch/cap/atomicrefer/" class="article-date">
  <time class="dt-published" datetime="2019-03-26T03:14:36.000Z" itemprop="datePublished">2019-03-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>►<a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%B8%80%E8%87%B4%E6%80%A7/">一致性</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/arch/cap/atomicrefer/">【CAP】JAVA之AtomicReference非锁同步</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>并发最简单的竞态问题是操作一个基本变量，如一个整数。</p>
<p>复杂问题是同时操作多个变量，要保证变量的结果一致，比如A加1那B就要减1。</p>
<p>简单问题和复杂问题都可以通过锁来实现。</p>
<p>用锁划出临界区（一段代码），这段代码通过锁保证不能被并行执行。</p>
<p>代码就是对竞态数据的逻辑操作，并且只能通过这段代码操作竞态数据。</p>
<p>CAS提供了另一种解决竞态问题的方案。</p>
<h2 id="AtomicReference解决竞态问题"><a href="#AtomicReference解决竞态问题" class="headerlink" title="AtomicReference解决竞态问题"></a>AtomicReference解决竞态问题</h2><p>比如A加1那B就要减1的问题，可以把A和B做成一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference&lt;AB&gt; data = new AtomicReference&lt;AB&gt;();</span><br></pre></td></tr></table></figure>

<p>每个线程复制一份data,操作完后通过compareAndSet设置到公共变量。</p>
<p>可以参考AtomicInteger加1的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以封装个AtomicAB类来完成这件事，复制data到ThreadLocal中，修改完后再写加公共data对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/arch/cap/atomicrefer/" data-id="clhlnylei006pojupgsca1sg0" data-title="【CAP】JAVA之AtomicReference非锁同步" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CAS/" rel="tag">CAS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag">一致性</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/arch/cap/cas" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/arch/cap/cas/" class="article-date">
  <time class="dt-published" datetime="2019-03-26T02:52:23.000Z" itemprop="datePublished">2019-03-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>►<a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%B8%80%E8%87%B4%E6%80%A7/">一致性</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/arch/cap/cas/">【CAP】CAS和自旋锁</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>自旋锁可以看成是不断自动重试的乐观锁，也会有乐观锁的ABA问题。</p>
<p>自旋锁的实现基础是CAS功能。</p>
<h2 id="什么是自旋锁？"><a href="#什么是自旋锁？" class="headerlink" title="什么是自旋锁？"></a>什么是自旋锁？</h2><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p>
<p>获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。</p>
<p>它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。</p>
<p>两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p>
<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。</p>
<p>这里以AtomicInteger说明一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加1就是先获取当前值，加1，设置时先对比当前值是不是内存中的值，如果是设置新值。</p>
<p>内存对比是通过本地方法实现的，需要操作系统的支持。</p>
<p>如果成功就可以退出循环，否则一直尝试。</p>
<h2 id="用AtomicReference实现自旋锁"><a href="#用AtomicReference实现自旋锁" class="headerlink" title="用AtomicReference实现自旋锁"></a>用AtomicReference实现自旋锁</h2><p>自旋锁就是线程调用lock()后，其他线程再调用lock()会卡住，等待锁的释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SpinLock &#123;</span><br><span class="line">    private AtomicReference&lt;Thread&gt; lock = new AtomicReference&lt;Thread&gt;();</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        // 利用CAS</span><br><span class="line">        while (!lock.compareAndSet(null, current)) &#123;</span><br><span class="line">            // DO nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        lock.compareAndSet(current, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，第一个线程调用lock()时lock没有set过值，对象是null，第二个线程在调用时已经set过值，所以会一直循环。</p>
<p>只有当第一个线程unlock()之后第二个循环才能结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/arch/cap/cas/" data-id="clhlnylei006wojup04wf7p1n" data-title="【CAP】CAS和自旋锁" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CAS/" rel="tag">CAS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag">一致性</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/arch/cap/allplan" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/arch/cap/allplan/" class="article-date">
  <time class="dt-published" datetime="2019-03-25T08:50:36.000Z" itemprop="datePublished">2019-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>►<a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%B8%80%E8%87%B4%E6%80%A7/">一致性</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/arch/cap/allplan/">【CAP】(转)分布式事务最佳实践方案汇总</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>说到分布式事务，就会谈到那个经典的”账号转账”问题：2个账号，分布处于2个不同的DB，对应2个不同的系统A,B。A要扣钱，B要加钱，如何保证原子性？</p>
<h2 id="传统方案-–-2PC"><a href="#传统方案-–-2PC" class="headerlink" title="传统方案 – 2PC"></a>传统方案 – 2PC</h2><p>（1）2PC的理论层面：</p>
<p>2pc涉及到2个阶段，3个操作：</p>
<p>阶段1：“准备提交”。事务协调者向所有参与者发起prepare，所有参与者回答yes&#x2F;no。</p>
<p>阶段2：“正式提交”。如果所有参与者都回答yes，则向所有参与者发起commit；否则，向所有参与者发起rollback。</p>
<p>因此，要实现2pc，所有参与者，都得实现3个接口：prepare&#x2F;commit&#x2F;rollback。</p>
<p>（2）2PC的实现层面</p>
<p>对应的实现层面，也就是XA协议，通常的数据库都实现了这个协议。</p>
<p>有一个Atomikos开源库，提供了2PC的实现方案。有兴趣的可以去看一下如何使用。</p>
<p>（3）2PC的问题</p>
<p>问题1：阶段2，事务协调者挂了，则所有参与者接受不到commit&#x2F;rollback指令，将处于“悬而不决”状态</p>
<p>问题2：阶段2，其中一个参与者超时或者出错，那其他参与者，是commit，还是rollback呢？ 也不能确定</p>
<p>为了解决2pc的问题，又引入3pc。3pc有类似的挂了如何解决的问题，因此还是没能彻底解决问题，此处就不详述了。</p>
<p>问题3：2PC的实现，目前主要是用在数据库层面（数据库实现了XA协议）。但目前，大家基本都是微服务架构，不会直接在2个业务DB之间搞一致性，而是想如何在2个服务上面实现一致性。</p>
<p>正因为2PC有上面诸多问题和不便，实践中一般很少使用，而是采用下面将要讲的各种方案。</p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>一般的思路都是通过消息中间件来实现“最终一致性”：A系统扣钱，然后发条消息给中间件，B系统接收此消息，进行加钱。</p>
<p>但这里面有个问题：A是先update DB，后发送消息呢？ 还是先发送消息，后update DB？</p>
<p>假设先update DB成功，发送消息网络失败，重发又失败，怎么办？</p>
<p>假设先发送消息成功，update DB失败。消息已经发出去了，又不能撤回，怎么办？</p>
<p>所以，这里下个结论： 只要发送消息和update DB这2个操作不是原子的，无论谁先谁后，都是有问题的。</p>
<p>那这个问题怎么解决呢？？</p>
<h2 id="错误的方案"><a href="#错误的方案" class="headerlink" title="错误的方案"></a>错误的方案</h2><p>有人可能想到了，我可以把“发送消息”这个网络调用和update DB放在同1个事务里面，如果发送消息失败，update DB自动回滚。这样不就保证2个操作的原子性了吗？</p>
<p>这个方案看似正确，其实是错误的，原因有2：</p>
<p>（1）网络的2将军问题：发送消息失败，发送方并不知道是消息中间件真的没有收到消息呢？还是消息已经收到了，只是返回response的时候失败了？</p>
<p>如果是已经收到消息了，而发送端认为没有收到，执行update db的回滚操作。则会导致A账号的钱没有扣，B账号的钱却加了。</p>
<p>（2）把网络调用放在DB事务里面，可能会因为网络的延时，导致DB长事务。严重的，会block整个DB。这个风险很大。</p>
<p>基于以上分析，我们知道，这个方案其实是错误的！</p>
<h2 id="方案1-–-最终一致性（业务方自己实现）"><a href="#方案1-–-最终一致性（业务方自己实现）" class="headerlink" title="方案1 – 最终一致性（业务方自己实现）"></a>方案1 – 最终一致性（业务方自己实现）</h2><p>假设消息中间件没有提供“事务消息”功能，比如你用的是Kafka。那如何解决这个问题呢？</p>
<p>解决方案如下：</p>
<p>（1）Producer端准备1张消息表，把update DB和insert message这2个操作，放在一个DB事务里面。</p>
<p>（2）准备一个后台程序，源源不断的把消息表中的message传送给消息中间件。失败了，不断重试重传。允许消息重复，但消息不会丢，顺序也不会打乱。</p>
<p>（3）Consumer端准备一个判重表。处理过的消息，记在判重表里面。实现业务的幂等。但这里又涉及一个原子性问题：如何保证消息消费 + insert message到判重表这2个操作的原子性？</p>
<p>消费成功，但insert判重表失败，怎么办？关于这个，在Kafka的源码分析系列，第1篇， exactly once问题的时候，有过讨论。</p>
<p>通过上面3步，我们基本就解决了这里update db和发送网络消息这2个操作的原子性问题。</p>
<p>但这个方案的一个缺点就是：需要设计DB消息表，同时还需要一个后台任务，不断扫描本地消息。导致消息的处理和业务逻辑耦合额外增加业务方的负担。</p>
<h2 id="方案2-–-最终一致性（RocketMQ-事务消息）"><a href="#方案2-–-最终一致性（RocketMQ-事务消息）" class="headerlink" title="方案2  – 最终一致性（RocketMQ 事务消息）"></a>方案2  – 最终一致性（RocketMQ 事务消息）</h2><p>为了能解决该问题，同时又不和业务耦合，RocketMQ提出了“事务消息”的概念。</p>
<p>具体来说，就是把消息的发送分成了2个阶段：Prepare阶段和确认阶段。</p>
<p>具体来说，上面的2个步骤，被分解成3个步骤：</p>
<p>(1) 发送Prepared消息</p>
<p>(2) update DB</p>
<p>(3) 根据update DB结果成功或失败，Confirm或者取消Prepared消息。</p>
<p>可能有人会问了，前2步执行成功了，最后1步失败了怎么办？这里就涉及到了RocketMQ的关键点：RocketMQ会定期（默认是1分钟）扫描所有的Prepared消息，询问发送方，到底是要确认这条消息发出去？还是取消此条消息？</p>
<p>总结：对比方案2和方案1，RocketMQ最大的改变，其实就是把“扫描消息表”这个事情，不让业务方做，而是消息中间件帮着做了。</p>
<p>至于消息表，其实还是没有省掉。因为消息中间件要询问发送方，事物是否执行成功，还是需要一个“变相的本地消息表”，记录事物执行状态。</p>
<h2 id="人工介入"><a href="#人工介入" class="headerlink" title="人工介入"></a>人工介入</h2><p>可能有人又要说了，无论方案1，还是方案2，发送端把消息成功放入了队列，但消费端消费失败怎么办？</p>
<p>消费失败了，重试，还一直失败怎么办？是不是要自动回滚整个流程？</p>
<p>答案是人工介入。从工程实践角度讲，这种整个流程自动回滚的代价是非常巨大的，不但实现复杂，还会引入新的问题。比如自动回滚失败，又怎么处理？</p>
<p>对应这种极低概率的case，采取人工处理，会比实现一个高复杂的自动化回滚系统，更加可靠，也更加简单。</p>
<h2 id="方案3：TCC"><a href="#方案3：TCC" class="headerlink" title="方案3：TCC"></a>方案3：TCC</h2><p>为了解决SOA系统中的分布式事务问题，支付宝提出了TCC。2PC通常都是在跨库的DB层面，而TCC本质就是一个应用层面的2PC。</p>
<p>同样，TCC中，每个参与者需要3个操作：Try&#x2F;Confirm&#x2F;Cancel，也是2个阶段。 </p>
<p>阶段1：”资源预留&#x2F;资源检查“，也就是事务协调者调用所有参与者的Try操作 </p>
<p>阶段2：“一起提交”。如果所有的Try成功，一起执行Confirm。否则，所有的执行Cancel.</p>
<p>TCC是如何解决2PC的问题呢？</p>
<p>关键：Try阶段成功之后，Confirm如果失败(不管是协调者挂了，还是某个参与者超时），不断重试！！</p>
<p>同样，Cancel失败了，也是不断重试。这就要求Confirm&#x2F;Cancel都必须是幂等操作。</p>
<p>下面以1个转账case为例，来说明TCC的过程： </p>
<p>有3个账号A, B, C，通过SOA提供的转账服务操作。A, B同时分别要向C转30, 50元，最后C的账号+80，A, B各减30, 50。</p>
<p>阶段1：A账号锁定30，B账号锁定50，检查C账号的合法性（比如C账号是否违法被冻结，C账号是否已注销。。。）。</p>
<p>所以，对应的“扣钱”的Try操作就是”锁定”，对应的“加钱”的Try操作就是检查账号合法性</p>
<p>阶段2：A, B, C都Try成功，执行Confirm。即A, B减钱，C加钱。如果任意一个失败，不断重试！</p>
<p>从上面的案例可以看出，Try操作主要是为了“保证业务操作的前置条件都得到满足”，然后在Confirm阶段，因为前置条件都满足了，所以可以不断重试保证成功。</p>
<h2 id="方案4：事务状态表-调用方重试-接收方幂等-（同步-异步）"><a href="#方案4：事务状态表-调用方重试-接收方幂等-（同步-异步）" class="headerlink" title="方案4：事务状态表 + 调用方重试 + 接收方幂等 （同步 + 异步）"></a>方案4：事务状态表 + 调用方重试 + 接收方幂等 （同步 + 异步）</h2><p>同样以上面的转账为例：调用方调系统A扣钱，系统B加钱，如何保证2个同时成功？</p>
<p>调用方维护1张事务状态表（或者说事务日志，日志流水），每次调用之前，落盘1条事务流水，生成1个全局的事务ID。</p>
<p>初始状态是Init，每调用成功1个系统更新1次状态（这里就2个系统），最后所有系统调用成功，状态更新为Success。</p>
<p>当然，你也可以不保存中间状态，简单一点，你也可以只设置2个状态：Init&#x2F;Success，或者说begin&#x2F;end。</p>
<p>然后有个后台任务，发现某条流水，在过了某个时间之后(假设1次事务执行成功通常最多花费30s)，状态仍然是Init，那就说明这条流水有问题。就重新调用系统A，系统B，保证这条流水的最终状态是Success。当然，系统A, 系统B根据这个全局的事务ID，做幂等，所以重复调用也没关系。</p>
<p>这就是通过同步调用 + 后台任务异步补偿，最终保证系统一致性。</p>
<p>补充说明：</p>
<p>（1）如果后台任务重试多次，仍然不能成功，那要为状态表加1个Error状态，要人工介入干预了。</p>
<p>（2）对于调用方的同步调用，如果部分成功，此时给客户端返回什么呢？</p>
<p>答案是不确定，或者说暂时未知。你只能告诉用户，该笔转账超时，稍后再来确认。</p>
<p>（3）对于同步调用，调用方调用A，或者B失败的时候，可以重试3次。重试3次还不成功，放弃操作。再交由后台任务后续处理。</p>
<h2 id="方案4的扩展：状态机-对账"><a href="#方案4的扩展：状态机-对账" class="headerlink" title="方案4的扩展：状态机 + 对账"></a>方案4的扩展：状态机 + 对账</h2><p>把方案4扩展一下，岂止事务有状态，系统中的各种数据对象都有状态，或者说都有各自完整的生命周期。</p>
<p>这种完整的生命周期，天生就具有校验功能！！！我们可以很好的利用这个特性，来实行系统的一致性。</p>
<p>一旦我们发现系统中的某个数据对象，过了一个限定时间，生命周期仍然没有走完，仍然处在某个中间状态，那就说明系统不一致了，可以执行某种操作。</p>
<p>举个电商系统的订单的例子：一张订单，从“已支付”，到“下发给仓库”，到“出仓完成”。假定从“已支付”到“下发给仓库”，最多用1个小时；从“下发给仓库”到“出仓完成”，最多用8个小时。</p>
<p>那意味着：只要我发现1个订单的状态，过了1个小时之后，还是“已支付”，我就认为订单下发没有成功，我就重新下发，也就是上面所说的“重试”；</p>
<p>同样，只要我发现订单过了8个小时，还未出仓，我这个时候可能就会发报警出来，是不是仓库的作业系统出了问题。。。诸如此类。</p>
<p>更复杂一点：订单有状态，库存系统的库存也有状态，优惠系统的优惠券也有状态，根据业务规则，这些状态之间进行比对，就能发现系统某个地方不一致，做相应的补偿行为。</p>
<p>上面说的“最终一致性”和TCC、状态机+对账，都是比较“完美”的方案，能完全保证数据的一致性。</p>
<p>但是呢，最终一致性这个方案是异步的；</p>
<p>TCC需要2个阶段，性能损耗大；</p>
<p>事务状态表，或者状态机，每次要记事务流水，要更新状态，性能也有损耗。</p>
<p>如果我需要1个同步的方案，可以立马得到结果，同时又要有很高的性能，支持高并发，那怎么处理呢？</p>
<h2 id="方案5：妥协方案-–-弱一致性-基于状态的补偿"><a href="#方案5：妥协方案-–-弱一致性-基于状态的补偿" class="headerlink" title="方案5：妥协方案 – 弱一致性 + 基于状态的补偿"></a>方案5：妥协方案 – 弱一致性 + 基于状态的补偿</h2><p>举个典型场景：</p>
<p>电商网站的下单，扣库存。订单系统有订单的DB，订单的服务；库存系统有库存的DB，库存的服务。 如何保证下单 + 扣库存，2个的原子性呢？</p>
<p>如果用上面的最终一致性方案，因为是异步的，库存扣减不及时，会导致超卖，因此最终一致性的方案不可行；</p>
<p>如果用TCC的方案，性能可能又达不到。</p>
<p>这里，就采用了一种弱一致的方案，什么意思呢？</p>
<p>对于该需求，有1个关键特性：对于电商的购物来讲，允许少卖，但不能超卖。你有100件东西，卖给99个人，有1件没有卖出去，这个可以接受；但是卖给了101个人，其中1个人拿不到货，平台违约，这个就不能接受。</p>
<p>而该处就利用了这个特性，具体是这么做的：</p>
<p>先扣库存，再提交订单。</p>
<p>（1）扣库存失败，不提交订单了，直接返回失败，调用方重试（此处可能会多扣库存）</p>
<p>（2）扣库存成功，提交订单失败，返回失败，调用方重试（此处可能会多扣库存）</p>
<p>（3）扣库存成功，提交订单成功，返回成功。</p>
<p>反过来，你先提交订单，后扣库存，也是按照类似的这个思路。</p>
<p>最终，只要保证1点：库存可以多扣，不能少扣！！！</p>
<p>但是，库存多扣了，这个数据不一致，怎么补偿呢？</p>
<p>库存每扣1次，都会生成1条流水记录。这条记录的初始状态是“占用”，等订单支付成功之后，会把状态改成“释放”。</p>
<p>对于那些过了很长时间，一直是占用，而不释放的库存。要么是因为前面多扣造成的，要么是因为用户下了单，但不支付。</p>
<p>通过比对，库存系统的“占用又没有释放的库存流水“与订单系统的未支付的订单，我们就可以回收掉这些库存，同时把对应的订单取消掉。（就类似12306网站一样，过多长时间，你不支付，订单就取消了，库存释放）</p>
<h2 id="方案6：-妥协方案-–-重试-回滚-监控报警-人工修复"><a href="#方案6：-妥协方案-–-重试-回滚-监控报警-人工修复" class="headerlink" title="方案6： 妥协方案 – 重试 + 回滚 + 监控报警 + 人工修复"></a>方案6： 妥协方案 – 重试 + 回滚 + 监控报警 + 人工修复</h2><p>对于方案5，我们是基于订单的状态 + 库存流水的状态，做补偿（或者说叫对账）。</p>
<p>如果业务很复杂，状态的维护也很复杂。方案5呢，就是1种更加妥协而简单的办法。</p>
<p>提交订单不是失败了嘛！</p>
<p>先重试！</p>
<p>重试还不成功，回滚库存的扣减！</p>
<p>回滚也失败，发报警出来，人工干预修复！</p>
<p>总之，根据业务逻辑，通过重试3次，或者回滚的办法，尽最大限度，保证一致。实在不一致，就发报警，让人工干预。只要日志流水记录的完整，人工肯定可以修复！ （通常只要业务逻辑本身没问题，重试、回滚之后，还失败的概率会比较低，所以这种办法虽然丑陋，但蛮实用）</p>
<p>后话</p>
<p>其他的，诸如状态机驱动、1PC之类的办法，只是说法不一，个人认为本质上都是方案4&#x2F;方案5的做法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在上文中，总结了实践中比较靠谱的6种方法：2种最终一致性的方案，2种妥协办法，2种基于状态 + 重试的方法（TCC，状态机 + 重试 + 幂等）。</p>
<p>实现层面，妥协的办法肯定最容易，TCC最复杂。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/arch/cap/allplan/" data-id="clhlnyleh006kojupg4idbo8f" data-title="【CAP】(转)分布式事务最佳实践方案汇总" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CAP/" rel="tag">CAP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag">一致性</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/arch/cap/dblock" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/arch/cap/dblock/" class="article-date">
  <time class="dt-published" datetime="2019-03-25T08:30:02.000Z" itemprop="datePublished">2019-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>►<a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%B8%80%E8%87%B4%E6%80%A7/">一致性</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/arch/cap/dblock/">【CAP】数据库的竞态问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>有并发就有竞态，就有锁的问题。</p>
<p>最基本的是数据库的竞态问题。</p>
<h2 id="一、脏读、不可重复读、幻读"><a href="#一、脏读、不可重复读、幻读" class="headerlink" title="一、脏读、不可重复读、幻读"></a>一、脏读、不可重复读、幻读</h2><p>1、脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
<p>例如：</p>
<p>张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。</p>
<p>与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。</p>
<p>随后，事务A发生异常，而回滚了事务。张三的工资又回滚为5000。</p>
<p>最后，事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。</p>
<p>2、不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p>
<p>例如：</p>
<p>在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。</p>
<p>与此同时，事务B把张三的工资改为8000，并提交了事务。</p>
<p>随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。</p>
<p>3、幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p>
<p>例如：</p>
<p>目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。</p>
<p>此时，事务B插入一条工资也为5000的记录。</p>
<p>这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。</p>
<p>4、提醒</p>
<p>不可重复读的重点是修改：</p>
<p>同样的条件，你读取过的数据，再次读取出来发现值不一样了</p>
<p>幻读的重点在于新增或者删除：</p>
<p>同样的条件，第 1 次和第 2 次读出来的记录数不一样</p>
<h2 id="二、独占锁、共享锁、更新锁，乐观锁、悲观锁"><a href="#二、独占锁、共享锁、更新锁，乐观锁、悲观锁" class="headerlink" title="二、独占锁、共享锁、更新锁，乐观锁、悲观锁"></a>二、独占锁、共享锁、更新锁，乐观锁、悲观锁</h2><p>1、锁的两种分类方式</p>
<p>###（1）从数据库系统的角度来看，锁分为以下三种类型：</p>
<p> 独占锁（Exclusive Lock）</p>
<p>独占锁锁定的资源只允许进行锁定操作的程序使用，其它任何对它的操作均不会被接受。执行数据更新命令，即INSERT、 UPDATE 或DELETE 命令时，数据库会自动使用独占锁。但当对象上有其它锁存在时，无法对其加独占锁。独占锁一直到事务结束才能被释放。</p>
<p>共享锁（Shared Lock）</p>
<p>共享锁锁定的资源可以被其它用户读取，但其它用户不能修改它。在SELECT 命令执行时，数据库通常会对对象进行共享锁锁定。通常加共享锁的数据页被读取完毕后，共享锁就会立即被释放。</p>
<p>更新锁（Update Lock）</p>
<p>更新锁是为了防止死锁而设立的。当数据库准备更新数据时，它首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到数据库确定要进行更新数据操作时，它会自动将更新锁换为独占锁。但当对象上有其它锁存在时，无法对其作更新锁锁定。</p>
<p>###（2）从程序员的角度看，锁分为以下两种类型：</p>
<p>悲观锁（Pessimistic Lock）</p>
<p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p>乐观锁（Optimistic Lock）</p>
<p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>
<p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<h2 id="三、事务五种隔离级别"><a href="#三、事务五种隔离级别" class="headerlink" title="三、事务五种隔离级别"></a>三、事务五种隔离级别</h2><p>在竞态数据对不同事务的可见性。</p>
<p>Isolation 属性一共支持五种事务设置，具体介绍如下：</p>
<p>（1）DEFAULT</p>
<p>使用数据库设置的隔离级别（默认），由DBA 默认的设置来决定隔离级别。</p>
<p>（2）READ_UNCOMMITTED</p>
<p>这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。</p>
<p>会出现脏读、不可重复读、幻读 （隔离级别最低，并发性能高）。</p>
<p>（3）READ_COMMITTED</p>
<p>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。</p>
<p>可以避免脏读，但会出现不可重复读、幻读问题（锁定正在读取的行）。</p>
<p>（4）REPEATABLE_READ</p>
<p>可以防止脏读、不可重复读，但会出幻读（锁定所读取的所有行）。</p>
<p>（5）SERIALIZABLE</p>
<p>这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。</p>
<p>保证所有的情况不会发生（锁表）。</p>
<h3 id="MYSQL悲观锁的使用"><a href="#MYSQL悲观锁的使用" class="headerlink" title="MYSQL悲观锁的使用"></a>MYSQL悲观锁的使用</h3><p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0;　　</span><br><span class="line">//设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</span><br><span class="line">//0.开始事务</span><br><span class="line">begin;/begin work;/start transaction; (三者选一就可以)</span><br><span class="line">//1.查询出商品信息</span><br><span class="line">select status from t_goods where id=1 for update;</span><br><span class="line">//2.根据商品信息生成订单</span><br><span class="line">insert into t_orders (id,goods_id) values (null,1);</span><br><span class="line">//3.修改商品status为2</span><br><span class="line">update t_goods set status=2;</span><br><span class="line">//4.提交事务</span><br><span class="line">commit;/commit work;</span><br></pre></td></tr></table></figure>

<p>上面的第一步我们执行了一次查询操作：select status from t_goods where id&#x3D;1 for update;与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p>
<p>使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，所以只有「明确」地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/arch/cap/dblock/" data-id="clhlnylej006zojupdodve5ts" data-title="【CAP】数据库的竞态问题" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag">一致性</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/arch/cap/cpuio" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/arch/cap/cpuio/" class="article-date">
  <time class="dt-published" datetime="2019-03-25T08:04:17.000Z" itemprop="datePublished">2019-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/arch/cap/cpuio/">【CAP】CPU密集型与IO密集型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>如何控制并发量，区分任务类型是第一因素。</p>
<p>###CPU密集型（CPU-bound）</p>
<p>CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读&#x2F;写I&#x2F;O(硬盘&#x2F;内存)，I&#x2F;O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。</p>
<p>在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</p>
<p>CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I&#x2F;O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I&#x2F;O的时间。</p>
<p>###IO密集型（I&#x2F;O bound）</p>
<p>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I&#x2F;O (硬盘&#x2F;内存) 的读&#x2F;写操作，此时CPU Loading并不高。</p>
<p>I&#x2F;O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I&#x2F;O操作，而pipeline做得不是很好，没有充分利用处理器能力。</p>
<p>###CPU密集型 vs IO密集型</p>
<p>我们可以把任务分为计算密集型和IO密集型。</p>
<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p>
<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>
<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/arch/cap/cpuio/" data-id="clhlnylei006sojup9gas8qkg" data-title="【CAP】CPU密集型与IO密集型" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/arch/crypto/openssl/srcmain" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/arch/crypto/openssl/srcmain/" class="article-date">
  <time class="dt-published" datetime="2019-03-04T07:37:03.000Z" itemprop="datePublished">2019-03-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>►<a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%AF%86%E7%A0%81%E6%9C%AF/">密码术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/arch/crypto/openssl/srcmain/">【密码术】openssl源码分析一</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="openssl命令入口"><a href="#openssl命令入口" class="headerlink" title="openssl命令入口"></a>openssl命令入口</h3><p>文件：openssl.c<br>位置：apps目录</p>
<p>命令调用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">prog = prog_init();</span><br><span class="line">pname = opt_progname(argv[0]);</span><br><span class="line"></span><br><span class="line">/* first check the program name */</span><br><span class="line">f.name = pname;</span><br><span class="line">fp = lh_FUNCTION_retrieve(prog, &amp;f);</span><br><span class="line">if (fp != NULL) &#123;</span><br><span class="line">    argv[0] = pname;</span><br><span class="line">    ret = fp-&gt;func(argc, argv);</span><br><span class="line">    goto end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是生成了一个<code>FUNCTION</code>对象的结构体。</p>
<h3 id="FUNCTION对象"><a href="#FUNCTION对象" class="headerlink" title="FUNCTION对象"></a>FUNCTION对象</h3><p>文件：progs.h<br>位置：apps<br>来源：通过apps&#x2F;progs.pl生成，不可修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct function_st &#123;</span><br><span class="line">    FUNC_TYPE type;</span><br><span class="line">    const char *name;</span><br><span class="line">    int (*func)(int argc, char *argv[]);</span><br><span class="line">    const OPTIONS *help;</span><br><span class="line">&#125; FUNCTION;</span><br></pre></td></tr></table></figure>

<p><code>FUNCTION</code>结构体是对一个方法调用的封装。</p>
<p>最主要的是函数指针，用于调用命令指定的函数。</p>
<p><code>FUNC_TYPE</code>是一个枚举对象，用于分类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef enum FUNC_TYPE &#123;</span><br><span class="line">    FT_none, FT_general, FT_md, FT_cipher, FT_pkey,</span><br><span class="line">    FT_md_alg, FT_cipher_alg</span><br><span class="line">&#125; FUNC_TYPE;</span><br></pre></td></tr></table></figure>

<p>对于类型只用到三类，对应<code>openssl help</code>列出的帮助。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static FUNCTION functions[] = &#123;</span><br><span class="line">......</span><br><span class="line">    &#123;FT_general, &quot;help&quot;, help_main, help_options&#125;,</span><br><span class="line">    &#123;FT_general, &quot;list&quot;, list_main, list_options&#125;,</span><br><span class="line">......</span><br><span class="line">    &#123;FT_md, &quot;sha256&quot;, dgst_main&#125;,</span><br><span class="line">......</span><br><span class="line">    &#123;FT_cipher, &quot;aes-128-cbc&quot;, enc_main, enc_options&#125;,</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><code>openssl help</code>的显示结果为三部分，第一部类标准命令对应类型<code>FT_general</code>，第二部分对应摘要命令对应类型<code>FT_md</code>，第三部分为加解密命令对应类型<code>FT_cipher</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ openssl help</span><br><span class="line">Standard commands</span><br><span class="line">asn1parse         ca                ciphers           cms</span><br><span class="line">crl               crl2pkcs7         dgst              dhparam</span><br><span class="line">dsa               dsaparam          ec                ecparam</span><br><span class="line">enc               engine            errstr            gendsa</span><br><span class="line">genpkey           genrsa            help              list</span><br><span class="line">nseq              ocsp              passwd            pkcs12</span><br><span class="line">pkcs7             pkcs8             pkey              pkeyparam</span><br><span class="line">pkeyutl           prime             rand              rehash</span><br><span class="line">req               rsa               rsautl            s_client</span><br><span class="line">s_server          s_time            sess_id           smime</span><br><span class="line">speed             spkac             srp               storeutl</span><br><span class="line">ts                verify            version           x509</span><br><span class="line"></span><br><span class="line">Message Digest commands (see the `dgst&#x27; command for more details)</span><br><span class="line">blake2b512        blake2s256        gost              md4</span><br><span class="line">md5               mdc2              rmd160            sha1</span><br><span class="line">sha224            sha256            sha3-224          sha3-256</span><br><span class="line">sha3-384          sha3-512          sha384            sha512</span><br><span class="line">sha512-224        sha512-256        shake128          shake256</span><br><span class="line">sm3</span><br><span class="line"></span><br><span class="line">Cipher commands (see the `enc&#x27; command for more details)</span><br><span class="line">aes-128-cbc       aes-128-ecb       aes-192-cbc       aes-192-ecb</span><br><span class="line">aes-256-cbc       aes-256-ecb       aria-128-cbc      aria-128-cfb</span><br><span class="line">aria-128-cfb1     aria-128-cfb8     aria-128-ctr      aria-128-ecb</span><br><span class="line">aria-128-ofb      aria-192-cbc      aria-192-cfb      aria-192-cfb1</span><br><span class="line">aria-192-cfb8     aria-192-ctr      aria-192-ecb      aria-192-ofb</span><br><span class="line">aria-256-cbc      aria-256-cfb      aria-256-cfb1     aria-256-cfb8</span><br><span class="line">aria-256-ctr      aria-256-ecb      aria-256-ofb      base64</span><br><span class="line">bf                bf-cbc            bf-cfb            bf-ecb</span><br><span class="line">bf-ofb            camellia-128-cbc  camellia-128-ecb  camellia-192-cbc</span><br><span class="line">camellia-192-ecb  camellia-256-cbc  camellia-256-ecb  cast</span><br><span class="line">cast-cbc          cast5-cbc         cast5-cfb         cast5-ecb</span><br><span class="line">cast5-ofb         des               des-cbc           des-cfb</span><br><span class="line">des-ecb           des-ede           des-ede-cbc       des-ede-cfb</span><br><span class="line">des-ede-ofb       des-ede3          des-ede3-cbc      des-ede3-cfb</span><br><span class="line">des-ede3-ofb      des-ofb           des3              desx</span><br><span class="line">idea              idea-cbc          idea-cfb          idea-ecb</span><br><span class="line">idea-ofb          rc2               rc2-40-cbc        rc2-64-cbc</span><br><span class="line">rc2-cbc           rc2-cfb           rc2-ecb           rc2-ofb</span><br><span class="line">rc4               rc4-40            seed              seed-cbc</span><br><span class="line">seed-cfb          seed-ecb          seed-ofb          sm4-cbc</span><br><span class="line">sm4-cfb           sm4-ctr           sm4-ecb           sm4-ofb</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/arch/crypto/openssl/srcmain/" data-id="clhlnylgz00lyojup0fqc0jzm" data-title="【密码术】openssl源码分析一" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/openssl/" rel="tag">openssl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E6%9C%AF/" rel="tag">密码术</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/arch/crypto/openssl/cygwininstall" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/arch/crypto/openssl/cygwininstall/" class="article-date">
  <time class="dt-published" datetime="2019-03-04T03:10:25.000Z" itemprop="datePublished">2019-03-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>►<a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%AF%86%E7%A0%81%E6%9C%AF/">密码术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/arch/crypto/openssl/cygwininstall/">【密码术】cygwin编译安装openssl</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>cygwin怎么安装这里不多说了。</p>
<p>装完cygwin要装gcc，安装cygwin如果按照默认的方式一直点下去的话，安装完了会发现没有安装gcc&#x2F;g++。</p>
<p>这个时候可以在安装文件的目录打开命令行，并输入：</p>
<p><code>setup-x86_64.exe -q -P wget -P gcc-g++ -P make -P diffutils -P libmpfr-devel -P libgmp-devel -P libmpc-devel</code></p>
<p>其中，”setup-x86_64.exe”对应安装文件的名称。接着就会出来安装的界面，等待下载完成即可。</p>
<p>装完gcc后还要安装perl，用界面化安装就可以。</p>
<p>下载openssl源码</p>
<p><a target="_blank" rel="noopener" href="https://www.openssl.org/source/">https://www.openssl.org/source/</a></p>
<p>也可以从github上剪出</p>
<p><a target="_blank" rel="noopener" href="https://github.com/openssl/openssl">https://github.com/openssl/openssl</a></p>
<p>解压源码文件。</p>
<p>用安装好的cygwin的“Cygwin64 Terminal”切换到解压后目录。</p>
<p>生成make文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Configure gcc</span><br></pre></td></tr></table></figure>
<p>生成完了之后就可以用<code>make</code>命令编译，用<code>make install</code>安装到cygwin环境。</p>
<p>用<code>./config</code>生成多几次不成功，看安装说明，用上面的命令生成后可以编译了。</p>
<p>最近版的openssl是支持国密算法的，比如SM2算法。</p>
<p>比如查看ECC支持的曲线可以看到支持SM2曲线了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ecparam -list_curves</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ecparam -list_curves</span><br></pre></td></tr></table></figure>

<p>如果有什么疑问呆以看源码包里的<code>INSTALL</code>文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/arch/crypto/openssl/cygwininstall/" data-id="clhlnylgy00lvojupeg5pgh1d" data-title="【密码术】cygwin编译安装openssl" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/openssl/" rel="tag">openssl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E6%9C%AF/" rel="tag">密码术</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/plang/ccpp/mingwcygwin" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/plang/ccpp/mingwcygwin/" class="article-date">
  <time class="dt-published" datetime="2019-03-01T07:35:45.000Z" itemprop="datePublished">2019-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/plang/ccpp/mingwcygwin/">MinGw 和 cygwin 的区别和联系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="windows与Linux操作系统的不同"><a href="#windows与Linux操作系统的不同" class="headerlink" title="windows与Linux操作系统的不同"></a>windows与Linux操作系统的不同</h3><p>windows和Linux是目前来说最流行的两大操作系统，在基本设计概念上，进程、线程、寻址、内存管理等方面都是大同小异的，但是二者之间的程序不兼容，因为二者在系统功能上是不同的，提供的系统API也是不同的。</p>
<p>从最明显的几点来说：</p>
<p>可执行文件的格式，Windows采用的是PE的格式，要求以.exe为后缀名，而Linux使用的是 elf 的格式；</p>
<p>操作系统提供的系统API是不同的，如Windows使用CreateProcess()创建进程，而Linux使用fork()。</p>
<p>所以想要在Windows环境下使用Linux的编译工具，也就是gcc&#x2F;g++，我们需要一个中间的转换工具或者平台，这也就是MinGW和cygwin存在的原因。</p>
<h3 id="什么是-MinGW"><a href="#什么是-MinGW" class="headerlink" title="什么是 MinGW"></a>什么是 MinGW</h3><p>MinGw全称 Minimalistic GNU for Windows，某种程度上可以看做是win版本下的GCC。Mingw有一个Msys的子项目，可以提供一些模拟Linux的shell和基本的Linux工具，Msys是一个辅助环境。</p>
<p>MinGw 有专门的Win32 API的头文件，来把代码中Linux方式的系统调用替换为对应的Windows下的调用方式，某种程度上可以称之为将Linux调用 翻译为 Windows调用。</p>
<h3 id="什么是-cygwin"><a href="#什么是-cygwin" class="headerlink" title="什么是 cygwin"></a>什么是 cygwin</h3><p>Cygwin 则是一个在Windows平台上运行的unix模拟环境，是cygnus solutions 公司开发的自由软件。Cygwin更像一个平台，模拟了Linux的接口，提供了运行在它上面的程序使用，提供了很多Linux环境下的GNU软件。</p>
<p>Cygwin 通过Cygwin1.dll的文件实现操作系统API的转换，模拟了Linux的调用接口给程序，程序以Linux的方式调用系统API，但这个API的目标库是Cygwin1.dll，Cygwin1.dll再调用Windows对用的方式实现，再把结果返回给程序。</p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p>MinGW生成的程序，究其本质调用的是Kernel.32导出的标准Windows系统API，在windows下Mingw的编译性能会高一些，编译速度也会快一些。</p>
<p>Cygwin更像一个平台，它相对完整地模拟了LInux，提供了一个接近2M的Cygwin1.dll的文件作为目标库，来模拟Linux系统的接口，但是相对来说编译的速度就要慢一些。如果想要在Windows上开发可以运行在LInux上的程序，应该选用Cygwin。</p>
<p>总的来说：</p>
<ol>
<li>cygwin大，mingw小</li>
<li>cygwin编译后的exe需要cygwin1.dll作为支持，而mingw不需要就可以直接运行，因为有中间层所以cygwin慢，mingw快。</li>
<li>cygwin包含的内容更全面，能编译通过的linux源文件更多，mingw的min是minimalist所以能编译通过的更少。但，不是全部，就是说别指望你可以把任何为linux写的源代码在cygwin或mingw编译通过并运行。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>事实上，cygwin&#x2F;gcc和Mingw都是为了gcc可以在windows下使用的编译环境，可以方便进行一些类Linux环境下的编程。但是两种平台不管是哪一种，Linux程序都不能直接运行在Windows下的，需要对程序进行重新编译，同时建议重要的源码还是应该在真正的Linux环境下进行编译。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/ccpp/mingwcygwin/" data-id="clhlnylg000fxojupes16cy6e" data-title="MinGw 和 cygwin 的区别和联系" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/">JAVA WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/Spring-Boot/">Spring Boot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%BC%80%E5%8F%91/">WEB开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/">nosql</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/MongoDB/">MongoDB</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E9%9B%86/">字符集</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/">spark</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/Emacs/">Emacs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/GIT/">GIT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/SSO/">SSO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%B8%80%E8%87%B4%E6%80%A7/">一致性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%AF%86%E7%A0%81%E6%9C%AF/">密码术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/JMS/">JMS</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6/">组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%AE%97%E6%B3%95/">树算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/BASE/">BASE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/JAVA8/">JAVA8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/NIO/">NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/">Lisp</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/Common-Lisp/">Common Lisp</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Scala/">Scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10.5px;">AOP</a> <a href="/tags/ASCII%E7%A0%81/" style="font-size: 10px;">ASCII码</a> <a href="/tags/ActiveMQ/" style="font-size: 11px;">ActiveMQ</a> <a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/BAT%E8%84%9A%E6%9C%AC/" style="font-size: 10px;">BAT脚本</a> <a href="/tags/CAP/" style="font-size: 10px;">CAP</a> <a href="/tags/CAS/" style="font-size: 10.5px;">CAS</a> <a href="/tags/Common-Lisp/" style="font-size: 13.5px;">Common Lisp</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10.5px;">C语言</a> <a href="/tags/Eclipse/" style="font-size: 11px;">Eclipse</a> <a href="/tags/Emacs/" style="font-size: 16.5px;">Emacs</a> <a href="/tags/Emmet/" style="font-size: 10px;">Emmet</a> <a href="/tags/GIT/" style="font-size: 10px;">GIT</a> <a href="/tags/HttpClient/" style="font-size: 12.5px;">HttpClient</a> <a href="/tags/IPFS/" style="font-size: 10px;">IPFS</a> <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/JAVA-IO/" style="font-size: 15.5px;">JAVA IO</a> <a href="/tags/JAVA-NIO/" style="font-size: 17px;">JAVA NIO</a> <a href="/tags/JAVA-WEB/" style="font-size: 10.5px;">JAVA WEB</a> <a href="/tags/JAVA8/" style="font-size: 13.5px;">JAVA8</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Lisp/" style="font-size: 12px;">Lisp</a> <a href="/tags/Markdown/" style="font-size: 10.5px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 18px;">MongoDB</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/Scala/" style="font-size: 11px;">Scala</a> <a href="/tags/Shiro/" style="font-size: 10px;">Shiro</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/VIM/" style="font-size: 16px;">VIM</a> <a href="/tags/WEB%E5%BC%80%E5%8F%91/" style="font-size: 11px;">WEB开发</a> <a href="/tags/XML/" style="font-size: 10.5px;">XML</a> <a href="/tags/archtype/" style="font-size: 10px;">archtype</a> <a href="/tags/azkaban/" style="font-size: 10.5px;">azkaban</a> <a href="/tags/hadoop/" style="font-size: 13px;">hadoop</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/hive/" style="font-size: 10px;">hive</a> <a href="/tags/javascript/" style="font-size: 14px;">javascript</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/linux/" style="font-size: 13px;">linux</a> <a href="/tags/maven/" style="font-size: 12px;">maven</a> <a href="/tags/nosql/" style="font-size: 18.5px;">nosql</a> <a href="/tags/nosql-neo4j/" style="font-size: 11.5px;">nosql neo4j</a> <a href="/tags/openssl/" style="font-size: 11px;">openssl</a> <a href="/tags/servlet/" style="font-size: 11px;">servlet</a> <a href="/tags/spark/" style="font-size: 12px;">spark</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/webservice/" style="font-size: 11px;">webservice</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 11.5px;">一致性</a> <a href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" style="font-size: 10.5px;">任务调度</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 10px;">区块链</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 17.5px;">大数据</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/" style="font-size: 12.5px;">字符集</a> <a href="/tags/%E5%AE%A1%E8%AE%A1/" style="font-size: 10px;">审计</a> <a href="/tags/%E5%AF%86%E7%A0%81%E6%9C%AF/" style="font-size: 14.5px;">密码术</a> <a href="/tags/%E5%B0%BE%E9%80%92%E5%BD%92/" style="font-size: 10px;">尾递归</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 12px;">并发</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 14px;">排序</a> <a href="/tags/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/" style="font-size: 10px;">摘要算法</a> <a href="/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" style="font-size: 10.5px;">数字签名</a> <a href="/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/" style="font-size: 10px;">数字证书</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 18.5px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/" style="font-size: 10px;">数据权限</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 11.5px;">杂谈</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 13.5px;">架构</a> <a href="/tags/%E6%A0%91%E7%AE%97%E6%B3%95/" style="font-size: 14px;">树算法</a> <a href="/tags/%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正规表达式</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" style="font-size: 12px;">知识体系</a> <a href="/tags/%E7%A5%9E%E5%99%A8/" style="font-size: 12px;">神器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.5px;">算法</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" style="font-size: 19px;">线程安全</a> <a href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">自制操作系统</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.5px;">设计模式</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 13px;">负载均衡</a> <a href="/tags/%E9%94%81/" style="font-size: 11px;">锁</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/explain/">【置顶】公告</a>
          </li>
        
          <li>
            <a href="/blog/tools/maven/dn-cst-maven-archtype/">开发一个maven脚手架</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustrystock/">neo4j创建行业与股票关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustry/">neo4j创建三级行业关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jtimeline/">neo4j创建时间线</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 证心<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a target="_blank" rel="noopener" href="http://site.onekbase.com" class="mobile-nav-link">ITEEDU</a>
  
    <a href="/about/" class="mobile-nav-link">关于</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>