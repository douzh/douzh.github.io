<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>OneKBase</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="OneKBase">
<meta property="og:url" content="http://www.onekbase.com/page/12/index.html">
<meta property="og:site_name" content="OneKBase">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="证心">
<meta name="twitter:card" content="summary">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">OneKBase</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">归一</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" target="_blank" rel="noopener" href="http://site.onekbase.com">ITEEDU</a>
        
          <a class="main-nav-link" href="/about/">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.onekbase.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-blog/plang/javascript/createobject" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/plang/javascript/createobject/" class="article-date">
  <time class="dt-published" datetime="2016-04-01T03:40:21.000Z" itemprop="datePublished">2016-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/plang/javascript/createobject/">javascript创建对象详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="传统的方法"><a href="#传统的方法" class="headerlink" title="传统的方法"></a>传统的方法</h2><p>创建对象最简单的方法，就是创建一个Object对象，然后为它添加属性和方法。</p>
<p>如果一个对象成员引用了一个函数，该成员就被称为一个”方法”，如果一个对象成员引用了一个非函数，该成员就被称为”属性”。</p>
<p>看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;Tony&quot;;  </span><br><span class="line">//创建了书一个方法（因为引用了函数）</span><br><span class="line">person.sayName = function()&#123;   </span><br><span class="line">  //this前面讲过，指的是当前函数的对象，在这里指的就是person对象</span><br><span class="line">    alert(this.name);          </span><br><span class="line">&#125;;</span><br><span class="line">person.sayName();  //输出结果显而易见 Tony</span><br></pre></td></tr></table></figure>

<p>缺点：使用同一个接口创建很多相似对象，会产生大量的重复代码。（为了解决这个问题—工厂模式出现了）</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>用函数来封装用特定接口创建对象的细节</p>
<p>比如下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123; </span><br><span class="line">    var o = new Object();              </span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = createPerson(&quot;Tony&quot;,23,&quot;worker&quot;);</span><br><span class="line">var person2 = createPerson(&quot;Tom&quot;,18,&quot;student&quot;);</span><br><span class="line">person1.sayName();  //Tony</span><br><span class="line">person2.sayName();  //Tom</span><br></pre></td></tr></table></figure>

<p>函数createPerson()能够根据接受的三个参数来创建一个包含</p>
<p>所有信息的Person对象。</p>
<p>优点：解决了传统方法里创建多个相似对象的问题。</p>
<p>缺点：没有解决对象识别的问题。（可以靠构造函数模式来解决）</p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>可以创造特定类型的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 =new Person(&quot;Tony&quot;,23,&quot;worker&quot;);</span><br><span class="line">var person2 =new Person(&quot;Tom&quot;,18,&quot;student&quot;);</span><br><span class="line">person1.sayName();  //Tony</span><br><span class="line">person2.sayName();  //Tom</span><br></pre></td></tr></table></figure>

<p>与工厂模式的不同之处：</p>
<ol>
<li>没有显示地创建构造函数</li>
<li>直接将属性和方法赋给了this对象</li>
<li>没有return语句</li>
</ol>
<p>优点：动态的传递参数</p>
<p>缺点：每创建一个对象就会创建相同的方法函数对象，占用大量内存。（可以用原型模式来解决）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.sayName == person2.sayName) //false</span><br></pre></td></tr></table></figure>

<p>由上代码可以看出来，这两个Function实例并不相等，然而创建两个完成同样任务的Function实例没有必要。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>将对象属性及方法定义都写在对象的prototype里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125; </span><br><span class="line">Person.prototype.name = &quot;Tony&quot;;</span><br><span class="line">Person.prototype.age = 22;</span><br><span class="line">Person.prototype.job = &quot;worker&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">person1.sayName();//Tony</span><br><span class="line">var person2 = new Person();</span><br><span class="line">//这里就是原型模式的缺点：无法动态传递构造参数</span><br><span class="line">person2.sayName();//Tony</span><br><span class="line">//正好与上文中的构造函数相反，这里是相同的Function对象</span><br><span class="line">alert(person1.sayName == person2.sayName); //true</span><br></pre></td></tr></table></figure>

<p>优点：每次创建对象时都是使用相同prototype中的方法，不会占用重复的内存<br>缺点：无法动态传递构造参数（构造函数模式可以解决）</p>
<h2 id="组合构造函数模式和原型模式"><a href="#组合构造函数模式和原型模式" class="headerlink" title="组合构造函数模式和原型模式"></a>组合构造函数模式和原型模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;   //构造函数模式</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job =job;</span><br><span class="line">    this.friends = [&quot;S&quot;,&quot;C&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;    //原型模式</span><br><span class="line">    constructor : Person,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Tony&quot;,22,&quot;worker&quot;);</span><br><span class="line">var person2 = new Person(&quot;Tom&quot;,18,&quot;student&quot;);</span><br><span class="line">//person1里面添加了V,并不影响person2,因为他们引用的是不同数组</span><br><span class="line">person1.friends.push(&quot;V&quot;);   </span><br><span class="line"></span><br><span class="line">alert(person1.friends);     //s,c,v</span><br><span class="line">alert(person2.friends);     //s,c</span><br><span class="line">alert(person1.friends === person2.friends); //false</span><br><span class="line">alert(person1.sayName === person2.sayName); //true</span><br></pre></td></tr></table></figure>

<p>优点：综合了constructor及prototype方式的优点，可以动态传递构造参数，并且方法函数对象也只创建一个。<br>缺点：函数写在对象外面，不太符合面向对象的思想（可以用动态原型的方式来解决）</p>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>加一个判断属性，来判断该对象是否已经被创建过，如果被创建过，则方法就不在构建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    //属性</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    //方法</span><br><span class="line">    //只有在sayName方法不存时，才会添加到原型中</span><br><span class="line">    if(typeof this.sayName !=&quot;function&quot;)&#123;      </span><br><span class="line">        Person.prototype.sayName = function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&quot;Tony&quot;,22,&quot;worker&quot;);</span><br><span class="line">person.sayName();</span><br></pre></td></tr></table></figure>

<p>优点：将原型函数写在对象定义里面</p>
<p>缺点：不支持继承</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/javascript/createobject/" data-id="clhlnylg400gfojupg7d79vsc" data-title="javascript创建对象详解" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/plang/javascript/prototype" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/plang/javascript/prototype/" class="article-date">
  <time class="dt-published" datetime="2016-04-01T03:36:56.000Z" itemprop="datePublished">2016-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/plang/javascript/prototype/">javascript面向对象设计-对象和原型浅析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="基本类型和对象"><a href="#基本类型和对象" class="headerlink" title="基本类型和对象"></a>基本类型和对象</h2><p>javascript中有三种基本数据类型，字符串(string)，数值(number)，布尔值(boolean),其余全是对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(typeof &#x27;asdf&#x27;);//string</span><br><span class="line">alert(typeof 22);//number</span><br><span class="line">alert(typeof true);//boolean</span><br><span class="line">alert(typeof new function()&#123;&#125;);//object</span><br></pre></td></tr></table></figure>

<p>基本数据类型在需要时会自动包装成对象类型，完成后再拆装为基本类型。</p>
<p>包装过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(typeof new String(&#x27;asdf&#x27;));//object</span><br><span class="line">alert(typeof new Number(22));//object</span><br><span class="line">alert(typeof new Boolean(true));//object</span><br></pre></td></tr></table></figure>

<p>将对象转换为基本类型则是通过这样的方式：通过调用对象的valueOf()方法来取得对象的值，如果和上下文的类型匹配，则使用该值。如果valueOf取不到值的话，则需要调用对象的toString()方法，而如果上下文为数值型，则又需要将此字符串转换为数值。</p>
<h2 id="对象的原型"><a href="#对象的原型" class="headerlink" title="对象的原型"></a>对象的原型</h2><p>每个对象都有一个__proto__属性，这个属性指向另一个对象。__proto__属性指向的对象为拥有__proto__属性对象的原型。由于原型也是对象，所以它也有原型，这样就成了一个链结构叫原型链。原型链最终一个原型的__proto__会指向null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj=new function()&#123;&#125;;</span><br><span class="line">alert(obj.__proto__.__proto__.__proto__);//null</span><br><span class="line">alert(obj.__proto__);//[object Object]</span><br><span class="line">alert(obj.__proto__.__proto__);//[object Object]</span><br></pre></td></tr></table></figure>

<p>函数对象的__proto__属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function func()&#123;var a=1;return &#x27;adf&#x27;;&#125;;</span><br><span class="line">alert(typeof func);//function</span><br><span class="line">alert(func instanceof Function);//true</span><br><span class="line">alert(func.__proto__.__proto__.__proto__);//null</span><br><span class="line">alert(func.__proto__);//function()&#123;&#125;</span><br><span class="line">alert(typeof func.__proto__);//function</span><br><span class="line">alert(func.__proto__ instanceof Function);//false</span><br><span class="line">alert(func.__proto__.__proto__);//[object Object]</span><br></pre></td></tr></table></figure>

<p>函数的__proto__属性很奇怪，是function类型但不是Function实例。</p>
<p>调用对象上的一个方法，由于方法在JavaScript对象中是对另一个函数对象的引用，因此解释器会在对象中查找该属性，如果没有找到，则在其内部对象__proto__属性上搜索，由于__proto__属性与对象本身的结构是一样的，因此这个过程会一直回溯到发现该属性，则调用该属性，否则，报告一个错误。</p>
<h2 id="对象的原型是怎么来的"><a href="#对象的原型是怎么来的" class="headerlink" title="对象的原型是怎么来的"></a>对象的原型是怎么来的</h2><p>__proto__属性是在new操作中产生的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = new ClassA ();</span><br></pre></td></tr></table></figure>

<p>以上创建对象过程可以用以下过程模拟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p = &#123;&#125;;</span><br><span class="line">ClassA.apply(p);</span><br><span class="line">p.__proto__= ClassA.prototype;</span><br></pre></td></tr></table></figure>

<p>也就是说对象的原型是其构造函数的prototype属性。这样就很好理解用原型实现继承的过程了。</p>
<p>构造函数的prototype是用其创建的对象的原型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/javascript/prototype/" data-id="clhlnylg500gpojup9nx9fev8" data-title="javascript面向对象设计-对象和原型浅析" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/plang/javascript/this" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/plang/javascript/this/" class="article-date">
  <time class="dt-published" datetime="2016-04-01T03:33:17.000Z" itemprop="datePublished">2016-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/plang/javascript/this/">javascript面向对象设计-深入this关键字</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>函数中的this默认代表调用函数的对象，为什么说默认呢，因为可以通过call和apply设置this。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function func()&#123;</span><br><span class="line">    alert(this.toString());</span><br><span class="line">&#125;</span><br><span class="line">func();//[object Window]</span><br><span class="line">var obj=new function()&#123;&#125;;</span><br><span class="line">obj.f=func;</span><br><span class="line">obj.f();//[object Object]</span><br></pre></td></tr></table></figure>

<p>输出的是什么意思？object说明this是一个对象，Window指出this的类型是什么。</p>
<p>在浏览器中Window类型有一个可用实例window，window对象是浏览器javascript引擎的顶层对象。任何函数调用都是类似于obj.func()形式的，只不过当obj为顶层对象时可以不用写。所以所有全局的函数和变量都是这个对象的属性。</p>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var testVar=’ testVar通过window调用’;</span><br><span class="line">function testWindow()&#123;</span><br><span class="line">     alert(‘testWindow通过window调用’);</span><br><span class="line">&#125;</span><br><span class="line">window. testWindow ();//testWindow通过window调用</span><br><span class="line">alert(window. testVar);// testVar通过window调用</span><br></pre></td></tr></table></figure>

<p>调用是成功的。</p>
<p>所以,我们定义了一个全局的变量或函数的时候，以下三种方式是相同的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var test=&quot;Tony&quot;;</span><br><span class="line">function f1()&#123;&#125;</span><br><span class="line">//--------------------</span><br><span class="line">window.test=&quot;Tony&quot;</span><br><span class="line">window.f1= function ()&#123;&#125;;</span><br><span class="line">//------------------------------</span><br><span class="line">window[&quot;test&quot;]=&quot;Tony&quot;;</span><br><span class="line">window[&quot;f1&quot;]= function ()&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，func()调用者是window，输出[object Window]；obj.f()调用者是obj，输出[object Object]。正是应了”函数中的this默认代表调用函数的对象”。</p>
<p>为什么不用var声明的变量为全局变量，因为有个隐藏前缀window对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj=&#123;</span><br><span class="line">    func:function()&#123;</span><br><span class="line">       v1=&#x27;in func no var&#x27;;</span><br><span class="line">       var v2=&#x27;in func with var&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func();</span><br><span class="line">alert(obj.v1);//undefined</span><br><span class="line">alert(window.v1);//in func no var</span><br><span class="line">alert(obj.v2);//undefined</span><br></pre></td></tr></table></figure>

<p>在对象obj的func函数中声明的变量v1因为没有添加var变成了全局变量了。</p>
<p>为了更好的理解”函数中的this默认代表调用函数的对象”，我们看一个闭包的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name : &quot;My Object&quot;,</span><br><span class="line">    doSomething : function() &#123;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.doSomething()());//The Window</span><br></pre></td></tr></table></figure>

<p>为什么会是The Window？object.doSomething()()可以等同于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var func= object.doSomething();</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<p>可以看到返回的函数会被widow对象调用，自然其中的this也是window对象了。this.name也就成了window.name了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/javascript/this/" data-id="clhlnylg700gxojupafbwcowp" data-title="javascript面向对象设计-深入this关键字" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/os/mkos/fat12bootsec" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/os/mkos/fat12bootsec/" class="article-date">
  <time class="dt-published" datetime="2016-03-13T08:58:53.000Z" itemprop="datePublished">2016-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/os/mkos/fat12bootsec/">FAT12文件系统之引导扇区结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>文件系统即文件管理系统，是操作系统的重要组成部分之一，如果需要开发底层磁盘驱动或编写自己的操作系统，就必须详细了解文件系统。</p>
<p>FAT12是Microsoft公司DOS操作系统所支持的文件系统之一，此外还有FAT16和FAT32，之后会分别详述这些文件系统。当软盘被标准格式化后，磁盘被格式化为：每磁头80个柱面(磁道)，每个柱面有18个扇区，每个扇区有512字节空间。所以标准软盘的总空间(容量)为：</p>
<p>2<em>80</em>18*512&#x3D;1474560B&#x3D;1440K&#x3D;1.44M</p>
<p>FAT12文件系统将按照下表所示的方式划分全部的容量，即文件系统数据结构：</p>
<p><strong>FAT12 2880扇区 (1474560B)</strong></p>
<table>
<thead>
<tr>
<th>逻辑扇区</th>
<th>占用扇区</th>
<th>内容</th>
<th>磁盘CHS参数(磁头&#x2F;柱面&#x2F;扇区)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1(512B)</td>
<td>引导程序</td>
<td>起：0&#x2F;0&#x2F;1</td>
</tr>
<tr>
<td>1</td>
<td>9(4608B)</td>
<td>FAT文件分配表1</td>
<td>起：0&#x2F;0&#x2F;2止：0&#x2F;0&#x2F;10</td>
</tr>
<tr>
<td>10</td>
<td>9(4608B)</td>
<td>FAT文件分配表2</td>
<td>起：0&#x2F;0&#x2F;11止：1&#x2F;0&#x2F;1</td>
</tr>
<tr>
<td>19</td>
<td>14(9728B)</td>
<td>根目录</td>
<td>-</td>
</tr>
<tr>
<td>33</td>
<td>14(9728B)</td>
<td>文件数据区</td>
<td>-</td>
</tr>
</tbody></table>
<p>操作系统之所以认识FAT12格式的磁盘，其秘密就在于逻辑0扇区这512B上。如果这512字节的最后两个字节的内容分别是55和AA（0xAA55低字节在前，高字节在后)的话，BIOS在启动时会将这个扇区读取到0:7C00h - 0:7DFFh处，然后跳转到0:7C00h处继续执行指令，操作系统即用此来达到引导系统的目的，而这个磁盘就称为可引导磁盘。操作系统标识FAT12文件系统是因为在逻辑0扇区(即引导扇区)处还存储着一个特定的数据结构，此结构有固定的格式，在操作系统将此磁盘格式化时自动生成，具体数据结构如下表所示：</p>
<table>
<thead>
<tr>
<th>标识</th>
<th>偏移量</th>
<th>类型</th>
<th>大小</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>?</td>
<td>0</td>
<td>db</td>
<td>3</td>
<td>跳转指令</td>
<td></td>
</tr>
<tr>
<td>BS_OEMName</td>
<td>3</td>
<td>db</td>
<td>8</td>
<td>OEM字符串，必须为8个字符，不足以空格填空</td>
<td>MSWIN4.1</td>
</tr>
<tr>
<td>BPB_BytsPerSec</td>
<td>11</td>
<td>dw</td>
<td>2</td>
<td>每扇区字节数</td>
<td>200h</td>
</tr>
<tr>
<td>BPB_SecPerClus</td>
<td>13</td>
<td>db</td>
<td>1</td>
<td>每簇占用的扇区数</td>
<td>1</td>
</tr>
<tr>
<td>BPB_RsvdSecCnt</td>
<td>14</td>
<td>dw</td>
<td>2</td>
<td>保留扇区数</td>
<td>1</td>
</tr>
<tr>
<td>BPB_NumFATs</td>
<td>16</td>
<td>db</td>
<td>1</td>
<td>FAT表的记录数</td>
<td>2</td>
</tr>
<tr>
<td>BPB_RootEntCnt</td>
<td>17</td>
<td>dw</td>
<td>2</td>
<td>最大根目录文件数</td>
<td>0e0h</td>
</tr>
<tr>
<td>BPB_TotSec16</td>
<td>19</td>
<td>dw</td>
<td>2</td>
<td>逻辑扇区总数</td>
<td>0b40h</td>
</tr>
<tr>
<td>BPB_Media</td>
<td>21</td>
<td>db</td>
<td>1</td>
<td>媒体描述符</td>
<td>0f0h</td>
</tr>
<tr>
<td>BPB_FATSz16</td>
<td>22</td>
<td>dw</td>
<td>2</td>
<td>每个FAT占用扇区数</td>
<td>9</td>
</tr>
<tr>
<td>BPB_SecPerTrk</td>
<td>24</td>
<td>dw</td>
<td>2</td>
<td>每个磁道扇区数</td>
<td>12h</td>
</tr>
<tr>
<td>BPB_NumHeads</td>
<td>26</td>
<td>dw</td>
<td>2</td>
<td>磁头数</td>
<td>2</td>
</tr>
<tr>
<td>BPB_HiddSec</td>
<td>28</td>
<td>dd</td>
<td>4</td>
<td>隐藏扇区数</td>
<td>0</td>
</tr>
<tr>
<td>BPB_TotSec32</td>
<td>32</td>
<td>dd</td>
<td>4</td>
<td>如果BPB_TotSec16是0，则在这里记录扇区总数</td>
<td>0</td>
</tr>
<tr>
<td>BS_DrvNum</td>
<td>36</td>
<td>db</td>
<td>1</td>
<td>中断13的驱动器号</td>
<td>0</td>
</tr>
<tr>
<td>BS_Reserved1</td>
<td>37</td>
<td>db</td>
<td>1</td>
<td>未使用</td>
<td>0</td>
</tr>
<tr>
<td>BS_BootSig</td>
<td>38</td>
<td>db</td>
<td>1</td>
<td>扩展引导标志</td>
<td>29h</td>
</tr>
<tr>
<td>BS_VolID</td>
<td>39</td>
<td>dd</td>
<td>4</td>
<td>卷序列号</td>
<td>0</td>
</tr>
<tr>
<td>BS_VolLab</td>
<td>43</td>
<td>db</td>
<td>11</td>
<td>卷标，必须是11个字符，不足以空格填充</td>
<td></td>
</tr>
<tr>
<td>BS_FileSysType</td>
<td>54</td>
<td>db</td>
<td>8</td>
<td>文件系统类型，必须是8个字符，不足填充空格</td>
<td>FAT12</td>
</tr>
<tr>
<td></td>
<td>62</td>
<td></td>
<td></td>
<td>引导代码，由偏移0字节处的短跳转而来</td>
<td></td>
</tr>
<tr>
<td></td>
<td>510</td>
<td>dw</td>
<td>2</td>
<td>系统引导标识</td>
<td>0aa55h</td>
</tr>
</tbody></table>
<p>首先是跳转指令，偏移0处的跳转指令必须是合法的可执行的基于x86的CPU指令，如：jmpstart，这样可以生成3字节长的指令，（加关键字short的短跳转指令的长度是2字节），指向操作系统引导代码部分。Windows和MS-DOS生成的FAT12启动扇区中的跳转指令是短跳转，如：jmpshort start，然后加一个nop的空指令来保持3字节的长度。</p>
<p>接着是位于偏移3处的OEM字符串，它必须是一个8字节长的字符串，标识了格式化此磁盘的操作系统的名称和版本号，为了保留与MS-DOS的兼容性，通常Windows2000系统格式化的磁盘上在此记录中的字符串是“MSDOS5.0”，在Windows95系统格式化的磁盘上在此记录中的字符串是“MSWIN4.0”，在Windows 95 OSR2和Windows98系统上格式化的磁盘上在此记录中的字符串是“MSWIN4.1”。</p>
<p>接下来是每扇区的字节数，类型是双字节长，标准分区上的每扇区字节数一般是512B，但也可以是其它的数字，如1024,2048和4096，FAT12的格式下设置为512(200h)。</p>
<p>偏移13处的是每簇所占用的扇区，类型是字节，簇是数据存储的最小单位，此字段的值取决于分区的大小，在FAT12格式下一般为1，即每簇只有1个扇区(512字节)，簇越大，那么分区的容量也就越大，通过增加簇的扇区数，可以支持更大的磁盘分区，标准的簇大小为1、2、4、8、16、32、64和128，FAT12格式下只能管理2^12个簇(4096)，所以在FAT12格式下能管理和分配的最大空间为：4096<em>1</em>512&#x3D;2097152B&#x3D;2M，所以FAT12一般只适合3.5寸高密度软盘(1.44M)。</p>
<p>保留扇区指的是在第一个FAT文件分配表之前的引导扇区，一般情况下只保留1个扇区(512B)。</p>
<p>接下来是类型为1字节长的FAT表的总数，默认情况下此字段的值为2，也就是有两个FAT表，FAT1和FAT2的内容相同，当FAT1表出错的时候可以使用FAT2来恢复文件分配表。</p>
<p>位于偏移17处的字段是类型为双字节长的能够储存在根目录下的最大文件(包含子目录)数量，默认为224，每个目录或文件名占用32B的空间，因此根目录的大小为：224*32&#x3D;7168B&#x3D;7KB，如果使用长文件名的话，根目录文件数还可能无法达到224的数量。</p>
<p>接下来是位于偏移19处的逻辑扇区总数，类型是双字节，如果此磁盘的逻辑扇区总数大于2^16位(65536)的话，就设置此字段为0，然后使用偏移32处的双字来表示逻辑总扇区数。</p>
<p>位于偏移21处的是单字节长的磁盘类型标识符，使用0f0h表示3.5寸高密码软盘，用0f8h来表示硬盘。此字段主要用于FAT12或FAT16的分区格式中，在Windows2000中未使用。</p>
<p>偏移22处双字节长的是每个FAT文件分配表所占用的扇区数，操作系统用这个字段和FAT表数量以及隐藏扇区数量来计算根目录所在的扇区。还可以根据最大根目录数来计算用户数据区从哪里开始。</p>
<p>根目录扇区位置&#x3D;FAT表数量*FAT表所占用的扇区数量+隐藏扇区数量</p>
<p>用户数据开始位置&#x3D;根目录扇区位置+根目录所占用扇区(FAT12格式下为224*32&#x2F;512)</p>
<p>此处所说的扇区指的是逻辑(线性)扇区，需要通过转换才能得到CHS磁盘参数，然后通过CHS参数来读写磁盘扇区。</p>
<p>接下来是位于偏移24处的每磁道扇区总数，类型是双字节长，软盘的默认值为18，即每个磁道有18个扇区。</p>
<p>然后是双字节长的磁头数，磁头数指的是磁盘面数，每面都有一个磁头，软盘都是2面的，所以在FAT12格式下此字段固定为2。</p>
<p>接下来是的位于偏移28处类型为双字(4B)长的隐藏扇区数，指的在引导扇区之前的隐藏扇区，在FAT12格式上此字段默认为0，即不隐藏任何扇区，此字段参与计算根目录区和用户数据区位置。</p>
<p>偏移32处的是类型为双字(4B)长的逻辑扇区总数，如果此分区或磁盘的逻辑扇区总数大于65536则用这个字段来表示逻辑扇区总数，否则设置此字段为0后用位于偏移19处的双字节字段来表示。</p>
<p>偏移36处的是物理驱动器号，类型是字节长，它与BIOS物理驱动器相关，在磁盘中断Int13h相关的操作中使用，第一个软盘驱动器设置为0，第一个硬盘驱动器设置为80h，第二个硬盘驱动器设置为81h，以此类推。此字段的值可以在系统引导时用dl寄存器得到。</p>
<p>位于偏移37处的字节没有使用，保留并设置为0。</p>
<p>位于偏移38处的是扩展引导标识，类型是字节，操作系统用它来识别引导信息，值可以是28h或29h。</p>
<p>接下来的是位于偏移39处的卷标号，类型是双字(4B)长，在格式化磁盘时所产生的一个随机序号，有助于区分磁盘，可以为0。</p>
<p>然后是位于偏移43处的卷标，长度必须是11字节长(不足以空格20h填充)，此字段只能使用一次，用来保存磁盘卷的标识符，再次设置的时候被保存到根目录中作为一个特殊的文件来储存。</p>
<p>最后是位于偏移54处的是长度为8字节的文件系统类型标识符，不足8字节则以空格20h来填充。FAT12格式下此字段为“FAT12”，相应的还有“FAT16”和“FAT32”。但要注意的是，操作系统并不使用这个字段来识别此磁盘所用的文件系统。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/os/mkos/fat12bootsec/" data-id="clhlnylfu00epojup1eyzhik4" data-title="FAT12文件系统之引导扇区结构" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">自制操作系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/algorithm/other/wdg" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/algorithm/other/wdg/" class="article-date">
  <time class="dt-published" datetime="2016-03-11T09:52:51.000Z" itemprop="datePublished">2016-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/algorithm/other/wdg/">递归和尾递归详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1、递归"><a href="#1、递归" class="headerlink" title="1、递归"></a>1、递归</h2><p>关于递归的概念，我们都不陌生。简单的来说递归就是一个函数直接或间接地调用自身，是为直接或间接递归。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。用递归需要注意以下两点：</p>
<ol>
<li>递归就是在过程或函数里调用自身。</li>
<li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</li>
</ol>
<p>递归一般用于解决三类问题：</p>
<ol>
<li>数据的定义是按递归定义的。（Fibonacci函数，n的阶乘）</li>
<li>问题解法按递归实现。（回溯）</li>
<li>数据的结构形式是按递归定义的。（二叉树的遍历，图的搜索）</li>
</ol>
<p>递归的缺点：</p>
<p>递归解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，因此递归次数过多容易造成栈溢出。</p>
<p>用线性递归实现Fibonacci函数，程序如下所示：</p>
<pre><code>int FibonacciRecursive(int n)
&#123;
    if( n &lt; 2)
        return n;
    return (FibonacciRecursive(n-1)+FibonacciRecursive(n-2));
&#125;
</code></pre>
<p>递归写的代码非常容易懂，完全是根据函数的条件进行选择计算机步骤。例如现在要计算n&#x3D;5时的值，递归调用过程如下图所示：</p>
<p><img src="/images/algorithm/wdg1.png"></p>
<h2 id="2、尾递归"><a href="#2、尾递归" class="headerlink" title="2、尾递归"></a>2、尾递归</h2><p>顾名思义，尾递归就是从最后开始计算, 每递归一次就算出相应的结果,也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部,所以根本没有必要去保存任何局部变量. 直接让被调用的函数返回时越过调用者,返回到调用者的调用者去。尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。</p>
<p>尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如f(n,sum) &#x3D; f(n-1) + value(n) + sum; 会保存n个函数调用堆栈，而使用尾递归f(n,sum) &#x3D; f(n-1, sum+value(n));</p>
<p>这样则只保留后一个函数堆栈即可，之前的可优化删去。</p>
<p>采用尾递归实现Fibonacci函数，程序如下所示：</p>
<pre><code> int FibonacciTailRecursive(int n,int ret1,int ret2)
&#123;
   if(n==0)
      return ret1; 
    return FibonacciTailRecursive(n-1,ret2,ret1+ret2);
&#125;
</code></pre>
<p>例如现在要计算n&#x3D;5时的值，尾递归调用过程如下图所示：</p>
<p><img src="/images/algorithm/wdg2.png"></p>
<p>从图可以看出，为递归不需要向上返回了，但是需要引入而外的两个空间来保持当前的结果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/algorithm/other/wdg/" data-id="clhlnyldh0016ojup5ev3hk50" data-title="递归和尾递归详解" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B0%BE%E9%80%92%E5%BD%92/" rel="tag">尾递归</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/plang/java/base/hashmap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/plang/java/base/hashmap/" class="article-date">
  <time class="dt-published" datetime="2016-02-26T05:49:13.000Z" itemprop="datePublished">2016-02-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/BASE/">BASE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/plang/java/base/hashmap/">JAVA源码之HashMap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>HashMap 类的 put(K key , V value) 方法的源代码：</p>
<pre><code> public V put(K key, V value) 
 &#123; 
     // 如果 key 为 null，调用 putForNullKey 方法进行处理
     if (key == null) 
         return putForNullKey(value); 
     // 根据 key 的 keyCode 计算 Hash 值
     int hash = hash(key.hashCode()); 
     // 搜索指定 hash 值在对应 table 中的索引
     int i = indexFor(hash, table.length);
     // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素
     for (Entry&lt; K,V&gt; e = table[i]; e != null; e = e.next) 
     &#123; 
         Object k; 
         // 找到指定 key 与需要放入的 key 相等（hash 值相同
         // 通过 equals 比较放回 true）
         if (e.hash == hash &amp;&amp; ((k = e.key) == key 
             || key.equals(k))) 
         &#123; 
             V oldValue = e.value; 
             e.value = value; 
             e.recordAccess(this); 
             return oldValue; 
         &#125; 
     &#125; 
     // 如果 i 索引处的 Entry 为 null，表明此处还没有 Entry 
     modCount++; 
     // 将 key、value 添加到 i 索引处
     addEntry(hash, key, value, i); 
     return null; 
 &#125; 
</code></pre>
<p>上面程序中用到了一个重要的内部接口：Map.Entry，每个 Map.Entry<br>其实就是一个 key-value 对。从上面程序中可以看出：当系统决定存储 HashMap<br>中的 key-value 对时，完全没有考虑 Entry 中的 value，仅仅只是根据 key<br>来计算并决定每个 Entry 的存储位置。这也说明了前面的结论：我们完全可以把<br>Map 集合中的 value 当成 key 的附属，当系统决定了 key<br>的存储位置之后，value 随之保存在那里即可。</p>
<p>上面方法提供了一个根据 hashCode() 返回值来计算 Hash<br>码的方法：hash()，这个方法是一个纯粹的数学计算，其方法如下：</p>
<pre><code>static int hash(int h) 
&#123; 
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); 
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); 
&#125; 
</code></pre>
<p>对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用<br>hash(int h) 方法所计算得到的 Hash 码值总是相同的。接下来程序会调用<br>indexFor(int h, int length) 方法来计算该对象应该保存在 table<br>数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：</p>
<pre><code>static int indexFor(int h, int length) 
&#123; 
    return h &amp; (length-1); 
&#125;
</code></pre>
<p>这个方法非常巧妙，它总是通过 h &amp;(table.length -1)<br>来得到该对象的保存位置——而 HashMap 底层数组的长度总是 2 的 n<br>次方，这一点可参看后面关于 HashMap 构造器的介绍。</p>
<p>当 length 总是 2 的倍数时，h &amp; (length-1) 将是一个非常巧妙的设计：假设<br>h&#x3D;5,length&#x3D;16, 那么 h &amp; length - 1 将得到 5；如果 h&#x3D;6,length&#x3D;16, 那么 h<br>&amp; length - 1 将得到 6 ……如果 h&#x3D;15,length&#x3D;16, 那么 h &amp; length - 1<br>将得到 15；但是当 h&#x3D;16 时 , length&#x3D;16 时，那么 h &amp; length - 1 将得到 0<br>了；当 h&#x3D;17 时 , length&#x3D;16 时，那么 h &amp; length - 1 将得到 1<br>了……这样保证计算得到的索引值总是位于 table 数组的索引之内。</p>
<p>根据上面 put 方法的源代码可以看出，当程序试图将一个 key-value 对放入<br>HashMap 中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry<br>的存储位置：如果两个 Entry 的 key 的 hashCode()<br>返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals<br>比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但<br>key 不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回<br>false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的<br>Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>
<p>当向 HashMap 中添加 key-value 对，由其 key 的 hashCode() 返回值决定该<br>key-value 对（就是 Entry 对象）的存储位置。当两个 Entry 对象的 key 的<br>hashCode() 返回值相同时，将由 key 通过 eqauls()<br>比较值决定是采用覆盖行为（返回 true），还是产生 Entry 链（返回 false）。</p>
<p>上面程序中还调用了 addEntry(hash, key, value, i); 代码，其中 addEntry 是<br>HashMap 提供的一个包访问权限的方法，该方法仅用于添加一个 key-value<br>对。下面是该方法的代码：</p>
<pre><code>void addEntry(int hash, K key, V value, int bucketIndex) 
&#123; 
    // 获取指定 bucketIndex 索引处的 Entry 
    Entry&lt; K,V&gt; e = table[bucketIndex];    // ①
    // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry 
    table[bucketIndex] = new Entry&lt; K,V&gt;(hash, key, value, e); 
    // 如果 Map 中的 key-value 对的数量超过了极限
    if (size++ &gt;= threshold) 
        // 把 table 对象的长度扩充到 2 倍。
        resize(2 * table.length);    // ②
&#125; 
</code></pre>
<p>上面方法的代码很简单，但其中包含了一个非常优雅的设计：系统总是将新添加的<br>Entry 对象放入 table 数组的 bucketIndex 索引处——如果 bucketIndex<br>索引处已经有了一个 Entry 对象，那新添加的 Entry 对象指向原有的 Entry<br>对象（产生一个 Entry 链），如果 bucketIndex 索引处没有 Entry<br>对象，也就是上面程序①号代码的 e 变量是 null，也就是新放入的 Entry<br>对象指向 null，也就是没有产生 Entry 链。</p>
<p>上面程序中还有这样两个变量：</p>
<p>* size：该变量保存了该 HashMap 中所包含的 key-value 对的数量。</p>
<p>* threshold：该变量包含了 HashMap 能容纳的 key-value<br>对的极限，它的值等于 HashMap 的容量乘以负载因子（load factor）。</p>
<p>当 size++ &gt;&#x3D; threshold 时，HashMap 会自动调用 resize 方法扩充 HashMap<br>的容量。每扩充一次，HashMap 的容量就增大一倍。</p>
<p>上面程序中使用的 table<br>其实就是一个普通数组，每个数组都有一个固定的长度，这个数组的长度就是<br>HashMap 的容量。HashMap 包含如下几个构造器：</p>
<p>HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。</p>
<p>HashMap(int initialCapacity)：构建一个初始容量为<br>initialCapacity，负载因子为 0.75 的 HashMap。</p>
<p>HashMap(int initialCapacity, float<br>loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。</p>
<p>当创建一个 HashMap 时，系统会自动创建一个 table 数组来保存 HashMap 中的<br>Entry，下面是 HashMap 中一个构造器的代码：</p>
<pre><code>// 以指定初始化容量、负载因子创建 HashMap 
 public HashMap(int initialCapacity, float loadFactor) 
 &#123; 
     // 初始容量不能为负数
     if (initialCapacity &lt; 0) 
         throw new IllegalArgumentException( 
        &quot;Illegal initial capacity: &quot; + 
             initialCapacity); 
     // 如果初始容量大于最大容量，让出示容量
     if (initialCapacity &gt; MAXIMUM_CAPACITY) 
         initialCapacity = MAXIMUM_CAPACITY; 
     // 负载因子必须大于 0 的数值
     if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) 
         throw new IllegalArgumentException( 
         loadFactor); 
     // 计算出大于 initialCapacity 的最小的 2 的 n 次方值。
     int capacity = 1; 
     while (capacity &lt; initialCapacity) 
         capacity &lt;&lt;= 1; 
     this.loadFactor = loadFactor; 
     // 设置容量极限等于容量 * 负载因子
     threshold = (int)(capacity * loadFactor); 
     // 初始化 table 数组
     table = new Entry[capacity];            // ①
     init(); 
 &#125; 
</code></pre>
<p>对于 HashMap 及其子类而言，它们采用 Hash<br>算法来决定集合中元素的存储位置。当系统开始初始化 HashMap<br>时，系统会创建一个长度为 capacity 的 Entry<br>数组，这个数组里可以存储元素的位置被称为”桶（bucket）”，每个 bucket<br>都有其指定索引，系统可以根据其索引快速访问该 bucket 里存储的元素。</p>
<p>无论何时，HashMap 的每个”桶”只存储一个元素（也就是一个 Entry），由于<br>Entry 对象可以包含一个引用变量（就是 Entry<br>构造器的的最后一个参数）用于指向下一个<br>Entry，因此可能出现的情况是：HashMap 的 bucket 中只有一个 Entry，但这个<br>Entry 指向另一个 Entry ——这就形成了一个 Entry 链。</p>
<p>HashMap 的读取实现</p>
<p>当 HashMap 的每个 bucket 里存储的 Entry 只是单个 Entry<br>——也就是没有通过指针产生 Entry 链时，此时的 HashMap<br>具有最好的性能：当程序通过 key 取出对应 value 时，系统只要先计算出该 key<br>的 hashCode() 返回值，在根据该 hashCode 返回值找出该 key 在 table<br>数组中的索引，然后取出该索引处的 Entry，最后返回该 key 对应的 value<br>即可。看 HashMap 类的 get(K key) 方法代码：</p>
<pre><code> public V get(Object key) 
 &#123; 
     // 如果 key 是 null，调用 getForNullKey 取出对应的 value 
     if (key == null) 
         return getForNullKey(); 
     // 根据该 key 的 hashCode 值计算它的 hash 码
     int hash = hash(key.hashCode()); 
     // 直接取出 table 数组中指定索引处的值，
     for (Entry&lt; K,V&gt; e = table[indexFor(hash, table.length)]; 
         e != null; 
         // 搜索该 Entry 链的下一个 Entr 
         e = e.next)         // ①
     &#123; 
         Object k; 
         // 如果该 Entry 的 key 与被搜索 key 相同
         if (e.hash == hash &amp;&amp; ((k = e.key) == key 
             || key.equals(k))) 
             return e.value; 
     &#125; 
     return null; 
 &#125; 
</code></pre>
<p>从上面代码中可以看出，如果 HashMap 的每个 bucket 里只有一个 Entry<br>时，HashMap 可以根据索引、快速地取出该 bucket 里的 Entry；在发生”Hash<br>冲突”的情况下，单个 bucket 里存储的不是一个 Entry，而是一个 Entry<br>链，系统只能必须按顺序遍历每个 Entry，直到找到想搜索的 Entry<br>为止——如果恰好要搜索的 Entry 位于该 Entry 链的最末端（该 Entry<br>是最早放入该 bucket 中），那系统必须循环到最后才能找到该元素。</p>
<p>归纳起来简单地说，HashMap 在底层将 key-value<br>当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个<br>Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry<br>对象时，会根据 Hash 算法来决定其存储位置；当需要取出一个 Entry<br>时，也会根据 Hash 算法找到其存储位置，直接取出该<br>Entry。由此可见：HashMap 之所以能快速存、取它所包含的<br>Entry，完全类似于现实生活中母亲从小教我们的：不同的东西要放在不同的位置，需要时才能快速找到它。</p>
<p>当创建 HashMap 时，有一个默认的负载因子（load factor），其默认值为<br>0.75，这是时间和空间成本上一种折衷：增大负载因子可以减少 Hash<br>表（就是那个 Entry<br>数组）所占用的内存空间，但会增加查询数据的时间开销，而查询是最频繁的的操作（HashMap<br>的 get() 与 put()<br>方法都要用到查询）；减小负载因子会提高数据查询的性能，但会增加 Hash<br>表所占用的内存空间。</p>
<p>掌握了上面知识之后，我们可以在创建 HashMap 时根据实际需要适当地调整 load<br>factor<br>的值；如果程序比较关心空间开销、内存比较紧张，可以适当地增加负载因子；如果程序比较关心时间开销，内存比较宽裕则可以适当的减少负载因子。通常情况下，程序员无需改变负载因子的值。</p>
<p>如果开始就知道 HashMap 会保存多个 key-value<br>对，可以在创建时就使用较大的初始化容量，如果 HashMap 中 Entry<br>的数量一直不会超过极限容量（capacity * load factor），HashMap<br>就无需调用 resize() 方法重新分配 table<br>数组，从而保证较好的性能。当然，开始就将初始容量设置太高可能会浪费空间（系统需要创建一个长度为<br>capacity 的 Entry 数组），因此创建 HashMap<br>时初始化容量设置也需要小心对待。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/base/hashmap/" data-id="clhlnylhp00phojup9f0h6b3d" data-title="JAVA源码之HashMap" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/plang/java/base/md5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/plang/java/base/md5/" class="article-date">
  <time class="dt-published" datetime="2016-02-23T08:33:50.000Z" itemprop="datePublished">2016-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/BASE/">BASE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/plang/java/base/md5/">JAVA之用MessageDigest进行MD5加密</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>用JAVA生成32位和16位MD5值。</p>
<p>其实16位的是取的32位的中间的一段。</p>
<pre><code>import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class MD5Test &#123;
    public static void main(String[] args) throws NoSuchAlgorithmException &#123;
        String str = &quot;123456&quot;;
        MessageDigest md = MessageDigest.getInstance(&quot;md5&quot;);
        String md32 = convertToHexString(md.digest(str.getBytes()));
        System.out.println(&quot;md32:&quot; + md32);
        System.out.println(&quot;md16:&quot; + md32.substring(7, 23));
    &#125;

    static String convertToHexString(byte data[]) &#123;
        StringBuffer strBuffer = new StringBuffer();
        for (int i = 0; i &lt; data.length; i++) &#123;
            strBuffer.append(Integer.toHexString(0xff &amp; data[i]));
        &#125;
        return strBuffer.toString();
    &#125;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/base/md5/" data-id="clhlnylhs00q5ojup3tpreeeb" data-title="JAVA之用MessageDigest进行MD5加密" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/tools/maven/model" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/tools/maven/model/" class="article-date">
  <time class="dt-published" datetime="2016-02-22T08:31:05.000Z" itemprop="datePublished">2016-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/tools/maven/model/">Maven最佳实践：划分模块</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>所有用Maven管理的真实的项目都应该是分模块的，每个模块都对应着一个pom.xml。它们之间通过继承和聚合（也称作多模块，multi-module）相互关联。那么，为什么要这么做呢？我们明明在开发一个项目，划分模块后，导入Eclipse变成了N个项目，这会带来复杂度，给开发带来不便。</p>
<p>为了解释原因，假设有这样一个项目，很常见的Java<br>Web应用。在这个应用中，我们分了几层：</p>
<ul>
<li>Dao层负责数据库交互，封装了Hibernate交互的类。</li>
<li>Service层处理业务逻辑，放一些Service接口和实现相关的Bean。</li>
<li>Web层负责与客户端交互，主要有一些Structs的Action类。</li>
</ul>
<p>对应的，在一个项目中，我们会看到一些包名：</p>
<ul>
<li>org.myorg.app.dao</li>
<li>org.myorg.app.service</li>
<li>org.myorg.app.web</li>
<li>org.myorg.app.util</li>
</ul>
<p>这样整个项目的框架就清晰了，但随着项目的进行，你可能会遇到如下问题：</p>
<ol>
<li>这个应用可能需要有一个前台和一个后台管理端（web或者swing），你发现大部分dao，一些service，和大部分util是在两个应用中可。这样的问题，你一周内遇到了好几次。</li>
<li>pom.xml中的依赖列表越来越长以重用的，但是，由于目前只有一个项目（WAR），你不得不新建一个项目依赖这个WAR，这变得非常的恶心，因为在Maven中配置对WAR的依赖远不如依赖JAR那样简单明了，而且你根本不需要org.myorg.app.web。有人修改了dao，提交到svn并且不小心导致build失败了，你在编写service的代码，发现编译不过，只能等那人把dao修复了，你才能继续进行，很多人都在修改，到后来你根本就不清楚哪个依赖是谁需要的，渐渐的，很多不必要的依赖被引入。甚至出现了一个依赖有多个版本存在。</li>
<li>build整个项目的时间越来越长，尽管你只是一直在web层工作，但你不得不build整个项目。</li>
<li>某个模块，比如util，你只想让一些经验丰富的人来维护，可是，现在这种情况，每个开发者都能修改，这导致关键模块的代码质量不能达到你的要求。\</li>
</ol>
<p>我们会发现，其实这里实际上没有遵守一个设计模式原则：”高内聚，低耦合”。虽然我们通过包名划分了层次，并且你还会说，这些包的依赖都是单向的，没有包的环依赖。这很好，但还不够，因为就构建层次来说，所有东西都被耦合在一起了。因此我们需要使用Maven划分模块。</p>
<p> </p>
<p>一个简单的Maven模块结构是这样的：</p>
<pre><code>---- app-parent
             |-- pom.xml (pom)
             |
             |-- app-util
             |        |-- pom.xml (jar)
             |
             |-- app-dao
             |        |-- pom.xml (jar)
             |
             |-- app-service
             |        |-- pom.xml (jar)
             |
             |-- app-web
                      |-- pom.xml (war)  
</code></pre>
<p>上述简单示意图中，有一个父项目(app-parent)聚合很多子项目（app-util,<br>app-dao, app-service,<br>app-web）。每个项目，不管是父子，都含有一个pom.xml文件。而且要注意的是，小括号中标出了每个项目的打包类型。父项目是pom,也只能是pom。子项目有jar，或者war。根据它包含的内容具体考虑。</p>
<p> </p>
<p>这些模块的依赖关系如下：</p>
<p> </p>
<p>app-dao      --&gt; app-util</p>
<p>app-service --&gt; app-dao</p>
<p>app-web     --&gt; app-service</p>
<p> </p>
<p>注意依赖的传递性（大部分情况是传递的，除非你配置了特殊的依赖scope），app-dao依赖于app-util，app-service依赖于app-dao，于是app-service也依赖于app-util。同理，app-web依赖于app-dao,app-util。</p>
<p> </p>
<p>用项目层次的划分替代包层次的划分能给我们带来如下好处：</p>
<ol>
<li>方便重用，如果你有一个新的swing项目需要用到app-dao和app-service，添加对它们的依赖即可，你不再需要去依赖一个WAR。而有些模块，如app-util，完全可以渐渐进化成公司的一份基础工具类库，供所有项目使用。这是模块化最重要的一个目的。</li>
<li>由于你现在划分了模块，每个模块的配置都在各自的pom.xml里，不用再到一个混乱的纷繁复杂的总的POM中寻找自己的配置。</li>
<li>如果你只是在app-dao上工作，你不再需要build整个项目，只要在app-dao目录运行mvn命令进行build即可，这样可以节省时间，尤其是当项目越来越复杂，build越来越耗时后。</li>
<li>某些模块，如app-util被所有人依赖，但你不想给所有人修改，现在你完全可以从这个项目结构出来，做成另外一个项目，svn只给特定的人访问，但仍提供jar给别人使用。</li>
<li>多模块的Maven项目结构支持一些Maven的更有趣的特性（如DepencencyManagement），这留作以后讨论。</li>
</ol>
<p>接下来讨论一下POM配置细节，实际上非常简单，先看app-parent的pom.xml：</p>
<pre><code>    4.0.0
    org.myorg.myapp
    app-parent
    pom
    1.0-SNAPSHOT
    
        app-util
        app-dao
        app-service
        app-web
    
</code></pre>
<p>Maven的坐标GAV（groupId, artifactId,<br>version）在这里进行配置，这些都是必须的。特殊的地方在于，这里的packaging为pom。所有带有子模块的项目的packaging都为pom。packaging如果不进行配置，它的默认值是jar，代表Maven会将项目打成一个jar包。</p>
<p>该配置重要的地方在于modules，例子中包含的子模块有app-util, app-dao,<br>app-service, app-war。在Maven build<br>app-parent的时候，它会根据子模块的相互依赖关系整理一个build顺序，然后依次build。</p>
<p>这就是一个父模块大概需要的配置，接下来看一下子模块符合配置继承父模块。、</p>
<pre><code>        app-parent
        org.myorg.myapp
        1.0-SNAPSHOT
    
    4.0.0
    app-util
    
        
            commons-lang
            commons-lang
            2.4
        
    
</code></pre>
<p>app-util模块继承了app-parent父模块，因此这个POM的一开始就声明了对app-parent的引用，该引用是通过Maven坐标GAV实现的。而关于项目app-util本身，它却没有声明完整GAV，这里我们只看到了artifactId。这个POM并没有错，groupId和version默认从父模块继承了。实际上子模块从父模块继承一切东西，包括依赖，插件配置等等。</p>
<p>此外app-util配置了一个对于commons-lang的简单依赖，这是最简单的依赖配置形式。大部分情况，也是通过GAV引用的。</p>
<p>再看一下app-dao，它也是继承于app-parent，同时依赖于app-util：</p>
<pre><code>        app-parent
        org.myorg.myapp
        1.0-SNAPSHOT
    
    4.0.0
    app-dao
    
        
            org.myorg.myapp
            app-util
            $&#123;project.version&#125;
        
    
</code></pre>
<p>该配置和app-util的配置几乎没什么差别，不同的地方在于，依赖变化了，app-dao依赖于app-util。这里要注意的是version的值为${project.version}，这个值是一个属性引用，指向了POM的project&#x2F;version的值，也就是这个POM对应的version。由于app-dao的version继承于app-parent，因此它的值就是1.0-SNAPSHOT。而app-util也继承了这个值，因此在所有这些项目中，我们做到了保持版本一致。</p>
<p>这里还需要注意的是，app-dao依赖于app-util，而app-util又依赖于commons-lang，根据传递性，app-dao也拥有了对于commons-lang的依赖。</p>
<p>app-service我们跳过不谈，它依赖于app-dao。我们最后看一下app-web：</p>
<pre><code>        app-parent
        org.myorg.myapp
        1.0-SNAPSHOT
    
    4.0.0
    app-web
    war
    
        
            org.myorg.myapp
            app-service
            $&#123;project.version&#125;
        
    
</code></pre>
<p>app-web依赖于app-service，因此配置了对其的依赖。</p>
<p>由于app-web是我们最终要部署的应用，因此它的packaging是war。为此，你需要有一个目录src&#x2F;main&#x2F;webapp。并在这个目录下拥有web应用需要的文件，如&#x2F;WEB-INF&#x2F;web.xml。没有web.xml，Maven会报告build失败，此外你可能还会有这样一些子目录：&#x2F;js,<br>&#x2F;img, &#x2F;css ... 。</p>
<p> </p>
<p>看看Maven是如何build整个项目的，我们在 app-parent 根目录中运行 mvn clean<br>install ，输出的末尾会有大致这样的内容：</p>
<pre><code>...
...
[INFO] [war:war]
[INFO] Packaging webapp
[INFO] Assembling webapp[app-web] in [/home/juven/workspaces/ws-others/myapp/app-web/target/app-web-1.0-SNAPSHOT]
[INFO] Processing war project
[INFO] Webapp assembled in[50 msecs]
[INFO] Building war: /home/juven/workspaces/ws-others/myapp/app-web/target/app-web-1.0-SNAPSHOT.war
[INFO] [install:install]
[INFO] Installing /home/juven/workspaces/ws-others/myapp/app-web/target/app-web-1.0-SNAPSHOT.war to /home/juven/.m2/repository/org/myorg/myapp/app-web/1.0-SNAPSHOT/app-web-1.0-SNAPSHOT.war
[INFO] 
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] app-parent ............................................ SUCCESS [1.191s]
[INFO] app-util .............................................. SUCCESS [1.274s]
[INFO] app-dao ............................................... SUCCESS [0.583s]
[INFO] app-service ........................................... SUCCESS [0.593s]
[INFO] app-web ............................................... SUCCESS [0.976s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 4 seconds
[INFO] Finished at: Sat Dec 27 08:20:18 PST 2008
[INFO] Final Memory: 3M/17M
[INFO] ------------------------------------------------------------------------
</code></pre>
<p>注意Reactor<br>Summary，整个项目根据我们希望的顺序进行build。Maven根据我们的依赖配置，智能的安排了顺序，app-util,<br>app-dao, app-service, app-web。</p>
<p> </p>
<p>最后，你可以在 app-web&#x2F;target 目录下找到文件 app-web-1.0-SNAPSHOT.war<br>，打开这个war包，在 &#x2F;WEB-INF&#x2F;lib 目录看到了<br>commons-lang-2.4.jar，以及对应的app-util, app-dao, app-service<br>的jar包。Maven自动帮你处理了打包的事情，并且根据你的依赖配置帮你引入了相应的jar文件。</p>
<p>使用多模块的Maven配置，可以帮助项目划分模块，鼓励重用，防止POM变得过于庞大，方便某个模块的构建，而不用每次都构建整个项目，并且使得针对某个模块的特殊控制更为方便。本文同时给出了一个实际的配置样例，展示了如何使用Maven配置多模块项目。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/maven/model/" data-id="clhlnylgh00j0ojup3ubaa4e0" data-title="Maven最佳实践：划分模块" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maven/" rel="tag">maven</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/tools/maven/repository" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/tools/maven/repository/" class="article-date">
  <time class="dt-published" datetime="2016-02-22T08:03:32.000Z" itemprop="datePublished">2016-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/tools/maven/repository/">MAVEN仓库repository介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>在Maven中，任何一个依赖，插件或者项目构建的输出，都可以成为构件。</p>
<p>得益于坐标机制，任何Maven项目使用任何一个构件的方式都是完全相同的。在此基础上，Maven可以在某一个位置统一存放所有Maven项目共享的构件，这个统一的位置就是<strong>仓库</strong>。实际的Maven项目将不在各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候，Maven会自动根据坐标找到仓库中的构件，并使用它们。\</p>
<h2 id="仓库的布局"><a href="#仓库的布局" class="headerlink" title="仓库的布局"></a>仓库的布局</h2><p>任何一个构件都有其唯一的坐标，可以根据这个坐标定义其在仓库中的唯一存储路径，这便是Maven的仓库布局方式。</p>
<p>例如：log4j:log4j:1.2.15这一依赖，其对应的仓库路径为log4j&#x2F;log4j&#x2F;1.2.15&#x2F;log4j-1.2.15.jar。该<strong>路径与坐标的大致对应关系为groupId<br>&#x2F; artifactId &#x2F; version &#x2F; artifactId-version.packaging</strong>。</p>
<p>Maven仓库是基于简单文件系统存储的。</p>
<h2 id="仓库的分类"><a href="#仓库的分类" class="headerlink" title="仓库的分类"></a>仓库的分类</h2><p>对于Maven来说，仓库只分为两类：本地仓库和远程仓库。</p>
<p><strong>当Maven根据坐标寻找构件的时候，它首先会查看本地仓库，如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要查看是否有更新的构件版本，Maven就会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。如果本地仓库和远程仓库都没有需要的构件，Maven就会报错</strong>。</p>
<p>远程仓库的分类：</p>
<ul>
<li>中央仓库——是Maven核心自带的远程仓库，它包含了绝大部分开源的构件。在默认配置下，当本地仓库没有Maven需要的构件的时候，它就会尝试从中央仓库下载。</li>
<li>私服——在局域网内假设一个私有的仓库服务器。</li>
<li>其他公开的远程仓库——</li>
</ul>
<h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>一般来说，在Maven项目目录下，没有哲如lib&#x2F;这样用来存放依赖文件的目录。当Maven在执行编译或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。</p>
<p>默认情况下，不管是在Windows还是Linux下，每个用户在自己的用户目录下都有一个路径名为**.m2<br>&#x2F; repository**的仓库目录。</p>
<p>如果用户想要自定义本地仓库的目录地址，这时，可以编辑文件~&#x2F;.m2&#x2F;settings.xml，设置localRepository元素的值为想要的仓库地址，例如：</p>
<pre><code>    D:\java\repository\
</code></pre>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>当用户输入第一条Maven命令之后，Maven才会创建本地仓库，然后根据配置和需要，从远程仓库下载构件至本地仓库。</p>
<p>对于Maven来说，每一个用户只有一个本地仓库，但可以配置访问很多远程仓库。</p>
<ul>
<li>中央仓库</li>
</ul>
<p>中央仓库是一个默认的远程仓库，Maven的安装文件自带了中央仓库的配置。打开文件￥M2_HOME&#x2F;lib&#x2F;maven-model-builder-3.0.jar，访问路径org&#x2F;apache&#x2F;maven&#x2F;model&#x2F;pom-4.0.0.xml，看到如下配置：</p>
<pre><code>        central
        Maven Repository Switchboard
        http://repol.maven.org/maven2
        default
        
            false
        
    
</code></pre>
<p><strong>包含这段配置的文件是所有Maven项目都会继承的超级POM</strong>。</p>
<p>私服</p>
<p>私服是一种特殊的远程仓库，它是假设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载提供请求服务。</p>
<h2 id="远程仓库的配置"><a href="#远程仓库的配置" class="headerlink" title="远程仓库的配置"></a>远程仓库的配置</h2><p>如果项目需要的构件存在于另外一个远程仓库中，如JBoss<br>Maven仓库，这时，可以在<strong>POM</strong>中配置该仓库，例如：</p>
<pre><code>... ...
    
        
            jboss
            JBoss Repository/name&gt;
            http://repository.jboss.com.maven2/
            
                true
            
            
                false
            
            default
    

...
</code></pre>
<p>在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。任何一个仓库声明的id必须是唯一的。如果其他仓库声明使用中央残酷的id——central，就会覆盖中央仓库的配置。</p>
<p>release子元素enabled的为true，表示开启JBoss仓库的发布版本下载支持。</p>
<p>snapshot的enabled的值为flase，表示关闭JBoss仓库的快照版本的支持，Maven只会从JBoss仓库下载发布版的构件，而不会下载快照版的构件。</p>
<p>对于release和snapshot来说，除了enabled，它们还包含另外两个子元素updatePolicy和checksumPolicy：</p>
<h3 id="远程仓库的认证"><a href="#远程仓库的认证" class="headerlink" title="远程仓库的认证"></a>远程仓库的认证</h3><p>大部分远程仓库无须认证就可以访问，但有时候出于安全方面的考虑，需要提供认证信息才能访问一些远程仓库。</p>
<p>配置认证信息和配置仓库信息不同，<strong>仓库信息可以直接配置在POM文件中，但是认证信息必须配置在settings.xml文件中</strong>。</p>
<p>假设需要一个id为my-proj的仓库配置认证信息，编辑settings.xml文件如下：</p>
<pre><code>    ... ...
    
        
            my-proj
            repo-user
            repo-pwd
        
    
    ... ...
</code></pre>
<p>settings.xml中server元素的id必须与POM中需要认证的repository元素的id完全一致，<strong>这个id将认证信息与仓库配置联系在了一起</strong>。</p>
<h2 id="仓库搜索服务"><a href="#仓库搜索服务" class="headerlink" title="仓库搜索服务"></a>仓库搜索服务</h2><p>使用Maven进行日常开发的时候，一个常见的问题就是如何寻找需要的依赖，我们可能只知道需要使用类库的项目名称，但添加Maven依赖要求提供确切的Maven坐标。这时，就可以使用仓库所有服务来根据关键字得到Maven坐标。</p>
<p><a target="_blank" rel="noopener" href="https://repository.sonatype.org/">https://repository.sonatype.org/</a></p>
<p><a target="_blank" rel="noopener" href="http://www.mvnrepository.com/">http://www.mvnrepository.com/</a></p>
<p><a target="_blank" rel="noopener" href="http://search.maven.org/">http://search.maven.org/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/maven/repository/" data-id="clhlnylgj00j9ojupduak08xx" data-title="MAVEN仓库repository介绍" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maven/" rel="tag">maven</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/tools/maven/archetype" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/tools/maven/archetype/" class="article-date">
  <time class="dt-published" datetime="2016-02-22T02:13:02.000Z" itemprop="datePublished">2016-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/tools/maven/archetype/">Maven插件archetype介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Archetype"><a href="#Archetype" class="headerlink" title="Archetype"></a>Archetype</h2><p>可以讲Archetype理解成Maven项目的模板，例如maven-archetype-quickstart就是最简单的Maven项目模板，只需提供基本的元素，如groupId,artifactId,version等，它就能生成项目的基本结构及POM文件。</p>
<h3 id="Maven-Archetype-Plugin"><a href="#Maven-Archetype-Plugin" class="headerlink" title="Maven Archetype Plugin"></a>Maven Archetype Plugin</h3><p>\</p>
<h3 id="使用Archetype的一般步骤"><a href="#使用Archetype的一般步骤" class="headerlink" title="使用Archetype的一般步骤"></a>使用Archetype的一般步骤</h3><ul>
<li>命令——mvn archetype:generate</li>
<li>输入命令后，Archetype插件会输出一个Archetype列表供用户选择；选择自己想要使用的Archetype，输入对应编号</li>
<li>提示输入一些基本参数，如groupId,artifactId,version,package等</li>
<li>Archetype插件生成项目骨架</li>
</ul>
<h2 id="常用Archetype"><a href="#常用Archetype" class="headerlink" title="常用Archetype"></a>常用Archetype</h2><h3 id="maven-archetype-quickstart"><a href="#maven-archetype-quickstart" class="headerlink" title="maven-archetype-quickstart"></a>maven-archetype-quickstart</h3><p>默认的Archetype,基本内容包括：</p>
<ul>
<li>一个包含junit依赖声明的pom.xml</li>
<li>src&#x2F;main&#x2F;java主代码目录及一个名为App的类</li>
<li>src&#x2F;test&#x2F;java测试代码目录及一个名为AppTest的测试用例</li>
</ul>
<h3 id="maven-archetype-webapp"><a href="#maven-archetype-webapp" class="headerlink" title="maven-archetype-webapp"></a>maven-archetype-webapp</h3><p>一个最简单的Maven<br>war项目模板，当需要快速创建一个Web应用的时候可以使用它。生成的项目内容包括：</p>
<ul>
<li>一个packaging为war且带有junit依赖声明的pom.xml</li>
<li>src&#x2F;main&#x2F;webapp&#x2F;目录</li>
<li>src&#x2F;main&#x2F;webapp&#x2F;index.jsp文件</li>
<li>src&#x2F;main&#x2F;webapp&#x2F;WEB-INF&#x2F;web.xml文件</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/maven/archetype/" data-id="clhlnylgh00ixojupc4fm2zqt" data-title="Maven插件archetype介绍" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maven/" rel="tag">maven</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/11/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/13/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/">JAVA WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/Spring-Boot/">Spring Boot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%BC%80%E5%8F%91/">WEB开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/">nosql</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/MongoDB/">MongoDB</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E9%9B%86/">字符集</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/">spark</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/Emacs/">Emacs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/GIT/">GIT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/SSO/">SSO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%B8%80%E8%87%B4%E6%80%A7/">一致性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%AF%86%E7%A0%81%E6%9C%AF/">密码术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/JMS/">JMS</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6/">组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%AE%97%E6%B3%95/">树算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/BASE/">BASE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/JAVA8/">JAVA8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/NIO/">NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/">Lisp</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/Common-Lisp/">Common Lisp</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Scala/">Scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10.5px;">AOP</a> <a href="/tags/ASCII%E7%A0%81/" style="font-size: 10px;">ASCII码</a> <a href="/tags/ActiveMQ/" style="font-size: 11px;">ActiveMQ</a> <a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/BAT%E8%84%9A%E6%9C%AC/" style="font-size: 10px;">BAT脚本</a> <a href="/tags/CAP/" style="font-size: 10px;">CAP</a> <a href="/tags/CAS/" style="font-size: 10.5px;">CAS</a> <a href="/tags/Common-Lisp/" style="font-size: 13.5px;">Common Lisp</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10.5px;">C语言</a> <a href="/tags/Eclipse/" style="font-size: 11px;">Eclipse</a> <a href="/tags/Emacs/" style="font-size: 16.5px;">Emacs</a> <a href="/tags/Emmet/" style="font-size: 10px;">Emmet</a> <a href="/tags/GIT/" style="font-size: 10px;">GIT</a> <a href="/tags/HttpClient/" style="font-size: 12.5px;">HttpClient</a> <a href="/tags/IPFS/" style="font-size: 10px;">IPFS</a> <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/JAVA-IO/" style="font-size: 15.5px;">JAVA IO</a> <a href="/tags/JAVA-NIO/" style="font-size: 17px;">JAVA NIO</a> <a href="/tags/JAVA-WEB/" style="font-size: 10.5px;">JAVA WEB</a> <a href="/tags/JAVA8/" style="font-size: 13.5px;">JAVA8</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Lisp/" style="font-size: 12px;">Lisp</a> <a href="/tags/Markdown/" style="font-size: 10.5px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 18px;">MongoDB</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/Scala/" style="font-size: 11px;">Scala</a> <a href="/tags/Shiro/" style="font-size: 10px;">Shiro</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/VIM/" style="font-size: 16px;">VIM</a> <a href="/tags/WEB%E5%BC%80%E5%8F%91/" style="font-size: 11px;">WEB开发</a> <a href="/tags/XML/" style="font-size: 10.5px;">XML</a> <a href="/tags/archtype/" style="font-size: 10px;">archtype</a> <a href="/tags/azkaban/" style="font-size: 10.5px;">azkaban</a> <a href="/tags/hadoop/" style="font-size: 13px;">hadoop</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/hive/" style="font-size: 10px;">hive</a> <a href="/tags/javascript/" style="font-size: 14px;">javascript</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/linux/" style="font-size: 13px;">linux</a> <a href="/tags/maven/" style="font-size: 12px;">maven</a> <a href="/tags/nosql/" style="font-size: 18.5px;">nosql</a> <a href="/tags/nosql-neo4j/" style="font-size: 11.5px;">nosql neo4j</a> <a href="/tags/openssl/" style="font-size: 11px;">openssl</a> <a href="/tags/servlet/" style="font-size: 11px;">servlet</a> <a href="/tags/spark/" style="font-size: 12px;">spark</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/webservice/" style="font-size: 11px;">webservice</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 11.5px;">一致性</a> <a href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" style="font-size: 10.5px;">任务调度</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 10px;">区块链</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 17.5px;">大数据</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/" style="font-size: 12.5px;">字符集</a> <a href="/tags/%E5%AE%A1%E8%AE%A1/" style="font-size: 10px;">审计</a> <a href="/tags/%E5%AF%86%E7%A0%81%E6%9C%AF/" style="font-size: 14.5px;">密码术</a> <a href="/tags/%E5%B0%BE%E9%80%92%E5%BD%92/" style="font-size: 10px;">尾递归</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 12px;">并发</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 14px;">排序</a> <a href="/tags/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/" style="font-size: 10px;">摘要算法</a> <a href="/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" style="font-size: 10.5px;">数字签名</a> <a href="/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/" style="font-size: 10px;">数字证书</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 18.5px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/" style="font-size: 10px;">数据权限</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 11.5px;">杂谈</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 13.5px;">架构</a> <a href="/tags/%E6%A0%91%E7%AE%97%E6%B3%95/" style="font-size: 14px;">树算法</a> <a href="/tags/%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正规表达式</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" style="font-size: 12px;">知识体系</a> <a href="/tags/%E7%A5%9E%E5%99%A8/" style="font-size: 12px;">神器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.5px;">算法</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" style="font-size: 19px;">线程安全</a> <a href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">自制操作系统</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.5px;">设计模式</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 13px;">负载均衡</a> <a href="/tags/%E9%94%81/" style="font-size: 11px;">锁</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/explain/">【置顶】公告</a>
          </li>
        
          <li>
            <a href="/blog/tools/maven/dn-cst-maven-archtype/">开发一个maven脚手架</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustrystock/">neo4j创建行业与股票关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustry/">neo4j创建三级行业关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jtimeline/">neo4j创建时间线</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 证心<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a target="_blank" rel="noopener" href="http://site.onekbase.com" class="mobile-nav-link">ITEEDU</a>
  
    <a href="/about/" class="mobile-nav-link">关于</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>