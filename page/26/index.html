<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>OneKBase</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="OneKBase">
<meta property="og:url" content="http://www.onekbase.com/page/26/index.html">
<meta property="og:site_name" content="OneKBase">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="证心">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="OneKBase" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">OneKBase</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.onekbase.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-blog/os/mkos/computerstart" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/os/mkos/computerstart/" class="article-date">
  <time datetime="2015-12-05T10:22:14.000Z" itemprop="datePublished">2015-12-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/os/mkos/computerstart/">【转】计算机的启动过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="零、boot的含义"><a href="#零、boot的含义" class="headerlink" title="零、boot的含义"></a>零、boot的含义</h4><p>先问一个问题，”启动”用英语怎么说？</p>
<p>回答是boot。可是，boot原来的意思是靴子，”启动”与靴子有什么关系呢？<br>原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：</p>
<pre><code>&quot;pull oneself up by one&#39;s bootstraps&quot;
</code></pre>
<p>字面意思是”拽着鞋带把自己拉起来”，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！</p>
<p>早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做”拉鞋带”，久而久之就简称为boot了。</p>
<p>计算机的整个启动过程分成四个阶段。</p>
<h4 id="一、第一阶段：BIOS"><a href="#一、第一阶段：BIOS" class="headerlink" title="一、第一阶段：BIOS"></a>一、第一阶段：BIOS</h4><p>上个世纪70年代初，”只读内存”（read-only<br>memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。</p>
<p><img src="/images/mkos/2013-02-17-1.png" alt="BIOS" title="BIOS"></p>
<p>这块芯片里的程序叫做”基本輸出輸入系統”（Basic Input&#x2F;Output<br>System），简称为BIOS。</p>
<h5 id="1-1-硬件自检"><a href="#1-1-硬件自检" class="headerlink" title="1.1 硬件自检"></a>1.1 硬件自检</h5><p>BIOS中主要存放的程序包括：自诊断程序（通过读取CMOS<br>RAM中的内容识别硬件配置，并对其进行自检和初始化）、CMOS设置程序（引导过程中，通过特殊热键启动，进行设置后，存入CMOS<br>RAM中）、系统自动装载程序（在系统自检成功后，将磁盘相对0道0扇区上的引导程序装入内存使其运行）和主要I&#x2F;O驱动程序和中断服务（BIOS和硬件直接打交道，需要加载I&#x2F;O驱动程序）。</p>
<p>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On<br>Self-Test），缩写为POST。</p>
<p>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p>
<h5 id="1-2-启动顺序"><a href="#1-2-启动顺序" class="headerlink" title="1.2 启动顺序"></a>1.2 启动顺序</h5><p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</p>
<p>这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot<br>Sequence）。</p>
<p>打开BIOS的操作界面，里面有一项就是”设定启动顺序”。</p>
<p><img src="/images/mkos/2013-02-17-2.png" alt="BIOS Sequence" title="BIOS Sequence"></p>
<h4 id="二、第二阶段：主引导记录"><a href="#二、第二阶段：主引导记录" class="headerlink" title="二、第二阶段：主引导记录"></a>二、第二阶段：主引导记录</h4><p>BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。即根据用户指定的引导顺序从软盘、硬盘或是可移动设备中读取启动设备的MBR，并放入指定的位置（0x7c000）内存中。</p>
<p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</p>
<p>这最前面的512个字节，就叫做”主引导记录”（Master boot<br>record，缩写为MBR）。</p>
<h5 id="2-1-主引导记录的结构"><a href="#2-1-主引导记录的结构" class="headerlink" title="2.1 主引导记录的结构"></a>2.1 主引导记录的结构</h5><p>“主引导记录”只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p>
<p>主引导记录由三个部分组成：</p>
<pre><code>（1） 第1-446字节：调用操作系统的机器码。
（2） 第447-510字节：分区表（Partition table）。
（3） 第511-512字节：主引导记录签名（0x55和0xAA）。
</code></pre>
<p>其中，第二部分”分区表”的作用，是将硬盘分成若干个区。</p>
<h5 id="2-2-分区表"><a href="#2-2-分区表" class="headerlink" title="2.2 分区表"></a>2.2 分区表</h5><p>硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，”主引导记录”因此必须知道将控制权转交给哪个区。</p>
<p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。</p>
<p>每个主分区的16个字节，由6个部分组成：</p>
<pre><code>（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3） 第5个字节：主分区类型。
（4） 第6-8个字节：主分区最后一个扇区的物理位置。
（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
（6） 第13-16字节：主分区的扇区总数。
</code></pre>
<p>最后的四个字节（”主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。</p>
<p>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。</p>
<h4 id="三、第三阶段：硬盘启动"><a href="#三、第三阶段：硬盘启动" class="headerlink" title="三、第三阶段：硬盘启动"></a>三、第三阶段：硬盘启动</h4><p>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p>
<h5 id="3-1-情况A：卷引导记录"><a href="#3-1-情况A：卷引导记录" class="headerlink" title="3.1 情况A：卷引导记录"></a>3.1 情况A：卷引导记录</h5><p>上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做”卷引导记录”（Volume<br>boot record，缩写为VBR）。</p>
<p>“卷引导记录”的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p>
<h5 id="3-2-情况B：扩展分区和逻辑分区"><a href="#3-2-情况B：扩展分区和逻辑分区" class="headerlink" title="3.2 情况B：扩展分区和逻辑分区"></a>3.2 情况B：扩展分区和逻辑分区</h5><p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成”扩展分区”（Extended<br>partition）。</p>
<p>所谓”扩展分区”，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做”逻辑分区”（logical<br>partition）。</p>
<p>计算机先读取扩展分区的第一个扇区，叫做”扩展引导记录”（Extended boot<br>record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。</p>
<p>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p>
<p>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p>
<h5 id="3-3-情况C：启动管理器"><a href="#3-3-情况C：启动管理器" class="headerlink" title="3.3 情况C：启动管理器"></a>3.3 情况C：启动管理器</h5><p>在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot<br>loader），由用户选择启动哪一个操作系统。</p>
<p>Linux环境中，目前最流行的启动管理器是Grub。</p>
<p><img src="/images/mkos/2013-02-17-3.png" alt="Grub" title="Grub"></p>
<p>对于grub而言，在MBR中的446字节的引导程序属于GRUB的开始执行程序，通过这段程序，进一步执行stage1.5或是stage2的执行程序，将在下面详细介绍执行过程。</p>
<p>其中stage1.5或是stage2便属于阶段2引导的过程了，stage2过程也是作为GRUB<br>kernel的核心代码出现。Stage1.5过程（对于GRUB而言存在stage1.5，GRUB2则不存在）的功能很单一，主要就是为了引导stage2过程服务。由于stage2过程的代码存放在文件系统下的boot分区目录中，因此stage1.5过程就是需要提供一个文件系统的环境，而该文件系统环境需要保证系统可以找到stage2过程的文件，那么stage1.5阶段提供的文件系统需要是boot文件系统所对应的，这个在执行grub<br>install过程中就已经确定了。stage2过程中，主要会把系统切换到保护模式，设置好C运行时环境，找到config文件（事实上就是menulist文件），如果没有找到就执行一个shell，等待用户的执行。然后的工作就变成了输入命令-&gt;解析命令-&gt;执行命令的循环中。当然该阶段引导的最终状态就是执行boot命令，将内核和initrd镜像加载进入内存中，进而将控制权转交给内核。</p>
<h4 id="四、第四阶段：操作系统"><a href="#四、第四阶段：操作系统" class="headerlink" title="四、第四阶段：操作系统"></a>四、第四阶段：操作系统</h4><p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p>
<p>以Linux系统为例，先载入&#x2F;boot目录下面的kernel。内核加载成功后，第一个运行的程序是&#x2F;sbin&#x2F;init。它根据配置文件（Debian系统是&#x2F;etc&#x2F;initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p>
<p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行&#x2F;bin&#x2F;login程序，跳出登录界面，等待用户输入用户名和密码。</p>
<p>至此，全部启动过程完成。</p>
<hr>
<p>\</p>
<h4 id="BIOS启动细节："><a href="#BIOS启动细节：" class="headerlink" title="BIOS启动细节："></a>BIOS启动细节：</h4><p>a)<br>按下电源开关，电源就开始向主板和其它设备供电；当芯片组检测到电源已经开始稳定供电了(当然从不稳定到稳定的过程只是一瞬间的事情)，它便撤去RESET信号(如果是手工按下计算机面板上的Reset按钮来重启机器，那么松开该按钮时芯片组就会撤去RESET信号)；CPU马上就从地址FFFF:0000H<br>处开始执行指令，放在这里的只是一条跳转指令，跳到系统BIOS中真正的启动代码处。</p>
<p>b) 系统BIOS的启动代码首先进行POST(Power－On Self<br>Test，加电后自检)。POST的主要检测系统中一些关键设备是否存在和能否正常工作，例如内存和显卡等设备；由于POST是最早进行的检测过程，此时显卡还没有初始化，如果系统BIOS在进行POST的过程中发现了一些致命错误，例如没有找到内存或者内存有问题(此时只会检查640K常规内存)，那么系统BIOS就会直接控制喇叭发声来报告错误，声音的长短和次数代表了错误的类型；在正常情况下，POST过程进行得非常快，几乎无法感觉到它的存在。POST结束之后就会调用其它代码来进行更完整的硬件检测。</p>
<p>c)<br>接下来系统BIOS将查找显卡的BIOS。前面说过，存放显卡BIOS的ROM芯片的起始地址通常设在C0000H处，系统BIOS在这个地方找到显卡BIOS之后就调用它的初始化代码，由显卡BIOS来初始化显卡。此时多数显卡都会在屏幕上显示出一些初始化信息，介绍生产厂商、图形芯片类型等内容，不过这个画面几乎是一闪而过。系统BIOS接着会查找其它设备的BIOS程序，找到之后同样要调用这些BIOS内部的初始化代码来初始化相关的设备。</p>
<p>d)<br>查找完所有其它设备的BIOS之后，系统BIOS将显示出它自己的启动画面，其中包括有系统BIOS的类型、序列号和版本号等内容。</p>
<p>e)<br>接着系统BIOS将检测和显示CPU的类型和工作频率，测试所有的RAM，并同时在屏幕上显示内存测试的进度。可以在CMOS设置中自行决定使用简单耗时少或者详细耗时多的测试方式。</p>
<p>f)<br>内存测试通过之后，系统BIOS将开始检测系统中安装的一些标准硬件设备，包括硬盘、CD-ROM、串口、并口和软驱等设备，另外绝大多数较新版本的系统BIOS在这一过程中还要自动检测和设置内存的定时参数、硬盘参数和访问模式等。</p>
<p>g)<br>标准设备检测完毕后，系统BIOS内部支持即插即用的代码将开始检测和配置系统中安装的即插即用设备。每找到一个设备之后，系统BIOS都会在屏幕上显示出设备的名称和型号等信息，同时为该设备分配中断、DMA通道和I&#x2F;O端口等资源。</p>
<p>h)<br>到这一步为止，所有硬件都已经检测配置完毕了，多数系统BIOS会重新清屏并在屏幕上方显示出一个表格，其中概略地列出了系统中安装的各种标准硬件设备，以及它们使用的资源和一些相关工作参数。</p>
<p>i) 接下来系统BIOS将更新ESCD(Extended System Configuration<br>Data，扩展系统配置数据)。ESCD是系统BIOS用来与操作系统交换硬件配置信息的一种手段，这些数据被存放在CMOS(一小块特殊的RAM，由主板上的电池来供电)之中。通常ESCD数据只在系统硬件配置发生改变后才会更新，所以不是每次启动机器时都能够看到”Update<br>ESCD…<br>Success”这样的信息。不过，某些主板的系统BIOS在保存ESCD数据时使用了与Windows<br>9x不相同的数据格式，于是Windows<br>9x在它自己的启动过程中会把ESCD数据修改成自己的格式。但在下一次启动机器时，即使硬件配置没有发生改变，系统BIOS也会把ESCD的数据格式改回来。如此循环，将会导致在每次启动机器时，系统BIOS都要更新一遍ESCD，这就是为什么有些机器在每次启动时都会显示出相关信息的原因。</p>
<p>j)<br>ESCD更新完毕后，系统BIOS的启动代码将进行它的最后一项工作：即根据用户指定的启动顺序从软盘、硬盘或光驱启动MBR。在这个过程中会按照启动顺序顺序比较其放置MBR的位置的结尾两位是否为0xAA55，通过这种方式判断从哪个引导设备进行引导。在确定之后，将该引导设备的MBR内容读入到0x7C00[1]的位置，并再次判断其最后两位，当检测正确之后，进行阶段1的引导。</p>
<h4 id="EFI启动细节"><a href="#EFI启动细节" class="headerlink" title="EFI启动细节"></a>EFI启动细节</h4><p>与传统MBR相比，GPT采用了不同的分区方式。</p>
<p>对于传统MBR，其结构主要如下：</p>
<p><img src="/images/mkos/2013-02-17-4.png" alt="BIOS Graph" title="BIOS Graph"></p>
<p>上图即对上文中所述的很形象的说明，在图中看到MBR被分成三个部分，分别是：Bootloader、分别表以及Magic<br>Number。其中Bootloader部分为stage1中被执行的起始部分。</p>
<p>相反，对于EFI系统中所采用的GPT分区方式，则采用了不同于MBR分区方式的形式，从下图中可以发现：</p>
<p><img src="/images/mkos/2013-02-17-5.png" alt="EFI Graph" title="EFI Graph"></p>
<p>如上图所示，GPT分区表主要包括：保护MBR、首要GPT头、首要GPT、备用GPT、备用GPT头和磁盘数据区。保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表。首要GPT头包含了众多信息，具体内容如下：</p>
<p><img src="/images/mkos/2013-02-17-6.png" alt="EFI Table" title="EFI Table"></p>
<p>分区表头定义了硬盘的可用空间以及组成分区表的项的大小和数量。分区表头还记录了这块硬盘的GUID，记录了分区表头本身的位置和大小（位置总是在LBA1）以及备份分区表头和分区表的位置和大小（在硬盘的最后）。它还存储着它本身和分区表的CRC32校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否有错误，如果出错了，可以使用软件从硬盘最后的备份GPT分区表恢复整个分区表，如果备份GPT也校验错误，那么磁盘将不可用，系统拒绝启动。</p>
<p>接下来主要是128个分区表项，GPT分区表使用简单而直接的方式表示分区。一个分区表项的前16字节是分区类型GUID。例如，EFI系统分区的GUID类型是{C12A7328-F81F-11D2-BA4B-00A0C93EC93B}<br>。接下来的16字节是该分区的唯一的GUID（这个指的是该分区本身，而之前的GUID指的是该分区的类型）。在接下来是分区其实和末尾的64位LBA编号，以及分区的名字和属性。具体结构如下表：</p>
<p><img src="/images/mkos/2013-02-17-7.png" alt="EFI Table2" title="EFI Table2"></p>
<h4 id="MBR引导"><a href="#MBR引导" class="headerlink" title="MBR引导"></a>MBR引导</h4><p>接下来开始真正的引导过程了，主要说明GRUP的引导。总体上GRUB更像是一个mini<br>os，只不过这个mini<br>os的作用只是加载其他的操作系统，在GRUB中包括stage1、stage1.5（可选）和stage2，其中stage1和stage1.5属于boot<br>loader，stage2属于mini<br>os的内核部分。GRUB中stage1过程主要位于MBR的前446字节中（对于支持GPT分区的磁盘，同样有最开始的512字节作为保护MBR，保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表，不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作），之后的64字节为硬盘的分区表，最后两个字节为MBR结束标志位（0xAA55）。</p>
<p>stage1部分占用了446字节，其代码文件是源码目录下stage1&#x2F;stage1.S文件，汇编后生成一个512字节的boot.img，被写在硬盘的0面0道1扇区中，作为硬盘的MBR。stage1的工作很简单，就是加载0面0道2扇区上的512字节到0×8000，然后跳转到0×8000执行。</p>
<p>在0面0道2扇区上的512字节内容为<code>stage1/start.S</code>文件汇编后生成。该扇区上的内容的作用是加载stage1.5或是stage2过程，并将控制权转交。</p>
<h4 id="Grub引导"><a href="#Grub引导" class="headerlink" title="Grub引导"></a>Grub引导</h4><p>在start过程将控制权转交后，接下来就是GRUB的核心过程了。该过程之所以区分stage1.5和stage2，主要原因是GRUB和GRUB2的区别。在GRUB2中，将stage1.5过程集成到了stage2的过程中，所以stage1.5过程仅仅是针对GRUB的。下面将会分别介绍两种GRUB版本的两种过程。</p>
<p>4.1 GRUB中stage1.5过程</p>
<p>Stage1.5过程很无辜，它的作用很单一，但是非常关键。它的主要功用就是构造一个boot分区系统对应的文件系统，这样可以通过文件系统的路径（&#x2F;boot&#x2F;grub&#x2F;）寻找stage2过程需要的core.img，进而加载到内存中开始执行。</p>
<p>Stage1.5存在于0面0道3扇区开始的地方，并一直延续十几k字节的区域，具体的大小与相应的文件系统的大小有关（文中涉及到了0面0道1-3+x扇区，这部分扇区为保留扇区，BIOS不会放置任何数据。正因为如此如果转换到GPT分区形式，系统将不能被正确引导，如上文所示，MBR后面的扇区都被其他内容所占据）。Stage1.5过程被构建成多种不同类型，但是功能类似，下面简单介绍一下基本的stage1.5过程的文件系统。e2fs_stage1_5（针对ext2fs，可引导ext2和ext3文件系统）、fat_stage1_5（针对fat文件系统，可引导fat32和fat16）、ffs_stage1_5、jfs_stage1_5、minix_stage1_5、reiserfs_stage1_5、vstafs_stage1_5和xfs_stage1_5，这些文件被称为stage1.5过程，这些文件每个至少都在11k以上。除此之外还有两个比较特殊的文件，分别为nbgrub和pxegrub，这两个文件主要是在网络引导时使用，只是格式不同而已，他们很类似与stage2，只是需要建立网络来获取配置文件。</p>
<p>由于stage1.5过程中会涉及到多个文件系统对应的文件，因此本文中主要以ext2fs为例进行说明，其他文件系统与此类似，可以同样进行分析理解。</p>
<p>对于ext2fs文件系统，用于生成该文件系统的stage1.5过程文件（e2fs_stage1_5）的代码为<code>stage2/fsys_ext2fs.c</code>文件。</p>
<p>在<code>stage2/filesys.h</code>文件中定义了每个文件系统对外的接口，用于上层调用，作为stage2过程寻找核心代码使用，文件系统一般被定义的接口主要就是三个函数，分别是mount、read和dir函数。对应ext2fs，其定义的函数为：</p>
<pre><code>#ifdef FSYS_EXT2FS
#define FSYS_EXT2FS_NUM 1
int ext2fs_mount (void);
int ext2fs_read (char *buf, int len);
int ext2fs_dir (char *dirname);
#else
#define FSYS_EXT2FS_NUM 0
#endif
</code></pre>
<p>针对ext2fs有如上的函数名称，每个函数将具体在<code>stage2/fsys_ext2fs.c</code>文件中被定义，这里面没有包含任何的写的过程，对于bootloader而言仅仅读就可以完成任务了，没必要对其系统进行写操作。其中ext2fs_mount函数用于检查文件系统类型，并将superblock读入到内存中；ext2fs_read函数和ext2fs_dir函数用于对文件系统具体的操作。在<code>stage2/fsys_ext2fs.c</code>文件中除了需要对这三个函数的定义之外，还需要文件系统的属性的数据结构（superblock、inode和group结构，这些结构最初被定义在<code>include/linux/ext2_fs.h</code>文件中），通过这些数据结构描述一个文件系统。</p>
<p>如果读者有兴趣可以试着创建新的文件系统的支持，可以参照目前存在的一些文件系统的模板（实例）编写。</p>
<p>4.2 GRUB中stage2过程</p>
<p>GRUB中的核心过程也就是stage2过程了，该过程主要是在文件系统建立以后选择合适的操作系统进行加载并转交控制权，达到最后引导操作系统的目标。由于GRUB属于multi<br>boot<br>loader，因此在引导的时候要进行选择，选择哪种操作系统来运行。在GRUB内部主要包括两种方式，首先是从menu.list中读取显示到屏幕让用户选择，其次是通过grub-shell中定义的命令手动进行启动。本文将在后面介绍这两种方式如何运行，接下来先介绍一下stage2的具体的执行过程。</p>
<p>在上面一节中介绍过，stage1.5过程中将boot分区的文件系统加载了，之后又做了一件事情，就是将控制权转交给stage2，而stage2入口的地方就是<code>stage2/asm.S</code>文件。<code>Stage2/asm.S</code>文件属于汇编代码，主要作用是初始化C语言的运行环境，为下面执行C语言的函数做好准备，在准备好之后，将执行init_bios_info(<code>stage2/common.c</code>)函数。init_bios_info函数的作用是执行一些底层的函数，然后跳转到cmain执行，cmain函数位于<code>stage2/stage2.c</code>文件中。cmain函数内部进行一个死循环，在循环内部首先加载配置文件，显示给用户，在这同时循环一个内层循环，在内层循环中，获取配置文件中的命令，并解析执行。过程中如果没有可用的配置文件，那么进入命令行模式（enter_cmdline函数），如果找到可用的menu，那么开始执行menu的对应的内容（run_menu函数）。</p>
<p>对于enter_cmdline（<code>stage2/stage2.c</code>）函数，将调用find_command（<code>stage2/cmdline.c</code>），进而执行相应命令的函数。</p>
<p>对于run_menu（<code>stage2/stage2.c</code>）函数，将调用<code>stage2/cmdline.c</code>文件中的run_script函数，进而调用find_command，执行相应命令的函数。</p>
<p>这两种方式虽然经过了不同的过程，对用户输入的行为进行分析和处理，最终调用的函数为find_command，在该函数中顺序循环比较”输入”的命令是否与系统内部定义的相同，如果相同转到执行该函数。在这个比较的过程中包含了一个全局的数据结构为struct<br>builtin（<code>stage2/shared.h</code>），由该数据结构组成了一个table类型（<code>stage2/builtins.c</code>），将命令与相对应的builtin结构对应一起并进行串联。下面描述一下builtin结构的定义：</p>
<pre><code>struct builtin &#123;
  /* 命令名称，重要，是搜索命令时的依据*/
  char *name;
  /* 命令函数，重要，是搜索匹配后调用的函数*/
  int (*func) (char *, int);
  /* 功能标示，一般未用到. */
  int flags;
  /* 简短帮助信息*/
  char *short_doc;
  /* 完整帮助信息*/
  char *long_doc;
&#125;;

struct builtin *builtin_table[]；
</code></pre>
<p>有兴趣的读者可以对上面的内容进行扩展，形成自己的命令，主要在<code>stage2/builtins.c</code>文件中按照预定的格式更新，并添加到builtin_table中即可。</p>
<p>在上面打开配置文件的过程中，主要是通过一些文件操作函数（被定义在<code>stage2/disk_io.c</code>中）完成。这些文件操作函数主要包括：grub_open、grub_read、grub_seek和grub_close等，这些函数属于grub对外的上层接口，具体的函数内部将调用前文中提到的boot分区对应的文件系统的相应的函数完成，这个过程主要是通过回调函数来完成。该过程整体思路类似于面向对象过程，通过对象操作具体的函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/os/mkos/computerstart/" data-id="clhlnylfv00evojuph21n98wq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">自制操作系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/os/mkos/helloos" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/os/mkos/helloos/" class="article-date">
  <time datetime="2015-12-05T09:23:09.000Z" itemprop="datePublished">2015-12-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/os/mkos/helloos/">制作最小操作系统hello world</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>知识点：</p>
<p>程序的起始地址：0x7c00，因为0x00007c00-0x00007dff规定为启动区内容的装载地址</p>
<p>启动扇区的最后两个字节：0x55aa，盘的第一个扇区的最后为0x55aa,表明第一个扇区为启动扇区。</p>
<p>其它的看汇编程序，注释很详细。</p>
<p>程序来源：《自己动手写操作系统》</p>
<pre><code>;
;一个简单的软盘启动程序，启动后输出hello world。
;可以用nasm编译。
;用虚拟机的软驱可以加载运行。
;
    org 07c00h      ; 告诉编译器程序加载到7c00处
    mov ax, cs
    mov ds, ax
    mov es, ax
    call    print_string    ; 调用显示字符串例程
    jmp $       ; 无限循环
print_string:
    mov ax, msg
    mov bp, ax      ; ES:BP = 串地址
    mov cx, 16      ; CX = 串长度
    mov ax, 01301h  ; AH = 13,  AL = 01h
    mov bx, 000ch   ; 页号为0(BH = 0) 黑底红字(BL = 0Ch,高亮)
    mov dl, 0
    int 10h     ; 10h 号中断
    ret
msg:    db  &quot;Hello world!&quot;

; 填充剩下的空间，使生成的二进制代码恰好为512字节
times   510-($-$$) db 0     
dw  0xaa55          ; 结束标志
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/os/mkos/helloos/" data-id="clhlnylfv00eyojup84bq1rw1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">自制操作系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/tools/vim/mutilwindow" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/tools/vim/mutilwindow/" class="article-date">
  <time datetime="2015-12-05T08:01:09.000Z" itemprop="datePublished">2015-12-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/tools/vim/mutilwindow/">vim打开多窗口、多文件之间的切换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、打开多个文件</p>
<p>1.在终端里输入?</p>
<p>vim还没有启动的时候：</p>
<p>vim file1 file2 … filen便可以打开所有想要打开的文件</p>
<p>2.vim已经启动</p>
<p>输入</p>
<p>:e file</p>
<p>可以再打开一个文件，并且此时vim里会显示出file文件的内容。</p>
<p>3.同时显示多个文件：</p>
<p>:sp ? ? ? ? &#x2F;&#x2F;水平切分窗口</p>
<p>:vsplit ? ? &#x2F;&#x2F;垂直切分窗口</p>
<p>二、在文件之间切换：</p>
<p>1.文件间切换</p>
<p>Ctrl+6 ?&#x2F;&#x2F;两文件间的切换</p>
<p>:bn ? ? ?&#x2F;&#x2F;下一个文件</p>
<p>:bp ? ? ?&#x2F;&#x2F;上一个文件</p>
<p>:ls ? ? ? &#x2F;&#x2F;列出打开的文件，带编号</p>
<p>:b1~n ?&#x2F;&#x2F;切换至第n个文件</p>
<p>对于用(v)split在多个窗格中打开的文件，这种方法只会在当前窗格中切换不同的文件。</p>
<p>2.在窗格间切换的方法</p>
<p>Ctrl+w+方向键——切换到前／下／上／后一个窗格</p>
<p>Ctrl+w+h&#x2F;j&#x2F;k&#x2F;l ——同上</p>
<p>Ctrl+ww——依次向后切换到下一个窗格中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/vim/mutilwindow/" data-id="clhlnylgn00jsojup003jg01k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/tools/emacs/emacsdiary/hexl-mode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/tools/emacs/emacsdiary/hexl-mode/" class="article-date">
  <time datetime="2015-12-04T10:30:40.000Z" itemprop="datePublished">2015-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/Emacs/">Emacs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/tools/emacs/emacsdiary/hexl-mode/">Emacs编辑二进制文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ALT+X hexl-mode 进入16进制模式</p>
<p>选中你要修改的位置</p>
<p>ALT+X hexl-insert-hex-char 插入16进制字符</p>
<p>或者</p>
<p>CTRL+ALT+X 命令</p>
<p>然后输入16进制数回车</p>
<p>比如输入40,就代表0x40.</p>
<p>退出命令</p>
<p>ALX+X hexl-mode-exit</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/emacs/emacsdiary/hexl-mode/" data-id="clhlnyliy00x6ojup6q610s7p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Emacs/" rel="tag">Emacs</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/tools/emacs/emacsdiary/cua-mode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/tools/emacs/emacsdiary/cua-mode/" class="article-date">
  <time datetime="2015-12-04T10:21:57.000Z" itemprop="datePublished">2015-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/Emacs/">Emacs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/tools/emacs/emacsdiary/cua-mode/">Emacs可视化列模式cua-mode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>除了emacs本身支持的列模式外，emacs还可以通过cua-mode支持一种可视化的列模式。在cua-mode下，按[C-return]会进入cua rectangle模式。在这个模式下可以通过鼠标点击确认起点，然后通过光标键来选中一个rect范围，这个rect会用另外的颜色显示出来。</p>
<p>之后我们<br>就可以很方便地对这个rect进行操作。比如[M-up],[M-down],[M-left],[M-right]可以移动这个rect，[C-<br>return]可以取消这个rect，[C-space]可以退出cua-rect模式并激活普通模式下的选择。</p>
<p>直接输入字符: 在每行前(或后)都插入这个字符</p>
<ul>
<li>[M-a]: 将rect中的文字左对齐</li>
<li>[M-b]: 用空格(tabs或者spaces)替换所有rect中的字符</li>
<li>[M-c]: 去掉所有行左侧的空格</li>
<li>[M-f]: 用单个字符替换所有rect中的字符(提示输入一个字符)</li>
<li>[M-i]: 对每行中第一个找到的数字进行加1操作(自动把0x开头的当作十六进制数字)</li>
<li>[M-k]: 剪切rect</li>
<li>[M-l]: 把rect中的内容全部转换为小写</li>
<li>[M-m]: 拷贝rect</li>
<li>[M-n]: 用一串自增的数字替换rect中的每一行(这个功能可以用来给每行编号)<br>### 非常好用的功能</li>
<li>[M-o]: rect的内容右移，选中的rect用空格填充</li>
<li>[M-r]: 用字符串替换符满足正则表达式的字符串</li>
<li>[M-R]: 上下反转</li>
<li>[M-s]: 把rect中的每一行替换为一个字符串(提示输入)</li>
<li>[M-t]: 把rect整个替换为一个字符串(提示输入)</li>
<li>[M-u]: 把rect中的内容全部转换为大写</li>
<li>[M-|]: 对rect执行一个shell命令</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/emacs/emacsdiary/cua-mode/" data-id="clhlnylit00wgojupebsj228o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Emacs/" rel="tag">Emacs</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/analyzer/matuse2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/analyzer/matuse2/" class="article-date">
  <time datetime="2015-12-04T06:11:58.000Z" itemprop="datePublished">2015-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/analyzer/matuse2/">【JAVA】使用 Eclipse Memory Analyzer 进行堆转储文件分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述 "></a>概述 </h2><p>对于大型 JAVA应用程序来说，再精细的测试也难以堵住所有的漏洞，即便我们在测试阶段进行了大量卓有成效的工作，很多问题还是会在生产环境下暴露出来，并且很难在测试环境中进行重现。JVM<br>能够记录下问题发生时系统的部分运行状态，并将其存储在堆转储 (Heap Dump)文件中，从而为我们分析和诊断问题提供了重要的依据。</p>
<p>通常内存泄露分析被认为是一件很有难度的工作，一般由团队中的资深人士进行。不过，今天我们要介绍的MAT（Eclipse Memory Analyzer）被认为是一个”傻瓜式”的堆转储文件分析工具，你只需要轻轻点击一下鼠标就可以生成一个专业的分析报告。和其他内存泄露分析工具相比，MAT的使用非常容易，基本可以实现一键到位，即使是新手也能够很快上手使用。</p>
<p>MAT的使用是如此容易，你是不是也很有兴趣来亲自感受下呢，那么第一步我们先来安装MAT。</p>
<h2 id="准备环境和测试数据"><a href="#准备环境和测试数据" class="headerlink" title="准备环境和测试数据 "></a>准备环境和测试数据 </h2><p>我们使用的是 Eclipse Memory Analyzer V0.8，Sun JDK 6</p>
<h3 id="安装-MAT"><a href="#安装-MAT" class="headerlink" title="安装 MAT"></a>安装 MAT</h3><p>和其他插件的安装非常类似，MAT支持两种安装方式，一种是”单机版”的，也就是说用户不必安装 Eclipse IDE环境，MAT 作为一个独立的 Eclipse RCP应用运行；另一种是”集成版”的，也就是说 MAT 也可以作为 Eclipse IDE的一部分，和现有的开发平台集成。</p>
<p>集成版的安装需要借助 Update Manager。</p>
<p>如图 1 所示，首先通过 Help -&gt; Software Updates...启动软件更新管理向导。</p>
<h5 id="图-1-安装插件第一步"><a href="#图-1-安装插件第一步" class="headerlink" title="图 1. 安装插件第一步"></a>图 1. 安装插件第一步</h5><p><img src="/images/janalyzer/image001.jpg" alt="图 1. 安装插件第一步">{width&#x3D;”282”}</p>
<p>选择”Available Software”然后按如图 2 所示的方式添加 MAT 的更新地址<br><a target="_blank" rel="noopener" href="http://download.eclipse.org/technology/mat/0.8/update-site/">http://download.eclipse.org/technology/mat/0.8/update-site/</a>。</p>
<h5 id="图-2-安装插件第二步"><a href="#图-2-安装插件第二步" class="headerlink" title="图 2. 安装插件第二步"></a>图 2. 安装插件第二步</h5><p><img src="/images/janalyzer/image002.jpg" alt="图 2. 安装插件第二步">{width&#x3D;”576”}</p>
<p>如图 3 所示，接下来选择你想要安装的 MAT 的功能点，需要注意的是 Memory Analyzer (Chart)这个功能是一个可选的安装项目，它主要用来生成相关的报表，不过如果需要用到这个功能，你还需要额外的安装<br>BIRT Chart Engine。</p>
<h5 id="图-3-安装插件第三步"><a href="#图-3-安装插件第三步" class="headerlink" title="图 3. 安装插件第三步"></a>图 3. 安装插件第三步</h5><p><img src="/images/janalyzer/image003.jpg" alt="图 3. 安装插件第三步">{width&#x3D;”575”}</p>
<p>插件安装完毕，你还需要重新启动 Eclipse 的工作平台。</p>
<p>比较而言，单机版的安装方式非常简单，用户只需要下载相应的安装包，然后解压缩即可运行，这也是被普遍采用的一种安装方式。在下面的例子里，我们使用的也是单机版的<br>MAT。具体的下载要求和地址可参见其产品下载页面：<a target="_blank" rel="noopener" href="http://www.eclipse.org/mat/downloads.php">http://www.eclipse.org/mat/downloads.php</a>。</p>
<p>另外，如果你需要用 MAT 来分析 IBM JVM 生成的 dump文件的话，还需要额外安装 IBM Diagnostic Tool Framework，具体的下载和安装配置步骤请参见：<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/java/jdk/tools/dtfj.html">http://www.ibm.com/developerworks/java/jdk/tools/dtfj.html</a></p>
<h3 id="配置环境参数"><a href="#配置环境参数" class="headerlink" title="配置环境参数"></a>配置环境参数</h3><p>安装完成之后，为了更有效率的使用MAT，我们还需要做一些配置工作。因为通常而言，分析一个堆转储文件需要消耗很多的堆空间，为了保证分析的效率和性能，在有条件的情况下，我们会建议分配给MAT 尽可能多的内存资源。你可以采用如下两种方式来分配内存更多的内存资源给MAT。</p>
<p>一种是修改启动参数 MemoryAnalyzer.exe -vmargs -Xmx4g</p>
<p>另一种是编辑文件 MemoryAnalyzer.ini，在里面添加类似信息 -vmargs –Xmx4g。</p>
<p>至此，MAT 就已经成功地安装配置好了，开始进入实战吧。</p>
<h3 id="获得堆转储文件"><a href="#获得堆转储文件" class="headerlink" title="获得堆转储文件"></a>获得堆转储文件</h3><p>巧妇难为无米之炊，我们首先需要获得一个堆转储文件。为了方便，本文采用的是Sun JDK 6。通常来说，只要你设置了如下所示的 JVM 参数：</p>
<p>-XX:+HeapDumpOnOutOfMemoryError</p>
<p>JVM就会在发生内存泄露时抓拍下当时的内存状态，也就是我们想要的堆转储文件。</p>
<p>如果你不想等到发生崩溃性的错误时才获得堆转储文件，也可以通过设置如下 JVM参数来按需获取堆转储文件。</p>
<p>-XX:+HeapDumpOnCtrlBreak</p>
<p>除此之外，还有很多的工具，例如<br><a target="_blank" rel="noopener" href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jmap.html">JMap</a>，JConsole都可以帮助我们得到一个堆转储文件。本文实例就是使用 JMap 直接获取了Eclipse Galileo 进程的堆转储文件。您可以使用如下命令：</p>
<p>JMap -dump:format&#x3D;b,file&#x3D;&lt;dumpfile&gt; &lt;pid&gt;</p>
<p>不过，您需要了解到，不同厂家的 JVM所生成的堆转储文件在数据存储格式以及数据存储内容上有很多区别， MAT不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如Sun, HP, SAP 所采用的 HPROF 二进制堆存储文件，以及 IBM 的 PHD堆存储文件等都能被很好的解析（您需要安装额外的插件，请参考<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/java/jdk/tools/dtfj.html">相关说明</a>，本文不作详细解释）。</p>
<p>万事俱备，接下来，我们就可以开始体验一键式的堆存储分析功能了。</p>
<h2 id="生成分析报告"><a href="#生成分析报告" class="headerlink" title="生成分析报告 "></a>生成分析报告 </h2><p>首先，启动前面安装配置好的 Memory Analyzer tool , 然后选择菜单项 File-Open Heap Dump来加载需要分析的堆转储文件。文件加载完成后，你可以看到如图 4所示的界面：</p>
<h5 id="图-4-概览"><a href="#图-4-概览" class="headerlink" title="图 4. 概览"></a>图 4. 概览</h5><p><img src="/images/janalyzer/image004.jpg" alt="图 4. 概览">{width&#x3D;”576”}</p>
<p>通过上面的概览，我们对内存占用情况有了一个总体的了解。先检查一下 MAT生成的一系列文件。</p>
<h5 id="图-5-文件列表"><a href="#图-5-文件列表" class="headerlink" title="图 5. 文件列表"></a>图 5. 文件列表</h5><p><img src="/images/janalyzer/image005.jpg" alt="图 5. 文件列表">{width&#x3D;”331”}</p>
<p>可以看到 MAT 工具提供了一个很贴心的功能，将报告的内容压缩打包到一个 zip文件，并把它存放到原始堆转储文件的存放目录下，这样如果您需要和同事一起分析这个内存问题的话，只需要把这个小小的zip 包发给他就可以了，不需要把整个堆文件发给他。并且整个报告是一个 HTML<br>格式的文件，用浏览器就可以轻松打开。</p>
<p>接下来我们就可以来看看生成的报告都包括什么内容，能不能帮我们找到问题所在吧。您可以点击工具栏上的Leak Suspects 菜单项来生成内存泄露分析报告，也可以直接点击饼图下方的Reports-&gt;Leak Suspects 链接来生成报告。</p>
<h5 id="图-6-工具栏菜单"><a href="#图-6-工具栏菜单" class="headerlink" title="图 6. 工具栏菜单"></a>图 6. 工具栏菜单</h5><p><img src="/images/janalyzer/image006.jpg" alt="图 6. 工具栏菜单">{width&#x3D;”301”}</p>
<h2 id="分析三步曲"><a href="#分析三步曲" class="headerlink" title="分析三步曲 "></a>分析三步曲 </h2><p>通常我们都会采用下面的”三步曲”来分析内存泄露问题：</p>
<p>首先，对问题发生时刻的系统内存状态获取一个整体印象。</p>
<p>第二步，找到最有可能导致内存泄露的元凶，通常也就是消耗内存最多的对象</p>
<p>接下来，进一步去查看这个内存消耗大户的具体情况，看看是否有什么异常的行为。</p>
<p>下面将用一个基本的例子来展示如何采用”三步曲”来查看生产的分析报告。</p>
<h3 id="查看报告之一：内存消耗的整体状况"><a href="#查看报告之一：内存消耗的整体状况" class="headerlink" title="查看报告之一：内存消耗的整体状况"></a>查看报告之一：内存消耗的整体状况</h3><h5 id="图-7-内存泄露分析报告"><a href="#图-7-内存泄露分析报告" class="headerlink" title="图 7. 内存泄露分析报告"></a>图 7. 内存泄露分析报告</h5><p><img src="/images/janalyzer/image007.jpg" alt="图 7. 内存泄露分析报告">{width&#x3D;”576”}</p>
<p>如图 7所示，在报告上最醒目的就是一张简洁明了的饼图，从图上我们可以清晰地看到一个可疑对象消耗了系统99% 的内存。</p>
<p>在图的下方还有对这个可疑对象的进一步描述。我们可以看到内存是由java.util.Vector 的实例消耗的，com.ibm.oti.vm.BootstrapClassLoader负责这个对象的加载。这段描述非常短，但我相信您已经可以从中找到很多线索了，比如是哪个类占用了绝大多数的内存，它属于哪个组件等等。</p>
<p>接下来，我们应该进一步去分析问题，为什么一个 Vector 会占据了系统 99%的内存，谁阻止了垃圾回收机制对它的回收。</p>
<h3 id="查看报告之二：分析问题的所在"><a href="#查看报告之二：分析问题的所在" class="headerlink" title="查看报告之二：分析问题的所在"></a>查看报告之二：分析问题的所在</h3><p>首先我们简单回顾下 JAVA的内存回收机制，内存空间中垃圾回收的工作由垃圾回收器 (Garbage Collector,GC)完成的，它的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象，反之，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配。</p>
<p>在垃圾回收机制中有一组元素被称为根元素集合，它们是一组被虚拟机直接引用的对象，比如，正在运行的线程对象，系统调用栈里面的对象以及被system class loader所加载的那些对象。堆空间中的每个对象都是由一个根元素为起点被层层调用的。因此，一个对象还被某一个存活的根元素所引用，就会被认为是存活对象，不能被回收，进行内存释放。因此，我们可以通过分析一个对象到根元素的引用路径来分析为什么该对象不能被顺利回收。如果说一个对象已经不被任何程序逻辑所需要但是还存在被根元素引用的情况，我们可以说这里存在内存泄露。</p>
<p>现在，让我们开始真正的寻找内存泄露之旅，点击”Details “链接，可以看到如图8 所示对可疑对象 1 的详细分析报告。</p>
<h5 id="图-8-可疑对象-1-的详细分析报告"><a href="#图-8-可疑对象-1-的详细分析报告" class="headerlink" title="图 8. 可疑对象 1 的详细分析报告"></a>图 8. 可疑对象 1 的详细分析报告</h5><p><img src="/images/janalyzer/image008.jpg" alt="图 8. 可疑对象 1的详细分析报告">{width&#x3D;”557”}</p>
<ol>
<li>我们查看下从 GC 根元素到内存消耗聚集点的最短路径：</li>
</ol>
<h5 id="图-9-从根元素到内存消耗聚集点的最短路径"><a href="#图-9-从根元素到内存消耗聚集点的最短路径" class="headerlink" title="图 9. 从根元素到内存消耗聚集点的最短路径"></a>图 9. 从根元素到内存消耗聚集点的最短路径</h5><p><img src="/images/janalyzer/image009.jpg" alt="图 9.从根元素到内存消耗聚集点的最短路径">{width&#x3D;”576”}</p>
<p>我们可以很清楚的看到整个引用链，内存聚集点是一个拥有大量对象的集合，如果你对代码比较熟悉的话，相信这些信息应该能给你提供一些找到内存泄露的思路了。</p>
<p>接下来，我们再继续看看，这个对象集合里到底存放了什么，为什么会消耗掉如此多的内存。</p>
<h5 id="图-10-内存消耗聚集对象信息"><a href="#图-10-内存消耗聚集对象信息" class="headerlink" title="图 10. 内存消耗聚集对象信息"></a>图 10. 内存消耗聚集对象信息</h5><p><img src="/images/janalyzer/image010.jpg" alt="图 10.内存消耗聚集对象信息">{width&#x3D;”509”}</p>
<p>在这张图上，我们可以清楚的看到，这个对象集合中保存了大量 Person对象的引用，就是它导致的内存泄露。</p>
<p>至此，我们已经拥有了足够的信息去寻找泄露点，回到代码，我们发现，是下面的代码导致了内存泄露<br>:</p>
<h5 id="清单-1-内存泄漏的代码段"><a href="#清单-1-内存泄漏的代码段" class="headerlink" title="清单 1. 内存泄漏的代码段"></a>清单 1. 内存泄漏的代码段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (1&lt;2) </span><br><span class="line">&#123; </span><br><span class="line">           </span><br><span class="line">    Person person = new Person(&quot;name&quot;,&quot;address&quot;,i); </span><br><span class="line">    v.add(person); </span><br><span class="line">    person = null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结 "></a>总结 </h2><p>从上面的例子我们可以看到用 MAT来进行堆转储文件分析，寻找内存泄露非常简单，尤其是对于新手而言，这是一个很好的辅助分析工具。但是，MAT绝对不仅仅是一个”傻瓜式”内存分析工具，它还提供很多高级功能，比如 MAT支持用 OQL（Object Query Language）对 heap dump中的对象进行查询，支持对线程的分析等，有关这些功能的使用可以参考 MAT的帮助文档。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/analyzer/matuse2/" data-id="clhlnyli000rnojupf2xac29x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/analyzer/matuse" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/analyzer/matuse/" class="article-date">
  <time datetime="2015-12-03T06:36:48.000Z" itemprop="datePublished">2015-12-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/analyzer/matuse/">【JAVA】使用Eclipse Memory Analyzer分析Tomcat内存溢出</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文用MAT(Eclipse Memory Analyzer)分析Tomcat内存溢出原因。</p>
<p>关于如何获取JAVA堆日志可以参考<a href="/plang/java/analyzer/getthreadheap.php">获取JAVA线程和堆信息</a></p>
<h2 id="MAT安装与介绍"><a href="#MAT安装与介绍" class="headerlink" title="MAT安装与介绍"></a>MAT安装与介绍</h2><p>下载地址：<a target="_blank" rel="noopener" href="http://www.eclipse.org/mat/downloads.php%E3%80%82">http://www.eclipse.org/mat/downloads.php。</a></p>
<p>通过MAT打开dump出来的内存文件，打开后如下图：</p>
<p><img src="/images/janalyzer/matindex.png"></p>
<p>从上图可以看到它的大部分功能。</p>
<ul>
<li>Histogram可以列出内存中的对象，对象的个数以及大小。</li>
<li>Dominator Tree可以列出那个线程，以及线程下面的那些对象占用的空间。</li>
<li>Top consumers通过图形列出最大的object。</li>
<li>Leak Suspects通过MA自动分析泄漏的原因。</li>
</ul>
<h2 id="Histogram界面"><a href="#Histogram界面" class="headerlink" title="Histogram界面"></a>Histogram界面</h2><p>Objects:类的对象的数量。</p>
<p>Shallow<br>size：就是对象本身占用内存的大小，不包含对其他对象的引用，也就是对象头加成员变量（不是成员变量的值）的总和。</p>
<p>Retained size：是该对象自己的shallow<br>size，加上从该对象能直接或间接访问到对象的shallow<br>size之和。换句话说，retained size是该对象被GC之后所能回收到内存的总和。</p>
<p>我们发现ThreadLocal和bingo.persister.dao.Daos类的对象占用了很多空间。</p>
<p><img src="/images/janalyzer/mathistogram.png"></p>
<h2 id="Dominator-Tree界面"><a href="#Dominator-Tree界面" class="headerlink" title="Dominator Tree界面"></a>Dominator Tree界面</h2><p>我们发现quartz的定时器的工作线程（10个）占了很多的内存空间</p>
<p><img src="/images/janalyzer/matdominator.png"></p>
<h2 id="Top-consumers界面"><a href="#Top-consumers界面" class="headerlink" title="Top consumers界面"></a>Top consumers界面</h2><p>这里显示了内存中最大的对象有哪些，他们对应的类是哪些，类加载器classloader是哪些。</p>
<p>有些时候，我们在这里就可以看到代码泄露的位置。</p>
<p><img src="/images/janalyzer/matconsumers.png"></p>
<h2 id="Leak-Suspects界面"><a href="#Leak-Suspects界面" class="headerlink" title="Leak Suspects界面"></a>Leak Suspects界面</h2><p>从那个饼图，该图深色区域被怀疑有内存泄漏，可以发现整个heap才250M内存，深色区域就占了34%。后面的描述，告诉我们quartz线程占用了大量内存，并指出system<br>class<br>loader加载的&quot;java.lang.ThreadLocal&quot;实例的内存中聚集（消耗空间），并建议用关键字&quot;java.lang.ThreadLocal$ThreadLocalMap$Entry[]&quot;进行检查。所以，MAT通过简单的报告就说明了问题所在。</p>
<p><img src="/images/janalyzer/matsuspects.png"></p>
<p>通过Leak Suspects的Problem Suspect 1点击【Details<br>?】，如下图如下图所示的上下文菜单中选择 List objects -&gt; with outgoning<br>references, 查看ThreadLocal都应用了些什么对象。</p>
<p><img src="/images/janalyzer/matsuspects2.png"></p>
<p>现在看到ThreadLocal中引用的对象如下图：是dao对象</p>
<p><img src="/images/janalyzer/matdao.png"></p>
<p>下面继续查看dao的gc ROOT,如下图所示的上下文菜单中选择 Path To GC Roots<br>-&gt; exclude weak references,<br>过滤掉弱引用，因为在这里弱引用不是引起问题的关键。</p>
<p><img src="/images/janalyzer/matdao2.png"></p>
<p>从下图中，可以看到在org.quartz.simpl.SimpleThreadPool中保存了daos的引用。所以可以得出是是因为定时器在运行的过程中持有大量的Daos对象应起了内存泄露。为什么会有那么多的Daos呢,Daos不是一个无状态的单例的、可以重用的吗？继续查看spring配置文件发现Daos的bean配置成scope&#x3D;&quot;prototype&quot;，导致定时任务又是每次调用都生产新的Daos实例。由于是Daos是无状态的，修改为单例的，问题解决。</p>
<p><img src="/images/janalyzer/matdao3.png"></p>
<p>以上是通过MAT分析Tomcat应用程序，找到内存泄露的原因，并解决。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/analyzer/matuse/" data-id="clhlnylhz00rgojupf8wp9juw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/analyzer/dtatools" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/analyzer/dtatools/" class="article-date">
  <time datetime="2015-12-03T05:49:50.000Z" itemprop="datePublished">2015-12-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/analyzer/dtatools/">【JAVA】线程日志分析之TDA</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="java-thread-日志分析工具"><a href="#java-thread-日志分析工具" class="headerlink" title="java thread 日志分析工具"></a>java thread 日志分析工具</h2><p>这里用的是tda(Thread Dump Analyzer)，可以到网上下载到，是个免费的软件。</p>
<p>这个软件可以分析导出的java线程日志，至于如何获取java线程日志，可以看”<a href="%E8%8E%B7%E5%8F%96JAVA%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A0%86%E4%BF%A1%E6%81%AF">获取JAVA线程和堆信息</a>“。</p>
<p><img src="/images/janalyzer/tda.gif">\</p>
<h2 id="各种JAVA线程状态的说明"><a href="#各种JAVA线程状态的说明" class="headerlink" title="各种JAVA线程状态的说明"></a>各种JAVA线程状态的说明</h2><p>先看一下线程的各种状态的状态图：</p>
<p><img src="/images/janalyzer/threadstat.gif">\</p>
<p><img src="/"></p>
<p>下面是日志里线程状态的一些解释。</p>
<h2 id="waiting-for-monitor-entry"><a href="#waiting-for-monitor-entry" class="headerlink" title="waiting for monitor entry"></a>waiting for monitor entry</h2><p>意味着它 在等待进入一个临界区 ，所以它在”Entry<br>Set”队列中等待。此时线程状态一般都是 Blocked</p>
<p>如果大量线程在 “waiting for monitor entry”：</p>
<p>可能是一个全局锁阻塞住了大量线程。</p>
<p>如果短时间内打印的 thread dump 文件反映，随着时间流逝，waiting for<br>monitor entry 的线程越来越多，没有减少的趋势，可能意味着<br>某些线程在临界区里呆的时间太长了，以至于越来越多新线程迟迟无法进入临界区。</p>
<p>java.lang.Thread.State: BLOCKED (on object monitor)</p>
<h2 id="waiting-on-condition"><a href="#waiting-on-condition" class="headerlink" title="waiting on condition"></a>waiting on condition</h2><p>说明它<br>在等待另一个条件的发生，来把自己唤醒，或者干脆它是调用了sleep(N)。此时线程状态大致为以下几种</p>
<p>java.lang.Thread.State: WAITING (parking)：一直等那个条件发生；</p>
<p>java.lang.Thread.State: TIMED_WAITING<br>(parking或sleeping)：定时的，那个条件不到来，也将定时唤醒自己。</p>
<p>如果大量线程在 “ waiting on condition “：</p>
<p>可能是它们又跑去获取第三方资源，<br>尤其是第三方网络资源，迟迟获取不到Response，导致大量线程进入等待状态。</p>
<p>所以如果你发现有大量的线程都处在 Wait on<br>condition，从线程堆栈看，正等待网络读写<br>，这可能是一个网络瓶颈的征兆，因为网络阻塞导致线程无法执行。</p>
<h2 id="in-Object-wait"><a href="#in-Object-wait" class="headerlink" title="in Object.wait()"></a>in Object.wait()</h2><p>说明它 获得了监视器之后，又调用了 java.lang.Object.wait() 方法。</p>
<p>每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 “Active<br>Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set”和<br>“Wait Set”里面等候。在 “Entry Set”中等待的线程状态是 “Waiting for<br>monitor entry”，而在 “Wait Set”中等待的线程状态是 “in Object.wait()”。</p>
<p>当线程获得了<br>Monitor，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被<br>synchronized 的对象）的 wait() 方法，放弃了 Monitor，进入 “Wait<br>Set”队列。此时线程状态大致为以下几种：</p>
<p>java.lang.Thread.State: TIMED_WAITING (on object monitor)；</p>
<p>java.lang.Thread.State: WAITING (on object monitor)；</p>
<h2 id="示范一"><a href="#示范一" class="headerlink" title="示范一"></a>示范一</h2><p>下面这个线程在等待这个锁 0x00000000fe7e3b50，等待进入临界区：</p>
<pre><code>&quot;RMI TCP Connection(64896)-172.16.52.118&quot; daemon prio=10 tid=0x00000000405a6000 nid=0x68fe waiting for monitor entry [0x00007f2be65a3000]
   java.lang.Thread.State: BLOCKED (on object monitor)
at com.xyz.goods.service.impl.GoodsServiceImpl. findChanellGoodsCountWithCache(GoodsServiceImpl.java:1734)
-  waiting to lock &lt;0x00000000fe7e3b50&gt; (a java.lang.String)
</code></pre>
<p>那么谁持有这个锁呢？</p>
<p>是另一个先调用了 findChanellGoodsCountWithCache 函数的线程：</p>
<pre><code>&quot;RMI TCP Connection(64878)-172.16.52.117&quot; daemon prio=10 tid=0x0000000040822000 nid=0x6841 runnable [0x00007f2be76b3000]
   java.lang.Thread.State: RUNNABLE
at java.net.SocketInputStream.socketRead0(Native Method)
at java.net.SocketInputStream.read(SocketInputStream.java:129)
at java.io.BufferedInputStream.fill(BufferedInputStream.java:218)
at java.io.BufferedInputStream.read1(BufferedInputStream.java:258)
at java.io.BufferedInputStream.read(BufferedInputStream.java:317)
- locked &lt;0x00000000af4ed638&gt; (a java.io.BufferedInputStream)
at org.bson.io.Bits.readFully(Bits.java:35)
at org.bson.io.Bits.readFully(Bits.java:28)
at com.mongodb.Response.(Response.java:35)
at com.mongodb.DBPort.go(DBPort.java:110)
- locked &lt;0x00000000af442d48&gt; (a com.mongodb.DBPort)
at com.mongodb.DBPort.go(DBPort.java:75)
- locked &lt;0x00000000af442d48&gt; (a com.mongodb.DBPort)
at com.mongodb.DBPort.call(DBPort.java:65)
at com.mongodb.DBTCPConnector.call(DBTCPConnector.java:202)
at com.mongodb.DBApiLayer$MyCollection.__find(DBApiLayer.java:296)
at com.mongodb.DB.command(DB.java:152)
at com.mongodb.DBCollection.getCount(DBCollection.java:760)
at com.mongodb.DBCollection.getCount(DBCollection.java:731)
at com.mongodb.DBCollection.count(DBCollection.java:697)
at com.xyz.goods.manager.MongodbManager.count(MongodbManager.java:202)
at com.xyz.goods.service.impl.GoodsServiceImpl.findChanellGoodsCount(GoodsServiceImpl.java:1787)
at com.xyz.goods.service.impl.GoodsServiceImpl. findChanellGoodsCountWithCache(GoodsServiceImpl.java:1739)
-  locked &lt;0x00000000fe7e3b50&gt; (a java.lang.String)
</code></pre>
<h2 id="示范二"><a href="#示范二" class="headerlink" title="示范二"></a>示范二</h2><p>等待另一个条件发生来将自己唤醒：</p>
<pre><code>&quot;RMI TCP Connection(idle)&quot; daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2  waiting on condition [0x00007fd4f1a59000]
   java.lang.Thread.State:  TIMED_WAITING (parking)
at sun.misc.Unsafe.park(Native Method)
-  parking to wait for  &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)
at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)
at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:424)
at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:323)
at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:874)
at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:945)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)
at java.lang.Thread.run(Thread.java:662)
</code></pre>
<p>&quot;TIMED_WAITING (parking)&quot;中的 timed_waiting<br>指等待状态，但这里指定了时间，到达指定的时间后自动退出等待状态；parking指线程处于挂起中。</p>
<p>&quot;waiting on condition&quot;需要与堆栈中的&quot;parking to wait for<br>&lt;0x00000000acd84de8&gt; (a<br>java.util.concurrent.SynchronousQueue$TransferStack)&quot;<br>结合来看。首先，本线程肯定是在等待某个条件的发生，来把自己唤醒。其次，SynchronousQueue<br>并不是一个队列，只是线程之间移交信息的机制，当我们把一个元素放入到<br>SynchronousQueue<br>中时必须有另一个线程正在等待接受移交的任务，因此这就是本线程在等待的条件。</p>
<p>示范三</p>
<pre><code>&quot;RMI RenewClean-[172.16.50.182:4888]&quot; daemon prio=10 tid=0x0000000040d2c800 nid=0x97e  in Object.wait() [0x00007f9ccafd0000]
   java.lang.Thread.State:  TIMED_WAITING (on object monitor)
at java.lang.Object.wait(Native Method)
- waiting on &lt;0x0000000799b032d8&gt; (a java.lang.ref.ReferenceQueue$Lock)
at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)
- locked &lt;0x0000000799b032d8&gt; (a java.lang.ref.ReferenceQueue$Lock)
at sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:516)
at java.lang.Thread.run(Thread.java:662)
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/analyzer/dtatools/" data-id="clhlnylhz00riojup1e4v15we" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/analyzer/binjktools" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/analyzer/binjktools/" class="article-date">
  <time datetime="2015-12-03T03:19:28.000Z" itemprop="datePublished">2015-12-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/analyzer/binjktools/">【Java】bin目录监控常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java的安装包自带了很多优秀的工具，善用这些工具对于监控和调试Java程序非常有帮助。常用工具如下：</p>
<h2 id="jps"><a href="#jps" class="headerlink" title="jps "></a>jps </h2><p>用途：jps用来查看JVM里面所有进程的具体状态, 包括进程ID，进程启动的路径等等。</p>
<p>常用参数：</p>
<p>-l: 输出完成的包名称；</p>
<p>-m: 输出程序的命令行输入参数；</p>
<p>-v: 输出完整的JVM参数。</p>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack "></a>jstack </h2><p>用途：1）查看java程序崩溃生成core文件，获得core文件的java stack和native stack的信息；2）查看正在运行的java程序的java stack和native stack的信息：a)<br>查看运行的java程序呈现hung的状态；b) 跟踪Java的调用栈，剖析程序。</p>
<h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>用途：jinfo可观察运行中的java程序的运行环境参数：参数包括Java System属性和JVM命令行参数；也可从core文件里面知道崩溃的Java应用程序的配置信息。</p>
<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat "></a>jstat </h2><p><strong>用途</strong>：jstat利用了JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控等等。</p>
<p><strong>语法结构：</strong></p>
<pre><code>Usage: jstat -help|-options
</code></pre>
<p>       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</p>
<p><strong>参数解释：</strong></p>
<p>Options — 选项，我们一般使用 -gcutil 查看gc情况</p>
<p>vmid    — VM的进程号，即当前运行的java进程号</p>
<p>interval– 间隔时间，单位为秒或者毫秒</p>
<p>count   — 打印次数，如果缺省则打印无数次</p>
<p><strong>具体option参数如下：</strong></p>
<p>-class：统计class loader行为信息</p>
<p>-compile：统计编译行为信息</p>
<p>-gc：统计jdk gc时heap信息</p>
<p>-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况</p>
<p>-gccause：统计gc的情况，（同-gcutil）和引起gc的事件</p>
<p>-gcnew：统计gc时，新生代的情况</p>
<p>-gcnewcapacity：统计gc时，新生代heap容量</p>
<p>-gcold：统计gc时，老年区的情况</p>
<p>-gcoldcapacity：统计gc时，老年区heap容量</p>
<p>-gcpermcapacity：统计gc时，permanent区heap容量</p>
<p>-gcutil：统计gc时，heap情况</p>
<p><strong>输出内容含义如下：</strong></p>
<p>S0  — Heap上的 Survivor space 0 区已使用空间的百分比</p>
<p>S1  — Heap上的 Survivor space 1 区已使用空间的百分比</p>
<p>E   — Heap上的 Eden space 区已使用空间的百分比</p>
<p>O   — Heap上的 Old space 区已使用空间的百分比</p>
<p>P   — Perm space 区已使用空间的百分比</p>
<p>YGC — 从应用程序启动到采样时发生 Young GC 的次数</p>
<p>YGCT– 从应用程序启动到采样时 Young GC 所用的时间(单位秒)</p>
<p>FGC — 从应用程序启动到采样时发生 Full GC 的次数</p>
<p>FGCT– 从应用程序启动到采样时 Full GC 所用的时间(单位秒)</p>
<p>GCT — 从应用程序启动到采样时用于垃圾回收的总时间(单位秒) </p>
<p><strong>示例</strong></p>
<p>实例使用1：</p>
<p>[root@localhost bin]# jstat -gcutil 25444</p>
<p>  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</p>
<p> 11.63   0.00   56.46  66.92  98.49 162    0.248    6      0.331    0.579 </p>
<p>实例使用2：</p>
<p>[root@localhost bin]# jstat -gcutil 25444 1000 5</p>
<p>  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</p>
<p> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583 </p>
<p>我们可以看到，5次young gc之后，垃圾内存被从Eden space区(E)放入了Old space区(O)，并引起了百分比的变化，导致Survivor space使用的百分比从73.54%(S0)降到0%(S1)。有效释放了内存空间。绿框中，我们可以看到，一次full gc之后，Old space区(O)的内存被回收，从99.05%降到67.52%。</p>
<p>图中同时打印了young gc和full gc的总次数、总耗时。而，每次young gc消耗的时间，可以用相间隔的两行YGCT相减得到。每次full gc消耗的时间，可以用相隔的两行FGCT相减得到。例如红框中表示的第一行、第二行之间发生了1次young gc，消耗的时间为0.252-0.252＝0.0秒。</p>
<p>常驻内存区(P)的使用率，始终停留在98.49%左右，说明常驻内存没有突变，比较正常。</p>
<p>如果young gc和full gc能够正常发生，而且都能有效回收内存，常驻内存区变化不明显，则说明java内存释放情况正常，垃圾回收及时，java内存泄露的几率就会大大降低。但也不能说明一定没有内存泄露。</p>
<p>GCT 是YGCT 和FGCT的时间总和。</p>
<p>以上，介绍了Jstat按百分比查看gc情况的功能。其实，它还有功能，例如加载类信息统计功能、内存池信息统计功能等，那些是以绝对值的形式打印出来的，比较少用，在此就不做介绍。 </p>
<p>[root@localhost bin]# ps -ef | grep java</p>
<p>root     25917     1  2 23:23 pts&#x2F;2    00:00:05 &#x2F;usr&#x2F;local&#x2F;jdk1.5&#x2F;bin&#x2F;java -Djava.endorsed.dirs&#x3D;&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30&#x2F;common&#x2F;endorsed -classpath &#x2F;usr&#x2F;local&#x2F;jdk1.5&#x2F;lib&#x2F;tools.jar:&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30&#x2F;bin&#x2F;bootstrap.jar:&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30&#x2F;bin&#x2F;commons-logging-api.jar -Dcatalina.base&#x3D;&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30 -Dcatalina.home&#x3D;&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30 -Djava.io.tmpdir&#x3D;&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30&#x2F;temp org.apache.catalina.startup.Bootstrap start</p>
<p><strong>jstat -class pid:显示加载class的数量，及所占空间等信息。</strong></p>
<p>实例使用3：</p>
<p>[root@localhost bin]# jstat -class 25917</p>
<p>Loaded  Bytes  Unloaded  Bytes     Time</p>
<p>2629    2916.8       29   24.6     0.90 </p>
<p><strong>jstat -compiler pid:显示VM实时编译的数量等信息。</strong></p>
<p>实例使用4：</p>
<p>[root@localhost bin]# jstat -compiler 25917</p>
<p>Compiled Failed Invalid   Time   FailedType FailedMethod</p>
<p>     768      0       0   0.70            0 </p>
<p><strong>jstat –gccapacity :可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小</strong>，如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。其他的可以根据这个类推， OC是old内纯的占用量。 </p>
<p>[root@localhost bin]# jstat -gccapacity 25917</p>
<p>NGCMN       640.0</p>
<p>NGCMX       4992.0</p>
<p>NGC         832.0</p>
<p>S0C         64.0</p>
<p>S1C         64.0</p>
<p>EC          704.0</p>
<p>OGCMN       1408.0</p>
<p>OGCMX       60544.0</p>
<p>OGC         9504.0</p>
<p>OC          9504.0                  OC是old内纯的占用量</p>
<p>PGCMN       8192.0                  PGCMN显示的是最小perm的内存使用量</p>
<p>PGCMX       65536.0                 PGCMX显示的是perm的内存最大使用量</p>
<p>PGC         12800.0                 PGC是当前新生成的perm内存占用量</p>
<p>PC          12800.0                 PC是但前perm内存占用量</p>
<p>YGC         164</p>
<p>FGC         6 </p>
<p><strong>jstat -gcnew pid: new对象的信息</strong></p>
<p>[root@localhost bin]# jstat -gcnew 25917</p>
<p> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</p>
<p> 64.0   64.0   47.4   0.0   2  15   32.0    704.0    145.7    168    0.254 </p>
<p><strong>jstat -gcnewcapacity pid: new对象的信息及其占用量</strong></p>
<p>[root@localhost bin]# jstat -gcnewcapacity 25917</p>
<p> NGCMN  NGCMX   NGC   S0CMX  S0C   S1CMX  S1C   ECMX    EC      YGC   FGC</p>
<p>640.0  4992.0  832.0 64.0   448.0 448.0  64.0   4096.0  704.0  168     6</p>
<p><strong>jstat -gcold pid: old对象的信息。</strong></p>
<p>[root@localhost bin]# jstat -gcold 25917</p>
<p>   PC       PU        OC          OU       YGC    FGC    FGCT     GCT</p>
<p> 12800.0  12617.6     9504.0      6561.3   169     6    0.335    0.591</p>
<p><strong>jstat -gcoldcapacity pid:old对象的信息及其占用量。</strong></p>
<p>[root@localhost bin]# jstat -gcoldcapacity 25917</p>
<p>OGCMN      OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</p>
<p>1408.0     60544.0      9504.0      9504.0   169     6    0.335    0.591 </p>
<p><strong>jstat -gcpermcapacity pid: perm对象的信息及其占用量。</strong></p>
<p>[root@localhost bin]# jstat -gcpermcapacity 25917</p>
<p>PGCMN      PGCMX       PGC         PC      YGC   FGC    FGCT     GCT</p>
<p>8192.0    65536.0    12800.0    12800.0   169     6    0.335    0.591 </p>
<p><strong>jstat -printcompilation pid:当前VM执行的信息。</strong></p>
<p>[root@localhost bin]# jstat -printcompilation -h3  25917 1000 5</p>
<p>每1000毫秒打印一次，一共打印5次，还可以加上-h3每三行显示一下标题。</p>
<p>Compiled  Size  Type Method</p>
<p>     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</p>
<p>     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</p>
<p>     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</p>
<p>Compiled  Size  Type Method</p>
<p>     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</p>
<p>     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</p>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p><strong>用途</strong>：观察运行中的jvm物理内存的占用情况，包括Heap size, Perm size等等。</p>
<p><strong>参数如下：</strong></p>
<p>-heap：打印jvm heap的情况</p>
<p>-histo：打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。</p>
<p>-histo：live ：同上，但是只答应存活对象的情况</p>
<p>-permstat：打印permanent generation heap情况</p>
<p><strong>命令使用：</strong></p>
<p>jmap -heap 2083<br>---- 观察到New Generation（Eden Space，From Space，To Space）,tenured generation,Perm Generation的内存使用情况</p>
<p>jmap -histo 2083 ｜ jmap -histo:live 2083  <br>---- 观察heap中所有对象的情况（heap中所有生存的对象的情况）。包括对象数量和所占空间大小。</p>
<p>jmap -dump:live,format&#x3D;b,file&#x3D;heap.bin 2083 ---- dump java heap in<br>hprof binary format。输出文件可用于进一步分析。</p>
<p>class name对应的就是Class文件里的class的标识<br>B代表byte<br>C代表char<br>D代表double<br>F代表float<br>I代表int<br>J代表long<br>Z代表boolean<br>前边有[代表数组，[I 就相当于int[]<br>对象用[L+类名表示</p>
<p> </p>
<hr>
<p>  <em>BaseType</em> ** Character**   <strong>Type</strong>    <strong>Interpretation</strong><br>  B                           byte        signed byte<br>  C                           char        Unicode character<br>  D                           double      double-precision floating-point value<br>  F                           float       single-precision floating-point value<br>  I                           int         integer<br>  J                           long        long integer<br>  L&lt;classname&gt;;             reference   an instance of class de&gt;&lt;classname&gt;de&gt;<br>  S                           short       signed short<br>  Z                           boolean     de&gt;truede&gt; or de&gt;falsede&gt;<br>  <strong>[</strong>                      reference   one array dimension</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/analyzer/binjktools/" data-id="clhlnylhy00raojupcear4mgl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blog/plang/java/analyzer/getthreadheap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/plang/java/analyzer/getthreadheap/" class="article-date">
  <time datetime="2015-12-03T02:50:14.000Z" itemprop="datePublished">2015-12-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/plang/java/analyzer/getthreadheap/">【JAVA】获取线程和堆信息</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JAVA性能分析的基础是获取线程和堆的信息，本文介绍了常用的获取这两种信息的方法。</p>
<h2 id="如何获得线程信息"><a href="#如何获得线程信息" class="headerlink" title="如何获得线程信息"></a>如何获得线程信息</h2><p>下以命令都是jdk的bin目录里自带的命令。</p>
<p>通过jps获得对应的进程名，然后通过jstack输出线程信息</p>
<p><img src="/images/janalyzer/jps.gif"><img src="/images/janalyzer/jstack.gif"></p>
<p>直接通过jvisualvm导出线程信息</p>
<p><img src="/images/janalyzer/jvmthread.gif"><img src="/images/janalyzer/jvmheapsaveas.gif"></p>
<h2 id="如何获得堆转储"><a href="#如何获得堆转储" class="headerlink" title="如何获得堆转储"></a>如何获得堆转储</h2><p>通过jps获得对应的进程名，然后通过jmap输出</p>
<p><img src="/images/janalyzer/jmap.gif"></p>
<p>通过jvisualvm直接做堆转储</p>
<p><img src="/images/janalyzer/jvmthreadsaveas.gif"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/analyzer/getthreadheap/" data-id="clhlnylhy00rcojup0lqa47ur" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/25/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/27/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/">JAVA WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/Spring-Boot/">Spring Boot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%BC%80%E5%8F%91/">WEB开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/">nosql</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/MongoDB/">MongoDB</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E9%9B%86/">字符集</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/">spark</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/Emacs/">Emacs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/GIT/">GIT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/SSO/">SSO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%B8%80%E8%87%B4%E6%80%A7/">一致性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%AF%86%E7%A0%81%E6%9C%AF/">密码术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/JMS/">JMS</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6/">组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%AE%97%E6%B3%95/">树算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/BASE/">BASE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/JAVA8/">JAVA8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/NIO/">NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/">Lisp</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/Common-Lisp/">Common Lisp</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Scala/">Scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ASCII%E7%A0%81/" rel="tag">ASCII码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActiveMQ/" rel="tag">ActiveMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ajax/" rel="tag">Ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BAT%E8%84%9A%E6%9C%AC/" rel="tag">BAT脚本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAP/" rel="tag">CAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS/" rel="tag">CAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Common-Lisp/" rel="tag">Common Lisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Emacs/" rel="tag">Emacs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Emmet/" rel="tag">Emmet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GIT/" rel="tag">GIT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HttpClient/" rel="tag">HttpClient</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPFS/" rel="tag">IPFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-IO/" rel="tag">JAVA IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-NIO/" rel="tag">JAVA NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-WEB/" rel="tag">JAVA WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA8/" rel="tag">JAVA8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/" rel="tag">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lisp/" rel="tag">Lisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/" rel="tag">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shiro/" rel="tag">Shiro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/" rel="tag">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/" rel="tag">UML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB%E5%BC%80%E5%8F%91/" rel="tag">WEB开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/" rel="tag">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/archtype/" rel="tag">archtype</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/azkaban/" rel="tag">azkaban</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/" rel="tag">hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jquery/" rel="tag">jquery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql/" rel="tag">nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql-neo4j/" rel="tag">nosql neo4j</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openssl/" rel="tag">openssl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/" rel="tag">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webservice/" rel="tag">webservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag">一致性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" rel="tag">任务调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/" rel="tag">字符集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%A1%E8%AE%A1/" rel="tag">审计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E6%9C%AF/" rel="tag">密码术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%BE%E9%80%92%E5%BD%92/" rel="tag">尾递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/" rel="tag">摘要算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" rel="tag">数字签名</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/" rel="tag">数字证书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/" rel="tag">数据权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E7%AE%97%E6%B3%95/" rel="tag">树算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正规表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" rel="tag">知识体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A5%9E%E5%99%A8/" rel="tag">神器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="tag">线程安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">自制操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" rel="tag">负载均衡</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10.5px;">AOP</a> <a href="/tags/ASCII%E7%A0%81/" style="font-size: 10px;">ASCII码</a> <a href="/tags/ActiveMQ/" style="font-size: 11px;">ActiveMQ</a> <a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/BAT%E8%84%9A%E6%9C%AC/" style="font-size: 10px;">BAT脚本</a> <a href="/tags/CAP/" style="font-size: 10px;">CAP</a> <a href="/tags/CAS/" style="font-size: 10.5px;">CAS</a> <a href="/tags/Common-Lisp/" style="font-size: 13.5px;">Common Lisp</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10.5px;">C语言</a> <a href="/tags/Eclipse/" style="font-size: 11px;">Eclipse</a> <a href="/tags/Emacs/" style="font-size: 16.5px;">Emacs</a> <a href="/tags/Emmet/" style="font-size: 10px;">Emmet</a> <a href="/tags/GIT/" style="font-size: 10px;">GIT</a> <a href="/tags/HttpClient/" style="font-size: 12.5px;">HttpClient</a> <a href="/tags/IPFS/" style="font-size: 10px;">IPFS</a> <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/JAVA-IO/" style="font-size: 15.5px;">JAVA IO</a> <a href="/tags/JAVA-NIO/" style="font-size: 17px;">JAVA NIO</a> <a href="/tags/JAVA-WEB/" style="font-size: 10.5px;">JAVA WEB</a> <a href="/tags/JAVA8/" style="font-size: 13.5px;">JAVA8</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Lisp/" style="font-size: 12px;">Lisp</a> <a href="/tags/Markdown/" style="font-size: 10.5px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 18px;">MongoDB</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/Scala/" style="font-size: 11px;">Scala</a> <a href="/tags/Shiro/" style="font-size: 10px;">Shiro</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/VIM/" style="font-size: 16px;">VIM</a> <a href="/tags/WEB%E5%BC%80%E5%8F%91/" style="font-size: 11px;">WEB开发</a> <a href="/tags/XML/" style="font-size: 10.5px;">XML</a> <a href="/tags/archtype/" style="font-size: 10px;">archtype</a> <a href="/tags/azkaban/" style="font-size: 10.5px;">azkaban</a> <a href="/tags/hadoop/" style="font-size: 13px;">hadoop</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/hive/" style="font-size: 10px;">hive</a> <a href="/tags/javascript/" style="font-size: 14px;">javascript</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/linux/" style="font-size: 13px;">linux</a> <a href="/tags/maven/" style="font-size: 12px;">maven</a> <a href="/tags/nosql/" style="font-size: 18.5px;">nosql</a> <a href="/tags/nosql-neo4j/" style="font-size: 11.5px;">nosql neo4j</a> <a href="/tags/openssl/" style="font-size: 11px;">openssl</a> <a href="/tags/servlet/" style="font-size: 11px;">servlet</a> <a href="/tags/spark/" style="font-size: 12px;">spark</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/webservice/" style="font-size: 11px;">webservice</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 11.5px;">一致性</a> <a href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" style="font-size: 10.5px;">任务调度</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 10px;">区块链</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 17.5px;">大数据</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/" style="font-size: 12.5px;">字符集</a> <a href="/tags/%E5%AE%A1%E8%AE%A1/" style="font-size: 10px;">审计</a> <a href="/tags/%E5%AF%86%E7%A0%81%E6%9C%AF/" style="font-size: 14.5px;">密码术</a> <a href="/tags/%E5%B0%BE%E9%80%92%E5%BD%92/" style="font-size: 10px;">尾递归</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 12px;">并发</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 14px;">排序</a> <a href="/tags/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/" style="font-size: 10px;">摘要算法</a> <a href="/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" style="font-size: 10.5px;">数字签名</a> <a href="/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/" style="font-size: 10px;">数字证书</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 18.5px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/" style="font-size: 10px;">数据权限</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 11.5px;">杂谈</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 13.5px;">架构</a> <a href="/tags/%E6%A0%91%E7%AE%97%E6%B3%95/" style="font-size: 14px;">树算法</a> <a href="/tags/%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正规表达式</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" style="font-size: 12px;">知识体系</a> <a href="/tags/%E7%A5%9E%E5%99%A8/" style="font-size: 12px;">神器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.5px;">算法</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" style="font-size: 19px;">线程安全</a> <a href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">自制操作系统</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.5px;">设计模式</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 13px;">负载均衡</a> <a href="/tags/%E9%94%81/" style="font-size: 11px;">锁</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2999/12/">十二月 2999</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/02/">二月 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/09/">九月 2009</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/explain/">【置顶】特别说明</a>
          </li>
        
          <li>
            <a href="/blog/tools/maven/dn-cst-maven-archtype/">开发一个maven脚手架</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustrystock/">neo4j创建行业与股票关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustry/">neo4j创建三级行业关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jtimeline/">neo4j创建时间线</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 证心<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>