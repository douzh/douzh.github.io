<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>OneKBase</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="OneKBase">
<meta property="og:url" content="http://www.onekbase.com/page/27/index.html">
<meta property="og:site_name" content="OneKBase">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="证心">
<meta name="twitter:card" content="summary">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">OneKBase</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">归一</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" target="_blank" rel="noopener" href="http://site.onekbase.com">ITEEDU</a>
        
          <a class="main-nav-link" href="/about/">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.onekbase.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-blog/tools/vim/vimcolmode" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/tools/vim/vimcolmode/" class="article-date">
  <time class="dt-published" datetime="2015-12-02T10:27:21.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/tools/vim/vimcolmode/">Vim列模式的应用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在nomal模式下进入列模式Windows和Linux不同。</p>
<p>Windows下：Ctrl+p</p>
<p>Linux下：Ctrl+v</p>
<p>进入之后按正常的移动命令移动鼠标选中编辑部分。</p>
<p>在区块前和区块后可以添加文本内容：</p>
<p>在区块前：Shift+i</p>
<p>在区块后：Shift+a</p>
<p>内容只能手动输入，输入时只有首行有变化，输入后退出模式，所有的行都会必变。</p>
<p>还可以在列模式下删除替换文本，和正常编辑命令一样，修改是只对第一行修改，退出后对所有行起作用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/vim/vimcolmode/" data-id="clhlnylgo00jxojup0e8j74mz" data-title="Vim列模式的应用" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/plang/java/base/javanetpgm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/plang/java/base/javanetpgm/" class="article-date">
  <time class="dt-published" datetime="2015-12-01T07:11:48.000Z" itemprop="datePublished">2015-12-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/BASE/">BASE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/plang/java/base/javanetpgm/">JAVA网络编程概要</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h2><p>7 应用层 : telnet，HTTP,FTP,NFS,SMTP</p>
<p>6 表示层</p>
<p>5 会话层</p>
<p>4 传输层 : 是否选择差错恢复协议还是无差错恢复协议，TCP、UDP协议</p>
<p>3 网络层 ：对端到端的包传输进行定义，IP协议</p>
<p>2 数据链路层 :<br>数据链路的建立,拆除,对数据的检错,纠错是数据链路层的基本任务</p>
<p>1 物理层：有关传输介质的特性标准，提供传输媒体及其连接</p>
<h2 id="网络四层层协议"><a href="#网络四层层协议" class="headerlink" title="网络四层层协议"></a>网络四层层协议</h2><p>实际的实现不是按七层开发来的，是四层。</p>
<p>七层协议中的物理层、会话层、表达层只是一种定义，实际上是没有实现的。</p>
<p><img src="/images/java/javanet7p.png"></p>
<h2 id="JAVA网络通信过程"><a href="#JAVA网络通信过程" class="headerlink" title="JAVA网络通信过程"></a>JAVA网络通信过程</h2><p><img src="http://iteedu.com/images/java/javasocket.png">\</p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>构造函数</p>
<pre><code>Socket()
Socket(InetAddress address, int port)throws UnknownHostException, IOException
Socket(InetAddress address, int port, InetAddress localAddress, int localPort)throws IOException
Socket(String host, int port)throws UnknownHostException, IOException
Socket(String host, int port, InetAddress localAddress, int localPort)throws IOException
</code></pre>
<p>除去第一种不带参数的之外，其它构造函数会尝试建立与服务器的连接。如果失败会抛出IOException错误。如果成功，则返回Socket对象。</p>
<p>InetAddress是一个用于记录主机的类，其静态getHostByName(String<br>msg)可以返回一个实例，其静态方法getLocalHost()也可以获得当前主机的IP地址，并返回一个实例。</p>
<p>Socket(String host, int port, InetAddress localAddress, int<br>localPort)构造函数的参数分别为目标IP、目标端口、绑定本地IP、绑定本地端口。</p>
<p>主要方法：</p>
<pre><code>getInetAddress();    //远程服务端的IP地址
getPort();    　　　//远程服务端的端口
getLocalAddress()   //本地客户端的IP地址
getLocalPort()    　//本地客户端的端口
getInputStream();   //获得输入流
getOutStream();    //获得输出流
isClosed(); //连接是否已关闭，若关闭，返回true；否则返回false
isConnect();　　//如果曾经连接过，返回true；否则返回false
isBound();  //如果Socket已经与本地一个端口绑定，返回true；否则返回false
</code></pre>
<h2 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h2><p>构造函数</p>
<pre><code>ServerSocket()throws IOException
ServerSocket(int port)throws IOException
ServerSocket(int port, int backlog)throws IOException
ServerSocket(int port, int backlog, InetAddress bindAddr)throws IOException
</code></pre>
<p>注意点：</p>
<p>1.port服务端要监听的端口；backlog客户端连接请求的队列长度；bindAddr服务端绑定IP</p>
<p>2.如果端口被占用或者没有权限使用某些端口会抛出BindException错误。譬如1~1023的端口需要管理员才拥有权限绑定。</p>
<p>3. 如果设置端口为0，则系统会自动为其分配一个端口；</p>
<p>4.bindAddr用于绑定服务器IP，为什么会有这样的设置呢，譬如有些机器有多个网卡。</p>
<p>5.ServerSocket一旦绑定了监听端口，就无法更改。ServerSocket()可以实现在绑定端口前设置其他的参数。</p>
<p>多线程的ServerSocket示例：</p>
<pre><code>public void service()&#123;
    while(true)&#123;
        Socket socket=null;
        try&#123;
            socket=serverSocket.accept();    //主线程获取客户端连接
            Thread workThread=new Thread(new Handler(socket)); //创建线程
            workThread.start();  //启动线程
        &#125;catch(Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

class Handler implements Runnable&#123;
    private Socket socket;
    public Handler(Socket socket)&#123;
        this.socket=socket;
    &#125;
    
    public void run()&#123;
        try&#123;
            System.out.println(&quot;新连接:&quot;+socket.getInetAddress()+&quot;:&quot;+socket.getPort());
            Thread.sleep(10000);
        &#125;catch(Exception e)&#123;e.printStackTrace();&#125;finally&#123;
            try&#123;
                System.out.println(&quot;关闭连接:&quot;+socket.getInetAddress()+&quot;:&quot;+socket.getPort());
                if(socket!=null)socket.close();
            &#125;catch(IOException e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="URL对象示例"><a href="#URL对象示例" class="headerlink" title="URL对象示例"></a>URL对象示例</h2><pre><code>URL url = new URL(&quot;http://www.cnblogs.com/linjiqin/&quot;);
BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
String inputLine;
while ((inputLine = in.readLine()) != null) &#123;
System.out.println(inputLine);
&#125;
in.close();
</code></pre>
<h2 id="URLConnection示例"><a href="#URLConnection示例" class="headerlink" title="URLConnection示例"></a>URLConnection示例</h2><p>通过URL的方法openStream()，我们只能从网络上读取数据，如果我们同时还想输出数据，例如向服务器端的CGI程序发送一些数据，我们必须先与URL建立连接，然后才能对其进行读写，这时就要用到类URLConnection了。</p>
<pre><code>//创建URL对象
URL url=new URL(&quot;http://www.javasoft.com/cgi-bin/backwards&quot;);
//由URL对象获取URLConnection对象
URLConnection conn=url.openConnection();
//由URLConnection获取输入流，并构造DataInputStream对象
DataInputStream dis=new DataInputStream(conn.getInputStream()); 
//由URLConnection获取输出流，并构造PrintStream对象
PrintStream ps=new PrintStream(conn.getOutputStream());
String line=dis.readLine(); 
ps.println(&quot;client…&quot;); //向服务器写出字符串 &quot;client…&quot;
</code></pre>
<h2 id="DatagramSocket"><a href="#DatagramSocket" class="headerlink" title="DatagramSocket"></a>DatagramSocket</h2><p>DatagramSocket具有的主要方法如下：</p>
<p>receive(DatagramPacket<br>d)：接收数据报文到d中。receive方法产生一个”阻塞”。”阻塞”是一个专业名词，它会产生一个内部循环，使程序暂停在这个地方，直到一个条件触发。</p>
<p>send(DatagramPacket dp)：发送报文dp到目的地。</p>
<p>setSoTimeout(int timeout)：设置超时时间，单位为毫秒。</p>
<p>close()：关闭DatagramSocket。在应用程序退出的时候，通常会主动释放资源，关闭Socket，但是由于异常地退出可能造成资源无法回收。所以，应该在程序完成时，主动使用此方法关闭Socket，或在捕获到异常抛出后关闭Socket。</p>
<pre><code>DatagramSocket  server = new DatagramSocket(5050);
</code></pre>
<h2 id="DatagramPacket"><a href="#DatagramPacket" class="headerlink" title="DatagramPacket"></a>DatagramPacket</h2><p>用于处理报文，它将Byte数组、目标地址、目标端口等数据包装成报文或者将报文拆卸成Byte数组。应用程序在产生数据包是应该注意，TCP&#x2F;IP规定数据报文大小最多包含65507个，通常主机接收548个字节，但大多数平台能够支持8192字节大小的报文。</p>
<p>DatagramPacket类的构建器共有4个：</p>
<p>DatagramPacket(byte[] buf, int<br>length)：将数据包中Length长的数据装进Buf数组，一般用来接收客户端发送的数据。</p>
<p>DatagramPacket(byte[] buf, int offset, int<br>length)：将数据包中从Offset开始、Length长的数据装进Buf数组。</p>
<p>DatagramPacket(byte[] buf, int length, InetAddress clientAddress, int<br>clientPort)：从Buf数组中，取出Length长的数据创建数据包对象，目标是clientAddress地址，clientPort端口,通常用来发送数据给客户端。</p>
<p>DatagramPacket(byte[] buf, int offset, int length, InetAddress<br>clientAddress, int<br>clientPort)：从Buf数组中，取出Offset开始的、Length长的数据创建数据包对象，目标是clientAddress地址，clientPort端口，通常用来发送数据给客户端。</p>
<p>主要的方法如下：</p>
<p>getData(): 从实例中取得报文的Byte数组编码。</p>
<p>setDate(byte[] buf)：将byte数组放入要发送的报文中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/plang/java/base/javanetpgm/" data-id="clhlnylhq00ppojupczwh93hc" data-title="JAVA网络编程概要" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/pytx/jsdql" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/pytx/jsdql/" class="article-date">
  <time class="dt-published" datetime="2015-11-30T06:07:03.000Z" itemprop="datePublished">2015-11-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/pytx/jsdql/">技术的囚笼</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="技术的囚笼"><a href="#技术的囚笼" class="headerlink" title="技术的囚笼"></a>技术的囚笼</h2><p>公司和个人会因为已经熟悉了某种技术而对有替代性的更先进技术有抗拒心理，当转换成本越大时这种倾向越明显。</p>
<p>天下大势，浩浩汤汤，顺之者昌，逆之者亡。</p>
<p>我写这篇文章只表述个人对未来技术的一些看法，可能会戳中某些人的痛点，你可以想想自己有没有被学过的技术困住。</p>
<h2 id="MVC还是那个MVC吗？"><a href="#MVC还是那个MVC吗？" class="headerlink" title="MVC还是那个MVC吗？"></a>MVC还是那个MVC吗？</h2><p>MVC是个老话题，百说不厌。过去的MVC就不说了，我想说说新趋势。</p>
<p>我们看到网页内容可以分为三个阶段，数据获取、数据装载、数据渲染。</p>
<p>这个过程已经发生了翻天覆地的变化。过去网页在服务器上生成，服务器返回一个网页，浏览器再把网页渲染成我们看到的内容。</p>
<p>现在服务器已经不再生成网页了，更倾向于提供数据接口，只保留了数据获取阶段，其它两个阶段都放浏览器端做了。</p>
<p>过程是这样的，加载的页面会加载js组件，js组件会从服务器接口获取数据，装载数据，渲染现在已经不止浏览器对HTML渲染了，还可以把数据渲染到canvas上，可以看一下百度的echarts，也可以看一些webgl的例子。</p>
<p>这样有很多好处。</p>
<p>服务器端技术已经不受具体限制了，只要接口返回指定格式的数据就行。所以可以用各种语言和框架编程，不用担心技术过时或受技术交替的冲击。</p>
<p>前端的显示也可以赶上多变的技术，更炫的效果还是要用canvas做渲染。webgl的和种框架可以做出很炫的3D动画，所以想像已经不受技术的限制了。有了新渲染框架和数据对接一下就OK了。</p>
<p>将来的前端会桌面化，加载一次，以后交互都只是数据更新。话说已经有好多这种例子了。</p>
<p>所以最先死的是各种P：jsp、php、asp等，还有各种基于P的标签组件技术。</p>
<h2 id="语言的大一统"><a href="#语言的大一统" class="headerlink" title="语言的大一统"></a>语言的大一统</h2><p>语言有两个端，C和LISP。</p>
<p>我是用JAVA的，JAVA好不好用？真心的不好用，当然和C++比还是有优势的。但用JAVA的地方太多了，所以一时也死不了。</p>
<p>将来的语言会怎么发展？</p>
<p>我觉得各种语言会死掉，但各种语言的虚拟机还会活很长时间。因为在各种虚拟机上会出现很多LISP方言，可以复用现有的库。但这已经不是原来的语言了，一个语言最重要的是语言的语法，语法都不一样了，就不能算一种语言了。</p>
<p>漫长的混乱之后，可能各种虚拟机也都消失了。LISP方言也有了统一的标准。这时我们发现我们在用一种20世纪60年代的编程语言，多么的可笑。</p>
<h2 id="LISP不是一种语言"><a href="#LISP不是一种语言" class="headerlink" title="LISP不是一种语言"></a>LISP不是一种语言</h2><p>LISP语言并不是一种语言，而是一种语法。列表形式的语法可以做到代码即数据，数据即代码。从而实现LISP的宏功能，让每个人都可以定义自己的语言。</p>
<p>用列表做语法的都可以认为是LISP方言，实现了LISP宏的都可以认为是完备的LISP方言。</p>
<p>自己的才是最好的，这一点对开发人员体现优为重要。</p>
<p>LISP语法实在太简单了，有点编程基础的人都可以写一个简单的LISP解析器。</p>
<p>LISP成为大一统的原因很简单：至简则至快，至快则至强，至强则无敌。</p>
<p>“天下武功无坚不破,唯快不破”，这在IT领域也是至理名言。以至于《黑客与画家》的作者把LISP当作他创业成功的秘密武器。</p>
<p>其实这很好理解：</p>
<p>同样的时间做更多的事意味着成本低。</p>
<p>更短的时间做更多的事意味着对手不可能超过你。</p>
<p>快意味着：更便宜、客户更满意、对手有你就有、你有对手没有的。这就是技术壁垒。</p>
<p>ASM、C、LISP，我们画了一个圈，又回到了原点。最终还是这三个古老的语言取得了胜利。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/pytx/jsdql/" data-id="clhlnyldc000rojup88dz5k04" data-title="技术的囚笼" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-blog/javaweb/verificationcode" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/javaweb/verificationcode/" class="article-date">
  <time class="dt-published" datetime="2015-11-24T03:08:43.000Z" itemprop="datePublished">2015-11-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/javaweb/verificationcode/">如何给java web应用添加登录验证码</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这片文章主要讲如何时在java web项目中如何给登录添加验证码功能。</p>
<h2 id="添加验证码主要工作："><a href="#添加验证码主要工作：" class="headerlink" title="添加验证码主要工作："></a>添加验证码主要工作：</h2><p>做一个验证码图片的生成类，在网上有很多，copy一个很方便。</p>
<p>做一个验证码的图片接口，通过链接可以访问，返回一张图片。</p>
<p>做一个filter，对登录请求进行拦截，判断验证码是否正确。</p>
<p>登录页面加上一个IMG节点，通过js设置其显示验证码。</p>
<h2 id="做一个验证码图片生成类："><a href="#做一个验证码图片生成类：" class="headerlink" title="做一个验证码图片生成类："></a>做一个验证码图片生成类：</h2><p>直接在网上复制了一个，还挺好用的。</p>
<pre><code>import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.Random;
import javax.imageio.ImageIO;
import javax.imageio.stream.ImageOutputStream;

/**
 * 验证码相关
 * VerificationCodeUtil
 * @author douzh
 * @version 1.0
 *
 */

public class VerificationCodeUtil &#123;
    public static String VCODE_SESSION_KEY=&quot;Verification_Code_Key&quot;;
    private ByteArrayInputStream image;//图像 

    private String str;//验证码 

    private VerificationCodeUtil() &#123;
        init();//初始化属性 
    &#125;

    /*
     * 取得RandomNumUtil实例
     */
    public static VerificationCodeUtil Instance() &#123;
        return new VerificationCodeUtil();
    &#125;

    /*
     * 取得验证码图片
     */
    public ByteArrayInputStream getImage() &#123;
        return this.image;
    &#125;

    /*
     * 取得图片的验证码
     */
    public String getString() &#123;
        return this.str;
    &#125;

    private void init() &#123;
        // 在内存中创建图象 
        int width = 85, height = 30;
        BufferedImage image = new BufferedImage(width, height,
                BufferedImage.TYPE_INT_RGB);
        // 获取图形上下文 
        Graphics g = image.getGraphics();
        // 生成随机类 
        Random random = new Random();
        // 设定背景色 
        g.setColor(getRandColor(200, 250));
        g.fillRect(0, 0, width, height);
        // 设定字体 
        g.setFont(new Font(&quot;Times New Roman&quot;, Font.PLAIN, 25));
        // 随机产生155条干扰线，使图象中的认证码不易被其它程序探测到 
        g.setColor(getRandColor(160, 200));
        for (int i = 0; i &lt; 155; i++) &#123;
            int x = random.nextInt(width);
            int y = random.nextInt(height);
            int xl = random.nextInt(12);
            int yl = random.nextInt(12);
            g.drawLine(x, y, x + xl, y + yl);
        &#125;
        // 取随机产生的认证码(6位数字) 
        String sRand = &quot;&quot;;
        for (int i = 0; i &lt; 6; i++) &#123;
            String rand = String.valueOf(random.nextInt(10));
            sRand += rand;
            // 将认证码显示到图象中 
            g.setColor(new Color(20 + random.nextInt(110), 20 + random
                    .nextInt(110), 20 + random.nextInt(110)));
            // 调用函数出来的颜色相同，可能是因为种子太接近，所以只能直接生成 
            g.drawString(rand, 13 * i + 6, 25);
        &#125;
        //赋值验证码
        this.str = sRand;

        //图象生效 
        g.dispose();
        ByteArrayInputStream input = null;
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        try &#123;
            ImageOutputStream imageOut = ImageIO
                    .createImageOutputStream(output);
            ImageIO.write(image, &quot;JPEG&quot;, imageOut);
            imageOut.close();
            input = new ByteArrayInputStream(output.toByteArray());
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;验证码图片产生出现错误：&quot; + e.toString());
        &#125;

        this.image = input;/* 赋值图像 */
    &#125;

    /*
     * 给定范围获得随机颜色
     */
    private Color getRandColor(int fc, int bc) &#123;
        Random random = new Random();
        if (fc &gt; 255)
            fc = 255;
        if (bc &gt; 255)
            bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    &#125;
&#125;
</code></pre>
<h2 id="做一个返回验证码的接口："><a href="#做一个返回验证码的接口：" class="headerlink" title="做一个返回验证码的接口："></a>做一个返回验证码的接口：</h2><pre><code>    public void getVcImage() &#123;
        try &#123;
            VerificationCodeUtil vc = VerificationCodeUtil.Instance();
            InputStream s = vc.getImage();
            this.getHttpRequest()
                    .getSession()
                    .setAttribute(VerificationCodeUtil.VCODE_SESSION_KEY,
                        vc.getString());
            ServletOutputStream outputStream = getHttpResponse()
                    .getOutputStream();
            if (s != null) &#123;
                IOUtils.copy(s, outputStream);
                IOUtils.closeQuietly(s);
                IOUtils.closeQuietly(outputStream);
            &#125;
        &#125; catch (Exception e) &#123;
            logger.error(&quot;获取验证码出错&quot;, e);
            writJsonResult(new ErrorPojo(&quot;syserror&quot;, &quot;获取验证码出错！&quot;));
        &#125;
        return;
    &#125;
</code></pre>
<p>注意，要把验证码对应的字符串放到session里，以供验证对比用。IOUtils是用的org.apache.commons.io里的类。</p>
<p>现在就可以通过浏览器访问接口返回一张验证码图片了。</p>
<h2 id="拦截登录请求的filter"><a href="#拦截登录请求的filter" class="headerlink" title="拦截登录请求的filter"></a>拦截登录请求的filter</h2><p>先写一个处理验证码的Filter类</p>
<pre><code>/**
 * 过滤验证码
 * VCodeFilter
 * @version 1.0
 *
 */
public class VCodeFilter extends BaseLogic implements Filter &#123;

    @Override
    public void destroy() &#123;

    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException &#123;
        HttpServletRequest servletRequest = null;
        try &#123;
            servletRequest = (HttpServletRequest) request;
            HttpServletResponse servletResponse = (HttpServletResponse) response;
            String action = servletRequest.getQueryString();
            if (StringUtils.isNotBlank(action)
                    &amp;&amp; action.startsWith(&quot;action=login&quot;)) &#123;
                String vcode = request.getParameter(&quot;j_vcode&quot;);
                if(StringUtils.isBlank(vcode))&#123;
                    writeResult(&quot;请先填写验证码&quot;,servletResponse);
                    return;
                &#125;
                String vcode2 = (String) servletRequest.getSession()
                        .getAttribute(VerificationCodeUtil.VCODE_SESSION_KEY);
                if(StringUtils.isBlank(vcode2))&#123;
                    writeResult(&quot;验证码已经过期，重新获取&quot;,servletResponse);
                    return;
                &#125;
                if(!vcode2.equals(vcode))&#123;
                    writeResult(&quot;验证码填写不正确，请重新填写&quot;,servletResponse);
                    return;
                &#125;
            &#125;
            chain.doFilter(servletRequest, servletResponse);
        &#125; catch (Exception e) &#123;
            logger.error(&quot;查看出现异常时候的方法&quot; + servletRequest.getMethod());
        &#125;

    &#125;
    /**
     * 向response管道写数据
     * 
     * @param data 输出的数据
     */
    protected void writeResult(String data,HttpServletResponse resp) &#123;
        try &#123;
            resp.setCharacterEncoding(&quot;UTF-8&quot;);
            resp.getWriter().write(data);
            resp.getWriter().flush();
            resp.getWriter().close();
        &#125; catch (IOException e) &#123;
            logger.error(&quot;接口输出内容出错&quot;, e);
        &#125;
    &#125;
    @Override
    public void init(FilterConfig config) throws ServletException &#123;
    &#125;
&#125;
</code></pre>
<p>添加对于filter配制。</p>
<pre><code>    &lt;filter&gt;
        &lt;filter-name&gt;VCodeFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;
            com.xxxx.support.VCodeFilter
        &lt;/filter-class&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;VCodeFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/login.do&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<p>这样所有的登录请求先要过验证码这一关。</p>
<h2 id="登录界面的验证码"><a href="#登录界面的验证码" class="headerlink" title="登录界面的验证码"></a>登录界面的验证码</h2><p>添加一个img节点：</p>
<p>用js初始化节点。</p>
<pre><code>function initVcode()&#123;
$(&quot;#vcode&quot;).attr(&#39;src&#39;,contextPath+&quot;/paramsApi.do?action=getVcImage&amp;time=&quot;+new Date().getTime()); ;
&#125;;
initVcode();
</code></pre>
<p>参数加个时间戳是为了防止浏览器缓存验证码图片。</p>
<h2 id="之后呢"><a href="#之后呢" class="headerlink" title="之后呢"></a>之后呢</h2><p>要有一个input让用户输入验证码，提交登录信息时也把这项提交上，filter就会处理带验证吗的请求了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/javaweb/verificationcode/" data-id="clhlnylcy0001ojup1qd6hkdv" data-title="如何给java web应用添加登录验证码" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-blog/tools/vim/vimgy" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/tools/vim/vimgy/" class="article-date">
  <time class="dt-published" datetime="2015-11-20T04:26:14.000Z" itemprop="datePublished">2015-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/tools/vim/vimgy/">vim格言</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文内容来自：《学习VI和VIM编辑器第７版》附录D</p>
<p>定理：vi是完美的。</p>
<p>证明：VI是罗马数字中的6。可以被6整除又小于6的自然数是1、2、3,<code>1+2+3=6</code>。因 此6是一个完美数。因此，vi是完美的。</p>
<p>—Arthur Tateishi</p>
<p>Nathan. T. Oelger的响应：</p>
<p>因此，将上面的结果用在Vim会如何呢？</p>
<p>VIM在罗马数字中是代表<code>(1000-(5 +1))= 994</code>，等于<code>2*496+2</code>。496可以被1、2、4、8、16、31、62、124<br>与248整除，而 <code>1+2+4+8+16+31+62+124+248=496</code>,所以，496是一个完美数。</p>
<p>因此，Vim比vi完美两倍，再加上许多的好东西。</p>
<p>也就是说，Vim比完美更美好。</p>
<p>这一则格言道尽了所有真正的vi爱好者的心声：</p>
<p>对我来说，vi就是禅。使用vi,就是参禅。每一个命令都是心印。来自内心深处，非有经验不能明白。每一次使用，都会发现真理。</p>
<p>—-Satish Reddy</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/vim/vimgy/" data-id="clhlnylgt00kuojup7wb3d4q0" data-title="vim格言" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/tools/vim/vimthinking" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/tools/vim/vimthinking/" class="article-date">
  <time class="dt-published" datetime="2015-11-15T13:11:31.000Z" itemprop="datePublished">2015-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/tools/vim/vimthinking/">VIM核心思想</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="本文的由来"><a href="#本文的由来" class="headerlink" title="本文的由来"></a>本文的由来</h2><p>学习Vim一时间，一直不得要领。编辑器之神没啥学习要领，鬼也不信。我的方法就是多看书，一本书浏览一遍，不行就换一本。</p>
<p>我在《学习VI和VIM编辑器第７版中文》貌似找到了这种感觉。下面来说一说。</p>
<p>Vim的成功之处在于它抽像了编辑操作的本质，针对编辑操作的本质给出了一套解决方案。</p>
<h2 id="思想一：分模式"><a href="#思想一：分模式" class="headerlink" title="思想一：分模式"></a>思想一：分模式</h2><p>从大的角度看编辑操作分两种：</p>
<p>新录入：需要连接性的输入文本，可能还要边输入边编辑。</p>
<p>修改已有：对现有文件做边边角角的修改，主要是浏览查找。</p>
<p>从这两个角度VIM给出了两个模式：</p>
<p>插入模式：对应新录入。</p>
<p>命令模式：对应修改已有。</p>
<p>这里的命令模式包含很多地方说的“正常模式”和“命令模式”。</p>
<h3 id="一些新手误区"><a href="#一些新手误区" class="headerlink" title="一些新手误区"></a>一些新手误区</h3><p>插入模式没有编辑命令</p>
<p>开始使用VIM觉得插入模式进行编辑不方便，其实插入模式也可以有很多Ctrl或Alt配合的命令，可以自己来定义。这样插入模式就有了一般编辑器的所有功能了，还可以定义出只属于自己的功能。</p>
<p>ESC太远太难用</p>
<p>开始觉得ESC使用不方便，模式的切换太频繁，ESC都按到吐了。其实还有其它键也等同ESC，比如Ctrl+[，再觉得不方便还可以自己定义。我看网上有很多人定义jj键，就是在插入模式连续输入jj就可以退到命令模式。</p>
<p>模式切换太频繁</p>
<p>如果你用VIM要频繁的切换模式，说明你没有好好学习VIM。插入模式一般不用切换到命令模式，常用命令可以自己定义快捷键。你应该学学<a href="/ide/vim/vimdiary/vimmap.php">Vim按键映射(Map)</a></p>
<h2 id="思想二：抽像编辑操作"><a href="#思想二：抽像编辑操作" class="headerlink" title="思想二：抽像编辑操作"></a>思想二：抽像编辑操作</h2><p>首先看一下VIM的一般命令模式：</p>
<pre><code>(编辑命令)(次数)(光标命令)
</code></pre>
<p>或</p>
<pre><code>(次数)(编辑命令)(光标命令)
</code></pre>
<p>光标命令是指光标移动的命令，如最常见的<code>hjkl</code>。</p>
<p>那一般命令模式的意思就是：“编辑指定文本几次”。</p>
<p>所以只要学会编辑命令和光标移动命令，其它的都是一些组合出的功能了。</p>
<h3 id="VIM帮助"><a href="#VIM帮助" class="headerlink" title="VIM帮助"></a>VIM帮助</h3><p>这里不会对命令进行详细说明，详细了解最好的还是用vim的帮助，学会vim帮助是学好vim的必须功课。</p>
<p>比如<code>:h d</code>会跳到vim命令d的帮助部分:</p>
<pre><code>[&quot;x]d&#123;motion&#125;        Delete text that &#123;motion&#125; moves over [into register
            x].  See below for exceptions
</code></pre>
<p>[“x]是可选的寄存器选项，以中括号括起来的是可选的意思，里面是默认值。</p>
<p>{motiont}和(光标命令)一样，是指确认处理哪些文本的光标命令。</p>
<h3 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h3><p>编辑命令比较少，所以先说。</p>
<p>编辑操作一般就几种：删除、复制、剪切、粘贴、修改。</p>
<p>在VIM中对应的命令：</p>
<ul>
<li>删除：d[elete]或x，x其它是dl的简写，可以看帮助。</li>
<li>复制：y[ank]，很多地方翻译为「拔」，把内容放到寄存器。</li>
<li>剪切：VIM里删除即是剪切，删除的内容会放到寄存器。</li>
<li>粘贴：p[ut]，放置，把寄存器里的内容放到指定位置。</li>
<li>修改：c[hange]、s[ub]、r{place]，将内容放入寄存器，并插入新内容。</li>
</ul>
<p>所以vim命令第一个字母一般都是ydpc里的一个。</p>
<h3 id="光标移动命令"><a href="#光标移动命令" class="headerlink" title="光标移动命令"></a>光标移动命令</h3><p>基本的上下左右对应<code>hjkl</code>，这也不是什么缩写，只是最快捷的键方式。</p>
<p>行内移动：</p>
<ul>
<li>w：右移光标到下一个字的开头；</li>
<li>e：右移光标到一个字的末尾；</li>
<li>b：左移光标到前一个字的开头；</li>
<li>0：数字０，左移光标到本行的开始；</li>
<li>$：右移光标，到本行的末尾；</li>
<li>^：移动光标，到本行的第一个非空字符。</li>
</ul>
<p>翻页：</p>
<ul>
<li>ctrl+f[orward]：在文件中前移一页（相当于 page down）；</li>
<li>ctrl+b[ackward]：在文件中后移一页（相当于 page up）；</li>
</ul>
<p>按其它方式移动：</p>
<ul>
<li>(&#x2F;)：移动到 前&#x2F;后 句 的开始；</li>
<li>{&#x2F;}：跳转到 当前&#x2F;下一个 段落 的开始。</li>
<li>gg：将光标定位到文件第一行起始位置；</li>
<li>G将光标定位到文件最后一行起始位置；</li>
<li>NG或Ngg:将光标定位到第 N 行的起始位置。</li>
<li>*：当光标停留在一个单词上，*<br>键会在文件内搜索该单词，并跳转到下一处；</li>
<li>#当光标停留在一个单词上，# 在文件内搜索该单词，并跳转到上一处；</li>
<li>g_ ：到本行最后一个不是 blank 字符的位置。</li>
<li>fa：到下一个为 a 的字符处，你也可以fs到下一个为s的字符。</li>
<li>t,：到逗号前的第一个字符。逗号可以变成其它字符。</li>
<li>F&#x2F;T：和 f 和 t 一样，只不过是相反方向;</li>
</ul>
<h3 id="一些组合示例"><a href="#一些组合示例" class="headerlink" title="一些组合示例"></a>一些组合示例</h3><ul>
<li>dw:删除光标右侧的字；</li>
<li>3dw:删除光标右侧的 3 个字；</li>
<li>5db:删除光标左侧的 5 个字；</li>
<li>3dd:删除（剪切） 3 行内容，并去除空隙；</li>
<li>d$:从当前光标起删除字符直到行的结束；</li>
<li>d0:从当前光标起删除字符直到行的开始；</li>
<li>c$:用输入的正文替换从光标开始到本行末尾的所有字符；</li>
<li>c0:用输入的正文替换从本行开头到光标的所有字符。</li>
<li>5yy:复制 5 行内容到内存缓冲区；</li>
<li>ncw:用输入的正文替换光标右侧的 n 个字；</li>
</ul>
<h2 id="以冒号-开头的命令"><a href="#以冒号-开头的命令" class="headerlink" title="以冒号(:)开头的命令"></a>以冒号(:)开头的命令</h2><p>如果要了解以冒号(:)开头的这些命令，还要了解一下vi的历史，vi是对unix的ex行编辑器的扩展，对ex可视化产物。所以vi里的精髓还是ex这些命令。</p>
<p>vim里的以冒号(:)开头的这些命令大多是ex的命令，所以学好vim还要学ex的命令，你也可以以为是学vim，其实是在学ex。</p>
<p>ex的常用命令格式：</p>
<pre><code>:(行地址符)(命令)
</code></pre>
<h3 id="行地址"><a href="#行地址" class="headerlink" title="行地址"></a>行地址</h3><p>对于每一个 ex 编辑命令，必须给出 ex 所要编辑的行。对于 ex 的 move 和<br>copy 命令，还需要给出 ex 移动或复制文本的目标位置。</p>
<p>可以使用下面几种方式来指定行地址：</p>
<p>[1] 使用明确的行号。</p>
<p>[2] 使用能帮助你指定相对于文件中当前位置的行号的符号。</p>
<p>[3] 使用搜索模式作为标识所要编辑的行的地址。</p>
<p>这里就不说太详细了，列一此常用的ex命令：</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>:e file2 &#x2F;&#x2F;使用 :e 进入文件 file2 中</li>
<li>:w &#x2F;&#x2F;把缓冲区写（保存）到文件中但不退出</li>
<li>:q &#x2F;&#x2F;退出编辑器</li>
<li>:wq &#x2F;&#x2F;写文件并退出编辑器，即使没有修改文件，写操作也会无条件的进行</li>
<li>:x &#x2F;&#x2F;写文件并退出编辑器，只有修改了文件，写操作才能进行</li>
<li>:q! &#x2F;&#x2F;在退出时不影响原来的文本</li>
<li>: 230 , $ w newfile &#x2F;&#x2F;将从第230行到文件末尾的文本保存到“newfile”中</li>
<li>: . , 600 w newfile &#x2F;&#x2F;将从当前行到第600行的文本保存到“newfile”中</li>
</ul>
<p>其它命令：</p>
<ul>
<li>:3,18d &#x2F;&#x2F;d[elete]删除3~18行</li>
<li>:160,224m23 &#x2F;&#x2F;m[ove]移动160~224行到23行的下面</li>
<li>:23,29co100 &#x2F;&#x2F;co[py]复制23~29行并把它们粘贴到100行的后面</li>
<li>: . , $d &#x2F;&#x2F;删除从当前行到文件末尾之间的文本</li>
<li>:%d &#x2F;&#x2F;删除文件中所有行</li>
<li>:%t$ &#x2F;&#x2F;复制所有行并把它们粘贴到文件的尾部</li>
<li>: 226 , $m . -2 &#x2F;&#x2F;把226行到文件末尾的文本移动到当前行上面的第二行</li>
<li>:&#x2F;pattern&#x2F;d &#x2F;&#x2F;删除下一个包含模式pattern的行</li>
<li>:1 , 3d | s&#x2F;thier&#x2F;their&#x2F; &#x2F;&#x2F;把1到3行删除，然后在当前行进行替换</li>
<li>:1 ,5 m 10 | g&#x2F;pattern&#x2F;nu<br>&#x2F;&#x2F;把1到5行移动到第10行的后面，然后显示所有包含模式pattern的行和行号</li>
</ul>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>vi核心是ex，多学ex的命令绝对有好处。</p>
<p>掌握vi的几个编辑命令和10几个光标移动命令，组合使用实现名称功能。</p>
<p>自己的vim才是好vim，学会用map定义自己的快捷键。</p>
<p>做完这些基本就完成了常用功能的学习，再学点要用的插件或编写插件，其它编辑器基本就不用了。</p>
<p>最后再来一句，vi的成功源于ex的强大，但不得不说模式确实是点睛之笔。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/vim/vimthinking/" data-id="clhlnylgt00kxojupc9fg0n64" data-title="VIM核心思想" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/tools/vim/vimmap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/tools/vim/vimmap/" class="article-date">
  <time class="dt-published" datetime="2015-11-11T09:15:01.000Z" itemprop="datePublished">2015-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/tools/vim/vimmap/">Vim按键映射(Map)详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Map简介"><a href="#Map简介" class="headerlink" title="Map简介"></a>Map简介</h2><p>Map是Vim强大的一个重要原因，可以自定义各种快捷键。</p>
<p>不只是将键映射，还可以将键映射到一组操作上，这种功能类似宏功能。</p>
<p>所以要想用好VIM还要把众多基本功能都有了解，才能组合出自己需要的快捷键。</p>
<p>使用以下命令，可以在Normal Mode和Visual&#x2F;Select Mode下，利用Tab键和Shift-Tab键来缩进文本：</p>
<pre><code>nmap  V&gt;
nmap  V&lt;
vmap  &gt;gv
vmap  
</code></pre>
<p>使用以下命令，指定F10键来新建标签页：</p>
<pre><code>:map  :tabnew
</code></pre>
<p>简而言之，map把快捷键映射为了指定的操作。</p>
<h2 id="命令的组合"><a href="#命令的组合" class="headerlink" title="命令的组合"></a>命令的组合</h2><p>同Vim下的其他命令一样，命令的名字往往由好几段组成。前缀作为命令本身的修饰符，微调命令的效果。</p>
<ul>
<li>nore:表示非递归，见下面的介绍</li>
<li>n:表示在普通模式下生效</li>
<li>v:表示在可视模式下生效</li>
<li>i:表示在插入模式下生效</li>
<li>c:表示在命令行模式下生效</li>
</ul>
<h2 id="递归Recursive-Mapping"><a href="#递归Recursive-Mapping" class="headerlink" title="递归Recursive Mapping"></a>递归Recursive Mapping</h2><p>递归的映射。其实很好理解，也就是如果键a被映射成了b，c又被映射成了a，如果映射是递归的，那么c就被映射成了b。</p>
<p>:map a b :map c a</p>
<p>对于c效果等同于</p>
<p>:map c b</p>
<p>默认的map就是递归的。如果遇到[nore]这种前缀，比如:noremap，就表示这种map是非递归的。</p>
<h2 id="常用map命令"><a href="#常用map命令" class="headerlink" title="常用map命令"></a>常用map命令</h2><p>这里列出常用的一些map命令，默认map命令影响到普通模式和可视模式。</p>
<ul>
<li>:map :noremap :unmap :mapclear</li>
<li>:nmap :nnoremap :nunmap :nmapclear</li>
<li>:vmap :vnoremap :vunmap :vmapclear</li>
<li>:imap :inoremap :iunmap :imapclear</li>
<li>:cmap :cnoremap :cunmap :cmapclear</li>
</ul>
<h2 id="不同map命令和模式的关系"><a href="#不同map命令和模式的关系" class="headerlink" title="不同map命令和模式的关系"></a>不同map命令和模式的关系</h2><table>
<thead>
<tr>
<th>命令</th>
<th>常规模式</th>
<th>可视化模式</th>
<th>运算符模式</th>
<th>插入模式</th>
<th>命令行模式</th>
</tr>
</thead>
<tbody><tr>
<td><code>:map</code>{.inset}</td>
<td>y</td>
<td>y</td>
<td>y</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>:nmap</code>{.inset}</td>
<td>y</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>:vmap</code>{.inset}</td>
<td></td>
<td>y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>:omap</code>{.inset}</td>
<td></td>
<td></td>
<td>y</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>:map!</code>{.inset}</td>
<td></td>
<td></td>
<td></td>
<td>y</td>
<td>y</td>
</tr>
<tr>
<td><code>:imap</code>{.inset}</td>
<td></td>
<td></td>
<td></td>
<td>y</td>
<td></td>
</tr>
<tr>
<td><code>:cmap</code>{.inset}</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>y</td>
</tr>
</tbody></table>
<h2 id="其它键"><a href="#其它键" class="headerlink" title="其它键"></a>其它键</h2><p>unmap</p>
<p>unmap后面跟着一个按键组合，表示删除这个映射。</p>
<p>:unmap c</p>
<p>那么在map生效模式下，c不再被映射到a上。</p>
<p>同样，unmap可以加各种前缀，表示影响到的模式。</p>
<p>mapclear</p>
<p>mapclear直接清除相关模式下的所有映射。</p>
<p>同样，mapclear可以加各种前缀，表示影响到的模式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/vim/vimmap/" data-id="clhlnylgq00kaojup30ab1xuo" data-title="Vim按键映射(Map)详解" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/os/bat/bakdbfile" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/os/bat/bakdbfile/" class="article-date">
  <time class="dt-published" datetime="2015-11-11T03:03:35.000Z" itemprop="datePublished">2015-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/os/bat/bakdbfile/">【BAT】实记备份数据库和文件的bat脚本</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一个备份网站数据库和附件和bat，记一下要点：</p>
<pre><code>@echo on
:: 设置 mysqldump.exe路径
set dumpcmd=&quot;C:\Program Files (x86)\MySQL\MySQL Server 5.1\bin\mysqldump.exe&quot;
::数据库用户名
set user=
::数据库连接密码
set pwd=
::备份文件目录,保证对应分区是存在的
set bakpath=D:\bak\
::要备份的附件目录
set fjpath=&quot;d:\test&quot;
::----------------开始备份-------------
set &quot;Ymd=%date:~,4%%date:~5,2%%date:~8,2%&quot;
::备份文件名
set bakfile=cms_web_%Ymd%.sql
set fname=%bakpath%%bakfile%
if not exist bakpath mkdir %bakpath%
%dumpcmd% -u %user% -p%pwd% cms_web&gt; %fname%
::只保留最后5个备份
dir /a-d/b %bakpath% | sort /r&gt;%bakpath%zlist.txt
set /a num=0
for /f &quot;usebackq skip=6 delims=&quot;  %%i in (%bakpath%zlist.txt) do del %bakpath%%%i
del %bakpath%zlist.txt
::------------------------备份附件------------------------
::要备份的目录不存在则不备份
if not exist %fjpath% goto end
::备份文件夹名称
set bakfjpath=%bakpath%nw%Ymd%
::已经备份过就不备份了
if exist %bakfjpath% goto end
if not exist bakpath mkdir %bakfjpath%
xcopy %fjpath% %bakfjpath% /e
dir /ad/b %bakpath% | sort /r&gt;%bakpath%zdirlist.txt
set /a num=0
for /f &quot;usebackq skip=5 delims=&quot;  %%i in (%bakpath%zdirlist.txt) do rd /s/q %bakpath%%%i
del %bakpath%zdirlist.txt
: end
pause
</code></pre>
<p>每天备份一次，只保留最近五天的：</p>
<p>实现思路，备份文件按名称排序，跳过前5个，删除以后的。</p>
<p>当然，分析文件名日期删除是最好的，但太麻烦了，所以用了这种简单的方法。</p>
<p>获取文件列表的方法：</p>
<pre><code>dir /a-d/b %bakpath% | sort /r&gt;%bakpath%zlist.txt
</code></pre>
<p>&quot;dir &#x2F;a-d&#x2F;b&quot;分析：</p>
<p>&#x2F;a是输出所有文件目录</p>
<p>-d是减去目录，所以只输出文件了</p>
<p>&#x2F;b的作用是只输出文件名，其它信息不输出</p>
<p>sort &#x2F;r是将文件名排序</p>
<p>&gt;%bakpath%zlist.txt是将结果输出到zlist.txt文件</p>
<p>删除文件分析：</p>
<pre><code>for /f &quot;usebackq skip=6 delims=&quot;  %%i in (%bakpath%zlist.txt) do del %bakpath%%%i
</code></pre>
<p>这行代码的作用是遍历zlist.txt文件，跳过前6行，因为zlist.txt是第一个，还要跳过5个备份文件，所以是6个，删除其余的文件。</p>
<p>附件的删除和这类似，只不过删除命令不同，就不说了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/os/bat/bakdbfile/" data-id="clhlnylfs00eeojupcl9t67be" data-title="【BAT】实记备份数据库和文件的bat脚本" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BAT%E8%84%9A%E6%9C%AC/" rel="tag">BAT脚本</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/tools/vim/vimaltjk" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/tools/vim/vimaltjk/" class="article-date">
  <time class="dt-published" datetime="2015-11-10T10:06:04.000Z" itemprop="datePublished">2015-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/tools/vim/vimaltjk/">Vim移动一行或一段代码</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>将一行（以回车为准，也可理解为一段）上&#x2F;下移一行，也就是与上&#x2F;下一段交换位置，这么常用的一功能，一定要加上。</p>
<pre><code>nmap  mz:m+`z
nmap  mz:m-2`z
vmap  :m&#39;&gt;+`mzgv`yo`z
vmap  :m&#39;&lt;-2`&gt;my`
</code></pre>
<p>把上面代码放到vim的配置文件_vimrc，这段代码实现的效果是:</p>
<p>在“普通模式”或“可视模式”下，同时按[Alt]+[j] 或[Alt]+[k]<br>可将鼠标所在段数据向上、向下移。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/vim/vimaltjk/" data-id="clhlnylgn00jpojup0vfr5g6z" data-title="Vim移动一行或一段代码" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/tools/vim/vimfaqzwlm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/tools/vim/vimfaqzwlm/" class="article-date">
  <time class="dt-published" datetime="2015-11-10T09:22:54.000Z" itemprop="datePublished">2015-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/tools/vim/vimfaqzwlm/">Vim打开中文文件乱码问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Vim有四个跟字符编码方式有关的选项，encoding、fileencoding、fileencodings、termencoding(这些选项设置请参考Vim文档中encoding-names章节)，它们的意义如下:</p>
<ul>
<li>encoding<br>encoding是Vim内部使用的字符编码方式，包括Vim的buffer(缓冲区)、菜单文本、消息文本等。默认是根据你的locale选择。VIM用户手册上建议只在.vimrc中改变它的值，事实上似乎也只有在.vimrc中改变它的值才有意义。你可以用另外一种编码来编辑和保存文件，如你的vim的encoding为utf-8,所编辑的文件采用cp936编码,vim会自动将读入的文件转成utf-8(vim的能读懂的方式），而当你写入文件时,又会自动转回成cp936（文件的保存编码)。</li>
<li>fileencoding<br>Vim中当前编辑的文件的字符编码方式，Vim保存文件时也会将文件保存为这种字符编码方式(不管是否新文件都如此)。</li>
<li>fileencodings<br>Vim自动探测fileencoding的顺序列表，启动时会按照它所列出的字符编码方式逐一探测即将打开的文件的字符编码方式，并且将fileencoding 设置为最终探测到的字符编码方式。因此最好将Unicode编码方式放到这个列表的最前面，将拉丁语系编码方式 latin1放到最后面。</li>
<li>termencoding<br>Vim所工作的终端(或者Windows的Console窗口)的字符编码方式。如果vim所在的term与vim编码相同，则无需设置。如其不然，你可以用vim的termencoding选项将自动转换成term的编码.这个选项对GUI模式Vim(GVim)无效，而对Console模式的Vim而言就是Windows控制台的代码页，并且通常我们不需要改变它。</li>
</ul>
<p>现在来看看Vim的多字符编码方式支持是如何工作的：</p>
<ol>
<li>启动Vim，根据.vimrc文件中设置的encoding的值来设置buffer、菜单文本、消息文的字符编码方式。</li>
<li>读取需要编辑的文件，根据fileencodings中列出的字符编码方式逐一探测该文件编码方式。并设置fileencoding为探测到的，看起来是正确的字符编码方式。</li>
<li>对比fileencoding和encoding的值，若不同则调用iconv将文件内容转换为encoding所描述的字符编码方式，并且把转换后的内容放到为此文件开辟的buffer里，此时我们就可以开始编辑这个文件了。注意，完成这一步动作需要调用外部的iconv.dll，你需要保证这个文件存在于$VIMRUNTIME或者其他列在PATH环境变量中的目录里。</li>
<li>编辑完成后保存文件时，再次对比fileencoding和encoding的值。若不同，再次调用iconv将即将保存的buffer中的文本转换为fileencoding所描述的字符编码方式，并保存到指定的文件中。同样，这需要调用iconv.dll由于Unicode能够包含几乎所有的语言的字符，而且Unicode的UTF-8编码方式又是非常具有性价比的编码方式(空间消耗比 UCS-2小)，因此建议encoding的值设置为utf-8。这么做的另一个理由是encoding设置为utf-8 时，Vim 自动探测文件的编码方式会更准确 (或许这个理由才是主要的;)。我们在中文Windows里编辑的文件，为了兼顾与其他软件的兼容性，文件编码还是设置为GB2312&#x2F;GBK比较合适，因此fileencoding建议设置为chinese(chinese是个别名，在Unix里表示gb2312，在Windows里表示cp936，也就是GBK的代码页)。</li>
</ol>
<p>当vim在utf-8的local下打开gbk文件时，显示的是乱码，可以在~&#x2F;.vimrc文件中加入如下代码来解决：</p>
<pre><code>set fencs=utf-8,gbk
</code></pre>
<p>这一行的作用是告诉vim，打开一个文件时，尝试utf8,gbk两种编码，vim只需要扫描文件的前一段，就可以根据文件里面的数据判断出文件是否用的是utf8或者gbk编码。如果不指定这一行，则vim只会用当前编码(locale)来打开文件，因为locale是UTF-8，而文件是gbk，所以打开是乱码。</p>
<p>一般vim打开中文文件时出现乱码时可以用下面的方法来解决：</p>
<pre><code>set fileencoding=gb18030 
set fileencodings=utf-8,gb18030,utf-16,big5
</code></pre>
<p>这样设置的原因说明如下：vim里面的编码主要跟三个参数有关：enc(encoding),fenc(fileencoding)和fencs(fileencodings)。其中fenc是当前文件的编码，也就是说，一个在vim里面已经正确显示了的文件(前提是你的系统环境跟你的enc设置匹配)，你可以通过改变fenc后再w来将此文件存成不同的编码。比如说，我:set fenc&#x3D;utf-8然后:w就把文件存成utf-8的了，:set fenc&#x3D;gb18030再:w就把文件存成gb18030的了。这个值对于打开文件的时候是否能够正确地解码没有任何关系。fencs就是用来在打开文件的时候进行解码的猜测列表。文件编码没有百分百正确的判断方法，所以vim只能猜测文件编码。比如我的vimrc里面这个的设置是：</p>
<pre><code>set fileencodings=utf-8,gb18030,utf-16,big5
</code></pre>
<p>所以我的vim每打开一个文件，先尝试用utf-8进行解码，如果用utf-8解码到了一半出错(所谓出错的意思是某个地方无法用utf-8正确地解码)，那么就从头来用gb18030重新尝试解码，如果gb18030又出错(注意gb18030并不是像utf-8似的规则编码，所以所谓的出错只是说某个编码没有对应的有意义的字，比如0)，就尝试用utf-16，仍然出错就尝试用big5。这一趟下来，如果中间的某次解码从头到尾都没有出错，那么vim就认为这个文件是这个编码的，不会再进行后面的尝试了。这个时候，fenc的值就会被设为vim最后采用的编码值，可以用:set fenc来查看具体是什么。</p>
<p>当然这个也是有可能出错的，比如你的文件是gb18030编码的，但是实际上只有一两个字符是中文，那么有可能他们正好也能被utf-8解码，那么这个文件就会被误认为是utf-8的导致错误解码。</p>
<p>至于enc，其作用基本只是显示。不管最后的文件是什么编码的，vim都会将其转换为当前系统编码来进行处理，这样才能在当前系统里面正确地显示出来，因此enc就是干这个的。在windows下面，enc默认是cp936，这也就是中文windows的默认编码，所以enc是不需要改的。在linux下，随着你的系统locale可能设为zh_CN.gb18030或者zh_CN.utf-8，你的enc要对应的设为gb18030或者utf-8(或者gbk之类的)。</p>
<p>最后再来说一下新建空文件的默认编码。看文档好像说会采用fencs里面的第一个编码作为新建文件的默认编码。但是这里有一个问题，就是fencs的顺序跟解码成功率有很大关系，根据我的经验utf-8在前比gb18030在前成功率要高一些，那么如果我新建文件默认想让它是gb18030编码怎么办？一个方法是每次新建文件后都:set fenc&#x3D;gb18030一下，不过我发现在vimrc里面设置fenc&#x3D;gb18030也能达到这个效果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/vim/vimfaqzwlm/" data-id="clhlnylgp00k3ojup2577cwzq" data-title="Vim打开中文文件乱码问题" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/26/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><a class="page-number" href="/page/29/">29</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/28/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/">JAVA WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/Spring-Boot/">Spring Boot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%BC%80%E5%8F%91/">WEB开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/">nosql</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/MongoDB/">MongoDB</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E9%9B%86/">字符集</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/">spark</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/Emacs/">Emacs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/GIT/">GIT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/SSO/">SSO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%B8%80%E8%87%B4%E6%80%A7/">一致性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%AF%86%E7%A0%81%E6%9C%AF/">密码术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/JMS/">JMS</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6/">组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%AE%97%E6%B3%95/">树算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/BASE/">BASE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/JAVA8/">JAVA8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/NIO/">NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/">Lisp</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/Common-Lisp/">Common Lisp</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Scala/">Scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10.5px;">AOP</a> <a href="/tags/ASCII%E7%A0%81/" style="font-size: 10px;">ASCII码</a> <a href="/tags/ActiveMQ/" style="font-size: 11px;">ActiveMQ</a> <a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/BAT%E8%84%9A%E6%9C%AC/" style="font-size: 10px;">BAT脚本</a> <a href="/tags/CAP/" style="font-size: 10px;">CAP</a> <a href="/tags/CAS/" style="font-size: 10.5px;">CAS</a> <a href="/tags/Common-Lisp/" style="font-size: 13.5px;">Common Lisp</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10.5px;">C语言</a> <a href="/tags/Eclipse/" style="font-size: 11px;">Eclipse</a> <a href="/tags/Emacs/" style="font-size: 16.5px;">Emacs</a> <a href="/tags/Emmet/" style="font-size: 10px;">Emmet</a> <a href="/tags/GIT/" style="font-size: 10px;">GIT</a> <a href="/tags/HttpClient/" style="font-size: 12.5px;">HttpClient</a> <a href="/tags/IPFS/" style="font-size: 10px;">IPFS</a> <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/JAVA-IO/" style="font-size: 15.5px;">JAVA IO</a> <a href="/tags/JAVA-NIO/" style="font-size: 17px;">JAVA NIO</a> <a href="/tags/JAVA-WEB/" style="font-size: 10.5px;">JAVA WEB</a> <a href="/tags/JAVA8/" style="font-size: 13.5px;">JAVA8</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Lisp/" style="font-size: 12px;">Lisp</a> <a href="/tags/Markdown/" style="font-size: 10.5px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 18px;">MongoDB</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/Scala/" style="font-size: 11px;">Scala</a> <a href="/tags/Shiro/" style="font-size: 10px;">Shiro</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/VIM/" style="font-size: 16px;">VIM</a> <a href="/tags/WEB%E5%BC%80%E5%8F%91/" style="font-size: 11px;">WEB开发</a> <a href="/tags/XML/" style="font-size: 10.5px;">XML</a> <a href="/tags/archtype/" style="font-size: 10px;">archtype</a> <a href="/tags/azkaban/" style="font-size: 10.5px;">azkaban</a> <a href="/tags/hadoop/" style="font-size: 13px;">hadoop</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/hive/" style="font-size: 10px;">hive</a> <a href="/tags/javascript/" style="font-size: 14px;">javascript</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/linux/" style="font-size: 13px;">linux</a> <a href="/tags/maven/" style="font-size: 12px;">maven</a> <a href="/tags/nosql/" style="font-size: 18.5px;">nosql</a> <a href="/tags/nosql-neo4j/" style="font-size: 11.5px;">nosql neo4j</a> <a href="/tags/openssl/" style="font-size: 11px;">openssl</a> <a href="/tags/servlet/" style="font-size: 11px;">servlet</a> <a href="/tags/spark/" style="font-size: 12px;">spark</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/webservice/" style="font-size: 11px;">webservice</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 11.5px;">一致性</a> <a href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" style="font-size: 10.5px;">任务调度</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 10px;">区块链</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 17.5px;">大数据</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/" style="font-size: 12.5px;">字符集</a> <a href="/tags/%E5%AE%A1%E8%AE%A1/" style="font-size: 10px;">审计</a> <a href="/tags/%E5%AF%86%E7%A0%81%E6%9C%AF/" style="font-size: 14.5px;">密码术</a> <a href="/tags/%E5%B0%BE%E9%80%92%E5%BD%92/" style="font-size: 10px;">尾递归</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 12px;">并发</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 14px;">排序</a> <a href="/tags/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/" style="font-size: 10px;">摘要算法</a> <a href="/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" style="font-size: 10.5px;">数字签名</a> <a href="/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/" style="font-size: 10px;">数字证书</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 18.5px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/" style="font-size: 10px;">数据权限</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 11.5px;">杂谈</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 13.5px;">架构</a> <a href="/tags/%E6%A0%91%E7%AE%97%E6%B3%95/" style="font-size: 14px;">树算法</a> <a href="/tags/%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正规表达式</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" style="font-size: 12px;">知识体系</a> <a href="/tags/%E7%A5%9E%E5%99%A8/" style="font-size: 12px;">神器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.5px;">算法</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" style="font-size: 19px;">线程安全</a> <a href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">自制操作系统</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.5px;">设计模式</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 13px;">负载均衡</a> <a href="/tags/%E9%94%81/" style="font-size: 11px;">锁</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/explain/">【置顶】公告</a>
          </li>
        
          <li>
            <a href="/blog/tools/maven/dn-cst-maven-archtype/">开发一个maven脚手架</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustrystock/">neo4j创建行业与股票关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustry/">neo4j创建三级行业关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jtimeline/">neo4j创建时间线</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 证心<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a target="_blank" rel="noopener" href="http://site.onekbase.com" class="mobile-nav-link">ITEEDU</a>
  
    <a href="/about/" class="mobile-nav-link">关于</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>