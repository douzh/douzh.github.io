<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>OneKBase</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="OneKBase">
<meta property="og:url" content="http://www.onekbase.com/page/25/index.html">
<meta property="og:site_name" content="OneKBase">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="证心">
<meta name="twitter:card" content="summary">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">OneKBase</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">归一</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" target="_blank" rel="noopener" href="http://site.onekbase.com">ITEEDU</a>
        
          <a class="main-nav-link" href="/about/">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.onekbase.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-blog/algorithm/sort/mergesort" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/algorithm/sort/mergesort/" class="article-date">
  <time class="dt-published" datetime="2015-12-10T08:38:33.000Z" itemprop="datePublished">2015-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/algorithm/sort/mergesort/">归并排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/images/sort/msort.gif"></p>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<p>归并排序示例：</p>
<p><img src="/images/sort/msort.jpg"></p>
<h2 id="合并方法："><a href="#合并方法：" class="headerlink" title="合并方法："></a>合并方法：</h2><p>设r[i…n]由两个有序子表r[i…m]和r[m+1…n]组成，两个子表长度分别为n-i+1、n-m。</p>
<ol>
<li><p>j&#x3D;m+1；k&#x3D;i；i&#x3D;i; &#x2F;&#x2F;置两个子表的起始下标及辅助数组的起始下标</p>
</li>
<li><p>若i&gt;m 或j&gt;n，转⑷ &#x2F;&#x2F;其中一个子表已合并完，比较选取结束</p>
</li>
<li><p>选取r[i]和r[j]较小的存入辅助数组rf<br>如果r[i] &lt; r[j]，rf[k]&#x3D;r[i]； i++； k++； 转⑵<br>否则，rf[k]&#x3D;r[j]； j++； k++； 转⑵</p>
</li>
<li><p>将尚未处理完的子表中元素存入rf<br>如果i&lt;&#x3D;m，将r[i…m]存入rf[k…n] &#x2F;&#x2F;前一子表非空<br>如果j&lt;&#x3D;n , 将r[j…n] 存入rf[k…n] &#x2F;&#x2F;后一子表非空</p>
</li>
<li><p>合并结束。</p>
<p>&#x2F;&#x2F;将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]<br>void Merge(ElemType *r,ElemType *rf, int i, int m, int n)<br>{<br>int j,k;<br>for(j&#x3D;m+1,k&#x3D;i; i&lt;&#x3D;m &amp;&amp; j &lt;&#x3D;n ; ++k){<br>    if(r[j] &lt; r[i]) rf[k] &#x3D; r[j++];<br>    else rf[k] &#x3D; r[i++];<br>}<br>while(i &lt;&#x3D; m)  rf[k++] &#x3D; r[i++];<br>while(j &lt;&#x3D; n)  rf[k++] &#x3D; r[j++];<br>}</p>
</li>
</ol>
<h2 id="归并的迭代算法"><a href="#归并的迭代算法" class="headerlink" title="归并的迭代算法"></a>归并的迭代算法</h2><p>1 个元素的表总是有序的。所以对n 个元素的待排序列，每个元素可看成1个有序子表。对子表两两合并生成n&#x2F;2个子表，所得子表除最后一个子表长度可能为1外，其余子表长度均为2。再进行两两合并，直到生成n个元素按关键码有序的表。</p>
<pre><code>void print(int a[], int n)&#123;
    for(int j= 0; j
</code></pre>
<h2 id="两路归并的递归算法"><a href="#两路归并的递归算法" class="headerlink" title="两路归并的递归算法"></a>两路归并的递归算法</h2><pre><code>void MSort(ElemType *r, ElemType *rf,int s, int t)
&#123;
    ElemType *rf2;
    if(s==t) r[s] = rf[s];
    else
    &#123;
        int m=(s+t)/2;          /*平分*p 表*/
        MSort(r, rf2, s, m);        /*递归地将p[s…m]归并为有序的p2[s…m]*/
        MSort(r, rf2, m+1, t);      /*递归地将p[m+1…t]归并为有序的p2[m+1…t]*/
        Merge(rf2, rf, s, m+1,t);   /*将p2[s…m]和p2[m+1…t]归并到p1[s…t]*/
    &#125;
&#125;
void MergeSort_recursive(ElemType *r, ElemType *rf, int n)
&#123;   /*对顺序表*p 作归并排序*/
    MSort(r, rf,0, n-1);
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/algorithm/sort/mergesort/" data-id="clhlnyldj001kojupffzjdld9" data-title="归并排序" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/algorithm/sort/quicksort" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/algorithm/sort/quicksort/" class="article-date">
  <time class="dt-published" datetime="2015-12-10T08:09:04.000Z" itemprop="datePublished">2015-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/algorithm/sort/quicksort/">快速排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/images/sort/qsort.gif"></p>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><ol>
<li>选择一个基准元素,通常选择第一个元素或者最后一个元素,</li>
<li>通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的元素值比基准值大。</li>
<li>此时基准元素在其排好序后的正确位置</li>
<li>然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</li>
</ol>
<p>一趟排序的过程：</p>
<p><img src="/images/sort/qsort1.jpg"></p>
<p>排序的全过程</p>
<p><img src="/images/sort/qsort2.jpg"></p>
<h2 id="算法的实现："><a href="#算法的实现：" class="headerlink" title="算法的实现："></a>算法的实现：</h2><p>递归实现：</p>
<pre><code>void print(int a[], int n)&#123;
    for(int j= 0; j&lt; n; j++)&#123;
        cout&lt;&lt; a[j] &lt;&lt;&quot;  &quot;;
    &#125;
    cout&lt;&lt; endl;
&#125;

void swap(int *a, int *b)
&#123;
    int tmp = *a;
    *a = *b;
    *b = tmp;
&#125;

int partition(int a[], int low, int high)
&#123;
    int privotKey = a[low];                             //基准元素
    while(low &lt; high)&#123;                                   //从表的两端交替地向中间扫描
        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high;  //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端
        swap(&amp;a[low], &amp;a[high]);
        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;
        swap(&amp;a[low], &amp;a[high]);
    &#125;
    print(a,10);
    return low;
&#125;


void quickSort(int a[], int low, int high)&#123;
    if(low &lt; high)&#123;
        int privotLoc = partition(a,  low,  high);  //将表一分为二
        quickSort(a,  low,  privotLoc -1);          //递归对低子表递归排序
        quickSort(a,   privotLoc + 1, high);        //递归对高子表递归排序
    &#125;
&#125;

int main()&#123;
    int a[10] = &#123;3,1,5,7,2,4,9,6,10,8&#125;;
    cout&lt;&lt;&quot;初始值：&quot;;
    print(a,10);
    quickSort(a,0,9);
    cout&lt;&lt;&quot;结果：&quot;;
    print(a,10);

&#125;
</code></pre>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p>
<h2 id="快速排序的改进"><a href="#快速排序的改进" class="headerlink" title="快速排序的改进"></a>快速排序的改进</h2><p>在本改进算法中,只对长度大于k的子序列递归调用快速排序,让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序。实践证明，改进后的算法时间复杂度有所降低，且当k取值为8 左右时,改进算法的性能最佳。算法思想如下：</p>
<pre><code>void print(int a[], int n)&#123;
    for(int j= 0; j &lt; n; j++)&#123;
        cout&lt;&lt; a[j] &lt;&lt; &quot;  &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

void swap(int *a, int *b)
&#123;
    int tmp = *a;
    *a = *b;
    *b = tmp;
&#125;

int partition(int a[], int low, int high)
&#123;
    int privotKey = a[low];                 //基准元素
    while(low &lt; high)&#123;                   //从表的两端交替地向中间扫描
        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high; //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端
        swap(&amp;a[low], &amp;a[high]);
        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;
        swap(&amp;a[low], &amp;a[high]);
    &#125;
    print(a,10);
    return low;
&#125;


void qsort_improve(int r[ ],int low,int high, int k)&#123;
    if( high -low &gt; k ) &#123; //长度大于k时递归, k为指定的数
        int pivot = partition(r, low, high); // 调用的Partition算法保持不变
        qsort_improve(r, low, pivot - 1,k);
        qsort_improve(r, pivot + 1, high,k);
    &#125;
&#125;
void quickSort(int r[], int n, int k)&#123;
    qsort_improve(r,0,n,k);//先调用改进算法Qsort使之基本有序

    //再用插入排序对基本有序序列排序
    for(int i=1; i&lt;=n;i ++)&#123;
        int tmp = r[i];
        int j=i-1;
        while(tmp &lt; r[j])&#123;
            r[j+1]=r[j]; j=j-1;
        &#125;
        r[j+1] = tmp;
    &#125;

&#125;

int main()&#123;
    int a[10] = &#123;3,1,5,7,2,4,9,6,10,8&#125;;
    cout&lt;&lt;&quot;初始值：&quot;;
    print(a,10);
    quickSort(a,9,4);
    cout&lt;&lt;&quot;结果：&quot;;
    print(a,10);

&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/algorithm/sort/quicksort/" data-id="clhlnyldk001pojupelt3fv27" data-title="快速排序" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/algorithm/sort/bubsort" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/algorithm/sort/bubsort/" class="article-date">
  <time class="dt-published" datetime="2015-12-10T07:59:35.000Z" itemprop="datePublished">2015-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/algorithm/sort/bubsort/">冒泡排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/images/sort/bsort.gif"></p>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>
<p>冒泡排序的示例：</p>
<p><img src="/images/sort/bubsort.jpg"></p>
<h2 id="算法的实现："><a href="#算法的实现：" class="headerlink" title="算法的实现："></a>算法的实现：</h2><pre><code>void bubbleSort(int a[], int n)&#123;
    for(int i =0 ; i&lt; n-1; ++i) &#123;
        for(int j = 0; j &lt; n-i-1; ++j) &#123;
            if(a[j] &gt; a[j+1])
            &#123;
                int tmp = a[j] ; a[j] = a[j+1] ;  a[j+1] = tmp;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="冒泡排序算法的改进"><a href="#冒泡排序算法的改进" class="headerlink" title="冒泡排序算法的改进"></a>冒泡排序算法的改进</h2><p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法：</p>
<p>1．设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p>
<p>改进后算法如下:</p>
<pre><code>void Bubble_1 ( int r[], int n) &#123;
    int i= n -1;  //初始时,最后位置保持不变
    while ( i&gt; 0) &#123;
        int pos= 0; //每趟开始时,无记录交换
        for (int j= 0; j&lt; i; j++)
            if (r[j]&gt; r[j+1]) &#123;
                pos= j; //记录交换的位置
                int tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;
            &#125;
        i= pos; //为下一趟排序作准备
     &#125;
&#125;
</code></pre>
<p>2．传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者), 从而使排序趟数几乎减少了一半。</p>
<p>改进后的算法实现为:</p>
<pre><code> void Bubble_2 ( int r[], int n)&#123;
    int low = 0;
    int high= n -1; //设置变量的初始值
    int tmp,j;
    while (low &lt; high) &#123;
        for (j= low; j &lt; high; ++j) //正向冒泡,找到最大者
            if (r[j] &gt; r[j+1]) &#123;
                tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;
            &#125;
        --high;                 //修改high值, 前移一位
        for ( j=high; j &gt; low; --j) //反向冒泡,找到最小者
            if (r[j] &lt; r[j-1]) &#123;
                tmp = r[j]; r[j]=r[j-1];r[j-1]=tmp;
            &#125;
        ++low;                  //修改low值,后移一位
    &#125;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/algorithm/sort/bubsort/" data-id="clhlnyldj001iojupduc0dvrh" data-title="冒泡排序" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/algorithm/sort/heapsort" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/algorithm/sort/heapsort/" class="article-date">
  <time class="dt-published" datetime="2015-12-10T07:32:05.000Z" itemprop="datePublished">2015-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/algorithm/sort/heapsort/">堆排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/images/sort/hsort.gif"></p>
<p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。</p>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>堆的定义如下：具有n个元素的序列（k1,k2,…,kn),当且仅当满足</p>
<p><img src="/images/sort/heapsort1.jpg"></p>
<p>时称之为堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。</p>
<p>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如：</p>
<p>（a）大顶堆序列：（96, 83,27,38,11,09)</p>
<p>(b) 小顶堆序列：（12，36，24，85，47，30，53，91）</p>
<p><img src="/images/sort/heapsort2.jpg"></p>
<p>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</p>
<p>因此，实现堆排序需解决两个问题：</p>
<ol>
<li><p>如何将n 个待排序的数建成堆；</p>
</li>
<li><p>输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。</p>
</li>
</ol>
<p>首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。</p>
<p>调整小顶堆的方法：</p>
<ol>
<li>设有m 个元素的堆，输出堆顶元素后，剩下m-1个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。</li>
<li>将根结点与左、右子树中较小元素的进行交换。</li>
<li>若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.</li>
<li>若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.</li>
<li>继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。</li>
</ol>
<p>称这个自根结点到叶子结点的调整过程为筛选。如图：</p>
<p><img src="/images/sort/heapsort3.jpg"></p>
<p>再讨论对n 个元素初始建堆的过程。</p>
<p>建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。</p>
<ol>
<li>n 个结点的完全二叉树，则最后一个结点是第n&#x2F;2个结点的子树。</li>
<li>筛选从第n&#x2F;2个结点为根的子树开始，该子树成为堆。</li>
<li>之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</li>
</ol>
<p>如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49）</p>
<p><img src="/images/sort/heapsort4.jpg"></p>
<h2 id="算法的实现："><a href="#算法的实现：" class="headerlink" title="算法的实现："></a>算法的实现：</h2><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p>
<pre><code>void print(int a[], int n)&#123;
    for(int j= 0; j= 0; --i)
        HeapAdjust(H,i,length);
&#125;
/**
 * 堆排序算法
 */
void HeapSort(int H[],int length)
&#123;
    //初始堆
    BuildingHeap(H, length);
    //从最后一个元素开始对序列进行调整
    for (int i = length - 1; i &gt; 0; --i)
    &#123;
        //交换堆顶元素H[0]和堆中最后一个元素
        int temp = H[i]; H[i] = H[0]; H[0] = temp;
        //每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整
        HeapAdjust(H,0,i);
  &#125;
&#125;

int main()&#123;
    int H[10] = &#123;3,1,5,7,2,4,9,6,10,8&#125;;
    cout&lt;&lt;&quot;初始值：&quot;;
    print(H,10);
    HeapSort(H,10);
    //selectSort(a, 8);
    cout&lt;&lt;&quot;结果：&quot;;
    print(H,10);

&#125;
</code></pre>
<p>分析:</p>
<p>设树深度为k，<code>k=[log~2~n]+1</code>。从根到叶的筛选，元素比较次数至多&#96;2(k-1)次，交换记录至多k次。所以，在建好堆后，排序过程中的筛选次数不超过下式：</p>
<p><img src="/images/sort/heapsort5.jpg"></p>
<p>而建堆时的比较次数不超过<code>4n</code>次，因此堆排序最坏情况下，时间复杂度也为：<code>O(nlogn)</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/algorithm/sort/heapsort/" data-id="clhlnyldk001oojupgpdq0n8z" data-title="堆排序" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/algorithm/sort/sselectsort" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/algorithm/sort/sselectsort/" class="article-date">
  <time class="dt-published" datetime="2015-12-10T07:15:44.000Z" itemprop="datePublished">2015-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/algorithm/sort/sselectsort/">简单选择排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/images/sort/ssort.gif"></p>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p>
<p>简单选择排序的示例：</p>
<p><img src="/images/sort/sselectsort.jpg">\</p>
<h2 id="操作方法："><a href="#操作方法：" class="headerlink" title="操作方法："></a>操作方法：</h2><p>第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；</p>
<p>第二趟，从第二个记录开始的n-1个记录中再选出关键码最小的记录与第二个记录交换；</p>
<p>以此类推…..</p>
<p>第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i个记录交换，</p>
<p>直到整个序列按关键码有序。</p>
<h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><pre><code>void print(int a[], int n ,int i)&#123;
    cout&lt;&lt;&quot;第&quot;&lt; a[j]) k = j;
    &#125;
    return k;
&#125;

/**
 * 选择排序
 *
 */
void selectSort(int a[], int n)&#123;
    int key, tmp;
    for(int i = 0; i&lt; n; ++i) &#123;
        key = SelectMinKey(a, n,i);           //选择最小的元素
        if(key != i)&#123;
            tmp = a[i];  a[i] = a[key]; a[key] = tmp; //最小元素与第i位置元素互换
        &#125;
        print(a,  n , i);
    &#125;
&#125;
int main()&#123;
    int a[8] = &#123;3,1,5,7,2,4,9,6&#125;;
    cout&lt;&lt;&quot;初始值：&quot;;
    for(int j= 0; j&lt;8; j++)&#123;
        cout&lt;
</code></pre>
<h2 id="简单选择排序的改进——二元选择排序"><a href="#简单选择排序的改进——二元选择排序" class="headerlink" title="简单选择排序的改进——二元选择排序"></a>简单选择排序的改进——二元选择排序</h2><p>简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n&#x2F;2]趟循环即可。具体实现如下：</p>
<pre><code>void SelectSort(int r[],int n) &#123;
    int i ,j , min ,max, tmp;
    for (i=1 ;i &lt;= n/2;i++) &#123;
        // 做不超过n/2趟选择排序
        min = i; max = i ; //分别记录最大和最小关键字记录位置
        for (j= i+1; j&lt;= n-i; j++) &#123;
            if (r[j] &gt; r[max]) &#123;
                max = j ; continue ;
            &#125;
            if (r[j]&lt; r[min]) &#123;
                min = j ;
            &#125;
      &#125;
      //该交换操作还可分情况讨论以提高效率
      tmp = r[i-1]; r[i-1] = r[min]; r[min] = tmp;
      tmp = r[n-i]; r[n-i] = r[max]; r[max] = tmp;

    &#125;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/algorithm/sort/sselectsort/" data-id="clhlnyldm001yojup4uk7fj3b" data-title="简单选择排序" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/algorithm/sort/shellsort" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/algorithm/sort/shellsort/" class="article-date">
  <time class="dt-published" datetime="2015-12-10T07:05:46.000Z" itemprop="datePublished">2015-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/algorithm/sort/shellsort/">希尔排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/images/sort/shsort.gif"></p>
<p>希尔排序是1959 年由D.L.Shell提出来的，相对直接排序有较大的改进。希尔排序又叫缩小增量排序</p>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p>操作方法：</p>
<ol>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p>希尔排序的示例：</p>
<p><img src="/images/sort/shellsort.jpg">\</p>
<h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><p>我们简单处理增量序列：增量序列d &#x3D; {n&#x2F;2 ,n&#x2F;4, n&#x2F;8 …..1}</p>
<p>n为要排序数的个数</p>
<p>即：先将要排序的一组记录按某个增量d（n&#x2F;2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d&#x2F;2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。</p>
<pre><code>oid print(int a[], int n ,int i)&#123;
    cout&lt;= 1  )&#123;
        ShellInsertSort(a, n, dk);
        dk = dk/2;
    &#125;
&#125;
int main()&#123;
    int a[8] = &#123;3,1,5,7,2,4,9,6&#125;;
    //ShellInsertSort(a,8,1); //直接插入排序
    shellSort(a,8);           //希尔插入排序
    print(a,8,8);
&#125;
</code></pre>
<p>希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个不稳定的排序方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/algorithm/sort/shellsort/" data-id="clhlnyldm001vojupgei76uhd" data-title="希尔排序" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/algorithm/sort/sisort" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/algorithm/sort/sisort/" class="article-date">
  <time class="dt-published" datetime="2015-12-10T06:56:31.000Z" itemprop="datePublished">2015-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/algorithm/sort/sisort/">直接插入排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/images/sort/sisort.gif"></p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想:"></a>基本思想:</h2><p>将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。</p>
<p>要点：设立哨兵，作为临时存储和判断数组边界之用。</p>
<p>直接插入排序示例：</p>
<p><img src="/images/sort/sisort.jpg"></p>
<p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<pre><code>void print(int a[], int n ,int i)&#123;
    cout&lt;
</code></pre>
<h2 id="效率："><a href="#效率：" class="headerlink" title="效率："></a>效率：</h2><p>时间复杂度：O（n^2）.</p>
<p>其他的插入排序有二分插入排序，2-路插入排序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/algorithm/sort/sisort/" data-id="clhlnyldn0022ojup669bd7a8" data-title="直接插入排序" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/os/mkos/nasmcvar" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/os/mkos/nasmcvar/" class="article-date">
  <time class="dt-published" datetime="2015-12-09T06:27:29.000Z" itemprop="datePublished">2015-12-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/os/mkos/nasmcvar/">NASM和C互相调用对方的变量</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="NASM和C互相调用对方的变量"><a href="#NASM和C互相调用对方的变量" class="headerlink" title="NASM和C互相调用对方的变量"></a>NASM和C互相调用对方的变量</h2><p><strong>hello.asm</strong></p>
<pre><code>global string
extern strhello
[section .data]
string:
    db &#39;I am Chinese.&#39;,0x0A,0x0
[section .text]
    global print_hello
    global cpy_mem
print_hello:    
    mov edx, 13
    mov ecx,[strhello]
    mov ebx,1
    mov eax,4
    int 0x80
</code></pre>
<p><strong>main.c</strong></p>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;string.h&quot;
extern char *string;
extern void print_hello();
extern cpy_mem (void *dest, int len);
char *strhello = &quot;Hello,world!\n&quot;;
char *str = NULL;
int
main ()
&#123;
        printf (&quot;%x\n&quot;,&amp;string);
        str = &amp;string;
        printf (&quot;%s&quot;, str);
       
        print_hello ();
        return 0;
&#125;
</code></pre>
<p>编译方法：</p>
<p>nasm -f elf hello.asm -o hello.o</p>
<p>gcc -o main main.c hello.o</p>
<p>如果机器是64位的，nasm要用elf64编译。</p>
<p>nasm -f elf64 hello.asm -o hello.o</p>
<p>会创建一个叫main的可执行文件。</p>
<p><strong>注意：</strong></p>
<p>1.在C语言中定义了一个strhello的字符串变量，在C语言中strhello表示的是字符串的首地址，比如字符串的地址是0xa00001，而strhello是个指针即4字节其地址为0xb00001，<br>在C语言中strhello表示的值是 0xa00001<br>字符串的首地址，但到了NASM中则表示的 strhello变量的首地址了<br>0xb00001，所以<code>mov ecx,[strhello]</code>代码中加了中括号表示是内容，这一点一定要注意，否则会出错！！</p>
<p>2.第二点要注意的是，在NASM中定义了一个字符串string ，<br>在C语言中导入的话，就是表示字符串的首地址，因此要引用该字符串一定要取其地址，不要直接转为(char*)类型直接用，否则出错，这是因为直接转的话，就将字符串的前4个字节转成了字符串指针，但该指针是不确定会出现段错误！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/os/mkos/nasmcvar/" data-id="clhlnylfw00f2ojupdcu2fnky" data-title="NASM和C互相调用对方的变量" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">自制操作系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/os/mkos/nasmcfunc" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/os/mkos/nasmcfunc/" class="article-date">
  <time class="dt-published" datetime="2015-12-09T06:16:36.000Z" itemprop="datePublished">2015-12-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/os/mkos/nasmcfunc/">NASM和C互相调用对方的函数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="NASM和C互相调用对方的函数"><a href="#NASM和C互相调用对方的函数" class="headerlink" title="NASM和C互相调用对方的函数"></a>NASM和C互相调用对方的函数</h2><p><strong>hello.asm</strong></p>
<pre><code>extern print_helloworld

[section .text]
global print_two_hello_world
print_two_hello_world:  
    call print_helloworld
    call print_helloworld
</code></pre>
<p><strong>main.c</strong></p>
<pre><code>#include &quot;stdio.h&quot;

extern void print_two_hello_world();

char *strhello = &quot;Hello,world!\n&quot;;

void print_helloworld ()
&#123;
        printf (&quot;%s&quot;,strhello);
&#125;

int  main ()
&#123;
        print_two_hello_world();
        return 0;
&#125;
</code></pre>
<p>编译方法：</p>
<p>nasm -f elf hello.asm -o hello.o</p>
<p>gcc -o main main.c hello.o</p>
<p>如果机器是64位的，nasm要用elf64编译。</p>
<p>nasm -f elf64 hello.asm -o hello.o</p>
<p>会创建一个叫main的可执行文件，打印出两行hello, world!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/os/mkos/nasmcfunc/" data-id="clhlnylfw00f1ojup4jtwg8zh" data-title="NASM和C互相调用对方的函数" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">自制操作系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blog/tools/vim/fdm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/tools/vim/fdm/" class="article-date">
  <time class="dt-published" datetime="2015-12-08T03:20:57.000Z" itemprop="datePublished">2015-12-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>►<a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/tools/vim/fdm/">VIM设置代码折叠</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="折叠方式"><a href="#折叠方式" class="headerlink" title="折叠方式"></a>折叠方式</h2><p>可在Vim 配置文件中设置 set fdm&#x3D;XXX</p>
<p>有6种方法来选定折叠：</p>
<ul>
<li>manual: 手工定义折叠</li>
<li>indent: 更多的缩进表示更高级别的折叠</li>
<li>expr: 用表达式来定义折叠</li>
<li>syntax: 用语法高亮来定义折叠</li>
<li>diff:对没有更改的文本进行折叠</li>
<li>marker:对文中的标志折叠</li>
</ul>
<p>注意，每一种折叠方式不兼容，如不能既用expr又用marker方式，我主要轮流使用indent和marker方式进行折叠。</p>
<p>使用时，用 set fdm&#x3D;marker命令来设置成marker折叠方式（fdm是foldmethod的缩写）。</p>
<p>要使每次打开vim时折叠都生效，则在.vimrc文件中添加设置，如添加：set fdm&#x3D;syntax，就像添加其它的初始化设置一样。</p>
<h2 id="折叠命令"><a href="#折叠命令" class="headerlink" title="折叠命令"></a>折叠命令</h2><p>选取了折叠方式后，我们就可以对某些代码实施我们需要的折叠了，由于我使用indent和marker稍微多一些，故以它们的使用为例：如果使用了indent方式，vim会自动的对大括号的中间部分进行折叠，我们可以直接使用这些现成的折叠成果。</p>
<p>在可折叠处（大括号中间）：</p>
<ul>
<li>zc:折叠</li>
<li>zC: 对所在范围内所有嵌套的折叠点进行折叠</li>
<li>zo: 展开折叠</li>
<li>zO: 对所在范围内所有嵌套的折叠点展开</li>
<li>[z: 到当前打开的折叠的开始处。</li>
<li>]z:到当前打开的折叠的末尾处。</li>
<li>zj: 向下移动。到达下一个折叠的开始处。关闭的折叠也被计入。</li>
<li>zk:向上移动到前一折叠的结束处。关闭的折叠也被计入。</li>
</ul>
<p>当使用marker方式时，需要用标计来标识代码的折叠，系统默认是 {{{和}}}，最好不要改动</p>
<p>我们可以使用下面的命令来创建和删除折叠：</p>
<p>zf: 创建折叠，比如在marker方式下：</p>
<p>zf56G，创建从当前行起到56行的代码折叠；</p>
<p>10zf或10zf+或zf10↓，创建从当前行起到后10行的代码折叠。</p>
<p>10zf-或zf10↑，创建从当前行起到之前10行的代码折叠。</p>
<p>在括号处zf%，创建从当前行起到对应的匹配的括号上去（（），{}，[]，</p>
<p>zd: 删除 (delete) 在光标下的折叠。</p>
<p>仅当 ‘foldmethod’ 设为 “manual” 或 “marker” 时有效。</p>
<p>zD:循环删除 (Delete) 光标下的折叠，即嵌套删除折叠。</p>
<p>仅当 ‘foldmethod’ 设为 “manual” 或 “marker” 时有效。</p>
<p>zE: 除去 (Eliminate) 窗口里“所有”的折叠。</p>
<p>仅当 ‘foldmethod’ 设为 “manual” 或 “marker” 时有效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.onekbase.com/blog/tools/vim/fdm/" data-id="clhlnylgm00jlojup6ijsb8ad" data-title="VIM设置代码折叠" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIM/" rel="tag">VIM</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/24/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/26/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/">JAVA WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-WEB/Spring-Boot/">Spring Boot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%BC%80%E5%8F%91/">WEB开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/">nosql</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/MongoDB/">MongoDB</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E9%9B%86/">字符集</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/">spark</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/Emacs/">Emacs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/GIT/">GIT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/VIM/">VIM</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/SSO/">SSO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%B8%80%E8%87%B4%E6%80%A7/">一致性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E5%AF%86%E7%A0%81%E6%9C%AF/">密码术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/JMS/">JMS</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6/">组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%AE%97%E6%B3%95/">树算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/">JAVA</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/BASE/">BASE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/JAVA8/">JAVA8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/NIO/">NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/">Lisp</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lisp/Common-Lisp/">Common Lisp</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Scala/">Scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10.5px;">AOP</a> <a href="/tags/ASCII%E7%A0%81/" style="font-size: 10px;">ASCII码</a> <a href="/tags/ActiveMQ/" style="font-size: 11px;">ActiveMQ</a> <a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/BAT%E8%84%9A%E6%9C%AC/" style="font-size: 10px;">BAT脚本</a> <a href="/tags/CAP/" style="font-size: 10px;">CAP</a> <a href="/tags/CAS/" style="font-size: 10.5px;">CAS</a> <a href="/tags/Common-Lisp/" style="font-size: 13.5px;">Common Lisp</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10.5px;">C语言</a> <a href="/tags/Eclipse/" style="font-size: 11px;">Eclipse</a> <a href="/tags/Emacs/" style="font-size: 16.5px;">Emacs</a> <a href="/tags/Emmet/" style="font-size: 10px;">Emmet</a> <a href="/tags/GIT/" style="font-size: 10px;">GIT</a> <a href="/tags/HttpClient/" style="font-size: 12.5px;">HttpClient</a> <a href="/tags/IPFS/" style="font-size: 10px;">IPFS</a> <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/JAVA-IO/" style="font-size: 15.5px;">JAVA IO</a> <a href="/tags/JAVA-NIO/" style="font-size: 17px;">JAVA NIO</a> <a href="/tags/JAVA-WEB/" style="font-size: 10.5px;">JAVA WEB</a> <a href="/tags/JAVA8/" style="font-size: 13.5px;">JAVA8</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Lisp/" style="font-size: 12px;">Lisp</a> <a href="/tags/Markdown/" style="font-size: 10.5px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 18px;">MongoDB</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/Scala/" style="font-size: 11px;">Scala</a> <a href="/tags/Shiro/" style="font-size: 10px;">Shiro</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/VIM/" style="font-size: 16px;">VIM</a> <a href="/tags/WEB%E5%BC%80%E5%8F%91/" style="font-size: 11px;">WEB开发</a> <a href="/tags/XML/" style="font-size: 10.5px;">XML</a> <a href="/tags/archtype/" style="font-size: 10px;">archtype</a> <a href="/tags/azkaban/" style="font-size: 10.5px;">azkaban</a> <a href="/tags/hadoop/" style="font-size: 13px;">hadoop</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/hive/" style="font-size: 10px;">hive</a> <a href="/tags/javascript/" style="font-size: 14px;">javascript</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/linux/" style="font-size: 13px;">linux</a> <a href="/tags/maven/" style="font-size: 12px;">maven</a> <a href="/tags/nosql/" style="font-size: 18.5px;">nosql</a> <a href="/tags/nosql-neo4j/" style="font-size: 11.5px;">nosql neo4j</a> <a href="/tags/openssl/" style="font-size: 11px;">openssl</a> <a href="/tags/servlet/" style="font-size: 11px;">servlet</a> <a href="/tags/spark/" style="font-size: 12px;">spark</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/webservice/" style="font-size: 11px;">webservice</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 11.5px;">一致性</a> <a href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" style="font-size: 10.5px;">任务调度</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 10px;">区块链</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 17.5px;">大数据</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/" style="font-size: 12.5px;">字符集</a> <a href="/tags/%E5%AE%A1%E8%AE%A1/" style="font-size: 10px;">审计</a> <a href="/tags/%E5%AF%86%E7%A0%81%E6%9C%AF/" style="font-size: 14.5px;">密码术</a> <a href="/tags/%E5%B0%BE%E9%80%92%E5%BD%92/" style="font-size: 10px;">尾递归</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 12px;">并发</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 14px;">排序</a> <a href="/tags/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/" style="font-size: 10px;">摘要算法</a> <a href="/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" style="font-size: 10.5px;">数字签名</a> <a href="/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/" style="font-size: 10px;">数字证书</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 18.5px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/" style="font-size: 10px;">数据权限</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 11.5px;">杂谈</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 13.5px;">架构</a> <a href="/tags/%E6%A0%91%E7%AE%97%E6%B3%95/" style="font-size: 14px;">树算法</a> <a href="/tags/%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正规表达式</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" style="font-size: 12px;">知识体系</a> <a href="/tags/%E7%A5%9E%E5%99%A8/" style="font-size: 12px;">神器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.5px;">算法</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" style="font-size: 19px;">线程安全</a> <a href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">自制操作系统</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.5px;">设计模式</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 13px;">负载均衡</a> <a href="/tags/%E9%94%81/" style="font-size: 11px;">锁</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/explain/">【置顶】公告</a>
          </li>
        
          <li>
            <a href="/blog/tools/maven/dn-cst-maven-archtype/">开发一个maven脚手架</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustrystock/">neo4j创建行业与股票关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jindustry/">neo4j创建三级行业关系</a>
          </li>
        
          <li>
            <a href="/blog/nosql/neo4j/neo4jtimeline/">neo4j创建时间线</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 证心<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a target="_blank" rel="noopener" href="http://site.onekbase.com" class="mobile-nav-link">ITEEDU</a>
  
    <a href="/about/" class="mobile-nav-link">关于</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>